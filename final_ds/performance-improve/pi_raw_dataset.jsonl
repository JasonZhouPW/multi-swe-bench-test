{"org": "pingcap", "repo": "tidb", "number": 63160, "state": "closed", "title": "stats: optimize memory footprint of pseudo stats table", "body": "<!--\r\n\r\nThank you for contributing to TiDB!\r\n\r\nPR Title Format:\r\n1. pkg [, pkg2, pkg3]: what's changed\r\n2. *: what's changed\r\n\r\n-->\r\n\r\n### What problem does this PR solve?\r\n<!--\r\n\r\nPlease create an issue first to describe the problem.\r\n\r\nThere MUST be one line starting with \"Issue Number:  \" and\r\nlinking the relevant issues via the \"close\" or \"ref\".\r\n\r\nFor more info, check https://pingcap.github.io/tidb-dev-guide/contribute-to-tidb/contribute-code.html#referring-to-an-issue.\r\n\r\n-->\r\n\r\nIssue Number: close #60137\r\n\r\nProblem Summary:\r\n\r\n### What changed and how does it work?\r\n\r\nA significant part of memory consumption of pseudo table is creating new chunk for every pseudo table creation. These new chunks are read only and only to provide compatibility to the code of using real stats table struct. We can make it a static object and shared by all pseudo tables to reduce memory usage.\r\n### Check List\r\n\r\nTests <!-- At least one of them must be included. -->\r\n\r\n- [ ] Unit test\r\n- [x] Integration test\r\n- [ ] Manual test (add detailed scripts or steps below)\r\n- [ ] No need to test\r\n  > - [ ] I checked and no code files have been changed.\r\n  > <!-- Or your custom  \"No need to test\" reasons -->\r\n\r\nSide effects\r\n\r\n- [ ] Performance regression: Consumes more CPU\r\n- [ ] Performance regression: Consumes more Memory\r\n- [ ] Breaking backward compatibility\r\n\r\nDocumentation\r\n\r\n- [ ] Affects user behaviors\r\n- [ ] Contains syntax changes\r\n- [ ] Contains variable changes\r\n- [ ] Contains experimental features\r\n- [ ] Changes MySQL compatibility\r\n\r\n### Release note\r\n\r\n<!-- compatibility change, improvement, bugfix, and new feature need a release note -->\r\n\r\nPlease refer to [Release Notes Language Style Guide](https://pingcap.github.io/tidb-dev-guide/contribute-to-tidb/release-notes-style-guide.html) to write a quality release note.\r\n\r\n```release-note\r\nNone\r\n```\r\n", "url": "https://api.github.com/repos/pingcap/tidb/pulls/63160", "id": 2767160400, "node_id": "PR_kwDOAoCpQc6k74RQ", "html_url": "https://github.com/pingcap/tidb/pull/63160", "diff_url": "https://github.com/pingcap/tidb/pull/63160.diff", "patch_url": "https://github.com/pingcap/tidb/pull/63160.patch", "issue_url": "https://api.github.com/repos/pingcap/tidb/issues/63160", "created_at": "2025-08-22T19:19:45+00:00", "updated_at": "2025-09-09T20:29:51+00:00", "closed_at": "2025-09-09T20:29:03+00:00", "merged_at": "2025-09-09T20:29:03+00:00", "merge_commit_sha": "6eade7b34f19994afdecbf1940cf201bafac0a63", "labels": ["sig/planner", "size/L", "release-note-none", "ok-to-test", "approved", "lgtm"], "draft": false, "commits_url": "https://api.github.com/repos/pingcap/tidb/pulls/63160/commits", "review_comments_url": "https://api.github.com/repos/pingcap/tidb/pulls/63160/comments", "review_comment_url": "https://api.github.com/repos/pingcap/tidb/pulls/comments{/number}", "comments_url": "https://api.github.com/repos/pingcap/tidb/issues/63160/comments", "base": {"label": "pingcap:master", "ref": "master", "sha": "abb662f76cbd5059d9afd215ed637a5f5e2bd195", "user": {"login": "pingcap", "id": 11855343, "node_id": "MDEyOk9yZ2FuaXphdGlvbjExODU1MzQz", "avatar_url": "https://avatars.githubusercontent.com/u/11855343?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pingcap", "html_url": "https://github.com/pingcap", "followers_url": "https://api.github.com/users/pingcap/followers", "following_url": "https://api.github.com/users/pingcap/following{/other_user}", "gists_url": "https://api.github.com/users/pingcap/gists{/gist_id}", "starred_url": "https://api.github.com/users/pingcap/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pingcap/subscriptions", "organizations_url": "https://api.github.com/users/pingcap/orgs", "repos_url": "https://api.github.com/users/pingcap/repos", "events_url": "https://api.github.com/users/pingcap/events{/privacy}", "received_events_url": "https://api.github.com/users/pingcap/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "repo": {"id": 41986369, "node_id": "MDEwOlJlcG9zaXRvcnk0MTk4NjM2OQ==", "name": "tidb", "full_name": "pingcap/tidb", "private": false, "owner": {"login": "pingcap", "id": 11855343, "node_id": "MDEyOk9yZ2FuaXphdGlvbjExODU1MzQz", "avatar_url": "https://avatars.githubusercontent.com/u/11855343?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pingcap", "html_url": "https://github.com/pingcap", "followers_url": "https://api.github.com/users/pingcap/followers", "following_url": "https://api.github.com/users/pingcap/following{/other_user}", "gists_url": "https://api.github.com/users/pingcap/gists{/gist_id}", "starred_url": "https://api.github.com/users/pingcap/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pingcap/subscriptions", "organizations_url": "https://api.github.com/users/pingcap/orgs", "repos_url": "https://api.github.com/users/pingcap/repos", "events_url": "https://api.github.com/users/pingcap/events{/privacy}", "received_events_url": "https://api.github.com/users/pingcap/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "html_url": "https://github.com/pingcap/tidb", "description": "TiDB - the open-source, cloud-native, distributed SQL database designed for modern applications.", "fork": false, "url": "https://api.github.com/repos/pingcap/tidb", "forks_url": "https://api.github.com/repos/pingcap/tidb/forks", "keys_url": "https://api.github.com/repos/pingcap/tidb/keys{/key_id}", "collaborators_url": "https://api.github.com/repos/pingcap/tidb/collaborators{/collaborator}", "teams_url": "https://api.github.com/repos/pingcap/tidb/teams", "hooks_url": "https://api.github.com/repos/pingcap/tidb/hooks", "issue_events_url": "https://api.github.com/repos/pingcap/tidb/issues/events{/number}", "events_url": "https://api.github.com/repos/pingcap/tidb/events", "assignees_url": "https://api.github.com/repos/pingcap/tidb/assignees{/user}", "branches_url": "https://api.github.com/repos/pingcap/tidb/branches{/branch}", "tags_url": "https://api.github.com/repos/pingcap/tidb/tags", "blobs_url": "https://api.github.com/repos/pingcap/tidb/git/blobs{/sha}", "git_tags_url": "https://api.github.com/repos/pingcap/tidb/git/tags{/sha}", "git_refs_url": "https://api.github.com/repos/pingcap/tidb/git/refs{/sha}", "trees_url": "https://api.github.com/repos/pingcap/tidb/git/trees{/sha}", "statuses_url": "https://api.github.com/repos/pingcap/tidb/statuses/{sha}", "languages_url": "https://api.github.com/repos/pingcap/tidb/languages", "stargazers_url": "https://api.github.com/repos/pingcap/tidb/stargazers", "contributors_url": "https://api.github.com/repos/pingcap/tidb/contributors", "subscribers_url": "https://api.github.com/repos/pingcap/tidb/subscribers", "subscription_url": "https://api.github.com/repos/pingcap/tidb/subscription", "commits_url": "https://api.github.com/repos/pingcap/tidb/commits{/sha}", "git_commits_url": "https://api.github.com/repos/pingcap/tidb/git/commits{/sha}", "comments_url": "https://api.github.com/repos/pingcap/tidb/comments{/number}", "issue_comment_url": "https://api.github.com/repos/pingcap/tidb/issues/comments{/number}", "contents_url": "https://api.github.com/repos/pingcap/tidb/contents/{+path}", "compare_url": "https://api.github.com/repos/pingcap/tidb/compare/{base}...{head}", "merges_url": "https://api.github.com/repos/pingcap/tidb/merges", "archive_url": "https://api.github.com/repos/pingcap/tidb/{archive_format}{/ref}", "downloads_url": "https://api.github.com/repos/pingcap/tidb/downloads", "issues_url": "https://api.github.com/repos/pingcap/tidb/issues{/number}", "pulls_url": "https://api.github.com/repos/pingcap/tidb/pulls{/number}", "milestones_url": "https://api.github.com/repos/pingcap/tidb/milestones{/number}", "notifications_url": "https://api.github.com/repos/pingcap/tidb/notifications{?since,all,participating}", "labels_url": "https://api.github.com/repos/pingcap/tidb/labels{/name}", "releases_url": "https://api.github.com/repos/pingcap/tidb/releases{/id}", "deployments_url": "https://api.github.com/repos/pingcap/tidb/deployments", "created_at": "2015-09-06T04:01:52Z", "updated_at": "2026-01-07T08:42:13Z", "pushed_at": "2026-01-07T08:42:08Z", "git_url": "git://github.com/pingcap/tidb.git", "ssh_url": "git@github.com:pingcap/tidb.git", "clone_url": "https://github.com/pingcap/tidb.git", "svn_url": "https://github.com/pingcap/tidb", "homepage": "https://pingcap.com", "size": 588595, "stargazers_count": 39565, "watchers_count": 39565, "language": "Go", "has_issues": true, "has_projects": true, "has_downloads": true, "has_wiki": true, "has_pages": false, "has_discussions": true, "forks_count": 6089, "mirror_url": null, "archived": false, "disabled": false, "open_issues_count": 5461, "license": {"key": "apache-2.0", "name": "Apache License 2.0", "spdx_id": "Apache-2.0", "url": "https://api.github.com/licenses/apache-2.0", "node_id": "MDc6TGljZW5zZTI="}, "allow_forking": true, "is_template": false, "web_commit_signoff_required": false, "topics": ["cloud-native", "database", "distributed-database", "distributed-transactions", "go", "hacktoberfest", "htap", "mysql", "mysql-compatibility", "scale", "serverless", "sql", "tidb"], "visibility": "public", "forks": 6089, "open_issues": 5461, "watchers": 39565, "default_branch": "master"}}, "commits": [{"sha": "d2eea49acf71b260c26925a98a00601ad5b5c45b", "parents": ["abb662f76cbd5059d9afd215ed637a5f5e2bd195"], "message": "singleton histogram chunk\n\nSigned-off-by: Wenqi Mou <wenqimou@gmail.com>"}, {"sha": "0a93788f7a1d2e851208ec1f693b5425744de463", "parents": ["d2eea49acf71b260c26925a98a00601ad5b5c45b"], "message": "address comments\n\nSigned-off-by: Wenqi Mou <wenqimou@gmail.com>"}, {"sha": "bbad494511da368cd377a28fe60687043fbe355f", "parents": ["0a93788f7a1d2e851208ec1f693b5425744de463"], "message": "unit test\n\nSigned-off-by: Wenqi Mou <wenqimou@gmail.com>"}, {"sha": "f1aeb192376e0b926e5464fe51da12e852c5c144", "parents": ["bbad494511da368cd377a28fe60687043fbe355f"], "message": "fix bazel\n\nSigned-off-by: Wenqi Mou <wenqimou@gmail.com>"}], "resolved_issues": [{"org": "pingcap", "repo": "tidb", "number": 60137, "state": "closed", "title": "planner: prevent pseudo-stats from dominating the Stats Cache", "body": "## Enhancement\nUse the python script below to reproduce this problem:\n```\nfor i in range(100000):\n    print(f\"CREATE TEMPORARY TABLE tmp_{i} (id BIGINT(20) NOT NULL,INDEX id_idx(id));\")\n    print(f\"select * from tmp_{i};\")\n    print(f\"DROP TEMPORARY TABLE tmp_{i};\")\n```\n\nIn a customer case below, pseudo-stats costs 1.8GB (40%) memory:\n![Image](https://github.com/user-attachments/assets/47252d9b-12ee-46d4-99c8-05b1ddb26e85)\n\nIn this case:\n1.  create and drop a lots of temporary tables;\n2. when accessing these tables, we create a pseudo-stats for each table, and put it into the stats cache;\n3. we don't drop stats from the stats cache when dropping a table;\n4. if this situation continues, a large number of unused pseudo-stats will dominate the stats cache and cause unexpected high memory usage.\n\nA possible foundamental solution might be that we can encapsulate all pseudo-stats as a global single object, and do not put it into our Stats Cache, this should help us save lots of memory in this scenario."}], "fix_patch": "diff --git a/pkg/planner/core/planbuilder.go b/pkg/planner/core/planbuilder.go\nindex f7b47a636df61..13ca48a9769ac 100644\n--- a/pkg/planner/core/planbuilder.go\n+++ b/pkg/planner/core/planbuilder.go\n@@ -1608,7 +1608,7 @@ func (b *PlanBuilder) buildPhysicalIndexLookUpReader(_ context.Context, dbName a\n \tidxColInfos := getIndexColumnInfos(tblInfo, idx)\n \tidxColSchema := getIndexColsSchema(tblInfo, idx, fullExprCols)\n \tidxCols, idxColLens := expression.IndexInfo2PrefixCols(idxColInfos, idxColSchema.Columns, idx)\n-\n+\tpseudoHistColl := statistics.PseudoHistColl(physicalID, false)\n \tis := physicalop.PhysicalIndexScan{\n \t\tTable:            tblInfo,\n \t\tTableAsName:      &tblInfo.Name,\n@@ -1621,10 +1621,10 @@ func (b *PlanBuilder) buildPhysicalIndexLookUpReader(_ context.Context, dbName a\n \t\tRanges:           ranger.FullRange(),\n \t\tPhysicalTableID:  physicalID,\n \t\tIsPartition:      isPartition,\n-\t\tTblColHists:      &(statistics.PseudoTable(tblInfo, false, false)).HistColl,\n+\t\tTblColHists:      &pseudoHistColl,\n \t}.Init(b.ctx, b.getSelectOffset())\n \t// There is no alternative plan choices, so just use pseudo stats to avoid panic.\n-\tis.SetStats(&property.StatsInfo{HistColl: &(statistics.PseudoTable(tblInfo, false, false)).HistColl})\n+\tis.SetStats(&property.StatsInfo{HistColl: &pseudoHistColl})\n \tif hasCommonCols {\n \t\tfor _, c := range commonInfos {\n \t\t\tis.Columns = append(is.Columns, c.ColumnInfo)\n@@ -1639,7 +1639,7 @@ func (b *PlanBuilder) buildPhysicalIndexLookUpReader(_ context.Context, dbName a\n \t\tTableAsName:     &tblInfo.Name,\n \t\tDBName:          dbName,\n \t\tPhysicalTableID: physicalID,\n-\t\tTblColHists:     &(statistics.PseudoTable(tblInfo, false, false)).HistColl,\n+\t\tTblColHists:     &pseudoHistColl,\n \t}.Init(b.ctx, b.getSelectOffset())\n \tts.SetIsPartition(isPartition)\n \tts.SetSchema(idxColSchema)\ndiff --git a/pkg/statistics/BUILD.bazel b/pkg/statistics/BUILD.bazel\nindex 3cee0ca23c22d..ebd53f29e78f0 100644\n--- a/pkg/statistics/BUILD.bazel\n+++ b/pkg/statistics/BUILD.bazel\n@@ -83,7 +83,7 @@ go_test(\n     data = glob([\"testdata/**\"]),\n     embed = [\":statistics\"],\n     flaky = True,\n-    shard_count = 41,\n+    shard_count = 42,\n     deps = [\n         \"//pkg/config\",\n         \"//pkg/meta/model\",\ndiff --git a/pkg/statistics/handle/handle.go b/pkg/statistics/handle/handle.go\nindex 99fcbe8fb17d9..d7ddda75d9e1d 100644\n--- a/pkg/statistics/handle/handle.go\n+++ b/pkg/statistics/handle/handle.go\n@@ -174,8 +174,8 @@ func NewHandle(\n // physicalTableID can be a table ID or partition ID.\n func (h *Handle) GetPhysicalTableStats(physicalTableID int64, tblInfo *model.TableInfo) *statistics.Table {\n \ttblStats, found := h.getStatsByPhysicalID(physicalTableID, tblInfo)\n-\tintest.Assert(tblStats != nil, \"stats shoud not be nil\")\n-\tintest.Assert(found, \"stats shoud not be nil\")\n+\tintest.Assert(tblStats != nil, \"stats should not be nil\")\n+\tintest.Assert(found, \"stats should not be nil\")\n \treturn tblStats\n }\n \ndiff --git a/pkg/statistics/histogram.go b/pkg/statistics/histogram.go\nindex 41f185ccbc1b2..caa725df0e0a8 100644\n--- a/pkg/statistics/histogram.go\n+++ b/pkg/statistics/histogram.go\n@@ -53,6 +53,12 @@ const (\n \toutOfRangeBetweenRate float64 = 100\n )\n \n+var (\n+\t// Global static chunk for pseudo histograms to avoid chunk allocation\n+\tglobalPseudoChunkOnce sync.Once\n+\tglobalPseudoChunk     *chunk.Chunk\n+)\n+\n // Histogram represents statistics for a column or index.\n type Histogram struct {\n \tTp *types.FieldType\n@@ -115,15 +121,55 @@ type scalar struct {\n // EmptyScalarSize is the size of empty scalar.\n const EmptyScalarSize = int64(unsafe.Sizeof(scalar{}))\n \n-// NewHistogram creates a new histogram.\n-func NewHistogram(id, ndv, nullCount int64, version uint64, tp *types.FieldType, bucketSize int, totColSize int64) *Histogram {\n+// initGlobalPseudoChunk initializes the global static chunk for pseudo histograms\n+func initGlobalPseudoChunk() {\n+\t// Create a minimal empty chunk that can be shared across all pseudo histograms\n+\t// Use a basic field type that won't cause issues when shared\n+\tglobalPseudoChunk = chunk.NewEmptyChunk([]*types.FieldType{types.NewFieldType(mysql.TypeBlob)})\n+}\n+\n+// getGlobalPseudoChunk returns the shared static chunk for pseudo histograms\n+// WARNING: The returned chunk MUST NOT be modified. It is shared across all pseudo histograms.\n+// Pseudo histograms should never have buckets added or bounds modified.\n+func getGlobalPseudoChunk() *chunk.Chunk {\n+\tglobalPseudoChunkOnce.Do(initGlobalPseudoChunk)\n+\treturn globalPseudoChunk\n+}\n+\n+// prepareFieldTypeForHistogram prepares the field type for histogram usage.\n+// For string types, it clones the field type and sets the collation to binary\n+// to avoid decoding issues with the histogram's key representation.\n+func prepareFieldTypeForHistogram(tp *types.FieldType) *types.FieldType {\n \tif tp.EvalType() == types.ETString {\n \t\t// The histogram will store the string value's 'sort key' representation of its collation.\n-\t\t// If we directly set the field type's collation to its original one. We would decode the Key representation using its collation.\n+\t\t// If we directly set the field type's collation to its original one, we would decode the Key representation using its collation.\n \t\t// This would cause panic. So we apply a little trick here to avoid decoding it by explicitly changing the collation to 'CollationBin'.\n \t\ttp = tp.Clone()\n \t\ttp.SetCollate(charset.CollationBin)\n \t}\n+\treturn tp\n+}\n+\n+// NewPseudoHistogram creates a pseudo histogram that reuses global static components\n+// This avoids chunk allocation while preserving field type semantics.\n+func NewPseudoHistogram(id int64, tp *types.FieldType) *Histogram {\n+\ttp = prepareFieldTypeForHistogram(tp)\n+\treturn &Histogram{\n+\t\tID:                id,\n+\t\tNDV:               0,\n+\t\tNullCount:         0,\n+\t\tLastUpdateVersion: 0,\n+\t\tTp:                tp,\n+\t\tBounds:            getGlobalPseudoChunk(),\n+\t\tBuckets:           make([]Bucket, 0),\n+\t\tTotColSize:        0,\n+\t\tCorrelation:       0,\n+\t}\n+}\n+\n+// NewHistogram creates a new histogram.\n+func NewHistogram(id, ndv, nullCount int64, version uint64, tp *types.FieldType, bucketSize int, totColSize int64) *Histogram {\n+\ttp = prepareFieldTypeForHistogram(tp)\n \treturn &Histogram{\n \t\tID:                id,\n \t\tNDV:               ndv,\ndiff --git a/pkg/statistics/table.go b/pkg/statistics/table.go\nindex db73e30549d6e..db1326528ace3 100644\n--- a/pkg/statistics/table.go\n+++ b/pkg/statistics/table.go\n@@ -1069,23 +1069,39 @@ func (coll *HistColl) GenerateHistCollFromColumnInfo(tblInfo *model.TableInfo, c\n \treturn newColl\n }\n \n+// PseudoHistColl creates a lightweight pseudo HistColl for cost calculation.\n+// This is optimized for cases where only HistColl is needed, avoiding the overhead\n+// of creating a full pseudo table with ColAndIdxExistenceMap and other structures.\n+func PseudoHistColl(physicalID int64, allowTriggerLoading bool) HistColl {\n+\treturn HistColl{\n+\t\tRealtimeCount:     PseudoRowCount,\n+\t\tPhysicalID:        physicalID,\n+\t\tcolumns:           nil,\n+\t\tindices:           nil,\n+\t\tPseudo:            true,\n+\t\tCanNotTriggerLoad: !allowTriggerLoading,\n+\t\tModifyCount:       0,\n+\t\tStatsVer:          0,\n+\t}\n+}\n+\n // PseudoTable creates a pseudo table statistics.\n // Usually, we don't want to trigger stats loading for pseudo table.\n // But there are exceptional cases. In such cases, we should pass allowTriggerLoading as true.\n // Such case could possibly happen in getStatsTable().\n func PseudoTable(tblInfo *model.TableInfo, allowTriggerLoading bool, allowFillHistMeta bool) *Table {\n-\tpseudoHistColl := HistColl{\n-\t\tRealtimeCount:     PseudoRowCount,\n-\t\tPhysicalID:        tblInfo.ID,\n-\t\tcolumns:           make(map[int64]*Column, 2),\n-\t\tindices:           make(map[int64]*Index, 2),\n-\t\tPseudo:            true,\n-\t\tCanNotTriggerLoad: !allowTriggerLoading,\n-\t}\n \tt := &Table{\n-\t\tHistColl:              pseudoHistColl,\n+\t\tHistColl:              PseudoHistColl(tblInfo.ID, allowTriggerLoading),\n+\t\tVersion:               PseudoVersion,\n \t\tColAndIdxExistenceMap: NewColAndIndexExistenceMap(len(tblInfo.Columns), len(tblInfo.Indices)),\n \t}\n+\n+\t// Initialize columns and indices maps only when allowFillHistMeta is true\n+\tif allowFillHistMeta {\n+\t\tt.columns = make(map[int64]*Column, len(tblInfo.Columns))\n+\t\tt.indices = make(map[int64]*Index, len(tblInfo.Indices))\n+\t}\n+\n \tfor _, col := range tblInfo.Columns {\n \t\t// The column is public to use. Also we should check the column is not hidden since hidden means that it's used by expression index.\n \t\t// We would not collect stats for the hidden column and we won't use the hidden column to estimate.\n@@ -1097,7 +1113,7 @@ func PseudoTable(tblInfo *model.TableInfo, allowTriggerLoading bool, allowFillHi\n \t\t\t\t\tPhysicalID: tblInfo.ID,\n \t\t\t\t\tInfo:       col,\n \t\t\t\t\tIsHandle:   tblInfo.PKIsHandle && mysql.HasPriKeyFlag(col.GetFlag()),\n-\t\t\t\t\tHistogram:  *NewHistogram(col.ID, 0, 0, 0, &col.FieldType, 0, 0),\n+\t\t\t\t\tHistogram:  *NewPseudoHistogram(col.ID, &col.FieldType),\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -1109,7 +1125,7 @@ func PseudoTable(tblInfo *model.TableInfo, allowTriggerLoading bool, allowFillHi\n \t\t\t\tt.indices[idx.ID] = &Index{\n \t\t\t\t\tPhysicalID: tblInfo.ID,\n \t\t\t\t\tInfo:       idx,\n-\t\t\t\t\tHistogram:  *NewHistogram(idx.ID, 0, 0, 0, types.NewFieldType(mysql.TypeBlob), 0, 0),\n+\t\t\t\t\tHistogram:  *NewPseudoHistogram(idx.ID, types.NewFieldType(mysql.TypeBlob)),\n \t\t\t\t}\n \t\t\t}\n \t\t}\n", "test_patch": "diff --git a/pkg/statistics/histogram_test.go b/pkg/statistics/histogram_test.go\nindex 4ba9364883e25..2aa73037e34ee 100644\n--- a/pkg/statistics/histogram_test.go\n+++ b/pkg/statistics/histogram_test.go\n@@ -696,3 +696,42 @@ func TestStandardizeForV2AnalyzeIndex(t *testing.T) {\n \t\t\tfmt.Sprintf(\"testData[%d].inputHist:%s\", i, test.inputHistToStr))\n \t}\n }\n+\n+func TestNewPseudoHistogramReuseChunk(t *testing.T) {\n+\tconst (\n+\t\tmsgPseudoSameChunk   = \"pseudo histograms should share the same Bounds chunk\"\n+\t\tmsgRegularDiffChunks = \"regular histograms should have different Bounds chunks\"\n+\t\tmsgRegularPseudoDiff = \"regular and pseudo histograms should have different Bounds chunks\"\n+\t)\n+\n+\t// test that NewPseudoHistogram reuses the same global chunk instance\n+\ttp1 := types.NewFieldType(mysql.TypeLonglong)\n+\ttp2 := types.NewFieldType(mysql.TypeVarchar)\n+\ttp3 := types.NewFieldType(mysql.TypeBlob)\n+\n+\thist1 := NewPseudoHistogram(1, tp1)\n+\thist2 := NewPseudoHistogram(2, tp2)\n+\thist3 := NewPseudoHistogram(3, tp3)\n+\n+\t// verify that all pseudo histograms share the same Bounds chunk instance\n+\trequire.Same(t, hist1.Bounds, hist2.Bounds, msgPseudoSameChunk)\n+\trequire.Same(t, hist1.Bounds, hist3.Bounds, msgPseudoSameChunk)\n+\trequire.Same(t, hist2.Bounds, hist3.Bounds, msgPseudoSameChunk)\n+\n+\t// verify that regular histograms do NOT share chunks\n+\tregularHist1 := NewHistogram(1, 0, 0, 0, tp1, 10, 0)\n+\tregularHist2 := NewHistogram(2, 0, 0, 0, tp2, 10, 0)\n+\n+\trequire.NotSame(t, regularHist1.Bounds, regularHist2.Bounds, msgRegularDiffChunks)\n+\trequire.NotSame(t, regularHist1.Bounds, hist1.Bounds, msgRegularPseudoDiff)\n+\trequire.NotSame(t, regularHist2.Bounds, hist1.Bounds, msgRegularPseudoDiff)\n+\n+\t// verify that string type field types are properly handled\n+\trequire.Equal(t, mysql.TypeLonglong, hist1.Tp.GetType())\n+\trequire.Equal(t, mysql.TypeVarchar, hist2.Tp.GetType())\n+\trequire.Equal(t, mysql.TypeBlob, hist3.Tp.GetType())\n+\n+\t// for string types, collation should be set to binary\n+\trequire.Equal(t, \"binary\", hist2.Tp.GetCollate())\n+\trequire.Equal(t, \"binary\", hist3.Tp.GetCollate())\n+}\n"}
{"org": "pingcap", "repo": "tidb", "number": 61633, "state": "closed", "title": "executor: optimize to get key ranges", "body": "<!--\r\n\r\nThank you for contributing to TiDB!\r\n\r\nPR Title Format:\r\n1. pkg [, pkg2, pkg3]: what's changed\r\n2. *: what's changed\r\n\r\n-->\r\n\r\n### What problem does this PR solve?\r\n<!--\r\n\r\nPlease create an issue first to describe the problem.\r\n\r\nThere MUST be one line starting with \"Issue Number:  \" and\r\nlinking the relevant issues via the \"close\" or \"ref\".\r\n\r\nFor more info, check https://pingcap.github.io/tidb-dev-guide/contribute-to-tidb/contribute-code.html#referring-to-an-issue.\r\n\r\n-->\r\n\r\nIssue Number: close #61640\r\n\r\nProblem Summary:\r\n\r\n### What changed and how does it work?\r\n\r\n### Check List\r\n\r\nTests <!-- At least one of them must be included. -->\r\n\r\n- [x] Unit test\r\n- [x] Integration test\r\n- [ ] Manual test (add detailed scripts or steps below)\r\n- [ ] No need to test\r\n  > - [ ] I checked and no code files have been changed.\r\n  > <!-- Or your custom  \"No need to test\" reasons -->\r\n\r\nSide effects\r\n\r\n- [ ] Performance regression: Consumes more CPU\r\n- [ ] Performance regression: Consumes more Memory\r\n- [ ] Breaking backward compatibility\r\n\r\nDocumentation\r\n\r\n- [ ] Affects user behaviors\r\n- [ ] Contains syntax changes\r\n- [ ] Contains variable changes\r\n- [ ] Contains experimental features\r\n- [ ] Changes MySQL compatibility\r\n\r\n### Release note\r\n\r\n<!-- compatibility change, improvement, bugfix, and new feature need a release note -->\r\n\r\nPlease refer to [Release Notes Language Style Guide](https://pingcap.github.io/tidb-dev-guide/contribute-to-tidb/release-notes-style-guide.html) to write a quality release note.\r\n\r\n```release-note\r\nNone\r\n```\r\n", "url": "https://api.github.com/repos/pingcap/tidb/pulls/61633", "id": 2581379702, "node_id": "PR_kwDOAoCpQc6Z3Lp2", "html_url": "https://github.com/pingcap/tidb/pull/61633", "diff_url": "https://github.com/pingcap/tidb/pull/61633.diff", "patch_url": "https://github.com/pingcap/tidb/pull/61633.patch", "issue_url": "https://api.github.com/repos/pingcap/tidb/issues/61633", "created_at": "2025-06-10T13:29:55+00:00", "updated_at": "2025-06-12T07:23:54+00:00", "closed_at": "2025-06-12T07:23:20+00:00", "merged_at": "2025-06-12T07:23:19+00:00", "merge_commit_sha": "648b03504954eb997a99175d6dbd3ffcba8526fb", "labels": ["sig/planner", "size/L", "release-note-none", "ok-to-test", "approved", "lgtm"], "draft": false, "commits_url": "https://api.github.com/repos/pingcap/tidb/pulls/61633/commits", "review_comments_url": "https://api.github.com/repos/pingcap/tidb/pulls/61633/comments", "review_comment_url": "https://api.github.com/repos/pingcap/tidb/pulls/comments{/number}", "comments_url": "https://api.github.com/repos/pingcap/tidb/issues/61633/comments", "base": {"label": "pingcap:master", "ref": "master", "sha": "11276faa9dc05ed7047f766a4c1fb45cd2b83109", "user": {"login": "pingcap", "id": 11855343, "node_id": "MDEyOk9yZ2FuaXphdGlvbjExODU1MzQz", "avatar_url": "https://avatars.githubusercontent.com/u/11855343?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pingcap", "html_url": "https://github.com/pingcap", "followers_url": "https://api.github.com/users/pingcap/followers", "following_url": "https://api.github.com/users/pingcap/following{/other_user}", "gists_url": "https://api.github.com/users/pingcap/gists{/gist_id}", "starred_url": "https://api.github.com/users/pingcap/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pingcap/subscriptions", "organizations_url": "https://api.github.com/users/pingcap/orgs", "repos_url": "https://api.github.com/users/pingcap/repos", "events_url": "https://api.github.com/users/pingcap/events{/privacy}", "received_events_url": "https://api.github.com/users/pingcap/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "repo": {"id": 41986369, "node_id": "MDEwOlJlcG9zaXRvcnk0MTk4NjM2OQ==", "name": "tidb", "full_name": "pingcap/tidb", "private": false, "owner": {"login": "pingcap", "id": 11855343, "node_id": "MDEyOk9yZ2FuaXphdGlvbjExODU1MzQz", "avatar_url": "https://avatars.githubusercontent.com/u/11855343?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pingcap", "html_url": "https://github.com/pingcap", "followers_url": "https://api.github.com/users/pingcap/followers", "following_url": "https://api.github.com/users/pingcap/following{/other_user}", "gists_url": "https://api.github.com/users/pingcap/gists{/gist_id}", "starred_url": "https://api.github.com/users/pingcap/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pingcap/subscriptions", "organizations_url": "https://api.github.com/users/pingcap/orgs", "repos_url": "https://api.github.com/users/pingcap/repos", "events_url": "https://api.github.com/users/pingcap/events{/privacy}", "received_events_url": "https://api.github.com/users/pingcap/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "html_url": "https://github.com/pingcap/tidb", "description": "TiDB - the open-source, cloud-native, distributed SQL database designed for modern applications.", "fork": false, "url": "https://api.github.com/repos/pingcap/tidb", "forks_url": "https://api.github.com/repos/pingcap/tidb/forks", "keys_url": "https://api.github.com/repos/pingcap/tidb/keys{/key_id}", "collaborators_url": "https://api.github.com/repos/pingcap/tidb/collaborators{/collaborator}", "teams_url": "https://api.github.com/repos/pingcap/tidb/teams", "hooks_url": "https://api.github.com/repos/pingcap/tidb/hooks", "issue_events_url": "https://api.github.com/repos/pingcap/tidb/issues/events{/number}", "events_url": "https://api.github.com/repos/pingcap/tidb/events", "assignees_url": "https://api.github.com/repos/pingcap/tidb/assignees{/user}", "branches_url": "https://api.github.com/repos/pingcap/tidb/branches{/branch}", "tags_url": "https://api.github.com/repos/pingcap/tidb/tags", "blobs_url": "https://api.github.com/repos/pingcap/tidb/git/blobs{/sha}", "git_tags_url": "https://api.github.com/repos/pingcap/tidb/git/tags{/sha}", "git_refs_url": "https://api.github.com/repos/pingcap/tidb/git/refs{/sha}", "trees_url": "https://api.github.com/repos/pingcap/tidb/git/trees{/sha}", "statuses_url": "https://api.github.com/repos/pingcap/tidb/statuses/{sha}", "languages_url": "https://api.github.com/repos/pingcap/tidb/languages", "stargazers_url": "https://api.github.com/repos/pingcap/tidb/stargazers", "contributors_url": "https://api.github.com/repos/pingcap/tidb/contributors", "subscribers_url": "https://api.github.com/repos/pingcap/tidb/subscribers", "subscription_url": "https://api.github.com/repos/pingcap/tidb/subscription", "commits_url": "https://api.github.com/repos/pingcap/tidb/commits{/sha}", "git_commits_url": "https://api.github.com/repos/pingcap/tidb/git/commits{/sha}", "comments_url": "https://api.github.com/repos/pingcap/tidb/comments{/number}", "issue_comment_url": "https://api.github.com/repos/pingcap/tidb/issues/comments{/number}", "contents_url": "https://api.github.com/repos/pingcap/tidb/contents/{+path}", "compare_url": "https://api.github.com/repos/pingcap/tidb/compare/{base}...{head}", "merges_url": "https://api.github.com/repos/pingcap/tidb/merges", "archive_url": "https://api.github.com/repos/pingcap/tidb/{archive_format}{/ref}", "downloads_url": "https://api.github.com/repos/pingcap/tidb/downloads", "issues_url": "https://api.github.com/repos/pingcap/tidb/issues{/number}", "pulls_url": "https://api.github.com/repos/pingcap/tidb/pulls{/number}", "milestones_url": "https://api.github.com/repos/pingcap/tidb/milestones{/number}", "notifications_url": "https://api.github.com/repos/pingcap/tidb/notifications{?since,all,participating}", "labels_url": "https://api.github.com/repos/pingcap/tidb/labels{/name}", "releases_url": "https://api.github.com/repos/pingcap/tidb/releases{/id}", "deployments_url": "https://api.github.com/repos/pingcap/tidb/deployments", "created_at": "2015-09-06T04:01:52Z", "updated_at": "2026-01-07T08:42:13Z", "pushed_at": "2026-01-07T08:42:08Z", "git_url": "git://github.com/pingcap/tidb.git", "ssh_url": "git@github.com:pingcap/tidb.git", "clone_url": "https://github.com/pingcap/tidb.git", "svn_url": "https://github.com/pingcap/tidb", "homepage": "https://pingcap.com", "size": 588595, "stargazers_count": 39565, "watchers_count": 39565, "language": "Go", "has_issues": true, "has_projects": true, "has_downloads": true, "has_wiki": true, "has_pages": false, "has_discussions": true, "forks_count": 6089, "mirror_url": null, "archived": false, "disabled": false, "open_issues_count": 5461, "license": {"key": "apache-2.0", "name": "Apache License 2.0", "spdx_id": "Apache-2.0", "url": "https://api.github.com/licenses/apache-2.0", "node_id": "MDc6TGljZW5zZTI="}, "allow_forking": true, "is_template": false, "web_commit_signoff_required": false, "topics": ["cloud-native", "database", "distributed-database", "distributed-transactions", "go", "hacktoberfest", "htap", "mysql", "mysql-compatibility", "scale", "serverless", "sql", "tidb"], "visibility": "public", "forks": 6089, "open_issues": 5461, "watchers": 39565, "default_branch": "master"}}, "commits": [{"sha": "81c69d156f83466ed28ab243d3f6b6dc7254b58f", "parents": ["51f0587d495686f1bd7b39fee59121e3650c2bba"], "message": "optimize key ranges\n\nSigned-off-by: 童剑 <1045931706@qq.com>"}, {"sha": "a9cb972c06469b07b76dcd236e4c6c76f7c6d2ca", "parents": ["81c69d156f83466ed28ab243d3f6b6dc7254b58f"], "message": "use slices.SortFunc\n\nSigned-off-by: 童剑 <1045931706@qq.com>"}, {"sha": "0d046ac6012b3f281156c6cc78fdbab838479a5b", "parents": ["a9cb972c06469b07b76dcd236e4c6c76f7c6d2ca", "11276faa9dc05ed7047f766a4c1fb45cd2b83109"], "message": "Merge branch 'master' of https://github.com/pingcap/tidb into optimize_key_ranges"}, {"sha": "004e72e55d270836b5577773618a4354e422eade", "parents": ["0d046ac6012b3f281156c6cc78fdbab838479a5b"], "message": "sort\n\nSigned-off-by: bufferflies <1045931706@qq.com>"}], "resolved_issues": [{"org": "pingcap", "repo": "tidb", "number": 61640, "state": "closed", "title": "optimize the keyrange if using multi continuous partitions", "body": "## Enhancement\n"}], "fix_patch": "diff --git a/pkg/executor/distribute.go b/pkg/executor/distribute.go\nindex 783836002157c..3afe005d4b235 100644\n--- a/pkg/executor/distribute.go\n+++ b/pkg/executor/distribute.go\n@@ -15,7 +15,9 @@\n package executor\n \n import (\n+\t\"cmp\"\n \t\"context\"\n+\t\"slices\"\n \t\"strings\"\n \n \t\"github.com/pingcap/tidb/pkg/domain/infosync\"\n@@ -55,6 +57,9 @@ func (e *DistributeTableExec) Open(context.Context) error {\n \t\treturn err\n \t}\n \te.keyRanges = ranges\n+\tslices.SortFunc(e.partitionNames, func(i, j ast.CIStr) int {\n+\t\treturn cmp.Compare(i.L, j.L)\n+\t})\n \treturn nil\n }\n \n@@ -158,13 +163,18 @@ func (e *DistributeTableExec) getKeyRanges() ([]*pdhttp.KeyRange, error) {\n \t\t\t}\n \t\t}\n \t}\n+\tslices.Sort(physicalIDs)\n \n \tranges := make([]*pdhttp.KeyRange, 0, len(physicalIDs))\n-\tfor _, pid := range physicalIDs {\n-\t\tstartKey := codec.EncodeBytes([]byte{}, tablecodec.GenTablePrefix(pid))\n-\t\tendKey := codec.EncodeBytes([]byte{}, tablecodec.GenTablePrefix(pid+1))\n-\t\tr := pdhttp.NewKeyRange(startKey, endKey)\n-\t\tranges = append(ranges, r)\n+\tfor i, pid := range physicalIDs {\n+\t\tif i == 0 || physicalIDs[i] != physicalIDs[i-1]+1 {\n+\t\t\tstartKey := codec.EncodeBytes([]byte{}, tablecodec.GenTablePrefix(pid))\n+\t\t\tendKey := codec.EncodeBytes([]byte{}, tablecodec.GenTablePrefix(pid+1))\n+\t\t\tr := pdhttp.NewKeyRange(startKey, endKey)\n+\t\t\tranges = append(ranges, r)\n+\t\t} else {\n+\t\t\tranges[len(ranges)-1].EndKey = codec.EncodeBytes([]byte{}, tablecodec.GenTablePrefix(pid+1))\n+\t\t}\n \t}\n \treturn ranges, nil\n }\ndiff --git a/pkg/planner/core/planbuilder.go b/pkg/planner/core/planbuilder.go\nindex 1ca92b445f254..e12be01de4141 100644\n--- a/pkg/planner/core/planbuilder.go\n+++ b/pkg/planner/core/planbuilder.go\n@@ -4821,7 +4821,7 @@ func (b *PlanBuilder) buildDistributeTable(node *ast.DistributeTableStmt) (base.\n \ttnW := b.resolveCtx.GetTableName(node.Table)\n \ttblInfo := tnW.TableInfo\n \tif !slices.Contains(ruleList, node.Rule.L) {\n-\t\treturn nil, plannererrors.ErrWrongArguments.GenWithStackByArgs(\"rule must be leader-scatter, follower-scatter or learner-scatter\")\n+\t\treturn nil, plannererrors.ErrWrongArguments.GenWithStackByArgs(\"rule must be leader-scatter, peer-scatter or learner-scatter\")\n \t}\n \tif !slices.Contains(engineList, node.Engine.L) {\n \t\treturn nil, plannererrors.ErrWrongArguments.GenWithStackByArgs(\"engine must be tikv or tiflash\")\n", "test_patch": "diff --git a/pkg/executor/distribute_table_test.go b/pkg/executor/distribute_table_test.go\nindex 1eea545f4e5e1..9cf60c3403572 100644\n--- a/pkg/executor/distribute_table_test.go\n+++ b/pkg/executor/distribute_table_test.go\n@@ -19,6 +19,7 @@ import (\n \t\"encoding/json\"\n \t\"fmt\"\n \t\"net/url\"\n+\t\"slices\"\n \t\"strings\"\n \t\"testing\"\n \t\"time\"\n@@ -124,19 +125,43 @@ func TestDistributeTable(t *testing.T) {\n \tcli := &MockDistributePDCli{}\n \trecoverCli := infosync.SetPDHttpCliForTest(cli)\n \tdefer recoverCli()\n-\tmockCreateSchedulerWithInput := func(tblName, partition string, config map[string]any) *mock.Call {\n+\tmockCreateSchedulerWithInput := func(tblName string, config map[string]any, partitions []string) *mock.Call {\n \t\tis := tk.Session().GetDomainInfoSchema()\n \t\ttbl, err := is.TableInfoByName(ast.NewCIStr(database), ast.NewCIStr(tblName))\n \t\trequire.NoError(t, err)\n \t\ttblID := tbl.ID\n-\t\tif partition != \"\" {\n-\t\t\ttblID = tbl.GetPartitionInfo().GetPartitionIDByName(partition)\n+\t\tpi := tbl.GetPartitionInfo()\n+\t\tpids := make([]int64, 0)\n+\t\tif pi == nil {\n+\t\t\tpids = append(pids, tblID)\n+\t\t} else {\n+\t\t\tif len(partitions) > 0 {\n+\t\t\t\tfor _, partition := range partitions {\n+\t\t\t\t\tpids = append(pids, pi.GetPartitionIDByName(partition))\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tfor _, partition := range pi.Definitions {\n+\t\t\t\t\tpids = append(pids, partition.ID)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tstarts := make([]string, 0)\n+\t\tends := make([]string, 0)\n+\t\tslices.Sort(pids)\n+\t\tfor i, pid := range pids {\n+\t\t\tif i == 0 || pid != pids[i-1]+1 {\n+\t\t\t\tstartKey := codec.EncodeBytes([]byte{}, tablecodec.GenTablePrefix(pid))\n+\t\t\t\tendKey := codec.EncodeBytes([]byte{}, tablecodec.GenTablePrefix(pid+1))\n+\t\t\t\tstarts = append(starts, url.QueryEscape(string(startKey)))\n+\t\t\t\tends = append(ends, url.QueryEscape(string(endKey)))\n+\t\t\t} else {\n+\t\t\t\tendKey := codec.EncodeBytes([]byte{}, tablecodec.GenTablePrefix(pid+1))\n+\t\t\t\tends[len(starts)-1] = url.QueryEscape(string(endKey))\n+\t\t\t}\n \t\t}\n \n-\t\tstartKey := codec.EncodeBytes([]byte{}, tablecodec.GenTablePrefix(tblID))\n-\t\tendKey := codec.EncodeBytes([]byte{}, tablecodec.GenTablePrefix(tblID+1))\n-\t\tconfig[\"start-key\"] = url.QueryEscape(string(startKey))\n-\t\tconfig[\"end-key\"] = url.QueryEscape(string(endKey))\n+\t\tconfig[\"start-key\"] = strings.Join(starts, \",\")\n+\t\tconfig[\"end-key\"] = strings.Join(ends, \",\")\n \t\treturn cli.On(\"CreateSchedulerWithInput\", mock.Anything, schedulerName, config).\n \t\t\tReturn(nil)\n \t}\n@@ -147,24 +172,42 @@ func TestDistributeTable(t *testing.T) {\n \ttable := \"t1\"\n \tpartition := \"\"\n \n-\talias := strings.Join([]string{database, table, partition}, \".\")\n \tconfig := map[string]any{\n-\t\t\"alias\":  alias,\n+\t\t\"alias\":  strings.Join([]string{database, table, partition}, \".\"),\n \t\t\"engine\": \"tikv\",\n \t\t\"rule\":   \"leader-scatter\",\n \t}\n-\ttk.MustExec(\"create table t1(a int)\")\n+\ttk.MustExec(`create table t1 (\n+\t\tc1 int, c2 int, c3 int\n+\t)\n+\tpartition by range( c1 ) (\n+\t\tpartition p0 values less than (1024),\n+\t\tpartition p1 values less than (2048),\n+\t\tpartition p2 values less than (3072)\n+\t   );`)\n \tmockGetSchedulerConfig(\"balance-range-scheduler\")\n-\tmockCreateSchedulerWithInput(table, partition, config)\n+\tmockCreateSchedulerWithInput(table, config, nil)\n \ttk.MustQuery(fmt.Sprintf(\"distribute table %s rule=`leader-scatter` engine=tikv\", table)).Check(testkit.Rows(\"1\"))\n-\t// create new scheduler with the same inputs\n-\tmockCreateSchedulerWithInput(table, partition, config)\n-\ttk.MustQuery(fmt.Sprintf(\"distribute table %s rule=`leader-scatter` engine=tikv\", table)).Check(testkit.Rows(\"2\"))\n+\t// test for multi partitions\n+\tpartition = \"partition(p1,p2)\"\n+\tconfig[\"alias\"] = strings.Join([]string{database, table, partition}, \".\")\n+\tmockCreateSchedulerWithInput(table, config, []string{\"p1\", \"p2\"})\n+\ttk.MustQuery(fmt.Sprintf(\"distribute table %s partition (p1,p2) rule=`leader-scatter` engine=tikv\", table)).Check(testkit.Rows(\"2\"))\n+\t// test for unordered partitions\n+\ttk.MustQuery(fmt.Sprintf(\"distribute table %s partition (p2,p1) rule=`leader-scatter` engine=tikv\", table)).Check(testkit.Rows(\"3\"))\n \n \t// test for timeout\n+\tpartition = \"partition(p0)\"\n+\tconfig[\"alias\"] = strings.Join([]string{database, table, partition}, \".\")\n+\tconfig[\"timeout\"] = \"30m\"\n+\tmockCreateSchedulerWithInput(table, config, []string{\"p0\"})\n+\ttk.MustQuery(fmt.Sprintf(\"distribute table %s partition(p0) rule=`leader-scatter` engine=tikv timeout=`30m`\", table)).Check(testkit.Rows(\"4\"))\n+\n+\tpartition = \"partition(p0,p2)\"\n+\tconfig[\"alias\"] = strings.Join([]string{database, table, partition}, \".\")\n \tconfig[\"timeout\"] = \"30m\"\n-\tmockCreateSchedulerWithInput(table, partition, config)\n-\ttk.MustQuery(fmt.Sprintf(\"distribute table %s rule=`leader-scatter` engine=tikv timeout=`30m`\", table)).Check(testkit.Rows(\"3\"))\n+\tmockCreateSchedulerWithInput(table, config, []string{\"p0\", \"p2\"})\n+\ttk.MustQuery(fmt.Sprintf(\"distribute table %s partition(p0,p2) rule=`leader-scatter` engine=tikv timeout=`30m`\", table)).Check(testkit.Rows(\"5\"))\n \n \t// test for incorrect arguments\n \ttk.MustGetErrMsg(fmt.Sprintf(\"distribute table %s rule=`leader-scatter` engine=tiflash\", table),\n@@ -172,7 +215,7 @@ func TestDistributeTable(t *testing.T) {\n \ttk.MustGetErrMsg(fmt.Sprintf(\"distribute table %s rule=`leader-scatter` engine=titan\", table),\n \t\t\"[planner:1210]Incorrect arguments to engine must be tikv or tiflash\")\n \ttk.MustGetErrMsg(fmt.Sprintf(\"distribute table %s rule=`witness` engine=tikv\", table),\n-\t\t\"[planner:1210]Incorrect arguments to rule must be leader-scatter, follower-scatter or learner-scatter\")\n+\t\t\"[planner:1210]Incorrect arguments to rule must be leader-scatter, peer-scatter or learner-scatter\")\n }\n \n func TestShowTableDistributions(t *testing.T) {\n"}
{"org": "go-gitea", "repo": "gitea", "number": 34154, "state": "closed", "title": "Refactor Git Attribute & performance optimization", "body": "This PR moved git attributes related code to `modules/git/attribute` sub package and moved language stats related code to `modules/git/languagestats` sub package to make it easier to maintain.\r\n\r\nAnd it also introduced a performance improvement which use the `git check-attr --source` which can be run in a bare git repository so that we don't need to create a git index file. The new parameter need a git version >= 2.40 . If git version less than 2.40, it will fall back to previous implementation.\r\n\r\nBefore:\r\n```\r\ngit-run duration=1.2684s func.caller=git.(*Repository).readTreeToIndex git.command=\"/opt/homebrew/bin/git ...global... read-tree 70187f7727d4ddd8282b576ece93ca233e88b19e\"\r\ngit-run duration=0.1633s func.caller=git.(*CheckAttributeReader).Run git.command=\"/opt/homebrew/bin/git ...global... check-attr --stdin -z --cached linguist-vendored linguist-generated linguist-documentation linguist-detectable linguist-language gitlab-language\"\r\n```\r\n\r\nAfter:\r\n```\r\ngit-run duration=0.1271s func.caller=attribute.(*BatchChecker).run git.command=\"/opt/homebrew/bin/git ...global... check-attr -z --source 70187f7727d4ddd8282b576ece93ca233e88b19e linguist-vendored linguist-generated linguist-language gitlab-language --stdin\"\r\n```", "url": "https://api.github.com/repos/go-gitea/gitea/pulls/34154", "id": 2447002148, "node_id": "PR_kwDOBFIx286R2kok", "html_url": "https://github.com/go-gitea/gitea/pull/34154", "diff_url": "https://github.com/go-gitea/gitea/pull/34154.diff", "patch_url": "https://github.com/go-gitea/gitea/pull/34154.patch", "issue_url": "https://api.github.com/repos/go-gitea/gitea/issues/34154", "created_at": "2025-04-08T21:36:11+00:00", "updated_at": "2025-07-10T15:46:47+00:00", "closed_at": "2025-04-11T13:41:29+00:00", "merged_at": "2025-04-11T13:41:29+00:00", "merge_commit_sha": "ae0af8ea5b2de99a49add2b7f7b76dde62a8a617", "labels": ["lgtm/done", "type/refactoring", "performance/speed", "modifies/go"], "draft": false, "commits_url": "https://api.github.com/repos/go-gitea/gitea/pulls/34154/commits", "review_comments_url": "https://api.github.com/repos/go-gitea/gitea/pulls/34154/comments", "review_comment_url": "https://api.github.com/repos/go-gitea/gitea/pulls/comments{/number}", "comments_url": "https://api.github.com/repos/go-gitea/gitea/issues/34154/comments", "base": {"label": "go-gitea:main", "ref": "main", "sha": "d725b78824a6e83bc5f6db3c83f742810241d1ee", "user": {"login": "go-gitea", "id": 12724356, "node_id": "MDEyOk9yZ2FuaXphdGlvbjEyNzI0MzU2", "avatar_url": "https://avatars.githubusercontent.com/u/12724356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/go-gitea", "html_url": "https://github.com/go-gitea", "followers_url": "https://api.github.com/users/go-gitea/followers", "following_url": "https://api.github.com/users/go-gitea/following{/other_user}", "gists_url": "https://api.github.com/users/go-gitea/gists{/gist_id}", "starred_url": "https://api.github.com/users/go-gitea/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/go-gitea/subscriptions", "organizations_url": "https://api.github.com/users/go-gitea/orgs", "repos_url": "https://api.github.com/users/go-gitea/repos", "events_url": "https://api.github.com/users/go-gitea/events{/privacy}", "received_events_url": "https://api.github.com/users/go-gitea/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "repo": {"id": 72495579, "node_id": "MDEwOlJlcG9zaXRvcnk3MjQ5NTU3OQ==", "name": "gitea", "full_name": "go-gitea/gitea", "private": false, "owner": {"login": "go-gitea", "id": 12724356, "node_id": "MDEyOk9yZ2FuaXphdGlvbjEyNzI0MzU2", "avatar_url": "https://avatars.githubusercontent.com/u/12724356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/go-gitea", "html_url": "https://github.com/go-gitea", "followers_url": "https://api.github.com/users/go-gitea/followers", "following_url": "https://api.github.com/users/go-gitea/following{/other_user}", "gists_url": "https://api.github.com/users/go-gitea/gists{/gist_id}", "starred_url": "https://api.github.com/users/go-gitea/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/go-gitea/subscriptions", "organizations_url": "https://api.github.com/users/go-gitea/orgs", "repos_url": "https://api.github.com/users/go-gitea/repos", "events_url": "https://api.github.com/users/go-gitea/events{/privacy}", "received_events_url": "https://api.github.com/users/go-gitea/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "html_url": "https://github.com/go-gitea/gitea", "description": "Git with a cup of tea! Painless self-hosted all-in-one software development service, including Git hosting, code review, team collaboration, package registry and CI/CD", "fork": false, "url": "https://api.github.com/repos/go-gitea/gitea", "forks_url": "https://api.github.com/repos/go-gitea/gitea/forks", "keys_url": "https://api.github.com/repos/go-gitea/gitea/keys{/key_id}", "collaborators_url": "https://api.github.com/repos/go-gitea/gitea/collaborators{/collaborator}", "teams_url": "https://api.github.com/repos/go-gitea/gitea/teams", "hooks_url": "https://api.github.com/repos/go-gitea/gitea/hooks", "issue_events_url": "https://api.github.com/repos/go-gitea/gitea/issues/events{/number}", "events_url": "https://api.github.com/repos/go-gitea/gitea/events", "assignees_url": "https://api.github.com/repos/go-gitea/gitea/assignees{/user}", "branches_url": "https://api.github.com/repos/go-gitea/gitea/branches{/branch}", "tags_url": "https://api.github.com/repos/go-gitea/gitea/tags", "blobs_url": "https://api.github.com/repos/go-gitea/gitea/git/blobs{/sha}", "git_tags_url": "https://api.github.com/repos/go-gitea/gitea/git/tags{/sha}", "git_refs_url": "https://api.github.com/repos/go-gitea/gitea/git/refs{/sha}", "trees_url": "https://api.github.com/repos/go-gitea/gitea/git/trees{/sha}", "statuses_url": "https://api.github.com/repos/go-gitea/gitea/statuses/{sha}", "languages_url": "https://api.github.com/repos/go-gitea/gitea/languages", "stargazers_url": "https://api.github.com/repos/go-gitea/gitea/stargazers", "contributors_url": "https://api.github.com/repos/go-gitea/gitea/contributors", "subscribers_url": "https://api.github.com/repos/go-gitea/gitea/subscribers", "subscription_url": "https://api.github.com/repos/go-gitea/gitea/subscription", "commits_url": "https://api.github.com/repos/go-gitea/gitea/commits{/sha}", "git_commits_url": "https://api.github.com/repos/go-gitea/gitea/git/commits{/sha}", "comments_url": "https://api.github.com/repos/go-gitea/gitea/comments{/number}", "issue_comment_url": "https://api.github.com/repos/go-gitea/gitea/issues/comments{/number}", "contents_url": "https://api.github.com/repos/go-gitea/gitea/contents/{+path}", "compare_url": "https://api.github.com/repos/go-gitea/gitea/compare/{base}...{head}", "merges_url": "https://api.github.com/repos/go-gitea/gitea/merges", "archive_url": "https://api.github.com/repos/go-gitea/gitea/{archive_format}{/ref}", "downloads_url": "https://api.github.com/repos/go-gitea/gitea/downloads", "issues_url": "https://api.github.com/repos/go-gitea/gitea/issues{/number}", "pulls_url": "https://api.github.com/repos/go-gitea/gitea/pulls{/number}", "milestones_url": "https://api.github.com/repos/go-gitea/gitea/milestones{/number}", "notifications_url": "https://api.github.com/repos/go-gitea/gitea/notifications{?since,all,participating}", "labels_url": "https://api.github.com/repos/go-gitea/gitea/labels{/name}", "releases_url": "https://api.github.com/repos/go-gitea/gitea/releases{/id}", "deployments_url": "https://api.github.com/repos/go-gitea/gitea/deployments", "created_at": "2016-11-01T02:13:26Z", "updated_at": "2026-01-07T07:02:30Z", "pushed_at": "2026-01-07T06:08:59Z", "git_url": "git://github.com/go-gitea/gitea.git", "ssh_url": "git@github.com:go-gitea/gitea.git", "clone_url": "https://github.com/go-gitea/gitea.git", "svn_url": "https://github.com/go-gitea/gitea", "homepage": "https://gitea.com", "size": 322636, "stargazers_count": 52973, "watchers_count": 52973, "language": "Go", "has_issues": true, "has_projects": false, "has_downloads": true, "has_wiki": false, "has_pages": false, "has_discussions": false, "forks_count": 6304, "mirror_url": null, "archived": false, "disabled": false, "open_issues_count": 2885, "license": {"key": "mit", "name": "MIT License", "spdx_id": "MIT", "url": "https://api.github.com/licenses/mit", "node_id": "MDc6TGljZW5zZTEz"}, "allow_forking": true, "is_template": false, "web_commit_signoff_required": true, "topics": ["bitbucket", "cicd", "devops", "docker-registry-v2", "git", "git-gui", "git-server", "gitea", "github", "github-actions", "gitlab", "go", "golang", "hacktoberfest", "maven-server", "npm-registry", "vue"], "visibility": "public", "forks": 6304, "open_issues": 2885, "watchers": 52973, "default_branch": "main"}}, "commits": [{"sha": "9321c271c0a63567c0001276f94614981709ca2f", "parents": ["d725b78824a6e83bc5f6db3c83f742810241d1ee"], "message": "Refactor Attribute"}, {"sha": "44288608a6a2f58ac2c0e5823a2f4dfe9d19172d", "parents": ["9321c271c0a63567c0001276f94614981709ca2f"], "message": "some improvements"}, {"sha": "419b959dfe0791087a129a2b26af08bc93ad1d44", "parents": ["44288608a6a2f58ac2c0e5823a2f4dfe9d19172d"], "message": "Support run attr check on bare repository if git version >= 2.40"}, {"sha": "ed1601a196605b0f20147cc35696b1c3cb5a92a0", "parents": ["419b959dfe0791087a129a2b26af08bc93ad1d44"], "message": "Fix builg gogit"}, {"sha": "0fc7704a301045c797c7dc716224e938da55c8e3", "parents": ["ed1601a196605b0f20147cc35696b1c3cb5a92a0"], "message": "Fix lint"}, {"sha": "6da7152bc1cd5df8bc1954d60462d5fdaf84e6e1", "parents": ["0fc7704a301045c797c7dc716224e938da55c8e3"], "message": "Fix bug"}, {"sha": "2a3571de281b62645e734b88f5774901397e4886", "parents": ["6da7152bc1cd5df8bc1954d60462d5fdaf84e6e1"], "message": "Fix bug"}, {"sha": "33b1cebdd63c66c0077e306a01dcc5760bf683e1", "parents": ["2a3571de281b62645e734b88f5774901397e4886"], "message": "Fix bug"}, {"sha": "1f473af6e1173de266cd0621252a838194f4531a", "parents": ["33b1cebdd63c66c0077e306a01dcc5760bf683e1"], "message": "Fix bug"}, {"sha": "1c4821239564f13c17f7d8f037ce4baef2c06a5b", "parents": ["1f473af6e1173de266cd0621252a838194f4531a"], "message": "Fix test"}, {"sha": "f98e2c7ff2a51e18efb25e197037a08ef9f63a80", "parents": ["1c4821239564f13c17f7d8f037ce4baef2c06a5b"], "message": "Fix lint"}, {"sha": "bdfb061041f94ed9e94aae35bd53fc2ad27d4a99", "parents": ["f98e2c7ff2a51e18efb25e197037a08ef9f63a80"], "message": "Correct tests repository under git"}, {"sha": "2d8c956ddf71ff816fa98600f33f41ab198397be", "parents": ["bdfb061041f94ed9e94aae35bd53fc2ad27d4a99"], "message": "Add tests"}, {"sha": "d17e7ad7697705ab703f5d6af7721d27decfd4ae", "parents": ["2d8c956ddf71ff816fa98600f33f41ab198397be"], "message": "Fix lint"}, {"sha": "a70ef5f701cb464e14779c133e80fa0211384d15", "parents": ["d17e7ad7697705ab703f5d6af7721d27decfd4ae"], "message": "Add trace code back"}, {"sha": "ed37f3a6600e06d63f42d66a3f86c47ab8bd0acc", "parents": ["a70ef5f701cb464e14779c133e80fa0211384d15"], "message": "Remove unnecessary code"}, {"sha": "9db67492f35f01e3e2267e19d7c441828745b2f5", "parents": ["ed37f3a6600e06d63f42d66a3f86c47ab8bd0acc"], "message": "Some improvements"}, {"sha": "d6f138b42b04d2b4aba22497eb0eafe16aa95650", "parents": ["9db67492f35f01e3e2267e19d7c441828745b2f5"], "message": "fine tune"}, {"sha": "2391070f1ef998fc411534f102513846eaf0d3eb", "parents": ["d6f138b42b04d2b4aba22497eb0eafe16aa95650"], "message": "add comment"}, {"sha": "1a522442d9e42491f4908ab640cd82431f35fca6", "parents": ["9db67492f35f01e3e2267e19d7c441828745b2f5"], "message": "merge two functions call as one"}, {"sha": "ad4af2dc03b5330531dc4412c9c1375f8ea32b5a", "parents": ["1a522442d9e42491f4908ab640cd82431f35fca6", "2391070f1ef998fc411534f102513846eaf0d3eb"], "message": "Merge branch 'lunny/attribute' of github.com:lunny/gitea into lunny/attribute"}, {"sha": "1d333296eb7c809eecf55b1c42dce586a044a55b", "parents": ["ad4af2dc03b5330531dc4412c9c1375f8ea32b5a"], "message": "don't make Attributes expose internal map"}, {"sha": "a0cfb36717ccd165e435d2d182152bc62094a89d", "parents": ["1d333296eb7c809eecf55b1c42dce586a044a55b"], "message": "improve test and comment"}, {"sha": "fca3bcf0d9a6adc37d553530bea8a3b0b278b5bf", "parents": ["a0cfb36717ccd165e435d2d182152bc62094a89d"], "message": "Update routers/web/repo/view_file.go\n\nCo-authored-by: yp05327 <576951401@qq.com>"}], "resolved_issues": [{"org": "go-gitea", "repo": "gitea", "number": -1, "state": "unknown", "title": "Refactor Git Attribute & performance optimization", "body": "This PR moved git attributes related code to `modules/git/attribute` sub package and moved language stats related code to `modules/git/languagestats` sub package to make it easier to maintain.\r\n\r\nAnd it also introduced a performance improvement which use the `git check-attr --source` which can be run in a bare git repository so that we don't need to create a git index file. The new parameter need a git version >= 2.40 . If git version less than 2.40, it will fall back to previous implementation.\r\n\r\nBefore:\r\n```\r\ngit-run duration=1.2684s func.caller=git.(*Repository).readTreeToIndex git.command=\"/opt/homebrew/bin/git ...global... read-tree 70187f7727d4ddd8282b576ece93ca233e88b19e\"\r\ngit-run duration=0.1633s func.caller=git.(*CheckAttributeReader).Run git.command=\"/opt/homebrew/bin/git ...global... check-attr --stdin -z --cached linguist-vendored linguist-generated linguist-documentation linguist-detectable linguist-language gitlab-language\"\r\n```\r\n\r\nAfter:\r\n```\r\ngit-run duration=0.1271s func.caller=attribute.(*BatchChecker).run git.command=\"/opt/homebrew/bin/git ...global... check-attr -z --source 70187f7727d4ddd8282b576ece93ca233e88b19e linguist-vendored linguist-generated linguist-language gitlab-language --stdin\"\r\n```"}], "fix_patch": "diff --git a/modules/git/attribute.go b/modules/git/attribute.go\ndeleted file mode 100644\nindex 4dfa510369086..0000000000000\n--- a/modules/git/attribute.go\n+++ /dev/null\n@@ -1,35 +0,0 @@\n-// Copyright 2024 The Gitea Authors. All rights reserved.\n-// SPDX-License-Identifier: MIT\n-\n-package git\n-\n-import (\n-\t\"code.gitea.io/gitea/modules/optional\"\n-)\n-\n-const (\n-\tAttributeLinguistVendored      = \"linguist-vendored\"\n-\tAttributeLinguistGenerated     = \"linguist-generated\"\n-\tAttributeLinguistDocumentation = \"linguist-documentation\"\n-\tAttributeLinguistDetectable    = \"linguist-detectable\"\n-\tAttributeLinguistLanguage      = \"linguist-language\"\n-\tAttributeGitlabLanguage        = \"gitlab-language\"\n-)\n-\n-// true if \"set\"/\"true\", false if \"unset\"/\"false\", none otherwise\n-func AttributeToBool(attr map[string]string, name string) optional.Option[bool] {\n-\tswitch attr[name] {\n-\tcase \"set\", \"true\":\n-\t\treturn optional.Some(true)\n-\tcase \"unset\", \"false\":\n-\t\treturn optional.Some(false)\n-\t}\n-\treturn optional.None[bool]()\n-}\n-\n-func AttributeToString(attr map[string]string, name string) optional.Option[string] {\n-\tif value, has := attr[name]; has && value != \"unspecified\" {\n-\t\treturn optional.Some(value)\n-\t}\n-\treturn optional.None[string]()\n-}\ndiff --git a/modules/git/attribute/attribute.go b/modules/git/attribute/attribute.go\nnew file mode 100644\nindex 0000000000000..adf323ef41c05\n--- /dev/null\n+++ b/modules/git/attribute/attribute.go\n@@ -0,0 +1,114 @@\n+// Copyright 2025 The Gitea Authors. All rights reserved.\n+// SPDX-License-Identifier: MIT\n+\n+package attribute\n+\n+import (\n+\t\"strings\"\n+\n+\t\"code.gitea.io/gitea/modules/optional\"\n+)\n+\n+type Attribute string\n+\n+const (\n+\tLinguistVendored      = \"linguist-vendored\"\n+\tLinguistGenerated     = \"linguist-generated\"\n+\tLinguistDocumentation = \"linguist-documentation\"\n+\tLinguistDetectable    = \"linguist-detectable\"\n+\tLinguistLanguage      = \"linguist-language\"\n+\tGitlabLanguage        = \"gitlab-language\"\n+\tLockable              = \"lockable\"\n+\tFilter                = \"filter\"\n+)\n+\n+var LinguistAttributes = []string{\n+\tLinguistVendored,\n+\tLinguistGenerated,\n+\tLinguistDocumentation,\n+\tLinguistDetectable,\n+\tLinguistLanguage,\n+\tGitlabLanguage,\n+}\n+\n+func (a Attribute) IsUnspecified() bool {\n+\treturn a == \"\" || a == \"unspecified\"\n+}\n+\n+func (a Attribute) ToString() optional.Option[string] {\n+\tif !a.IsUnspecified() {\n+\t\treturn optional.Some(string(a))\n+\t}\n+\treturn optional.None[string]()\n+}\n+\n+// ToBool converts the attribute value to optional boolean: true if \"set\"/\"true\", false if \"unset\"/\"false\", none otherwise\n+func (a Attribute) ToBool() optional.Option[bool] {\n+\tswitch a {\n+\tcase \"set\", \"true\":\n+\t\treturn optional.Some(true)\n+\tcase \"unset\", \"false\":\n+\t\treturn optional.Some(false)\n+\t}\n+\treturn optional.None[bool]()\n+}\n+\n+type Attributes struct {\n+\tm map[string]Attribute\n+}\n+\n+func NewAttributes() *Attributes {\n+\treturn &Attributes{m: make(map[string]Attribute)}\n+}\n+\n+func (attrs *Attributes) Get(name string) Attribute {\n+\tif value, has := attrs.m[name]; has {\n+\t\treturn value\n+\t}\n+\treturn \"\"\n+}\n+\n+func (attrs *Attributes) GetVendored() optional.Option[bool] {\n+\treturn attrs.Get(LinguistVendored).ToBool()\n+}\n+\n+func (attrs *Attributes) GetGenerated() optional.Option[bool] {\n+\treturn attrs.Get(LinguistGenerated).ToBool()\n+}\n+\n+func (attrs *Attributes) GetDocumentation() optional.Option[bool] {\n+\treturn attrs.Get(LinguistDocumentation).ToBool()\n+}\n+\n+func (attrs *Attributes) GetDetectable() optional.Option[bool] {\n+\treturn attrs.Get(LinguistDetectable).ToBool()\n+}\n+\n+func (attrs *Attributes) GetLinguistLanguage() optional.Option[string] {\n+\treturn attrs.Get(LinguistLanguage).ToString()\n+}\n+\n+func (attrs *Attributes) GetGitlabLanguage() optional.Option[string] {\n+\tattrStr := attrs.Get(GitlabLanguage).ToString()\n+\tif attrStr.Has() {\n+\t\traw := attrStr.Value()\n+\t\t// gitlab-language may have additional parameters after the language\n+\t\t// ignore them and just use the main language\n+\t\t// https://docs.gitlab.com/ee/user/project/highlighting.html#override-syntax-highlighting-for-a-file-type\n+\t\tif idx := strings.IndexByte(raw, '?'); idx >= 0 {\n+\t\t\treturn optional.Some(raw[:idx])\n+\t\t}\n+\t}\n+\treturn attrStr\n+}\n+\n+func (attrs *Attributes) GetLanguage() optional.Option[string] {\n+\t// prefer linguist-language over gitlab-language\n+\t// if linguist-language is not set, use gitlab-language\n+\t// if both are not set, return none\n+\tlanguage := attrs.GetLinguistLanguage()\n+\tif language.Value() == \"\" {\n+\t\tlanguage = attrs.GetGitlabLanguage()\n+\t}\n+\treturn language\n+}\ndiff --git a/modules/git/attribute/batch.go b/modules/git/attribute/batch.go\nnew file mode 100644\nindex 0000000000000..4e31fda5753cd\n--- /dev/null\n+++ b/modules/git/attribute/batch.go\n@@ -0,0 +1,216 @@\n+// Copyright 2019 The Gitea Authors. All rights reserved.\n+// SPDX-License-Identifier: MIT\n+\n+package attribute\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"time\"\n+\n+\t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/log\"\n+)\n+\n+// BatchChecker provides a reader for check-attribute content that can be long running\n+type BatchChecker struct {\n+\tattributesNum int\n+\trepo          *git.Repository\n+\tstdinWriter   *os.File\n+\tstdOut        *nulSeparatedAttributeWriter\n+\tctx           context.Context\n+\tcancel        context.CancelFunc\n+\tcmd           *git.Command\n+}\n+\n+// NewBatchChecker creates a check attribute reader for the current repository and provided commit ID\n+// If treeish is empty, then it will use current working directory, otherwise it will use the provided treeish on the bare repo\n+func NewBatchChecker(repo *git.Repository, treeish string, attributes []string) (checker *BatchChecker, returnedErr error) {\n+\tctx, cancel := context.WithCancel(repo.Ctx)\n+\tdefer func() {\n+\t\tif returnedErr != nil {\n+\t\t\tcancel()\n+\t\t}\n+\t}()\n+\n+\tcmd, envs, cleanup, err := checkAttrCommand(repo, treeish, nil, attributes)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer func() {\n+\t\tif returnedErr != nil {\n+\t\t\tcleanup()\n+\t\t}\n+\t}()\n+\n+\tcmd.AddArguments(\"--stdin\")\n+\n+\tchecker = &BatchChecker{\n+\t\tattributesNum: len(attributes),\n+\t\trepo:          repo,\n+\t\tctx:           ctx,\n+\t\tcmd:           cmd,\n+\t\tcancel: func() {\n+\t\t\tcancel()\n+\t\t\tcleanup()\n+\t\t},\n+\t}\n+\n+\tstdinReader, stdinWriter, err := os.Pipe()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tchecker.stdinWriter = stdinWriter\n+\n+\tlw := new(nulSeparatedAttributeWriter)\n+\tlw.attributes = make(chan attributeTriple, len(attributes))\n+\tlw.closed = make(chan struct{})\n+\tchecker.stdOut = lw\n+\n+\tgo func() {\n+\t\tdefer func() {\n+\t\t\t_ = stdinReader.Close()\n+\t\t\t_ = lw.Close()\n+\t\t}()\n+\t\tstdErr := new(bytes.Buffer)\n+\t\terr := cmd.Run(ctx, &git.RunOpts{\n+\t\t\tEnv:    envs,\n+\t\t\tDir:    repo.Path,\n+\t\t\tStdin:  stdinReader,\n+\t\t\tStdout: lw,\n+\t\t\tStderr: stdErr,\n+\t\t})\n+\n+\t\tif err != nil && !git.IsErrCanceledOrKilled(err) {\n+\t\t\tlog.Error(\"Attribute checker for commit %s exits with error: %v\", treeish, err)\n+\t\t}\n+\t\tchecker.cancel()\n+\t}()\n+\n+\treturn checker, nil\n+}\n+\n+// CheckPath check attr for given path\n+func (c *BatchChecker) CheckPath(path string) (rs *Attributes, err error) {\n+\tdefer func() {\n+\t\tif err != nil && err != c.ctx.Err() {\n+\t\t\tlog.Error(\"Unexpected error when checking path %s in %s, error: %v\", path, filepath.Base(c.repo.Path), err)\n+\t\t}\n+\t}()\n+\n+\tselect {\n+\tcase <-c.ctx.Done():\n+\t\treturn nil, c.ctx.Err()\n+\tdefault:\n+\t}\n+\n+\tif _, err = c.stdinWriter.Write([]byte(path + \"\\x00\")); err != nil {\n+\t\tdefer c.Close()\n+\t\treturn nil, err\n+\t}\n+\n+\treportTimeout := func() error {\n+\t\tstdOutClosed := false\n+\t\tselect {\n+\t\tcase <-c.stdOut.closed:\n+\t\t\tstdOutClosed = true\n+\t\tdefault:\n+\t\t}\n+\t\tdebugMsg := fmt.Sprintf(\"check path %q in repo %q\", path, filepath.Base(c.repo.Path))\n+\t\tdebugMsg += fmt.Sprintf(\", stdOut: tmp=%q, pos=%d, closed=%v\", string(c.stdOut.tmp), c.stdOut.pos, stdOutClosed)\n+\t\tif c.cmd != nil {\n+\t\t\tdebugMsg += fmt.Sprintf(\", process state: %q\", c.cmd.ProcessState())\n+\t\t}\n+\t\t_ = c.Close()\n+\t\treturn fmt.Errorf(\"CheckPath timeout: %s\", debugMsg)\n+\t}\n+\n+\trs = NewAttributes()\n+\tfor i := 0; i < c.attributesNum; i++ {\n+\t\tselect {\n+\t\tcase <-time.After(5 * time.Second):\n+\t\t\t// there is no \"hang\" problem now. This code is just used to catch other potential problems.\n+\t\t\treturn nil, reportTimeout()\n+\t\tcase attr, ok := <-c.stdOut.ReadAttribute():\n+\t\t\tif !ok {\n+\t\t\t\treturn nil, c.ctx.Err()\n+\t\t\t}\n+\t\t\trs.m[attr.Attribute] = Attribute(attr.Value)\n+\t\tcase <-c.ctx.Done():\n+\t\t\treturn nil, c.ctx.Err()\n+\t\t}\n+\t}\n+\treturn rs, nil\n+}\n+\n+func (c *BatchChecker) Close() error {\n+\tc.cancel()\n+\terr := c.stdinWriter.Close()\n+\treturn err\n+}\n+\n+type attributeTriple struct {\n+\tFilename  string\n+\tAttribute string\n+\tValue     string\n+}\n+\n+type nulSeparatedAttributeWriter struct {\n+\ttmp        []byte\n+\tattributes chan attributeTriple\n+\tclosed     chan struct{}\n+\tworking    attributeTriple\n+\tpos        int\n+}\n+\n+func (wr *nulSeparatedAttributeWriter) Write(p []byte) (n int, err error) {\n+\tl, read := len(p), 0\n+\n+\tnulIdx := bytes.IndexByte(p, '\\x00')\n+\tfor nulIdx >= 0 {\n+\t\twr.tmp = append(wr.tmp, p[:nulIdx]...)\n+\t\tswitch wr.pos {\n+\t\tcase 0:\n+\t\t\twr.working = attributeTriple{\n+\t\t\t\tFilename: string(wr.tmp),\n+\t\t\t}\n+\t\tcase 1:\n+\t\t\twr.working.Attribute = string(wr.tmp)\n+\t\tcase 2:\n+\t\t\twr.working.Value = string(wr.tmp)\n+\t\t}\n+\t\twr.tmp = wr.tmp[:0]\n+\t\twr.pos++\n+\t\tif wr.pos > 2 {\n+\t\t\twr.attributes <- wr.working\n+\t\t\twr.pos = 0\n+\t\t}\n+\t\tread += nulIdx + 1\n+\t\tif l > read {\n+\t\t\tp = p[nulIdx+1:]\n+\t\t\tnulIdx = bytes.IndexByte(p, '\\x00')\n+\t\t} else {\n+\t\t\treturn l, nil\n+\t\t}\n+\t}\n+\twr.tmp = append(wr.tmp, p...)\n+\treturn l, nil\n+}\n+\n+func (wr *nulSeparatedAttributeWriter) ReadAttribute() <-chan attributeTriple {\n+\treturn wr.attributes\n+}\n+\n+func (wr *nulSeparatedAttributeWriter) Close() error {\n+\tselect {\n+\tcase <-wr.closed:\n+\t\treturn nil\n+\tdefault:\n+\t}\n+\tclose(wr.attributes)\n+\tclose(wr.closed)\n+\treturn nil\n+}\ndiff --git a/modules/git/attribute/checker.go b/modules/git/attribute/checker.go\nnew file mode 100644\nindex 0000000000000..c17006a15407b\n--- /dev/null\n+++ b/modules/git/attribute/checker.go\n@@ -0,0 +1,96 @@\n+// Copyright 2025 The Gitea Authors. All rights reserved.\n+// SPDX-License-Identifier: MIT\n+\n+package attribute\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"os\"\n+\n+\t\"code.gitea.io/gitea/modules/git\"\n+)\n+\n+func checkAttrCommand(gitRepo *git.Repository, treeish string, filenames, attributes []string) (*git.Command, []string, func(), error) {\n+\tcancel := func() {}\n+\tenvs := []string{\"GIT_FLUSH=1\"}\n+\tcmd := git.NewCommand(\"check-attr\", \"-z\")\n+\tif len(attributes) == 0 {\n+\t\tcmd.AddArguments(\"--all\")\n+\t}\n+\n+\t// there is treeish, read from bare repo or temp index created by \"read-tree\"\n+\tif treeish != \"\" {\n+\t\tif git.DefaultFeatures().SupportCheckAttrOnBare {\n+\t\t\tcmd.AddArguments(\"--source\")\n+\t\t\tcmd.AddDynamicArguments(treeish)\n+\t\t} else {\n+\t\t\tindexFilename, worktree, deleteTemporaryFile, err := gitRepo.ReadTreeToTemporaryIndex(treeish)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, nil, nil, err\n+\t\t\t}\n+\n+\t\t\tcmd.AddArguments(\"--cached\")\n+\t\t\tenvs = append(envs,\n+\t\t\t\t\"GIT_INDEX_FILE=\"+indexFilename,\n+\t\t\t\t\"GIT_WORK_TREE=\"+worktree,\n+\t\t\t)\n+\t\t\tcancel = deleteTemporaryFile\n+\t\t}\n+\t} // else: no treeish, assume it is a not a bare repo, read from working directory\n+\n+\tcmd.AddDynamicArguments(attributes...)\n+\tif len(filenames) > 0 {\n+\t\tcmd.AddDashesAndList(filenames...)\n+\t}\n+\treturn cmd, envs, cancel, nil\n+}\n+\n+type CheckAttributeOpts struct {\n+\tFilenames  []string\n+\tAttributes []string\n+}\n+\n+// CheckAttributes return the attributes of the given filenames and attributes in the given treeish.\n+// If treeish is empty, then it will use current working directory, otherwise it will use the provided treeish on the bare repo\n+func CheckAttributes(ctx context.Context, gitRepo *git.Repository, treeish string, opts CheckAttributeOpts) (map[string]*Attributes, error) {\n+\tcmd, envs, cancel, err := checkAttrCommand(gitRepo, treeish, opts.Filenames, opts.Attributes)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer cancel()\n+\n+\tstdOut := new(bytes.Buffer)\n+\tstdErr := new(bytes.Buffer)\n+\n+\tif err := cmd.Run(ctx, &git.RunOpts{\n+\t\tEnv:    append(os.Environ(), envs...),\n+\t\tDir:    gitRepo.Path,\n+\t\tStdout: stdOut,\n+\t\tStderr: stdErr,\n+\t}); err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to run check-attr: %w\\n%s\\n%s\", err, stdOut.String(), stdErr.String())\n+\t}\n+\n+\tfields := bytes.Split(stdOut.Bytes(), []byte{'\\000'})\n+\tif len(fields)%3 != 1 {\n+\t\treturn nil, errors.New(\"wrong number of fields in return from check-attr\")\n+\t}\n+\n+\tattributesMap := make(map[string]*Attributes)\n+\tfor i := 0; i < (len(fields) / 3); i++ {\n+\t\tfilename := string(fields[3*i])\n+\t\tattribute := string(fields[3*i+1])\n+\t\tinfo := string(fields[3*i+2])\n+\t\tattribute2info, ok := attributesMap[filename]\n+\t\tif !ok {\n+\t\t\tattribute2info = NewAttributes()\n+\t\t\tattributesMap[filename] = attribute2info\n+\t\t}\n+\t\tattribute2info.m[attribute] = Attribute(info)\n+\t}\n+\n+\treturn attributesMap, nil\n+}\ndiff --git a/modules/git/command.go b/modules/git/command.go\nindex f449f1ff0e6a8..eaaa4969d0bb1 100644\n--- a/modules/git/command.go\n+++ b/modules/git/command.go\n@@ -80,6 +80,13 @@ func (c *Command) LogString() string {\n \treturn strings.Join(a, \" \")\n }\n \n+func (c *Command) ProcessState() string {\n+\tif c.cmd == nil {\n+\t\treturn \"\"\n+\t}\n+\treturn c.cmd.ProcessState.String()\n+}\n+\n // NewCommand creates and returns a new Git Command based on given command and arguments.\n // Each argument should be safe to be trusted. User-provided arguments should be passed to AddDynamicArguments instead.\n func NewCommand(args ...internal.CmdArg) *Command {\ndiff --git a/modules/git/git.go b/modules/git/git.go\nindex 2b593910a2dc0..a2ffd6d289880 100644\n--- a/modules/git/git.go\n+++ b/modules/git/git.go\n@@ -30,6 +30,7 @@ type Features struct {\n \tSupportProcReceive     bool           // >= 2.29\n \tSupportHashSha256      bool           // >= 2.42, SHA-256 repositories no longer an ‘experimental curiosity’\n \tSupportedObjectFormats []ObjectFormat // sha1, sha256\n+\tSupportCheckAttrOnBare bool           // >= 2.40\n }\n \n var (\n@@ -77,6 +78,7 @@ func loadGitVersionFeatures() (*Features, error) {\n \tif features.SupportHashSha256 {\n \t\tfeatures.SupportedObjectFormats = append(features.SupportedObjectFormats, Sha256ObjectFormat)\n \t}\n+\tfeatures.SupportCheckAttrOnBare = features.CheckVersionAtLeast(\"2.40\")\n \treturn features, nil\n }\n \ndiff --git a/modules/git/repo_language_stats.go b/modules/git/languagestats/language_stats.go\nsimilarity index 59%\nrename from modules/git/repo_language_stats.go\nrename to modules/git/languagestats/language_stats.go\nindex 8551ea9d24e8b..a71284c3e446f 100644\n--- a/modules/git/repo_language_stats.go\n+++ b/modules/git/languagestats/language_stats.go\n@@ -1,13 +1,15 @@\n // Copyright 2020 The Gitea Authors. All rights reserved.\n // SPDX-License-Identifier: MIT\n \n-package git\n+package languagestats\n \n import (\n+\t\"context\"\n \t\"strings\"\n \t\"unicode\"\n \n-\t\"code.gitea.io/gitea/modules/optional\"\n+\t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/git/attribute\"\n )\n \n const (\n@@ -49,19 +51,15 @@ func mergeLanguageStats(stats map[string]int64) map[string]int64 {\n \treturn res\n }\n \n-func TryReadLanguageAttribute(attrs map[string]string) optional.Option[string] {\n-\tlanguage := AttributeToString(attrs, AttributeLinguistLanguage)\n-\tif language.Value() == \"\" {\n-\t\tlanguage = AttributeToString(attrs, AttributeGitlabLanguage)\n-\t\tif language.Has() {\n-\t\t\traw := language.Value()\n-\t\t\t// gitlab-language may have additional parameters after the language\n-\t\t\t// ignore them and just use the main language\n-\t\t\t// https://docs.gitlab.com/ee/user/project/highlighting.html#override-syntax-highlighting-for-a-file-type\n-\t\t\tif idx := strings.IndexByte(raw, '?'); idx >= 0 {\n-\t\t\t\tlanguage = optional.Some(raw[:idx])\n-\t\t\t}\n-\t\t}\n+// GetFileLanguage tries to get the (linguist) language of the file content\n+func GetFileLanguage(ctx context.Context, gitRepo *git.Repository, treeish, treePath string) (string, error) {\n+\tattributesMap, err := attribute.CheckAttributes(ctx, gitRepo, treeish, attribute.CheckAttributeOpts{\n+\t\tAttributes: []string{attribute.LinguistLanguage, attribute.GitlabLanguage},\n+\t\tFilenames:  []string{treePath},\n+\t})\n+\tif err != nil {\n+\t\treturn \"\", err\n \t}\n-\treturn language\n+\n+\treturn attributesMap[treePath].GetLanguage().Value(), nil\n }\ndiff --git a/modules/git/repo_language_stats_gogit.go b/modules/git/languagestats/language_stats_gogit.go\nsimilarity index 73%\nrename from modules/git/repo_language_stats_gogit.go\nrename to modules/git/languagestats/language_stats_gogit.go\nindex a34c03c781f55..418c05b15789f 100644\n--- a/modules/git/repo_language_stats_gogit.go\n+++ b/modules/git/languagestats/language_stats_gogit.go\n@@ -3,13 +3,15 @@\n \n //go:build gogit\n \n-package git\n+package languagestats\n \n import (\n \t\"bytes\"\n \t\"io\"\n \n \t\"code.gitea.io/gitea/modules/analyze\"\n+\tgit_module \"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/git/attribute\"\n \t\"code.gitea.io/gitea/modules/optional\"\n \n \t\"github.com/go-enry/go-enry/v2\"\n@@ -19,7 +21,7 @@ import (\n )\n \n // GetLanguageStats calculates language stats for git repository at specified commit\n-func (repo *Repository) GetLanguageStats(commitID string) (map[string]int64, error) {\n+func GetLanguageStats(repo *git_module.Repository, commitID string) (map[string]int64, error) {\n \tr, err := git.PlainOpen(repo.Path)\n \tif err != nil {\n \t\treturn nil, err\n@@ -40,8 +42,11 @@ func (repo *Repository) GetLanguageStats(commitID string) (map[string]int64, err\n \t\treturn nil, err\n \t}\n \n-\tchecker, deferable := repo.CheckAttributeReader(commitID)\n-\tdefer deferable()\n+\tchecker, err := attribute.NewBatchChecker(repo, commitID, attribute.LinguistAttributes)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer checker.Close()\n \n \t// sizes contains the current calculated size of all files by language\n \tsizes := make(map[string]int64)\n@@ -62,43 +67,41 @@ func (repo *Repository) GetLanguageStats(commitID string) (map[string]int64, err\n \t\tisDocumentation := optional.None[bool]()\n \t\tisDetectable := optional.None[bool]()\n \n-\t\tif checker != nil {\n-\t\t\tattrs, err := checker.CheckPath(f.Name)\n-\t\t\tif err == nil {\n-\t\t\t\tisVendored = AttributeToBool(attrs, AttributeLinguistVendored)\n-\t\t\t\tif isVendored.ValueOrDefault(false) {\n-\t\t\t\t\treturn nil\n-\t\t\t\t}\n-\n-\t\t\t\tisGenerated = AttributeToBool(attrs, AttributeLinguistGenerated)\n-\t\t\t\tif isGenerated.ValueOrDefault(false) {\n-\t\t\t\t\treturn nil\n-\t\t\t\t}\n+\t\tattrs, err := checker.CheckPath(f.Name)\n+\t\tif err == nil {\n+\t\t\tisVendored = attrs.GetVendored()\n+\t\t\tif isVendored.ValueOrDefault(false) {\n+\t\t\t\treturn nil\n+\t\t\t}\n \n-\t\t\t\tisDocumentation = AttributeToBool(attrs, AttributeLinguistDocumentation)\n-\t\t\t\tif isDocumentation.ValueOrDefault(false) {\n-\t\t\t\t\treturn nil\n-\t\t\t\t}\n+\t\t\tisGenerated = attrs.GetGenerated()\n+\t\t\tif isGenerated.ValueOrDefault(false) {\n+\t\t\t\treturn nil\n+\t\t\t}\n \n-\t\t\t\tisDetectable = AttributeToBool(attrs, AttributeLinguistDetectable)\n-\t\t\t\tif !isDetectable.ValueOrDefault(true) {\n-\t\t\t\t\treturn nil\n-\t\t\t\t}\n+\t\t\tisDocumentation = attrs.GetDocumentation()\n+\t\t\tif isDocumentation.ValueOrDefault(false) {\n+\t\t\t\treturn nil\n+\t\t\t}\n \n-\t\t\t\thasLanguage := TryReadLanguageAttribute(attrs)\n-\t\t\t\tif hasLanguage.Value() != \"\" {\n-\t\t\t\t\tlanguage := hasLanguage.Value()\n+\t\t\tisDetectable = attrs.GetDetectable()\n+\t\t\tif !isDetectable.ValueOrDefault(true) {\n+\t\t\t\treturn nil\n+\t\t\t}\n \n-\t\t\t\t\t// group languages, such as Pug -> HTML; SCSS -> CSS\n-\t\t\t\t\tgroup := enry.GetLanguageGroup(language)\n-\t\t\t\t\tif len(group) != 0 {\n-\t\t\t\t\t\tlanguage = group\n-\t\t\t\t\t}\n+\t\t\thasLanguage := attrs.GetLanguage()\n+\t\t\tif hasLanguage.Value() != \"\" {\n+\t\t\t\tlanguage := hasLanguage.Value()\n \n-\t\t\t\t\t// this language will always be added to the size\n-\t\t\t\t\tsizes[language] += f.Size\n-\t\t\t\t\treturn nil\n+\t\t\t\t// group languages, such as Pug -> HTML; SCSS -> CSS\n+\t\t\t\tgroup := enry.GetLanguageGroup(language)\n+\t\t\t\tif len(group) != 0 {\n+\t\t\t\t\tlanguage = group\n \t\t\t\t}\n+\n+\t\t\t\t// this language will always be added to the size\n+\t\t\t\tsizes[language] += f.Size\n+\t\t\t\treturn nil\n \t\t\t}\n \t\t}\n \ndiff --git a/modules/git/repo_language_stats_nogogit.go b/modules/git/languagestats/language_stats_nogogit.go\nsimilarity index 73%\nrename from modules/git/repo_language_stats_nogogit.go\nrename to modules/git/languagestats/language_stats_nogogit.go\nindex de7707bd6cd8b..34797263a603a 100644\n--- a/modules/git/repo_language_stats_nogogit.go\n+++ b/modules/git/languagestats/language_stats_nogogit.go\n@@ -3,13 +3,15 @@\n \n //go:build !gogit\n \n-package git\n+package languagestats\n \n import (\n \t\"bytes\"\n \t\"io\"\n \n \t\"code.gitea.io/gitea/modules/analyze\"\n+\t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/git/attribute\"\n \t\"code.gitea.io/gitea/modules/log\"\n \t\"code.gitea.io/gitea/modules/optional\"\n \n@@ -17,7 +19,7 @@ import (\n )\n \n // GetLanguageStats calculates language stats for git repository at specified commit\n-func (repo *Repository) GetLanguageStats(commitID string) (map[string]int64, error) {\n+func GetLanguageStats(repo *git.Repository, commitID string) (map[string]int64, error) {\n \t// We will feed the commit IDs in order into cat-file --batch, followed by blobs as necessary.\n \t// so let's create a batch stdin and stdout\n \tbatchStdinWriter, batchReader, cancel, err := repo.CatFileBatch(repo.Ctx)\n@@ -34,19 +36,19 @@ func (repo *Repository) GetLanguageStats(commitID string) (map[string]int64, err\n \tif err := writeID(commitID); err != nil {\n \t\treturn nil, err\n \t}\n-\tshaBytes, typ, size, err := ReadBatchLine(batchReader)\n+\tshaBytes, typ, size, err := git.ReadBatchLine(batchReader)\n \tif typ != \"commit\" {\n \t\tlog.Debug(\"Unable to get commit for: %s. Err: %v\", commitID, err)\n-\t\treturn nil, ErrNotExist{commitID, \"\"}\n+\t\treturn nil, git.ErrNotExist{ID: commitID}\n \t}\n \n-\tsha, err := NewIDFromString(string(shaBytes))\n+\tsha, err := git.NewIDFromString(string(shaBytes))\n \tif err != nil {\n \t\tlog.Debug(\"Unable to get commit for: %s. Err: %v\", commitID, err)\n-\t\treturn nil, ErrNotExist{commitID, \"\"}\n+\t\treturn nil, git.ErrNotExist{ID: commitID}\n \t}\n \n-\tcommit, err := CommitFromReader(repo, sha, io.LimitReader(batchReader, size))\n+\tcommit, err := git.CommitFromReader(repo, sha, io.LimitReader(batchReader, size))\n \tif err != nil {\n \t\tlog.Debug(\"Unable to get commit for: %s. Err: %v\", commitID, err)\n \t\treturn nil, err\n@@ -62,8 +64,11 @@ func (repo *Repository) GetLanguageStats(commitID string) (map[string]int64, err\n \t\treturn nil, err\n \t}\n \n-\tchecker, deferable := repo.CheckAttributeReader(commitID)\n-\tdefer deferable()\n+\tchecker, err := attribute.NewBatchChecker(repo, commitID, attribute.LinguistAttributes)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer checker.Close()\n \n \tcontentBuf := bytes.Buffer{}\n \tvar content []byte\n@@ -96,43 +101,36 @@ func (repo *Repository) GetLanguageStats(commitID string) (map[string]int64, err\n \t\tisDocumentation := optional.None[bool]()\n \t\tisDetectable := optional.None[bool]()\n \n-\t\tif checker != nil {\n-\t\t\tattrs, err := checker.CheckPath(f.Name())\n-\t\t\tif err == nil {\n-\t\t\t\tisVendored = AttributeToBool(attrs, AttributeLinguistVendored)\n-\t\t\t\tif isVendored.ValueOrDefault(false) {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\n-\t\t\t\tisGenerated = AttributeToBool(attrs, AttributeLinguistGenerated)\n-\t\t\t\tif isGenerated.ValueOrDefault(false) {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n+\t\tattrs, err := checker.CheckPath(f.Name())\n+\t\tif err == nil {\n+\t\t\tif isVendored = attrs.GetVendored(); isVendored.ValueOrDefault(false) {\n+\t\t\t\tcontinue\n+\t\t\t}\n \n-\t\t\t\tisDocumentation = AttributeToBool(attrs, AttributeLinguistDocumentation)\n-\t\t\t\tif isDocumentation.ValueOrDefault(false) {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n+\t\t\tif isGenerated = attrs.GetGenerated(); isGenerated.ValueOrDefault(false) {\n+\t\t\t\tcontinue\n+\t\t\t}\n \n-\t\t\t\tisDetectable = AttributeToBool(attrs, AttributeLinguistDetectable)\n-\t\t\t\tif !isDetectable.ValueOrDefault(true) {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n+\t\t\tif isDocumentation = attrs.GetDocumentation(); isDocumentation.ValueOrDefault(false) {\n+\t\t\t\tcontinue\n+\t\t\t}\n \n-\t\t\t\thasLanguage := TryReadLanguageAttribute(attrs)\n-\t\t\t\tif hasLanguage.Value() != \"\" {\n-\t\t\t\t\tlanguage := hasLanguage.Value()\n+\t\t\tif isDetectable = attrs.GetDetectable(); !isDetectable.ValueOrDefault(true) {\n+\t\t\t\tcontinue\n+\t\t\t}\n \n-\t\t\t\t\t// group languages, such as Pug -> HTML; SCSS -> CSS\n-\t\t\t\t\tgroup := enry.GetLanguageGroup(language)\n-\t\t\t\t\tif len(group) != 0 {\n-\t\t\t\t\t\tlanguage = group\n-\t\t\t\t\t}\n+\t\t\tif hasLanguage := attrs.GetLanguage(); hasLanguage.Value() != \"\" {\n+\t\t\t\tlanguage := hasLanguage.Value()\n \n-\t\t\t\t\t// this language will always be added to the size\n-\t\t\t\t\tsizes[language] += f.Size()\n-\t\t\t\t\tcontinue\n+\t\t\t\t// group languages, such as Pug -> HTML; SCSS -> CSS\n+\t\t\t\tgroup := enry.GetLanguageGroup(language)\n+\t\t\t\tif len(group) != 0 {\n+\t\t\t\t\tlanguage = group\n \t\t\t\t}\n+\n+\t\t\t\t// this language will always be added to the size\n+\t\t\t\tsizes[language] += f.Size()\n+\t\t\t\tcontinue\n \t\t\t}\n \t\t}\n \n@@ -149,7 +147,7 @@ func (repo *Repository) GetLanguageStats(commitID string) (map[string]int64, err\n \t\t\tif err := writeID(f.ID.String()); err != nil {\n \t\t\t\treturn nil, err\n \t\t\t}\n-\t\t\t_, _, size, err := ReadBatchLine(batchReader)\n+\t\t\t_, _, size, err := git.ReadBatchLine(batchReader)\n \t\t\tif err != nil {\n \t\t\t\tlog.Debug(\"Error reading blob: %s Err: %v\", f.ID.String(), err)\n \t\t\t\treturn nil, err\n@@ -167,7 +165,7 @@ func (repo *Repository) GetLanguageStats(commitID string) (map[string]int64, err\n \t\t\t\treturn nil, err\n \t\t\t}\n \t\t\tcontent = contentBuf.Bytes()\n-\t\t\tif err := DiscardFull(batchReader, discard); err != nil {\n+\t\t\tif err := git.DiscardFull(batchReader, discard); err != nil {\n \t\t\t\treturn nil, err\n \t\t\t}\n \t\t}\ndiff --git a/modules/git/repo_attribute.go b/modules/git/repo_attribute.go\ndeleted file mode 100644\nindex fde42d4730c1d..0000000000000\n--- a/modules/git/repo_attribute.go\n+++ /dev/null\n@@ -1,341 +0,0 @@\n-// Copyright 2019 The Gitea Authors. All rights reserved.\n-// SPDX-License-Identifier: MIT\n-\n-package git\n-\n-import (\n-\t\"bytes\"\n-\t\"context\"\n-\t\"errors\"\n-\t\"fmt\"\n-\t\"io\"\n-\t\"os\"\n-\t\"path/filepath\"\n-\t\"time\"\n-\n-\t\"code.gitea.io/gitea/modules/log\"\n-)\n-\n-// CheckAttributeOpts represents the possible options to CheckAttribute\n-type CheckAttributeOpts struct {\n-\tCachedOnly    bool\n-\tAllAttributes bool\n-\tAttributes    []string\n-\tFilenames     []string\n-\tIndexFile     string\n-\tWorkTree      string\n-}\n-\n-// CheckAttribute return the Blame object of file\n-func (repo *Repository) CheckAttribute(opts CheckAttributeOpts) (map[string]map[string]string, error) {\n-\tenv := []string{}\n-\n-\tif len(opts.IndexFile) > 0 {\n-\t\tenv = append(env, \"GIT_INDEX_FILE=\"+opts.IndexFile)\n-\t}\n-\tif len(opts.WorkTree) > 0 {\n-\t\tenv = append(env, \"GIT_WORK_TREE=\"+opts.WorkTree)\n-\t}\n-\n-\tif len(env) > 0 {\n-\t\tenv = append(os.Environ(), env...)\n-\t}\n-\n-\tstdOut := new(bytes.Buffer)\n-\tstdErr := new(bytes.Buffer)\n-\n-\tcmd := NewCommand(\"check-attr\", \"-z\")\n-\n-\tif opts.AllAttributes {\n-\t\tcmd.AddArguments(\"-a\")\n-\t} else {\n-\t\tfor _, attribute := range opts.Attributes {\n-\t\t\tif attribute != \"\" {\n-\t\t\t\tcmd.AddDynamicArguments(attribute)\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tif opts.CachedOnly {\n-\t\tcmd.AddArguments(\"--cached\")\n-\t}\n-\n-\tcmd.AddDashesAndList(opts.Filenames...)\n-\n-\tif err := cmd.Run(repo.Ctx, &RunOpts{\n-\t\tEnv:    env,\n-\t\tDir:    repo.Path,\n-\t\tStdout: stdOut,\n-\t\tStderr: stdErr,\n-\t}); err != nil {\n-\t\treturn nil, fmt.Errorf(\"failed to run check-attr: %w\\n%s\\n%s\", err, stdOut.String(), stdErr.String())\n-\t}\n-\n-\t// FIXME: This is incorrect on versions < 1.8.5\n-\tfields := bytes.Split(stdOut.Bytes(), []byte{'\\000'})\n-\n-\tif len(fields)%3 != 1 {\n-\t\treturn nil, errors.New(\"wrong number of fields in return from check-attr\")\n-\t}\n-\n-\tname2attribute2info := make(map[string]map[string]string)\n-\n-\tfor i := 0; i < (len(fields) / 3); i++ {\n-\t\tfilename := string(fields[3*i])\n-\t\tattribute := string(fields[3*i+1])\n-\t\tinfo := string(fields[3*i+2])\n-\t\tattribute2info := name2attribute2info[filename]\n-\t\tif attribute2info == nil {\n-\t\t\tattribute2info = make(map[string]string)\n-\t\t}\n-\t\tattribute2info[attribute] = info\n-\t\tname2attribute2info[filename] = attribute2info\n-\t}\n-\n-\treturn name2attribute2info, nil\n-}\n-\n-// CheckAttributeReader provides a reader for check-attribute content that can be long running\n-type CheckAttributeReader struct {\n-\t// params\n-\tAttributes []string\n-\tRepo       *Repository\n-\tIndexFile  string\n-\tWorkTree   string\n-\n-\tstdinReader io.ReadCloser\n-\tstdinWriter *os.File\n-\tstdOut      *nulSeparatedAttributeWriter\n-\tcmd         *Command\n-\tenv         []string\n-\tctx         context.Context\n-\tcancel      context.CancelFunc\n-}\n-\n-// Init initializes the CheckAttributeReader\n-func (c *CheckAttributeReader) Init(ctx context.Context) error {\n-\tif len(c.Attributes) == 0 {\n-\t\tlw := new(nulSeparatedAttributeWriter)\n-\t\tlw.attributes = make(chan attributeTriple)\n-\t\tlw.closed = make(chan struct{})\n-\n-\t\tc.stdOut = lw\n-\t\tc.stdOut.Close()\n-\t\treturn errors.New(\"no provided Attributes to check\")\n-\t}\n-\n-\tc.ctx, c.cancel = context.WithCancel(ctx)\n-\tc.cmd = NewCommand(\"check-attr\", \"--stdin\", \"-z\")\n-\n-\tif len(c.IndexFile) > 0 {\n-\t\tc.cmd.AddArguments(\"--cached\")\n-\t\tc.env = append(c.env, \"GIT_INDEX_FILE=\"+c.IndexFile)\n-\t}\n-\n-\tif len(c.WorkTree) > 0 {\n-\t\tc.env = append(c.env, \"GIT_WORK_TREE=\"+c.WorkTree)\n-\t}\n-\n-\tc.env = append(c.env, \"GIT_FLUSH=1\")\n-\n-\tc.cmd.AddDynamicArguments(c.Attributes...)\n-\n-\tvar err error\n-\n-\tc.stdinReader, c.stdinWriter, err = os.Pipe()\n-\tif err != nil {\n-\t\tc.cancel()\n-\t\treturn err\n-\t}\n-\n-\tlw := new(nulSeparatedAttributeWriter)\n-\tlw.attributes = make(chan attributeTriple, 5)\n-\tlw.closed = make(chan struct{})\n-\tc.stdOut = lw\n-\treturn nil\n-}\n-\n-func (c *CheckAttributeReader) Run() error {\n-\tdefer func() {\n-\t\t_ = c.stdinReader.Close()\n-\t\t_ = c.stdOut.Close()\n-\t}()\n-\tstdErr := new(bytes.Buffer)\n-\terr := c.cmd.Run(c.ctx, &RunOpts{\n-\t\tEnv:    c.env,\n-\t\tDir:    c.Repo.Path,\n-\t\tStdin:  c.stdinReader,\n-\t\tStdout: c.stdOut,\n-\t\tStderr: stdErr,\n-\t})\n-\tif err != nil && !IsErrCanceledOrKilled(err) {\n-\t\treturn fmt.Errorf(\"failed to run attr-check. Error: %w\\nStderr: %s\", err, stdErr.String())\n-\t}\n-\treturn nil\n-}\n-\n-// CheckPath check attr for given path\n-func (c *CheckAttributeReader) CheckPath(path string) (rs map[string]string, err error) {\n-\tdefer func() {\n-\t\tif err != nil && err != c.ctx.Err() {\n-\t\t\tlog.Error(\"Unexpected error when checking path %s in %s, error: %v\", path, filepath.Base(c.Repo.Path), err)\n-\t\t}\n-\t}()\n-\n-\tselect {\n-\tcase <-c.ctx.Done():\n-\t\treturn nil, c.ctx.Err()\n-\tdefault:\n-\t}\n-\n-\tif _, err = c.stdinWriter.Write([]byte(path + \"\\x00\")); err != nil {\n-\t\tdefer c.Close()\n-\t\treturn nil, err\n-\t}\n-\n-\treportTimeout := func() error {\n-\t\tstdOutClosed := false\n-\t\tselect {\n-\t\tcase <-c.stdOut.closed:\n-\t\t\tstdOutClosed = true\n-\t\tdefault:\n-\t\t}\n-\t\tdebugMsg := fmt.Sprintf(\"check path %q in repo %q\", path, filepath.Base(c.Repo.Path))\n-\t\tdebugMsg += fmt.Sprintf(\", stdOut: tmp=%q, pos=%d, closed=%v\", string(c.stdOut.tmp), c.stdOut.pos, stdOutClosed)\n-\t\tif c.cmd.cmd != nil {\n-\t\t\tdebugMsg += fmt.Sprintf(\", process state: %q\", c.cmd.cmd.ProcessState.String())\n-\t\t}\n-\t\t_ = c.Close()\n-\t\treturn fmt.Errorf(\"CheckPath timeout: %s\", debugMsg)\n-\t}\n-\n-\trs = make(map[string]string)\n-\tfor range c.Attributes {\n-\t\tselect {\n-\t\tcase <-time.After(5 * time.Second):\n-\t\t\t// There is a strange \"hang\" problem in gitdiff.GetDiff -> CheckPath\n-\t\t\t// So add a timeout here to mitigate the problem, and output more logs for debug purpose\n-\t\t\t// In real world, if CheckPath runs long than seconds, it blocks the end user's operation,\n-\t\t\t// and at the moment the CheckPath result is not so important, so we can just ignore it.\n-\t\t\treturn nil, reportTimeout()\n-\t\tcase attr, ok := <-c.stdOut.ReadAttribute():\n-\t\t\tif !ok {\n-\t\t\t\treturn nil, c.ctx.Err()\n-\t\t\t}\n-\t\t\trs[attr.Attribute] = attr.Value\n-\t\tcase <-c.ctx.Done():\n-\t\t\treturn nil, c.ctx.Err()\n-\t\t}\n-\t}\n-\treturn rs, nil\n-}\n-\n-func (c *CheckAttributeReader) Close() error {\n-\tc.cancel()\n-\terr := c.stdinWriter.Close()\n-\treturn err\n-}\n-\n-type attributeTriple struct {\n-\tFilename  string\n-\tAttribute string\n-\tValue     string\n-}\n-\n-type nulSeparatedAttributeWriter struct {\n-\ttmp        []byte\n-\tattributes chan attributeTriple\n-\tclosed     chan struct{}\n-\tworking    attributeTriple\n-\tpos        int\n-}\n-\n-func (wr *nulSeparatedAttributeWriter) Write(p []byte) (n int, err error) {\n-\tl, read := len(p), 0\n-\n-\tnulIdx := bytes.IndexByte(p, '\\x00')\n-\tfor nulIdx >= 0 {\n-\t\twr.tmp = append(wr.tmp, p[:nulIdx]...)\n-\t\tswitch wr.pos {\n-\t\tcase 0:\n-\t\t\twr.working = attributeTriple{\n-\t\t\t\tFilename: string(wr.tmp),\n-\t\t\t}\n-\t\tcase 1:\n-\t\t\twr.working.Attribute = string(wr.tmp)\n-\t\tcase 2:\n-\t\t\twr.working.Value = string(wr.tmp)\n-\t\t}\n-\t\twr.tmp = wr.tmp[:0]\n-\t\twr.pos++\n-\t\tif wr.pos > 2 {\n-\t\t\twr.attributes <- wr.working\n-\t\t\twr.pos = 0\n-\t\t}\n-\t\tread += nulIdx + 1\n-\t\tif l > read {\n-\t\t\tp = p[nulIdx+1:]\n-\t\t\tnulIdx = bytes.IndexByte(p, '\\x00')\n-\t\t} else {\n-\t\t\treturn l, nil\n-\t\t}\n-\t}\n-\twr.tmp = append(wr.tmp, p...)\n-\treturn l, nil\n-}\n-\n-func (wr *nulSeparatedAttributeWriter) ReadAttribute() <-chan attributeTriple {\n-\treturn wr.attributes\n-}\n-\n-func (wr *nulSeparatedAttributeWriter) Close() error {\n-\tselect {\n-\tcase <-wr.closed:\n-\t\treturn nil\n-\tdefault:\n-\t}\n-\tclose(wr.attributes)\n-\tclose(wr.closed)\n-\treturn nil\n-}\n-\n-// CheckAttributeReader creates a check attribute reader for the current repository and provided commit ID\n-func (repo *Repository) CheckAttributeReader(commitID string) (*CheckAttributeReader, context.CancelFunc) {\n-\tindexFilename, worktree, deleteTemporaryFile, err := repo.ReadTreeToTemporaryIndex(commitID)\n-\tif err != nil {\n-\t\treturn nil, func() {}\n-\t}\n-\n-\tchecker := &CheckAttributeReader{\n-\t\tAttributes: []string{\n-\t\t\tAttributeLinguistVendored,\n-\t\t\tAttributeLinguistGenerated,\n-\t\t\tAttributeLinguistDocumentation,\n-\t\t\tAttributeLinguistDetectable,\n-\t\t\tAttributeLinguistLanguage,\n-\t\t\tAttributeGitlabLanguage,\n-\t\t},\n-\t\tRepo:      repo,\n-\t\tIndexFile: indexFilename,\n-\t\tWorkTree:  worktree,\n-\t}\n-\tctx, cancel := context.WithCancel(repo.Ctx)\n-\tif err := checker.Init(ctx); err != nil {\n-\t\tlog.Error(\"Unable to open attribute checker for commit %s, error: %v\", commitID, err)\n-\t} else {\n-\t\tgo func() {\n-\t\t\terr := checker.Run()\n-\t\t\tif err != nil && !IsErrCanceledOrKilled(err) {\n-\t\t\t\tlog.Error(\"Attribute checker for commit %s exits with error: %v\", commitID, err)\n-\t\t\t}\n-\t\t\tcancel()\n-\t\t}()\n-\t}\n-\tdeferrable := func() {\n-\t\t_ = checker.Close()\n-\t\tcancel()\n-\t\tdeleteTemporaryFile()\n-\t}\n-\n-\treturn checker, deferrable\n-}\ndiff --git a/modules/indexer/stats/db.go b/modules/indexer/stats/db.go\nindex 067a6f609bdc8..199d493e97d21 100644\n--- a/modules/indexer/stats/db.go\n+++ b/modules/indexer/stats/db.go\n@@ -8,6 +8,7 @@ import (\n \n \trepo_model \"code.gitea.io/gitea/models/repo\"\n \t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/git/languagestats\"\n \t\"code.gitea.io/gitea/modules/gitrepo\"\n \t\"code.gitea.io/gitea/modules/graceful\"\n \t\"code.gitea.io/gitea/modules/log\"\n@@ -62,7 +63,7 @@ func (db *DBIndexer) Index(id int64) error {\n \t}\n \n \t// Calculate and save language statistics to database\n-\tstats, err := gitRepo.GetLanguageStats(commitID)\n+\tstats, err := languagestats.GetLanguageStats(gitRepo, commitID)\n \tif err != nil {\n \t\tif !setting.IsInTesting {\n \t\t\tlog.Error(\"Unable to get language stats for ID %s for default branch %s in %s. Error: %v\", commitID, repo.DefaultBranch, repo.FullName(), err)\ndiff --git a/routers/web/repo/blame.go b/routers/web/repo/blame.go\nindex efd85b9452798..e125267524c7b 100644\n--- a/routers/web/repo/blame.go\n+++ b/routers/web/repo/blame.go\n@@ -15,13 +15,13 @@ import (\n \tuser_model \"code.gitea.io/gitea/models/user\"\n \t\"code.gitea.io/gitea/modules/charset\"\n \t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/git/languagestats\"\n \t\"code.gitea.io/gitea/modules/highlight\"\n \t\"code.gitea.io/gitea/modules/log\"\n \t\"code.gitea.io/gitea/modules/setting\"\n \t\"code.gitea.io/gitea/modules/templates\"\n \t\"code.gitea.io/gitea/modules/util\"\n \t\"code.gitea.io/gitea/services/context\"\n-\tfiles_service \"code.gitea.io/gitea/services/repository/files\"\n )\n \n type blameRow struct {\n@@ -234,7 +234,7 @@ func processBlameParts(ctx *context.Context, blameParts []*git.BlamePart) map[st\n func renderBlame(ctx *context.Context, blameParts []*git.BlamePart, commitNames map[string]*user_model.UserCommit) {\n \trepoLink := ctx.Repo.RepoLink\n \n-\tlanguage, err := files_service.TryGetContentLanguage(ctx.Repo.GitRepo, ctx.Repo.CommitID, ctx.Repo.TreePath)\n+\tlanguage, err := languagestats.GetFileLanguage(ctx, ctx.Repo.GitRepo, ctx.Repo.CommitID, ctx.Repo.TreePath)\n \tif err != nil {\n \t\tlog.Error(\"Unable to get file language for %-v:%s. Error: %v\", ctx.Repo.Repository, ctx.Repo.TreePath, err)\n \t}\ndiff --git a/routers/web/repo/setting/lfs.go b/routers/web/repo/setting/lfs.go\nindex efda9bda58bd5..a065620b2b249 100644\n--- a/routers/web/repo/setting/lfs.go\n+++ b/routers/web/repo/setting/lfs.go\n@@ -18,6 +18,7 @@ import (\n \t\"code.gitea.io/gitea/modules/charset\"\n \t\"code.gitea.io/gitea/modules/container\"\n \t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/git/attribute\"\n \t\"code.gitea.io/gitea/modules/git/pipeline\"\n \t\"code.gitea.io/gitea/modules/lfs\"\n \t\"code.gitea.io/gitea/modules/log\"\n@@ -134,39 +135,24 @@ func LFSLocks(ctx *context.Context) {\n \t}\n \tdefer gitRepo.Close()\n \n-\tfilenames := make([]string, len(lfsLocks))\n-\n-\tfor i, lock := range lfsLocks {\n-\t\tfilenames[i] = lock.Path\n-\t}\n-\n-\tif err := gitRepo.ReadTreeToIndex(ctx.Repo.Repository.DefaultBranch); err != nil {\n-\t\tlog.Error(\"Unable to read the default branch to the index: %s (%v)\", ctx.Repo.Repository.DefaultBranch, err)\n-\t\tctx.ServerError(\"LFSLocks\", fmt.Errorf(\"unable to read the default branch to the index: %s (%w)\", ctx.Repo.Repository.DefaultBranch, err))\n-\t\treturn\n-\t}\n-\n-\tname2attribute2info, err := gitRepo.CheckAttribute(git.CheckAttributeOpts{\n-\t\tAttributes: []string{\"lockable\"},\n-\t\tFilenames:  filenames,\n-\t\tCachedOnly: true,\n-\t})\n+\tchecker, err := attribute.NewBatchChecker(gitRepo, ctx.Repo.Repository.DefaultBranch, []string{attribute.Lockable})\n \tif err != nil {\n \t\tlog.Error(\"Unable to check attributes in %s (%v)\", tmpBasePath, err)\n \t\tctx.ServerError(\"LFSLocks\", err)\n \t\treturn\n \t}\n+\tdefer checker.Close()\n \n \tlockables := make([]bool, len(lfsLocks))\n+\tfilenames := make([]string, len(lfsLocks))\n \tfor i, lock := range lfsLocks {\n-\t\tattribute2info, has := name2attribute2info[lock.Path]\n-\t\tif !has {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif attribute2info[\"lockable\"] != \"set\" {\n+\t\tfilenames[i] = lock.Path\n+\t\tattrs, err := checker.CheckPath(lock.Path)\n+\t\tif err != nil {\n+\t\t\tlog.Error(\"Unable to check attributes in %s: %s (%v)\", tmpBasePath, lock.Path, err)\n \t\t\tcontinue\n \t\t}\n-\t\tlockables[i] = true\n+\t\tlockables[i] = attrs.Get(attribute.Lockable).ToBool().Value()\n \t}\n \tctx.Data[\"Lockables\"] = lockables\n \ndiff --git a/routers/web/repo/view_file.go b/routers/web/repo/view_file.go\nindex 12083a1ced188..ff0e1b4d54c72 100644\n--- a/routers/web/repo/view_file.go\n+++ b/routers/web/repo/view_file.go\n@@ -18,6 +18,7 @@ import (\n \t\"code.gitea.io/gitea/modules/actions\"\n \t\"code.gitea.io/gitea/modules/charset\"\n \t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/git/attribute\"\n \t\"code.gitea.io/gitea/modules/highlight\"\n \t\"code.gitea.io/gitea/modules/log\"\n \t\"code.gitea.io/gitea/modules/markup\"\n@@ -25,7 +26,6 @@ import (\n \t\"code.gitea.io/gitea/modules/util\"\n \t\"code.gitea.io/gitea/services/context\"\n \tissue_service \"code.gitea.io/gitea/services/issue\"\n-\tfiles_service \"code.gitea.io/gitea/services/repository/files\"\n \n \t\"github.com/nektos/act/pkg/model\"\n )\n@@ -147,6 +147,23 @@ func prepareToRenderFile(ctx *context.Context, entry *git.TreeEntry) {\n \t\tctx.Data[\"EditFileTooltip\"] = ctx.Tr(\"repo.editor.cannot_edit_non_text_files\")\n \t}\n \n+\t// read all needed attributes which will be used later\n+\t// there should be no performance different between reading 2 or 4 here\n+\tattrsMap, err := attribute.CheckAttributes(ctx, ctx.Repo.GitRepo, ctx.Repo.CommitID, attribute.CheckAttributeOpts{\n+\t\tFilenames:  []string{ctx.Repo.TreePath},\n+\t\tAttributes: []string{attribute.LinguistGenerated, attribute.LinguistVendored, attribute.LinguistLanguage, attribute.GitlabLanguage},\n+\t})\n+\tif err != nil {\n+\t\tctx.ServerError(\"attribute.CheckAttributes\", err)\n+\t\treturn\n+\t}\n+\tattrs := attrsMap[ctx.Repo.TreePath]\n+\tif attrs == nil {\n+\t\t// this case shouldn't happen, just in case.\n+\t\tsetting.PanicInDevOrTesting(\"no attributes found for %s\", ctx.Repo.TreePath)\n+\t\tattrs = attribute.NewAttributes()\n+\t}\n+\n \tswitch {\n \tcase isRepresentableAsText:\n \t\tif fInfo.fileSize >= setting.UI.MaxDisplayFileSize {\n@@ -209,11 +226,7 @@ func prepareToRenderFile(ctx *context.Context, entry *git.TreeEntry) {\n \t\t\t\tctx.Data[\"NumLines\"] = bytes.Count(buf, []byte{'\\n'}) + 1\n \t\t\t}\n \n-\t\t\tlanguage, err := files_service.TryGetContentLanguage(ctx.Repo.GitRepo, ctx.Repo.CommitID, ctx.Repo.TreePath)\n-\t\t\tif err != nil {\n-\t\t\t\tlog.Error(\"Unable to get file language for %-v:%s. Error: %v\", ctx.Repo.Repository, ctx.Repo.TreePath, err)\n-\t\t\t}\n-\n+\t\t\tlanguage := attrs.GetLanguage().Value()\n \t\t\tfileContent, lexerName, err := highlight.File(blob.Name(), language, buf)\n \t\t\tctx.Data[\"LexerName\"] = lexerName\n \t\t\tif err != nil {\n@@ -283,17 +296,7 @@ func prepareToRenderFile(ctx *context.Context, entry *git.TreeEntry) {\n \t\t}\n \t}\n \n-\tif ctx.Repo.GitRepo != nil {\n-\t\tchecker, deferable := ctx.Repo.GitRepo.CheckAttributeReader(ctx.Repo.CommitID)\n-\t\tif checker != nil {\n-\t\t\tdefer deferable()\n-\t\t\tattrs, err := checker.CheckPath(ctx.Repo.TreePath)\n-\t\t\tif err == nil {\n-\t\t\t\tctx.Data[\"IsVendored\"] = git.AttributeToBool(attrs, git.AttributeLinguistVendored).Value()\n-\t\t\t\tctx.Data[\"IsGenerated\"] = git.AttributeToBool(attrs, git.AttributeLinguistGenerated).Value()\n-\t\t\t}\n-\t\t}\n-\t}\n+\tctx.Data[\"IsVendored\"], ctx.Data[\"IsGenerated\"] = attrs.GetVendored().Value(), attrs.GetGenerated().Value()\n \n \tif fInfo.st.IsImage() && !fInfo.st.IsSvgImage() {\n \t\timg, _, err := image.DecodeConfig(bytes.NewReader(buf))\ndiff --git a/services/gitdiff/gitdiff.go b/services/gitdiff/gitdiff.go\nindex b9781cf8d067b..9ee86d9dfc0f8 100644\n--- a/services/gitdiff/gitdiff.go\n+++ b/services/gitdiff/gitdiff.go\n@@ -25,6 +25,7 @@ import (\n \t\"code.gitea.io/gitea/modules/analyze\"\n \t\"code.gitea.io/gitea/modules/charset\"\n \t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/git/attribute\"\n \t\"code.gitea.io/gitea/modules/highlight\"\n \t\"code.gitea.io/gitea/modules/lfs\"\n \t\"code.gitea.io/gitea/modules/log\"\n@@ -1237,24 +1238,21 @@ func GetDiffForRender(ctx context.Context, gitRepo *git.Repository, opts *DiffOp\n \t\treturn nil, err\n \t}\n \n-\tchecker, deferrable := gitRepo.CheckAttributeReader(opts.AfterCommitID)\n-\tdefer deferrable()\n+\tchecker, err := attribute.NewBatchChecker(gitRepo, opts.AfterCommitID, []string{attribute.LinguistVendored, attribute.LinguistGenerated, attribute.LinguistLanguage, attribute.GitlabLanguage})\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer checker.Close()\n \n \tfor _, diffFile := range diff.Files {\n \t\tisVendored := optional.None[bool]()\n \t\tisGenerated := optional.None[bool]()\n-\t\tif checker != nil {\n-\t\t\tattrs, err := checker.CheckPath(diffFile.Name)\n-\t\t\tif err == nil {\n-\t\t\t\tisVendored = git.AttributeToBool(attrs, git.AttributeLinguistVendored)\n-\t\t\t\tisGenerated = git.AttributeToBool(attrs, git.AttributeLinguistGenerated)\n-\n-\t\t\t\tlanguage := git.TryReadLanguageAttribute(attrs)\n-\t\t\t\tif language.Has() {\n-\t\t\t\t\tdiffFile.Language = language.Value()\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tchecker = nil // CheckPath fails, it's not impossible to \"check\" anymore\n+\t\tattrs, err := checker.CheckPath(diffFile.Name)\n+\t\tif err == nil {\n+\t\t\tisVendored, isGenerated = attrs.GetVendored(), attrs.GetGenerated()\n+\t\t\tlanguage := attrs.GetLanguage()\n+\t\t\tif language.Has() {\n+\t\t\t\tdiffFile.Language = language.Value()\n \t\t\t}\n \t\t}\n \ndiff --git a/services/markup/renderhelper_codepreview.go b/services/markup/renderhelper_codepreview.go\nindex 28d11209846d8..fa1eb824a2f54 100644\n--- a/services/markup/renderhelper_codepreview.go\n+++ b/services/markup/renderhelper_codepreview.go\n@@ -14,13 +14,13 @@ import (\n \t\"code.gitea.io/gitea/models/repo\"\n \t\"code.gitea.io/gitea/models/unit\"\n \t\"code.gitea.io/gitea/modules/charset\"\n+\t\"code.gitea.io/gitea/modules/git/languagestats\"\n \t\"code.gitea.io/gitea/modules/gitrepo\"\n \t\"code.gitea.io/gitea/modules/indexer/code\"\n \t\"code.gitea.io/gitea/modules/markup\"\n \t\"code.gitea.io/gitea/modules/setting\"\n \t\"code.gitea.io/gitea/modules/util\"\n \tgitea_context \"code.gitea.io/gitea/services/context\"\n-\t\"code.gitea.io/gitea/services/repository/files\"\n )\n \n func renderRepoFileCodePreview(ctx context.Context, opts markup.RenderCodePreviewOptions) (template.HTML, error) {\n@@ -61,7 +61,7 @@ func renderRepoFileCodePreview(ctx context.Context, opts markup.RenderCodePrevie\n \t\treturn \"\", err\n \t}\n \n-\tlanguage, _ := files.TryGetContentLanguage(gitRepo, opts.CommitID, opts.FilePath)\n+\tlanguage, _ := languagestats.GetFileLanguage(ctx, gitRepo, opts.CommitID, opts.FilePath)\n \tblob, err := commit.GetBlobByPath(opts.FilePath)\n \tif err != nil {\n \t\treturn \"\", err\ndiff --git a/services/repository/files/content.go b/services/repository/files/content.go\nindex e23cd1abce610..0327e7f2cebeb 100644\n--- a/services/repository/files/content.go\n+++ b/services/repository/files/content.go\n@@ -277,28 +277,3 @@ func GetBlobBySHA(ctx context.Context, repo *repo_model.Repository, gitRepo *git\n \t\tContent:  content,\n \t}, nil\n }\n-\n-// TryGetContentLanguage tries to get the (linguist) language of the file content\n-func TryGetContentLanguage(gitRepo *git.Repository, commitID, treePath string) (string, error) {\n-\tindexFilename, worktree, deleteTemporaryFile, err := gitRepo.ReadTreeToTemporaryIndex(commitID)\n-\tif err != nil {\n-\t\treturn \"\", err\n-\t}\n-\n-\tdefer deleteTemporaryFile()\n-\n-\tfilename2attribute2info, err := gitRepo.CheckAttribute(git.CheckAttributeOpts{\n-\t\tCachedOnly: true,\n-\t\tAttributes: []string{git.AttributeLinguistLanguage, git.AttributeGitlabLanguage},\n-\t\tFilenames:  []string{treePath},\n-\t\tIndexFile:  indexFilename,\n-\t\tWorkTree:   worktree,\n-\t})\n-\tif err != nil {\n-\t\treturn \"\", err\n-\t}\n-\n-\tlanguage := git.TryReadLanguageAttribute(filename2attribute2info[treePath])\n-\n-\treturn language.Value(), nil\n-}\ndiff --git a/services/repository/files/update.go b/services/repository/files/update.go\nindex 3f6255e77a77c..75ede4976f9a2 100644\n--- a/services/repository/files/update.go\n+++ b/services/repository/files/update.go\n@@ -15,6 +15,7 @@ import (\n \trepo_model \"code.gitea.io/gitea/models/repo\"\n \tuser_model \"code.gitea.io/gitea/models/user\"\n \t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/git/attribute\"\n \t\"code.gitea.io/gitea/modules/gitrepo\"\n \t\"code.gitea.io/gitea/modules/lfs\"\n \t\"code.gitea.io/gitea/modules/log\"\n@@ -488,16 +489,15 @@ func CreateOrUpdateFile(ctx context.Context, t *TemporaryUploadRepository, file\n \tvar lfsMetaObject *git_model.LFSMetaObject\n \tif setting.LFS.StartServer && hasOldBranch {\n \t\t// Check there is no way this can return multiple infos\n-\t\tfilename2attribute2info, err := t.gitRepo.CheckAttribute(git.CheckAttributeOpts{\n-\t\t\tAttributes: []string{\"filter\"},\n+\t\tattributesMap, err := attribute.CheckAttributes(ctx, t.gitRepo, \"\" /* use temp repo's working dir */, attribute.CheckAttributeOpts{\n+\t\t\tAttributes: []string{attribute.Filter},\n \t\t\tFilenames:  []string{file.Options.treePath},\n-\t\t\tCachedOnly: true,\n \t\t})\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n \n-\t\tif filename2attribute2info[file.Options.treePath] != nil && filename2attribute2info[file.Options.treePath][\"filter\"] == \"lfs\" {\n+\t\tif attributesMap[file.Options.treePath] != nil && attributesMap[file.Options.treePath].Get(attribute.Filter).ToString().Value() == \"lfs\" {\n \t\t\t// OK so we are supposed to LFS this data!\n \t\t\tpointer, err := lfs.GeneratePointer(treeObjectContentReader)\n \t\t\tif err != nil {\ndiff --git a/services/repository/files/upload.go b/services/repository/files/upload.go\nindex 2e4ed1744ef7c..f348cb68ab543 100644\n--- a/services/repository/files/upload.go\n+++ b/services/repository/files/upload.go\n@@ -14,6 +14,7 @@ import (\n \trepo_model \"code.gitea.io/gitea/models/repo\"\n \tuser_model \"code.gitea.io/gitea/models/user\"\n \t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/git/attribute\"\n \t\"code.gitea.io/gitea/modules/lfs\"\n \t\"code.gitea.io/gitea/modules/setting\"\n )\n@@ -105,12 +106,11 @@ func UploadRepoFiles(ctx context.Context, repo *repo_model.Repository, doer *use\n \t\t}\n \t}\n \n-\tvar filename2attribute2info map[string]map[string]string\n+\tvar attributesMap map[string]*attribute.Attributes\n \tif setting.LFS.StartServer {\n-\t\tfilename2attribute2info, err = t.gitRepo.CheckAttribute(git.CheckAttributeOpts{\n-\t\t\tAttributes: []string{\"filter\"},\n+\t\tattributesMap, err = attribute.CheckAttributes(ctx, t.gitRepo, \"\" /* use temp repo's working dir */, attribute.CheckAttributeOpts{\n+\t\t\tAttributes: []string{attribute.Filter},\n \t\t\tFilenames:  names,\n-\t\t\tCachedOnly: true,\n \t\t})\n \t\tif err != nil {\n \t\t\treturn err\n@@ -119,7 +119,7 @@ func UploadRepoFiles(ctx context.Context, repo *repo_model.Repository, doer *use\n \n \t// Copy uploaded files into repository.\n \tfor i := range infos {\n-\t\tif err := copyUploadedLFSFileIntoRepository(ctx, &infos[i], filename2attribute2info, t, opts.TreePath); err != nil {\n+\t\tif err := copyUploadedLFSFileIntoRepository(ctx, &infos[i], attributesMap, t, opts.TreePath); err != nil {\n \t\t\treturn err\n \t\t}\n \t}\n@@ -176,7 +176,7 @@ func UploadRepoFiles(ctx context.Context, repo *repo_model.Repository, doer *use\n \treturn repo_model.DeleteUploads(ctx, uploads...)\n }\n \n-func copyUploadedLFSFileIntoRepository(ctx context.Context, info *uploadInfo, filename2attribute2info map[string]map[string]string, t *TemporaryUploadRepository, treePath string) error {\n+func copyUploadedLFSFileIntoRepository(ctx context.Context, info *uploadInfo, attributesMap map[string]*attribute.Attributes, t *TemporaryUploadRepository, treePath string) error {\n \tfile, err := os.Open(info.upload.LocalPath())\n \tif err != nil {\n \t\treturn err\n@@ -184,7 +184,7 @@ func copyUploadedLFSFileIntoRepository(ctx context.Context, info *uploadInfo, fi\n \tdefer file.Close()\n \n \tvar objectHash string\n-\tif setting.LFS.StartServer && filename2attribute2info[info.upload.Name] != nil && filename2attribute2info[info.upload.Name][\"filter\"] == \"lfs\" {\n+\tif setting.LFS.StartServer && attributesMap[info.upload.Name] != nil && attributesMap[info.upload.Name].Get(attribute.Filter).ToString().Value() == \"lfs\" {\n \t\t// Handle LFS\n \t\t// FIXME: Inefficient! this should probably happen in models.Upload\n \t\tpointer, err := lfs.GeneratePointer(file)\n", "test_patch": "diff --git a/modules/git/attribute/attribute_test.go b/modules/git/attribute/attribute_test.go\nnew file mode 100644\nindex 0000000000000..dadb5582a3cb5\n--- /dev/null\n+++ b/modules/git/attribute/attribute_test.go\n@@ -0,0 +1,37 @@\n+// Copyright 2025 The Gitea Authors. All rights reserved.\n+// SPDX-License-Identifier: MIT\n+\n+package attribute\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func Test_Attribute(t *testing.T) {\n+\tassert.Empty(t, Attribute(\"\").ToString().Value())\n+\tassert.Empty(t, Attribute(\"unspecified\").ToString().Value())\n+\tassert.Equal(t, \"python\", Attribute(\"python\").ToString().Value())\n+\tassert.Equal(t, \"Java\", Attribute(\"Java\").ToString().Value())\n+\n+\tattributes := Attributes{\n+\t\tm: map[string]Attribute{\n+\t\t\tLinguistGenerated:     \"true\",\n+\t\t\tLinguistDocumentation: \"false\",\n+\t\t\tLinguistDetectable:    \"set\",\n+\t\t\tLinguistLanguage:      \"Python\",\n+\t\t\tGitlabLanguage:        \"Java\",\n+\t\t\t\"filter\":              \"unspecified\",\n+\t\t\t\"test\":                \"\",\n+\t\t},\n+\t}\n+\n+\tassert.Empty(t, attributes.Get(\"test\").ToString().Value())\n+\tassert.Empty(t, attributes.Get(\"filter\").ToString().Value())\n+\tassert.Equal(t, \"Python\", attributes.Get(LinguistLanguage).ToString().Value())\n+\tassert.Equal(t, \"Java\", attributes.Get(GitlabLanguage).ToString().Value())\n+\tassert.True(t, attributes.Get(LinguistGenerated).ToBool().Value())\n+\tassert.False(t, attributes.Get(LinguistDocumentation).ToBool().Value())\n+\tassert.True(t, attributes.Get(LinguistDetectable).ToBool().Value())\n+}\ndiff --git a/modules/git/repo_attribute_test.go b/modules/git/attribute/batch_test.go\nsimilarity index 50%\nrename from modules/git/repo_attribute_test.go\nrename to modules/git/attribute/batch_test.go\nindex d8fd9f0e8d857..30a3d805fe983 100644\n--- a/modules/git/repo_attribute_test.go\n+++ b/modules/git/attribute/batch_test.go\n@@ -1,13 +1,19 @@\n // Copyright 2021 The Gitea Authors. All rights reserved.\n // SPDX-License-Identifier: MIT\n \n-package git\n+package attribute\n \n import (\n+\t\"path/filepath\"\n \t\"testing\"\n \t\"time\"\n \n+\t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/setting\"\n+\t\"code.gitea.io/gitea/modules/test\"\n+\n \t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n )\n \n func Test_nulSeparatedAttributeWriter_ReadAttribute(t *testing.T) {\n@@ -24,7 +30,7 @@ func Test_nulSeparatedAttributeWriter_ReadAttribute(t *testing.T) {\n \tselect {\n \tcase attr := <-wr.ReadAttribute():\n \t\tassert.Equal(t, \".gitignore\\\"\\n\", attr.Filename)\n-\t\tassert.Equal(t, AttributeLinguistVendored, attr.Attribute)\n+\t\tassert.Equal(t, LinguistVendored, attr.Attribute)\n \t\tassert.Equal(t, \"unspecified\", attr.Value)\n \tcase <-time.After(100 * time.Millisecond):\n \t\tassert.FailNow(t, \"took too long to read an attribute from the list\")\n@@ -38,7 +44,7 @@ func Test_nulSeparatedAttributeWriter_ReadAttribute(t *testing.T) {\n \tselect {\n \tcase attr := <-wr.ReadAttribute():\n \t\tassert.Equal(t, \".gitignore\\\"\\n\", attr.Filename)\n-\t\tassert.Equal(t, AttributeLinguistVendored, attr.Attribute)\n+\t\tassert.Equal(t, LinguistVendored, attr.Attribute)\n \t\tassert.Equal(t, \"unspecified\", attr.Value)\n \tcase <-time.After(100 * time.Millisecond):\n \t\tassert.FailNow(t, \"took too long to read an attribute from the list\")\n@@ -77,21 +83,90 @@ func Test_nulSeparatedAttributeWriter_ReadAttribute(t *testing.T) {\n \tassert.NoError(t, err)\n \tassert.Equal(t, attributeTriple{\n \t\tFilename:  \"shouldbe.vendor\",\n-\t\tAttribute: AttributeLinguistVendored,\n+\t\tAttribute: LinguistVendored,\n \t\tValue:     \"set\",\n \t}, attr)\n \tattr = <-wr.ReadAttribute()\n \tassert.NoError(t, err)\n \tassert.Equal(t, attributeTriple{\n \t\tFilename:  \"shouldbe.vendor\",\n-\t\tAttribute: AttributeLinguistGenerated,\n+\t\tAttribute: LinguistGenerated,\n \t\tValue:     \"unspecified\",\n \t}, attr)\n \tattr = <-wr.ReadAttribute()\n \tassert.NoError(t, err)\n \tassert.Equal(t, attributeTriple{\n \t\tFilename:  \"shouldbe.vendor\",\n-\t\tAttribute: AttributeLinguistLanguage,\n+\t\tAttribute: LinguistLanguage,\n \t\tValue:     \"unspecified\",\n \t}, attr)\n }\n+\n+func expectedAttrs() *Attributes {\n+\treturn &Attributes{\n+\t\tm: map[string]Attribute{\n+\t\t\tLinguistGenerated:     \"unspecified\",\n+\t\t\tLinguistDetectable:    \"unspecified\",\n+\t\t\tLinguistDocumentation: \"unspecified\",\n+\t\t\tLinguistVendored:      \"unspecified\",\n+\t\t\tLinguistLanguage:      \"Python\",\n+\t\t\tGitlabLanguage:        \"unspecified\",\n+\t\t},\n+\t}\n+}\n+\n+func Test_BatchChecker(t *testing.T) {\n+\tsetting.AppDataPath = t.TempDir()\n+\trepoPath := \"../tests/repos/language_stats_repo\"\n+\tgitRepo, err := git.OpenRepository(t.Context(), repoPath)\n+\trequire.NoError(t, err)\n+\tdefer gitRepo.Close()\n+\n+\tcommitID := \"8fee858da5796dfb37704761701bb8e800ad9ef3\"\n+\n+\tt.Run(\"Create index file to run git check-attr\", func(t *testing.T) {\n+\t\tdefer test.MockVariableValue(&git.DefaultFeatures().SupportCheckAttrOnBare, false)()\n+\t\tchecker, err := NewBatchChecker(gitRepo, commitID, LinguistAttributes)\n+\t\tassert.NoError(t, err)\n+\t\tdefer checker.Close()\n+\t\tattributes, err := checker.CheckPath(\"i-am-a-python.p\")\n+\t\tassert.NoError(t, err)\n+\t\tassert.Equal(t, expectedAttrs(), attributes)\n+\t})\n+\n+\t// run git check-attr on work tree\n+\tt.Run(\"Run git check-attr on git work tree\", func(t *testing.T) {\n+\t\tdir := filepath.Join(t.TempDir(), \"test-repo\")\n+\t\terr := git.Clone(t.Context(), repoPath, dir, git.CloneRepoOptions{\n+\t\t\tShared: true,\n+\t\t\tBranch: \"master\",\n+\t\t})\n+\t\tassert.NoError(t, err)\n+\n+\t\ttempRepo, err := git.OpenRepository(t.Context(), dir)\n+\t\tassert.NoError(t, err)\n+\t\tdefer tempRepo.Close()\n+\n+\t\tchecker, err := NewBatchChecker(tempRepo, \"\", LinguistAttributes)\n+\t\tassert.NoError(t, err)\n+\t\tdefer checker.Close()\n+\t\tattributes, err := checker.CheckPath(\"i-am-a-python.p\")\n+\t\tassert.NoError(t, err)\n+\t\tassert.Equal(t, expectedAttrs(), attributes)\n+\t})\n+\n+\tif !git.DefaultFeatures().SupportCheckAttrOnBare {\n+\t\tt.Skip(\"git version 2.40 is required to support run check-attr on bare repo\")\n+\t\treturn\n+\t}\n+\n+\tt.Run(\"Run git check-attr in bare repository\", func(t *testing.T) {\n+\t\tchecker, err := NewBatchChecker(gitRepo, commitID, LinguistAttributes)\n+\t\tassert.NoError(t, err)\n+\t\tdefer checker.Close()\n+\n+\t\tattributes, err := checker.CheckPath(\"i-am-a-python.p\")\n+\t\tassert.NoError(t, err)\n+\t\tassert.Equal(t, expectedAttrs(), attributes)\n+\t})\n+}\ndiff --git a/modules/git/attribute/checker_test.go b/modules/git/attribute/checker_test.go\nnew file mode 100644\nindex 0000000000000..97db43460bb81\n--- /dev/null\n+++ b/modules/git/attribute/checker_test.go\n@@ -0,0 +1,74 @@\n+// Copyright 2025 The Gitea Authors. All rights reserved.\n+// SPDX-License-Identifier: MIT\n+\n+package attribute\n+\n+import (\n+\t\"path/filepath\"\n+\t\"testing\"\n+\n+\t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/setting\"\n+\t\"code.gitea.io/gitea/modules/test\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+func Test_Checker(t *testing.T) {\n+\tsetting.AppDataPath = t.TempDir()\n+\trepoPath := \"../tests/repos/language_stats_repo\"\n+\tgitRepo, err := git.OpenRepository(t.Context(), repoPath)\n+\trequire.NoError(t, err)\n+\tdefer gitRepo.Close()\n+\n+\tcommitID := \"8fee858da5796dfb37704761701bb8e800ad9ef3\"\n+\n+\tt.Run(\"Create index file to run git check-attr\", func(t *testing.T) {\n+\t\tdefer test.MockVariableValue(&git.DefaultFeatures().SupportCheckAttrOnBare, false)()\n+\t\tattrs, err := CheckAttributes(t.Context(), gitRepo, commitID, CheckAttributeOpts{\n+\t\t\tFilenames:  []string{\"i-am-a-python.p\"},\n+\t\t\tAttributes: LinguistAttributes,\n+\t\t})\n+\t\tassert.NoError(t, err)\n+\t\tassert.Len(t, attrs, 1)\n+\t\tassert.Equal(t, expectedAttrs(), attrs[\"i-am-a-python.p\"])\n+\t})\n+\n+\t// run git check-attr on work tree\n+\tt.Run(\"Run git check-attr on git work tree\", func(t *testing.T) {\n+\t\tdir := filepath.Join(t.TempDir(), \"test-repo\")\n+\t\terr := git.Clone(t.Context(), repoPath, dir, git.CloneRepoOptions{\n+\t\t\tShared: true,\n+\t\t\tBranch: \"master\",\n+\t\t})\n+\t\tassert.NoError(t, err)\n+\n+\t\ttempRepo, err := git.OpenRepository(t.Context(), dir)\n+\t\tassert.NoError(t, err)\n+\t\tdefer tempRepo.Close()\n+\n+\t\tattrs, err := CheckAttributes(t.Context(), tempRepo, \"\", CheckAttributeOpts{\n+\t\t\tFilenames:  []string{\"i-am-a-python.p\"},\n+\t\t\tAttributes: LinguistAttributes,\n+\t\t})\n+\t\tassert.NoError(t, err)\n+\t\tassert.Len(t, attrs, 1)\n+\t\tassert.Equal(t, expectedAttrs(), attrs[\"i-am-a-python.p\"])\n+\t})\n+\n+\tif !git.DefaultFeatures().SupportCheckAttrOnBare {\n+\t\tt.Skip(\"git version 2.40 is required to support run check-attr on bare repo\")\n+\t\treturn\n+\t}\n+\n+\tt.Run(\"Run git check-attr in bare repository\", func(t *testing.T) {\n+\t\tattrs, err := CheckAttributes(t.Context(), gitRepo, commitID, CheckAttributeOpts{\n+\t\t\tFilenames:  []string{\"i-am-a-python.p\"},\n+\t\t\tAttributes: LinguistAttributes,\n+\t\t})\n+\t\tassert.NoError(t, err)\n+\t\tassert.Len(t, attrs, 1)\n+\t\tassert.Equal(t, expectedAttrs(), attrs[\"i-am-a-python.p\"])\n+\t})\n+}\ndiff --git a/modules/git/attribute/main_test.go b/modules/git/attribute/main_test.go\nnew file mode 100644\nindex 0000000000000..df8241bfb08d4\n--- /dev/null\n+++ b/modules/git/attribute/main_test.go\n@@ -0,0 +1,41 @@\n+// Copyright 2025 The Gitea Authors. All rights reserved.\n+// SPDX-License-Identifier: MIT\n+\n+package attribute\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"testing\"\n+\n+\t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/setting\"\n+\t\"code.gitea.io/gitea/modules/util\"\n+)\n+\n+func testRun(m *testing.M) error {\n+\tgitHomePath, err := os.MkdirTemp(os.TempDir(), \"git-home\")\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"unable to create temp dir: %w\", err)\n+\t}\n+\tdefer util.RemoveAll(gitHomePath)\n+\tsetting.Git.HomePath = gitHomePath\n+\n+\tif err = git.InitFull(context.Background()); err != nil {\n+\t\treturn fmt.Errorf(\"failed to call Init: %w\", err)\n+\t}\n+\n+\texitCode := m.Run()\n+\tif exitCode != 0 {\n+\t\treturn fmt.Errorf(\"run test failed, ExitCode=%d\", exitCode)\n+\t}\n+\treturn nil\n+}\n+\n+func TestMain(m *testing.M) {\n+\tif err := testRun(m); err != nil {\n+\t\t_, _ = fmt.Fprintf(os.Stderr, \"Test failed: %v\", err)\n+\t\tos.Exit(1)\n+\t}\n+}\ndiff --git a/modules/git/repo_language_stats_test.go b/modules/git/languagestats/language_stats_test.go\nsimilarity index 75%\nrename from modules/git/repo_language_stats_test.go\nrename to modules/git/languagestats/language_stats_test.go\nindex 12ce958c6e556..b908ae6413d72 100644\n--- a/modules/git/repo_language_stats_test.go\n+++ b/modules/git/languagestats/language_stats_test.go\n@@ -3,12 +3,12 @@\n \n //go:build !gogit\n \n-package git\n+package languagestats\n \n import (\n-\t\"path/filepath\"\n \t\"testing\"\n \n+\t\"code.gitea.io/gitea/modules/git\"\n \t\"code.gitea.io/gitea/modules/setting\"\n \n \t\"github.com/stretchr/testify/assert\"\n@@ -17,13 +17,12 @@ import (\n \n func TestRepository_GetLanguageStats(t *testing.T) {\n \tsetting.AppDataPath = t.TempDir()\n-\trepoPath := filepath.Join(testReposDir, \"language_stats_repo\")\n-\tgitRepo, err := openRepositoryWithDefaultContext(repoPath)\n+\trepoPath := \"../tests/repos/language_stats_repo\"\n+\tgitRepo, err := git.OpenRepository(t.Context(), repoPath)\n \trequire.NoError(t, err)\n-\n \tdefer gitRepo.Close()\n \n-\tstats, err := gitRepo.GetLanguageStats(\"8fee858da5796dfb37704761701bb8e800ad9ef3\")\n+\tstats, err := GetLanguageStats(gitRepo, \"8fee858da5796dfb37704761701bb8e800ad9ef3\")\n \trequire.NoError(t, err)\n \n \tassert.Equal(t, map[string]int64{\ndiff --git a/modules/git/languagestats/main_test.go b/modules/git/languagestats/main_test.go\nnew file mode 100644\nindex 0000000000000..707d268c818ef\n--- /dev/null\n+++ b/modules/git/languagestats/main_test.go\n@@ -0,0 +1,41 @@\n+// Copyright 2025 The Gitea Authors. All rights reserved.\n+// SPDX-License-Identifier: MIT\n+\n+package languagestats\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"testing\"\n+\n+\t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/setting\"\n+\t\"code.gitea.io/gitea/modules/util\"\n+)\n+\n+func testRun(m *testing.M) error {\n+\tgitHomePath, err := os.MkdirTemp(os.TempDir(), \"git-home\")\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"unable to create temp dir: %w\", err)\n+\t}\n+\tdefer util.RemoveAll(gitHomePath)\n+\tsetting.Git.HomePath = gitHomePath\n+\n+\tif err = git.InitFull(context.Background()); err != nil {\n+\t\treturn fmt.Errorf(\"failed to call Init: %w\", err)\n+\t}\n+\n+\texitCode := m.Run()\n+\tif exitCode != 0 {\n+\t\treturn fmt.Errorf(\"run test failed, ExitCode=%d\", exitCode)\n+\t}\n+\treturn nil\n+}\n+\n+func TestMain(m *testing.M) {\n+\tif err := testRun(m); err != nil {\n+\t\t_, _ = fmt.Fprintf(os.Stderr, \"Test failed: %v\", err)\n+\t\tos.Exit(1)\n+\t}\n+}\ndiff --git a/modules/git/tests/repos/language_stats_repo/config b/modules/git/tests/repos/language_stats_repo/config\nindex 515f4836297fd..a4ef456cbc233 100644\n--- a/modules/git/tests/repos/language_stats_repo/config\n+++ b/modules/git/tests/repos/language_stats_repo/config\n@@ -1,5 +1,5 @@\n [core]\n \trepositoryformatversion = 0\n \tfilemode = true\n-\tbare = false\n+\tbare = true\n \tlogallrefupdates = true\ndiff --git a/modules/git/tests/repos/repo3_notes/config b/modules/git/tests/repos/repo3_notes/config\nindex d545cdabdbdda..5ed22e23d15d7 100644\n--- a/modules/git/tests/repos/repo3_notes/config\n+++ b/modules/git/tests/repos/repo3_notes/config\n@@ -1,7 +1,7 @@\n [core]\n \trepositoryformatversion = 0\n \tfilemode = false\n-\tbare = false\n+\tbare = true\n \tlogallrefupdates = true\n \tsymlinks = false\n \tignorecase = true\ndiff --git a/modules/git/tests/repos/repo4_commitsbetween/config b/modules/git/tests/repos/repo4_commitsbetween/config\nindex d545cdabdbdda..5ed22e23d15d7 100644\n--- a/modules/git/tests/repos/repo4_commitsbetween/config\n+++ b/modules/git/tests/repos/repo4_commitsbetween/config\n@@ -1,7 +1,7 @@\n [core]\n \trepositoryformatversion = 0\n \tfilemode = false\n-\tbare = false\n+\tbare = true\n \tlogallrefupdates = true\n \tsymlinks = false\n \tignorecase = true\n"}
{"org": "gofiber", "repo": "fiber", "number": 3895, "state": "closed", "title": "⚡ perf: Improve performance of RebuildTree() by 68%", "body": "## Summary\r\n- This pull request focuses on improving the efficiency and memory management of the routing tree construction within the application. It refactors the buildTree function to simplify bucket allocation and ensure precise preallocation of data structures. Additionally, a new benchmark is added to track the performance of the tree rebuilding operation, providing a baseline for future optimizations.\r\n\r\n### Before\r\n\r\n```console\r\ngoos: linux\r\ngoarch: amd64\r\npkg: github.com/gofiber/fiber/v3\r\ncpu: AMD Ryzen 7 7800X3D 8-Core Processor           \r\nBenchmark_App_RebuildTree\r\nBenchmark_App_RebuildTree-4   \t   32095\t     37059 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   32386\t     37005 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   33099\t     36389 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   31860\t     36865 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   32568\t     37237 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   32446\t     36411 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   33307\t     36342 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   32185\t     36923 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   33567\t     36420 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   31746\t     36938 ns/op\t   26768 B/op\t     290 allocs/op\r\nPASS\r\nok  \tgithub.com/gofiber/fiber/v3\t11.972s\r\n```\r\n\r\n### After\r\n\r\n```console\r\ngoos: linux\r\ngoarch: amd64\r\npkg: github.com/gofiber/fiber/v3\r\ncpu: AMD Ryzen 7 7800X3D 8-Core Processor           \r\nBenchmark_App_RebuildTree\r\nBenchmark_App_RebuildTree-4   \t   88698\t     13380 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   87627\t     13122 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   89563\t     13367 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   90487\t     13846 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   83514\t     14268 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   81895\t     13929 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   84560\t     14110 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   81997\t     13364 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   87638\t     13045 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   91272\t     13427 ns/op\t   17952 B/op\t      93 allocs/op\r\nPASS\r\nok  \tgithub.com/gofiber/fiber/v3\t11.795s\r\n```\r\n\r\n### Benchstat\r\n\r\n```console\r\n$ go run golang.org/x/perf/cmd/benchstat@latest old.txt new.txt \r\ngoos: linux\r\ngoarch: amd64\r\npkg: github.com/gofiber/fiber/v3\r\ncpu: AMD Ryzen 7 7800X3D 8-Core Processor           \r\n                   │   old.txt   │               new.txt               │\r\n                   │   sec/op    │   sec/op     vs base                │\r\n_App_RebuildTree-4   36.89µ ± 1%   13.40µ ± 5%  -63.67% (p=0.000 n=10)\r\n\r\n                   │   old.txt    │               new.txt                │\r\n                   │     B/op     │     B/op      vs base                │\r\n_App_RebuildTree-4   26.14Ki ± 0%   17.53Ki ± 0%  -32.93% (p=0.000 n=10)\r\n\r\n                   │   old.txt   │              new.txt               │\r\n                   │  allocs/op  │ allocs/op   vs base                │\r\n_App_RebuildTree-4   290.00 ± 0%   93.00 ± 0%  -67.93% (p=0.000 n=10)\r\n```\r\n", "url": "https://api.github.com/repos/gofiber/fiber/pulls/3895", "id": 3038244364, "node_id": "PR_kwDODfYWS861F-4M", "html_url": "https://github.com/gofiber/fiber/pull/3895", "diff_url": "https://github.com/gofiber/fiber/pull/3895.diff", "patch_url": "https://github.com/gofiber/fiber/pull/3895.patch", "issue_url": "https://api.github.com/repos/gofiber/fiber/issues/3895", "created_at": "2025-11-24T02:46:25+00:00", "updated_at": "2025-11-24T12:11:23+00:00", "closed_at": "2025-11-24T12:11:11+00:00", "merged_at": "2025-11-24T12:11:11+00:00", "merge_commit_sha": "a477afdf84310dbc34f1ac9ec72ce2765cb7e004", "labels": ["🧹 Updates", "v3", "⚡️ Performance", "codex"], "draft": false, "commits_url": "https://api.github.com/repos/gofiber/fiber/pulls/3895/commits", "review_comments_url": "https://api.github.com/repos/gofiber/fiber/pulls/3895/comments", "review_comment_url": "https://api.github.com/repos/gofiber/fiber/pulls/comments{/number}", "comments_url": "https://api.github.com/repos/gofiber/fiber/issues/3895/comments", "base": {"label": "gofiber:main", "ref": "main", "sha": "5caa478c02c5eb6cd1c251ddc634ec0600e66a7b", "user": {"login": "gofiber", "id": 59947262, "node_id": "MDEyOk9yZ2FuaXphdGlvbjU5OTQ3MjYy", "avatar_url": "https://avatars.githubusercontent.com/u/59947262?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gofiber", "html_url": "https://github.com/gofiber", "followers_url": "https://api.github.com/users/gofiber/followers", "following_url": "https://api.github.com/users/gofiber/following{/other_user}", "gists_url": "https://api.github.com/users/gofiber/gists{/gist_id}", "starred_url": "https://api.github.com/users/gofiber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gofiber/subscriptions", "organizations_url": "https://api.github.com/users/gofiber/orgs", "repos_url": "https://api.github.com/users/gofiber/repos", "events_url": "https://api.github.com/users/gofiber/events{/privacy}", "received_events_url": "https://api.github.com/users/gofiber/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "repo": {"id": 234231371, "node_id": "MDEwOlJlcG9zaXRvcnkyMzQyMzEzNzE=", "name": "fiber", "full_name": "gofiber/fiber", "private": false, "owner": {"login": "gofiber", "id": 59947262, "node_id": "MDEyOk9yZ2FuaXphdGlvbjU5OTQ3MjYy", "avatar_url": "https://avatars.githubusercontent.com/u/59947262?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gofiber", "html_url": "https://github.com/gofiber", "followers_url": "https://api.github.com/users/gofiber/followers", "following_url": "https://api.github.com/users/gofiber/following{/other_user}", "gists_url": "https://api.github.com/users/gofiber/gists{/gist_id}", "starred_url": "https://api.github.com/users/gofiber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gofiber/subscriptions", "organizations_url": "https://api.github.com/users/gofiber/orgs", "repos_url": "https://api.github.com/users/gofiber/repos", "events_url": "https://api.github.com/users/gofiber/events{/privacy}", "received_events_url": "https://api.github.com/users/gofiber/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "html_url": "https://github.com/gofiber/fiber", "description": "⚡️ Express inspired web framework written in Go", "fork": false, "url": "https://api.github.com/repos/gofiber/fiber", "forks_url": "https://api.github.com/repos/gofiber/fiber/forks", "keys_url": "https://api.github.com/repos/gofiber/fiber/keys{/key_id}", "collaborators_url": "https://api.github.com/repos/gofiber/fiber/collaborators{/collaborator}", "teams_url": "https://api.github.com/repos/gofiber/fiber/teams", "hooks_url": "https://api.github.com/repos/gofiber/fiber/hooks", "issue_events_url": "https://api.github.com/repos/gofiber/fiber/issues/events{/number}", "events_url": "https://api.github.com/repos/gofiber/fiber/events", "assignees_url": "https://api.github.com/repos/gofiber/fiber/assignees{/user}", "branches_url": "https://api.github.com/repos/gofiber/fiber/branches{/branch}", "tags_url": "https://api.github.com/repos/gofiber/fiber/tags", "blobs_url": "https://api.github.com/repos/gofiber/fiber/git/blobs{/sha}", "git_tags_url": "https://api.github.com/repos/gofiber/fiber/git/tags{/sha}", "git_refs_url": "https://api.github.com/repos/gofiber/fiber/git/refs{/sha}", "trees_url": "https://api.github.com/repos/gofiber/fiber/git/trees{/sha}", "statuses_url": "https://api.github.com/repos/gofiber/fiber/statuses/{sha}", "languages_url": "https://api.github.com/repos/gofiber/fiber/languages", "stargazers_url": "https://api.github.com/repos/gofiber/fiber/stargazers", "contributors_url": "https://api.github.com/repos/gofiber/fiber/contributors", "subscribers_url": "https://api.github.com/repos/gofiber/fiber/subscribers", "subscription_url": "https://api.github.com/repos/gofiber/fiber/subscription", "commits_url": "https://api.github.com/repos/gofiber/fiber/commits{/sha}", "git_commits_url": "https://api.github.com/repos/gofiber/fiber/git/commits{/sha}", "comments_url": "https://api.github.com/repos/gofiber/fiber/comments{/number}", "issue_comment_url": "https://api.github.com/repos/gofiber/fiber/issues/comments{/number}", "contents_url": "https://api.github.com/repos/gofiber/fiber/contents/{+path}", "compare_url": "https://api.github.com/repos/gofiber/fiber/compare/{base}...{head}", "merges_url": "https://api.github.com/repos/gofiber/fiber/merges", "archive_url": "https://api.github.com/repos/gofiber/fiber/{archive_format}{/ref}", "downloads_url": "https://api.github.com/repos/gofiber/fiber/downloads", "issues_url": "https://api.github.com/repos/gofiber/fiber/issues{/number}", "pulls_url": "https://api.github.com/repos/gofiber/fiber/pulls{/number}", "milestones_url": "https://api.github.com/repos/gofiber/fiber/milestones{/number}", "notifications_url": "https://api.github.com/repos/gofiber/fiber/notifications{?since,all,participating}", "labels_url": "https://api.github.com/repos/gofiber/fiber/labels{/name}", "releases_url": "https://api.github.com/repos/gofiber/fiber/releases{/id}", "deployments_url": "https://api.github.com/repos/gofiber/fiber/deployments", "created_at": "2020-01-16T03:59:20Z", "updated_at": "2026-01-07T16:33:00Z", "pushed_at": "2026-01-07T14:22:10Z", "git_url": "git://github.com/gofiber/fiber.git", "ssh_url": "git@github.com:gofiber/fiber.git", "clone_url": "https://github.com/gofiber/fiber.git", "svn_url": "https://github.com/gofiber/fiber", "homepage": "https://gofiber.io", "size": 235074, "stargazers_count": 38919, "watchers_count": 38919, "language": "Go", "has_issues": true, "has_projects": true, "has_downloads": true, "has_wiki": false, "has_pages": true, "has_discussions": false, "forks_count": 1937, "mirror_url": null, "archived": false, "disabled": false, "open_issues_count": 73, "license": {"key": "mit", "name": "MIT License", "spdx_id": "MIT", "url": "https://api.github.com/licenses/mit", "node_id": "MDc6TGljZW5zZTEz"}, "allow_forking": true, "is_template": false, "web_commit_signoff_required": false, "topics": ["express", "expressjs", "fast", "fiber", "flexible", "framework", "friendly", "go", "golang", "hacktoberfest", "hacktoberfest2020", "nodejs", "performance", "rest-api", "web"], "visibility": "public", "forks": 1937, "open_issues": 73, "watchers": 38919, "default_branch": "main"}}, "commits": [{"sha": "ee1466ccc04f6df90b1f39d780a24227ec7c81fc", "parents": ["46651b0011ad28bde4b2f2ae54118fc08e64e8cc"], "message": "Add RebuildTree benchmark"}], "resolved_issues": [{"org": "gofiber", "repo": "fiber", "number": -1, "state": "unknown", "title": "⚡ perf: Improve performance of RebuildTree() by 68%", "body": "## Summary\r\n- This pull request focuses on improving the efficiency and memory management of the routing tree construction within the application. It refactors the buildTree function to simplify bucket allocation and ensure precise preallocation of data structures. Additionally, a new benchmark is added to track the performance of the tree rebuilding operation, providing a baseline for future optimizations.\r\n\r\n### Before\r\n\r\n```console\r\ngoos: linux\r\ngoarch: amd64\r\npkg: github.com/gofiber/fiber/v3\r\ncpu: AMD Ryzen 7 7800X3D 8-Core Processor           \r\nBenchmark_App_RebuildTree\r\nBenchmark_App_RebuildTree-4   \t   32095\t     37059 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   32386\t     37005 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   33099\t     36389 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   31860\t     36865 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   32568\t     37237 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   32446\t     36411 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   33307\t     36342 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   32185\t     36923 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   33567\t     36420 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   31746\t     36938 ns/op\t   26768 B/op\t     290 allocs/op\r\nPASS\r\nok  \tgithub.com/gofiber/fiber/v3\t11.972s\r\n```\r\n\r\n### After\r\n\r\n```console\r\ngoos: linux\r\ngoarch: amd64\r\npkg: github.com/gofiber/fiber/v3\r\ncpu: AMD Ryzen 7 7800X3D 8-Core Processor           \r\nBenchmark_App_RebuildTree\r\nBenchmark_App_RebuildTree-4   \t   88698\t     13380 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   87627\t     13122 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   89563\t     13367 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   90487\t     13846 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   83514\t     14268 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   81895\t     13929 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   84560\t     14110 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   81997\t     13364 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   87638\t     13045 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   91272\t     13427 ns/op\t   17952 B/op\t      93 allocs/op\r\nPASS\r\nok  \tgithub.com/gofiber/fiber/v3\t11.795s\r\n```\r\n\r\n### Benchstat\r\n\r\n```console\r\n$ go run golang.org/x/perf/cmd/benchstat@latest old.txt new.txt \r\ngoos: linux\r\ngoarch: amd64\r\npkg: github.com/gofiber/fiber/v3\r\ncpu: AMD Ryzen 7 7800X3D 8-Core Processor           \r\n                   │   old.txt   │               new.txt               │\r\n                   │   sec/op    │   sec/op     vs base                │\r\n_App_RebuildTree-4   36.89µ ± 1%   13.40µ ± 5%  -63.67% (p=0.000 n=10)\r\n\r\n                   │   old.txt    │               new.txt                │\r\n                   │     B/op     │     B/op      vs base                │\r\n_App_RebuildTree-4   26.14Ki ± 0%   17.53Ki ± 0%  -32.93% (p=0.000 n=10)\r\n\r\n                   │   old.txt   │              new.txt               │\r\n                   │  allocs/op  │ allocs/op   vs base                │\r\n_App_RebuildTree-4   290.00 ± 0%   93.00 ± 0%  -67.93% (p=0.000 n=10)\r\n```\r\n"}], "fix_patch": "diff --git a/router.go b/router.go\nindex 917b7b1f33..a333b4a0ab 100644\n--- a/router.go\n+++ b/router.go\n@@ -710,52 +710,47 @@ func (app *App) buildTree() *App {\n \n \t// 1) First loop: determine all possible 3-char prefixes (\"treePaths\") for each method\n \tfor method := range app.config.RequestMethods {\n-\t\tprefixSet := map[int]struct{}{\n-\t\t\t0: {},\n-\t\t}\n-\t\tfor _, route := range app.stack[method] {\n+\t\troutes := app.stack[method]\n+\t\ttreePaths := make([]int, len(routes))\n+\n+\t\tglobalCount := 0\n+\t\tprefixCounts := make(map[int]int, len(routes))\n+\n+\t\tfor i, route := range routes {\n \t\t\tif len(route.routeParser.segs) > 0 && len(route.routeParser.segs[0].Const) >= maxDetectionPaths {\n-\t\t\t\tprefix := int(route.routeParser.segs[0].Const[0])<<16 |\n+\t\t\t\ttreePaths[i] = int(route.routeParser.segs[0].Const[0])<<16 |\n \t\t\t\t\tint(route.routeParser.segs[0].Const[1])<<8 |\n \t\t\t\t\tint(route.routeParser.segs[0].Const[2])\n-\t\t\t\tprefixSet[prefix] = struct{}{}\n \t\t\t}\n+\n+\t\t\tif treePaths[i] == 0 {\n+\t\t\t\tglobalCount++\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tprefixCounts[treePaths[i]]++\n \t\t}\n-\t\ttsMap := make(map[int][]*Route, len(prefixSet))\n-\t\tfor prefix := range prefixSet {\n-\t\t\ttsMap[prefix] = nil\n+\n+\t\ttsMap := make(map[int][]*Route, len(prefixCounts)+1)\n+\t\ttsMap[0] = make([]*Route, 0, globalCount)\n+\t\tfor treePath, count := range prefixCounts {\n+\t\t\ttsMap[treePath] = make([]*Route, 0, count+globalCount)\n \t\t}\n-\t\tapp.treeStack[method] = tsMap\n-\t}\n \n-\t// 2) Second loop: for each method and each discovered treePath, assign matching routes\n-\tfor method := range app.config.RequestMethods {\n-\t\t// get the map of buckets for this method\n-\t\ttsMap := app.treeStack[method]\n-\n-\t\t// for every treePath key (including the empty one)\n-\t\tfor treePath := range tsMap {\n-\t\t\t// iterate all routes of this method\n-\t\t\tfor _, route := range app.stack[method] {\n-\t\t\t\t// compute this route's own prefix (\"\" or first 3 chars)\n-\t\t\t\troutePath := 0\n-\t\t\t\tif len(route.routeParser.segs) > 0 && len(route.routeParser.segs[0].Const) >= 3 {\n-\t\t\t\t\troutePath = int(route.routeParser.segs[0].Const[0])<<16 |\n-\t\t\t\t\t\tint(route.routeParser.segs[0].Const[1])<<8 |\n-\t\t\t\t\t\tint(route.routeParser.segs[0].Const[2])\n-\t\t\t\t}\n+\t\tfor i, route := range routes {\n+\t\t\ttreePath := treePaths[i]\n \n-\t\t\t\t// if it's a global route, assign to every bucket\n-\t\t\t\t// If the route path is 0 (global route) or matches the current tree path,\n-\t\t\t\t// append this route to the current bucket\n-\t\t\t\tif routePath == 0 || routePath == treePath {\n-\t\t\t\t\ttsMap[treePath] = append(tsMap[treePath], route)\n+\t\t\tif treePath == 0 {\n+\t\t\t\tfor bucket := range tsMap {\n+\t\t\t\t\ttsMap[bucket] = append(tsMap[bucket], route)\n \t\t\t\t}\n+\t\t\t\tcontinue\n \t\t\t}\n \n-\t\t\t// after collecting, dedupe the bucket if it's not the global one\n-\t\t\ttsMap[treePath] = uniqueRouteStack(tsMap[treePath])\n+\t\t\ttsMap[treePath] = append(tsMap[treePath], route)\n \t\t}\n+\n+\t\tapp.treeStack[method] = tsMap\n \t}\n \n \t// reset the flag and return\n", "test_patch": "diff --git a/router_test.go b/router_test.go\nindex 6ad70ccbc7..9cbaa31ef0 100644\n--- a/router_test.go\n+++ b/router_test.go\n@@ -1454,6 +1454,20 @@ func registerDummyRoutes(app *App) {\n \t}\n }\n \n+// go test -v -run=^$ -bench=Benchmark_App_RebuildTree -benchmem -count=4\n+func Benchmark_App_RebuildTree(b *testing.B) {\n+\tapp := New()\n+\tregisterDummyRoutes(app)\n+\n+\tb.ReportAllocs()\n+\tb.ResetTimer()\n+\n+\tfor b.Loop() {\n+\t\tapp.routesRefreshed = true\n+\t\tapp.RebuildTree()\n+\t}\n+}\n+\n // go test -v -run=^$ -bench=Benchmark_App_MethodNotAllowed -benchmem -count=4\n func Benchmark_App_MethodNotAllowed(b *testing.B) {\n \tapp := New()\n"}
