{"org": "go-gitea", "repo": "gitea", "number": 34154, "state": "closed", "title": "Refactor Git Attribute & performance optimization", "body": "This PR moved git attributes related code to `modules/git/attribute` sub package and moved language stats related code to `modules/git/languagestats` sub package to make it easier to maintain.\r\n\r\nAnd it also introduced a performance improvement which use the `git check-attr --source` which can be run in a bare git repository so that we don't need to create a git index file. The new parameter need a git version >= 2.40 . If git version less than 2.40, it will fall back to previous implementation.\r\n\r\nBefore:\r\n```\r\ngit-run duration=1.2684s func.caller=git.(*Repository).readTreeToIndex git.command=\"/opt/homebrew/bin/git ...global... read-tree 70187f7727d4ddd8282b576ece93ca233e88b19e\"\r\ngit-run duration=0.1633s func.caller=git.(*CheckAttributeReader).Run git.command=\"/opt/homebrew/bin/git ...global... check-attr --stdin -z --cached linguist-vendored linguist-generated linguist-documentation linguist-detectable linguist-language gitlab-language\"\r\n```\r\n\r\nAfter:\r\n```\r\ngit-run duration=0.1271s func.caller=attribute.(*BatchChecker).run git.command=\"/opt/homebrew/bin/git ...global... check-attr -z --source 70187f7727d4ddd8282b576ece93ca233e88b19e linguist-vendored linguist-generated linguist-language gitlab-language --stdin\"\r\n```", "url": "https://api.github.com/repos/go-gitea/gitea/pulls/34154", "id": 2447002148, "node_id": "PR_kwDOBFIx286R2kok", "html_url": "https://github.com/go-gitea/gitea/pull/34154", "diff_url": "https://github.com/go-gitea/gitea/pull/34154.diff", "patch_url": "https://github.com/go-gitea/gitea/pull/34154.patch", "issue_url": "https://api.github.com/repos/go-gitea/gitea/issues/34154", "created_at": "2025-04-08T21:36:11+00:00", "updated_at": "2025-07-10T15:46:47+00:00", "closed_at": "2025-04-11T13:41:29+00:00", "merged_at": "2025-04-11T13:41:29+00:00", "merge_commit_sha": "ae0af8ea5b2de99a49add2b7f7b76dde62a8a617", "labels": ["lgtm/done", "type/refactoring", "performance/speed", "modifies/go"], "draft": false, "commits_url": "https://api.github.com/repos/go-gitea/gitea/pulls/34154/commits", "review_comments_url": "https://api.github.com/repos/go-gitea/gitea/pulls/34154/comments", "review_comment_url": "https://api.github.com/repos/go-gitea/gitea/pulls/comments{/number}", "comments_url": "https://api.github.com/repos/go-gitea/gitea/issues/34154/comments", "base": {"label": "go-gitea:main", "ref": "main", "sha": "d725b78824a6e83bc5f6db3c83f742810241d1ee", "user": {"login": "go-gitea", "id": 12724356, "node_id": "MDEyOk9yZ2FuaXphdGlvbjEyNzI0MzU2", "avatar_url": "https://avatars.githubusercontent.com/u/12724356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/go-gitea", "html_url": "https://github.com/go-gitea", "followers_url": "https://api.github.com/users/go-gitea/followers", "following_url": "https://api.github.com/users/go-gitea/following{/other_user}", "gists_url": "https://api.github.com/users/go-gitea/gists{/gist_id}", "starred_url": "https://api.github.com/users/go-gitea/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/go-gitea/subscriptions", "organizations_url": "https://api.github.com/users/go-gitea/orgs", "repos_url": "https://api.github.com/users/go-gitea/repos", "events_url": "https://api.github.com/users/go-gitea/events{/privacy}", "received_events_url": "https://api.github.com/users/go-gitea/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "repo": {"id": 72495579, "node_id": "MDEwOlJlcG9zaXRvcnk3MjQ5NTU3OQ==", "name": "gitea", "full_name": "go-gitea/gitea", "private": false, "owner": {"login": "go-gitea", "id": 12724356, "node_id": "MDEyOk9yZ2FuaXphdGlvbjEyNzI0MzU2", "avatar_url": "https://avatars.githubusercontent.com/u/12724356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/go-gitea", "html_url": "https://github.com/go-gitea", "followers_url": "https://api.github.com/users/go-gitea/followers", "following_url": "https://api.github.com/users/go-gitea/following{/other_user}", "gists_url": "https://api.github.com/users/go-gitea/gists{/gist_id}", "starred_url": "https://api.github.com/users/go-gitea/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/go-gitea/subscriptions", "organizations_url": "https://api.github.com/users/go-gitea/orgs", "repos_url": "https://api.github.com/users/go-gitea/repos", "events_url": "https://api.github.com/users/go-gitea/events{/privacy}", "received_events_url": "https://api.github.com/users/go-gitea/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "html_url": "https://github.com/go-gitea/gitea", "description": "Git with a cup of tea! Painless self-hosted all-in-one software development service, including Git hosting, code review, team collaboration, package registry and CI/CD", "fork": false, "url": "https://api.github.com/repos/go-gitea/gitea", "forks_url": "https://api.github.com/repos/go-gitea/gitea/forks", "keys_url": "https://api.github.com/repos/go-gitea/gitea/keys{/key_id}", "collaborators_url": "https://api.github.com/repos/go-gitea/gitea/collaborators{/collaborator}", "teams_url": "https://api.github.com/repos/go-gitea/gitea/teams", "hooks_url": "https://api.github.com/repos/go-gitea/gitea/hooks", "issue_events_url": "https://api.github.com/repos/go-gitea/gitea/issues/events{/number}", "events_url": "https://api.github.com/repos/go-gitea/gitea/events", "assignees_url": "https://api.github.com/repos/go-gitea/gitea/assignees{/user}", "branches_url": "https://api.github.com/repos/go-gitea/gitea/branches{/branch}", "tags_url": "https://api.github.com/repos/go-gitea/gitea/tags", "blobs_url": "https://api.github.com/repos/go-gitea/gitea/git/blobs{/sha}", "git_tags_url": "https://api.github.com/repos/go-gitea/gitea/git/tags{/sha}", "git_refs_url": "https://api.github.com/repos/go-gitea/gitea/git/refs{/sha}", "trees_url": "https://api.github.com/repos/go-gitea/gitea/git/trees{/sha}", "statuses_url": "https://api.github.com/repos/go-gitea/gitea/statuses/{sha}", "languages_url": "https://api.github.com/repos/go-gitea/gitea/languages", "stargazers_url": "https://api.github.com/repos/go-gitea/gitea/stargazers", "contributors_url": "https://api.github.com/repos/go-gitea/gitea/contributors", "subscribers_url": "https://api.github.com/repos/go-gitea/gitea/subscribers", "subscription_url": "https://api.github.com/repos/go-gitea/gitea/subscription", "commits_url": "https://api.github.com/repos/go-gitea/gitea/commits{/sha}", "git_commits_url": "https://api.github.com/repos/go-gitea/gitea/git/commits{/sha}", "comments_url": "https://api.github.com/repos/go-gitea/gitea/comments{/number}", "issue_comment_url": "https://api.github.com/repos/go-gitea/gitea/issues/comments{/number}", "contents_url": "https://api.github.com/repos/go-gitea/gitea/contents/{+path}", "compare_url": "https://api.github.com/repos/go-gitea/gitea/compare/{base}...{head}", "merges_url": "https://api.github.com/repos/go-gitea/gitea/merges", "archive_url": "https://api.github.com/repos/go-gitea/gitea/{archive_format}{/ref}", "downloads_url": "https://api.github.com/repos/go-gitea/gitea/downloads", "issues_url": "https://api.github.com/repos/go-gitea/gitea/issues{/number}", "pulls_url": "https://api.github.com/repos/go-gitea/gitea/pulls{/number}", "milestones_url": "https://api.github.com/repos/go-gitea/gitea/milestones{/number}", "notifications_url": "https://api.github.com/repos/go-gitea/gitea/notifications{?since,all,participating}", "labels_url": "https://api.github.com/repos/go-gitea/gitea/labels{/name}", "releases_url": "https://api.github.com/repos/go-gitea/gitea/releases{/id}", "deployments_url": "https://api.github.com/repos/go-gitea/gitea/deployments", "created_at": "2016-11-01T02:13:26Z", "updated_at": "2026-01-07T07:02:30Z", "pushed_at": "2026-01-07T06:08:59Z", "git_url": "git://github.com/go-gitea/gitea.git", "ssh_url": "git@github.com:go-gitea/gitea.git", "clone_url": "https://github.com/go-gitea/gitea.git", "svn_url": "https://github.com/go-gitea/gitea", "homepage": "https://gitea.com", "size": 322636, "stargazers_count": 52973, "watchers_count": 52973, "language": "Go", "has_issues": true, "has_projects": false, "has_downloads": true, "has_wiki": false, "has_pages": false, "has_discussions": false, "forks_count": 6304, "mirror_url": null, "archived": false, "disabled": false, "open_issues_count": 2885, "license": {"key": "mit", "name": "MIT License", "spdx_id": "MIT", "url": "https://api.github.com/licenses/mit", "node_id": "MDc6TGljZW5zZTEz"}, "allow_forking": true, "is_template": false, "web_commit_signoff_required": true, "topics": ["bitbucket", "cicd", "devops", "docker-registry-v2", "git", "git-gui", "git-server", "gitea", "github", "github-actions", "gitlab", "go", "golang", "hacktoberfest", "maven-server", "npm-registry", "vue"], "visibility": "public", "forks": 6304, "open_issues": 2885, "watchers": 52973, "default_branch": "main"}}, "commits": [{"sha": "9321c271c0a63567c0001276f94614981709ca2f", "parents": ["d725b78824a6e83bc5f6db3c83f742810241d1ee"], "message": "Refactor Attribute"}, {"sha": "44288608a6a2f58ac2c0e5823a2f4dfe9d19172d", "parents": ["9321c271c0a63567c0001276f94614981709ca2f"], "message": "some improvements"}, {"sha": "419b959dfe0791087a129a2b26af08bc93ad1d44", "parents": ["44288608a6a2f58ac2c0e5823a2f4dfe9d19172d"], "message": "Support run attr check on bare repository if git version >= 2.40"}, {"sha": "ed1601a196605b0f20147cc35696b1c3cb5a92a0", "parents": ["419b959dfe0791087a129a2b26af08bc93ad1d44"], "message": "Fix builg gogit"}, {"sha": "0fc7704a301045c797c7dc716224e938da55c8e3", "parents": ["ed1601a196605b0f20147cc35696b1c3cb5a92a0"], "message": "Fix lint"}, {"sha": "6da7152bc1cd5df8bc1954d60462d5fdaf84e6e1", "parents": ["0fc7704a301045c797c7dc716224e938da55c8e3"], "message": "Fix bug"}, {"sha": "2a3571de281b62645e734b88f5774901397e4886", "parents": ["6da7152bc1cd5df8bc1954d60462d5fdaf84e6e1"], "message": "Fix bug"}, {"sha": "33b1cebdd63c66c0077e306a01dcc5760bf683e1", "parents": ["2a3571de281b62645e734b88f5774901397e4886"], "message": "Fix bug"}, {"sha": "1f473af6e1173de266cd0621252a838194f4531a", "parents": ["33b1cebdd63c66c0077e306a01dcc5760bf683e1"], "message": "Fix bug"}, {"sha": "1c4821239564f13c17f7d8f037ce4baef2c06a5b", "parents": ["1f473af6e1173de266cd0621252a838194f4531a"], "message": "Fix test"}, {"sha": "f98e2c7ff2a51e18efb25e197037a08ef9f63a80", "parents": ["1c4821239564f13c17f7d8f037ce4baef2c06a5b"], "message": "Fix lint"}, {"sha": "bdfb061041f94ed9e94aae35bd53fc2ad27d4a99", "parents": ["f98e2c7ff2a51e18efb25e197037a08ef9f63a80"], "message": "Correct tests repository under git"}, {"sha": "2d8c956ddf71ff816fa98600f33f41ab198397be", "parents": ["bdfb061041f94ed9e94aae35bd53fc2ad27d4a99"], "message": "Add tests"}, {"sha": "d17e7ad7697705ab703f5d6af7721d27decfd4ae", "parents": ["2d8c956ddf71ff816fa98600f33f41ab198397be"], "message": "Fix lint"}, {"sha": "a70ef5f701cb464e14779c133e80fa0211384d15", "parents": ["d17e7ad7697705ab703f5d6af7721d27decfd4ae"], "message": "Add trace code back"}, {"sha": "ed37f3a6600e06d63f42d66a3f86c47ab8bd0acc", "parents": ["a70ef5f701cb464e14779c133e80fa0211384d15"], "message": "Remove unnecessary code"}, {"sha": "9db67492f35f01e3e2267e19d7c441828745b2f5", "parents": ["ed37f3a6600e06d63f42d66a3f86c47ab8bd0acc"], "message": "Some improvements"}, {"sha": "d6f138b42b04d2b4aba22497eb0eafe16aa95650", "parents": ["9db67492f35f01e3e2267e19d7c441828745b2f5"], "message": "fine tune"}, {"sha": "2391070f1ef998fc411534f102513846eaf0d3eb", "parents": ["d6f138b42b04d2b4aba22497eb0eafe16aa95650"], "message": "add comment"}, {"sha": "1a522442d9e42491f4908ab640cd82431f35fca6", "parents": ["9db67492f35f01e3e2267e19d7c441828745b2f5"], "message": "merge two functions call as one"}, {"sha": "ad4af2dc03b5330531dc4412c9c1375f8ea32b5a", "parents": ["1a522442d9e42491f4908ab640cd82431f35fca6", "2391070f1ef998fc411534f102513846eaf0d3eb"], "message": "Merge branch 'lunny/attribute' of github.com:lunny/gitea into lunny/attribute"}, {"sha": "1d333296eb7c809eecf55b1c42dce586a044a55b", "parents": ["ad4af2dc03b5330531dc4412c9c1375f8ea32b5a"], "message": "don't make Attributes expose internal map"}, {"sha": "a0cfb36717ccd165e435d2d182152bc62094a89d", "parents": ["1d333296eb7c809eecf55b1c42dce586a044a55b"], "message": "improve test and comment"}, {"sha": "fca3bcf0d9a6adc37d553530bea8a3b0b278b5bf", "parents": ["a0cfb36717ccd165e435d2d182152bc62094a89d"], "message": "Update routers/web/repo/view_file.go\n\nCo-authored-by: yp05327 <576951401@qq.com>"}], "resolved_issues": [{"org": "go-gitea", "repo": "gitea", "number": -1, "state": "unknown", "title": "Refactor Git Attribute & performance optimization", "body": "This PR moved git attributes related code to `modules/git/attribute` sub package and moved language stats related code to `modules/git/languagestats` sub package to make it easier to maintain.\r\n\r\nAnd it also introduced a performance improvement which use the `git check-attr --source` which can be run in a bare git repository so that we don't need to create a git index file. The new parameter need a git version >= 2.40 . If git version less than 2.40, it will fall back to previous implementation.\r\n\r\nBefore:\r\n```\r\ngit-run duration=1.2684s func.caller=git.(*Repository).readTreeToIndex git.command=\"/opt/homebrew/bin/git ...global... read-tree 70187f7727d4ddd8282b576ece93ca233e88b19e\"\r\ngit-run duration=0.1633s func.caller=git.(*CheckAttributeReader).Run git.command=\"/opt/homebrew/bin/git ...global... check-attr --stdin -z --cached linguist-vendored linguist-generated linguist-documentation linguist-detectable linguist-language gitlab-language\"\r\n```\r\n\r\nAfter:\r\n```\r\ngit-run duration=0.1271s func.caller=attribute.(*BatchChecker).run git.command=\"/opt/homebrew/bin/git ...global... check-attr -z --source 70187f7727d4ddd8282b576ece93ca233e88b19e linguist-vendored linguist-generated linguist-language gitlab-language --stdin\"\r\n```"}], "fix_patch": "diff --git a/modules/git/attribute.go b/modules/git/attribute.go\ndeleted file mode 100644\nindex 4dfa510369086..0000000000000\n--- a/modules/git/attribute.go\n+++ /dev/null\n@@ -1,35 +0,0 @@\n-// Copyright 2024 The Gitea Authors. All rights reserved.\n-// SPDX-License-Identifier: MIT\n-\n-package git\n-\n-import (\n-\t\"code.gitea.io/gitea/modules/optional\"\n-)\n-\n-const (\n-\tAttributeLinguistVendored      = \"linguist-vendored\"\n-\tAttributeLinguistGenerated     = \"linguist-generated\"\n-\tAttributeLinguistDocumentation = \"linguist-documentation\"\n-\tAttributeLinguistDetectable    = \"linguist-detectable\"\n-\tAttributeLinguistLanguage      = \"linguist-language\"\n-\tAttributeGitlabLanguage        = \"gitlab-language\"\n-)\n-\n-// true if \"set\"/\"true\", false if \"unset\"/\"false\", none otherwise\n-func AttributeToBool(attr map[string]string, name string) optional.Option[bool] {\n-\tswitch attr[name] {\n-\tcase \"set\", \"true\":\n-\t\treturn optional.Some(true)\n-\tcase \"unset\", \"false\":\n-\t\treturn optional.Some(false)\n-\t}\n-\treturn optional.None[bool]()\n-}\n-\n-func AttributeToString(attr map[string]string, name string) optional.Option[string] {\n-\tif value, has := attr[name]; has && value != \"unspecified\" {\n-\t\treturn optional.Some(value)\n-\t}\n-\treturn optional.None[string]()\n-}\ndiff --git a/modules/git/attribute/attribute.go b/modules/git/attribute/attribute.go\nnew file mode 100644\nindex 0000000000000..adf323ef41c05\n--- /dev/null\n+++ b/modules/git/attribute/attribute.go\n@@ -0,0 +1,114 @@\n+// Copyright 2025 The Gitea Authors. All rights reserved.\n+// SPDX-License-Identifier: MIT\n+\n+package attribute\n+\n+import (\n+\t\"strings\"\n+\n+\t\"code.gitea.io/gitea/modules/optional\"\n+)\n+\n+type Attribute string\n+\n+const (\n+\tLinguistVendored      = \"linguist-vendored\"\n+\tLinguistGenerated     = \"linguist-generated\"\n+\tLinguistDocumentation = \"linguist-documentation\"\n+\tLinguistDetectable    = \"linguist-detectable\"\n+\tLinguistLanguage      = \"linguist-language\"\n+\tGitlabLanguage        = \"gitlab-language\"\n+\tLockable              = \"lockable\"\n+\tFilter                = \"filter\"\n+)\n+\n+var LinguistAttributes = []string{\n+\tLinguistVendored,\n+\tLinguistGenerated,\n+\tLinguistDocumentation,\n+\tLinguistDetectable,\n+\tLinguistLanguage,\n+\tGitlabLanguage,\n+}\n+\n+func (a Attribute) IsUnspecified() bool {\n+\treturn a == \"\" || a == \"unspecified\"\n+}\n+\n+func (a Attribute) ToString() optional.Option[string] {\n+\tif !a.IsUnspecified() {\n+\t\treturn optional.Some(string(a))\n+\t}\n+\treturn optional.None[string]()\n+}\n+\n+// ToBool converts the attribute value to optional boolean: true if \"set\"/\"true\", false if \"unset\"/\"false\", none otherwise\n+func (a Attribute) ToBool() optional.Option[bool] {\n+\tswitch a {\n+\tcase \"set\", \"true\":\n+\t\treturn optional.Some(true)\n+\tcase \"unset\", \"false\":\n+\t\treturn optional.Some(false)\n+\t}\n+\treturn optional.None[bool]()\n+}\n+\n+type Attributes struct {\n+\tm map[string]Attribute\n+}\n+\n+func NewAttributes() *Attributes {\n+\treturn &Attributes{m: make(map[string]Attribute)}\n+}\n+\n+func (attrs *Attributes) Get(name string) Attribute {\n+\tif value, has := attrs.m[name]; has {\n+\t\treturn value\n+\t}\n+\treturn \"\"\n+}\n+\n+func (attrs *Attributes) GetVendored() optional.Option[bool] {\n+\treturn attrs.Get(LinguistVendored).ToBool()\n+}\n+\n+func (attrs *Attributes) GetGenerated() optional.Option[bool] {\n+\treturn attrs.Get(LinguistGenerated).ToBool()\n+}\n+\n+func (attrs *Attributes) GetDocumentation() optional.Option[bool] {\n+\treturn attrs.Get(LinguistDocumentation).ToBool()\n+}\n+\n+func (attrs *Attributes) GetDetectable() optional.Option[bool] {\n+\treturn attrs.Get(LinguistDetectable).ToBool()\n+}\n+\n+func (attrs *Attributes) GetLinguistLanguage() optional.Option[string] {\n+\treturn attrs.Get(LinguistLanguage).ToString()\n+}\n+\n+func (attrs *Attributes) GetGitlabLanguage() optional.Option[string] {\n+\tattrStr := attrs.Get(GitlabLanguage).ToString()\n+\tif attrStr.Has() {\n+\t\traw := attrStr.Value()\n+\t\t// gitlab-language may have additional parameters after the language\n+\t\t// ignore them and just use the main language\n+\t\t// https://docs.gitlab.com/ee/user/project/highlighting.html#override-syntax-highlighting-for-a-file-type\n+\t\tif idx := strings.IndexByte(raw, '?'); idx >= 0 {\n+\t\t\treturn optional.Some(raw[:idx])\n+\t\t}\n+\t}\n+\treturn attrStr\n+}\n+\n+func (attrs *Attributes) GetLanguage() optional.Option[string] {\n+\t// prefer linguist-language over gitlab-language\n+\t// if linguist-language is not set, use gitlab-language\n+\t// if both are not set, return none\n+\tlanguage := attrs.GetLinguistLanguage()\n+\tif language.Value() == \"\" {\n+\t\tlanguage = attrs.GetGitlabLanguage()\n+\t}\n+\treturn language\n+}\ndiff --git a/modules/git/attribute/batch.go b/modules/git/attribute/batch.go\nnew file mode 100644\nindex 0000000000000..4e31fda5753cd\n--- /dev/null\n+++ b/modules/git/attribute/batch.go\n@@ -0,0 +1,216 @@\n+// Copyright 2019 The Gitea Authors. All rights reserved.\n+// SPDX-License-Identifier: MIT\n+\n+package attribute\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"time\"\n+\n+\t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/log\"\n+)\n+\n+// BatchChecker provides a reader for check-attribute content that can be long running\n+type BatchChecker struct {\n+\tattributesNum int\n+\trepo          *git.Repository\n+\tstdinWriter   *os.File\n+\tstdOut        *nulSeparatedAttributeWriter\n+\tctx           context.Context\n+\tcancel        context.CancelFunc\n+\tcmd           *git.Command\n+}\n+\n+// NewBatchChecker creates a check attribute reader for the current repository and provided commit ID\n+// If treeish is empty, then it will use current working directory, otherwise it will use the provided treeish on the bare repo\n+func NewBatchChecker(repo *git.Repository, treeish string, attributes []string) (checker *BatchChecker, returnedErr error) {\n+\tctx, cancel := context.WithCancel(repo.Ctx)\n+\tdefer func() {\n+\t\tif returnedErr != nil {\n+\t\t\tcancel()\n+\t\t}\n+\t}()\n+\n+\tcmd, envs, cleanup, err := checkAttrCommand(repo, treeish, nil, attributes)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer func() {\n+\t\tif returnedErr != nil {\n+\t\t\tcleanup()\n+\t\t}\n+\t}()\n+\n+\tcmd.AddArguments(\"--stdin\")\n+\n+\tchecker = &BatchChecker{\n+\t\tattributesNum: len(attributes),\n+\t\trepo:          repo,\n+\t\tctx:           ctx,\n+\t\tcmd:           cmd,\n+\t\tcancel: func() {\n+\t\t\tcancel()\n+\t\t\tcleanup()\n+\t\t},\n+\t}\n+\n+\tstdinReader, stdinWriter, err := os.Pipe()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tchecker.stdinWriter = stdinWriter\n+\n+\tlw := new(nulSeparatedAttributeWriter)\n+\tlw.attributes = make(chan attributeTriple, len(attributes))\n+\tlw.closed = make(chan struct{})\n+\tchecker.stdOut = lw\n+\n+\tgo func() {\n+\t\tdefer func() {\n+\t\t\t_ = stdinReader.Close()\n+\t\t\t_ = lw.Close()\n+\t\t}()\n+\t\tstdErr := new(bytes.Buffer)\n+\t\terr := cmd.Run(ctx, &git.RunOpts{\n+\t\t\tEnv:    envs,\n+\t\t\tDir:    repo.Path,\n+\t\t\tStdin:  stdinReader,\n+\t\t\tStdout: lw,\n+\t\t\tStderr: stdErr,\n+\t\t})\n+\n+\t\tif err != nil && !git.IsErrCanceledOrKilled(err) {\n+\t\t\tlog.Error(\"Attribute checker for commit %s exits with error: %v\", treeish, err)\n+\t\t}\n+\t\tchecker.cancel()\n+\t}()\n+\n+\treturn checker, nil\n+}\n+\n+// CheckPath check attr for given path\n+func (c *BatchChecker) CheckPath(path string) (rs *Attributes, err error) {\n+\tdefer func() {\n+\t\tif err != nil && err != c.ctx.Err() {\n+\t\t\tlog.Error(\"Unexpected error when checking path %s in %s, error: %v\", path, filepath.Base(c.repo.Path), err)\n+\t\t}\n+\t}()\n+\n+\tselect {\n+\tcase <-c.ctx.Done():\n+\t\treturn nil, c.ctx.Err()\n+\tdefault:\n+\t}\n+\n+\tif _, err = c.stdinWriter.Write([]byte(path + \"\\x00\")); err != nil {\n+\t\tdefer c.Close()\n+\t\treturn nil, err\n+\t}\n+\n+\treportTimeout := func() error {\n+\t\tstdOutClosed := false\n+\t\tselect {\n+\t\tcase <-c.stdOut.closed:\n+\t\t\tstdOutClosed = true\n+\t\tdefault:\n+\t\t}\n+\t\tdebugMsg := fmt.Sprintf(\"check path %q in repo %q\", path, filepath.Base(c.repo.Path))\n+\t\tdebugMsg += fmt.Sprintf(\", stdOut: tmp=%q, pos=%d, closed=%v\", string(c.stdOut.tmp), c.stdOut.pos, stdOutClosed)\n+\t\tif c.cmd != nil {\n+\t\t\tdebugMsg += fmt.Sprintf(\", process state: %q\", c.cmd.ProcessState())\n+\t\t}\n+\t\t_ = c.Close()\n+\t\treturn fmt.Errorf(\"CheckPath timeout: %s\", debugMsg)\n+\t}\n+\n+\trs = NewAttributes()\n+\tfor i := 0; i < c.attributesNum; i++ {\n+\t\tselect {\n+\t\tcase <-time.After(5 * time.Second):\n+\t\t\t// there is no \"hang\" problem now. This code is just used to catch other potential problems.\n+\t\t\treturn nil, reportTimeout()\n+\t\tcase attr, ok := <-c.stdOut.ReadAttribute():\n+\t\t\tif !ok {\n+\t\t\t\treturn nil, c.ctx.Err()\n+\t\t\t}\n+\t\t\trs.m[attr.Attribute] = Attribute(attr.Value)\n+\t\tcase <-c.ctx.Done():\n+\t\t\treturn nil, c.ctx.Err()\n+\t\t}\n+\t}\n+\treturn rs, nil\n+}\n+\n+func (c *BatchChecker) Close() error {\n+\tc.cancel()\n+\terr := c.stdinWriter.Close()\n+\treturn err\n+}\n+\n+type attributeTriple struct {\n+\tFilename  string\n+\tAttribute string\n+\tValue     string\n+}\n+\n+type nulSeparatedAttributeWriter struct {\n+\ttmp        []byte\n+\tattributes chan attributeTriple\n+\tclosed     chan struct{}\n+\tworking    attributeTriple\n+\tpos        int\n+}\n+\n+func (wr *nulSeparatedAttributeWriter) Write(p []byte) (n int, err error) {\n+\tl, read := len(p), 0\n+\n+\tnulIdx := bytes.IndexByte(p, '\\x00')\n+\tfor nulIdx >= 0 {\n+\t\twr.tmp = append(wr.tmp, p[:nulIdx]...)\n+\t\tswitch wr.pos {\n+\t\tcase 0:\n+\t\t\twr.working = attributeTriple{\n+\t\t\t\tFilename: string(wr.tmp),\n+\t\t\t}\n+\t\tcase 1:\n+\t\t\twr.working.Attribute = string(wr.tmp)\n+\t\tcase 2:\n+\t\t\twr.working.Value = string(wr.tmp)\n+\t\t}\n+\t\twr.tmp = wr.tmp[:0]\n+\t\twr.pos++\n+\t\tif wr.pos > 2 {\n+\t\t\twr.attributes <- wr.working\n+\t\t\twr.pos = 0\n+\t\t}\n+\t\tread += nulIdx + 1\n+\t\tif l > read {\n+\t\t\tp = p[nulIdx+1:]\n+\t\t\tnulIdx = bytes.IndexByte(p, '\\x00')\n+\t\t} else {\n+\t\t\treturn l, nil\n+\t\t}\n+\t}\n+\twr.tmp = append(wr.tmp, p...)\n+\treturn l, nil\n+}\n+\n+func (wr *nulSeparatedAttributeWriter) ReadAttribute() <-chan attributeTriple {\n+\treturn wr.attributes\n+}\n+\n+func (wr *nulSeparatedAttributeWriter) Close() error {\n+\tselect {\n+\tcase <-wr.closed:\n+\t\treturn nil\n+\tdefault:\n+\t}\n+\tclose(wr.attributes)\n+\tclose(wr.closed)\n+\treturn nil\n+}\ndiff --git a/modules/git/attribute/checker.go b/modules/git/attribute/checker.go\nnew file mode 100644\nindex 0000000000000..c17006a15407b\n--- /dev/null\n+++ b/modules/git/attribute/checker.go\n@@ -0,0 +1,96 @@\n+// Copyright 2025 The Gitea Authors. All rights reserved.\n+// SPDX-License-Identifier: MIT\n+\n+package attribute\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"os\"\n+\n+\t\"code.gitea.io/gitea/modules/git\"\n+)\n+\n+func checkAttrCommand(gitRepo *git.Repository, treeish string, filenames, attributes []string) (*git.Command, []string, func(), error) {\n+\tcancel := func() {}\n+\tenvs := []string{\"GIT_FLUSH=1\"}\n+\tcmd := git.NewCommand(\"check-attr\", \"-z\")\n+\tif len(attributes) == 0 {\n+\t\tcmd.AddArguments(\"--all\")\n+\t}\n+\n+\t// there is treeish, read from bare repo or temp index created by \"read-tree\"\n+\tif treeish != \"\" {\n+\t\tif git.DefaultFeatures().SupportCheckAttrOnBare {\n+\t\t\tcmd.AddArguments(\"--source\")\n+\t\t\tcmd.AddDynamicArguments(treeish)\n+\t\t} else {\n+\t\t\tindexFilename, worktree, deleteTemporaryFile, err := gitRepo.ReadTreeToTemporaryIndex(treeish)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, nil, nil, err\n+\t\t\t}\n+\n+\t\t\tcmd.AddArguments(\"--cached\")\n+\t\t\tenvs = append(envs,\n+\t\t\t\t\"GIT_INDEX_FILE=\"+indexFilename,\n+\t\t\t\t\"GIT_WORK_TREE=\"+worktree,\n+\t\t\t)\n+\t\t\tcancel = deleteTemporaryFile\n+\t\t}\n+\t} // else: no treeish, assume it is a not a bare repo, read from working directory\n+\n+\tcmd.AddDynamicArguments(attributes...)\n+\tif len(filenames) > 0 {\n+\t\tcmd.AddDashesAndList(filenames...)\n+\t}\n+\treturn cmd, envs, cancel, nil\n+}\n+\n+type CheckAttributeOpts struct {\n+\tFilenames  []string\n+\tAttributes []string\n+}\n+\n+// CheckAttributes return the attributes of the given filenames and attributes in the given treeish.\n+// If treeish is empty, then it will use current working directory, otherwise it will use the provided treeish on the bare repo\n+func CheckAttributes(ctx context.Context, gitRepo *git.Repository, treeish string, opts CheckAttributeOpts) (map[string]*Attributes, error) {\n+\tcmd, envs, cancel, err := checkAttrCommand(gitRepo, treeish, opts.Filenames, opts.Attributes)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer cancel()\n+\n+\tstdOut := new(bytes.Buffer)\n+\tstdErr := new(bytes.Buffer)\n+\n+\tif err := cmd.Run(ctx, &git.RunOpts{\n+\t\tEnv:    append(os.Environ(), envs...),\n+\t\tDir:    gitRepo.Path,\n+\t\tStdout: stdOut,\n+\t\tStderr: stdErr,\n+\t}); err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to run check-attr: %w\\n%s\\n%s\", err, stdOut.String(), stdErr.String())\n+\t}\n+\n+\tfields := bytes.Split(stdOut.Bytes(), []byte{'\\000'})\n+\tif len(fields)%3 != 1 {\n+\t\treturn nil, errors.New(\"wrong number of fields in return from check-attr\")\n+\t}\n+\n+\tattributesMap := make(map[string]*Attributes)\n+\tfor i := 0; i < (len(fields) / 3); i++ {\n+\t\tfilename := string(fields[3*i])\n+\t\tattribute := string(fields[3*i+1])\n+\t\tinfo := string(fields[3*i+2])\n+\t\tattribute2info, ok := attributesMap[filename]\n+\t\tif !ok {\n+\t\t\tattribute2info = NewAttributes()\n+\t\t\tattributesMap[filename] = attribute2info\n+\t\t}\n+\t\tattribute2info.m[attribute] = Attribute(info)\n+\t}\n+\n+\treturn attributesMap, nil\n+}\ndiff --git a/modules/git/command.go b/modules/git/command.go\nindex f449f1ff0e6a8..eaaa4969d0bb1 100644\n--- a/modules/git/command.go\n+++ b/modules/git/command.go\n@@ -80,6 +80,13 @@ func (c *Command) LogString() string {\n \treturn strings.Join(a, \" \")\n }\n \n+func (c *Command) ProcessState() string {\n+\tif c.cmd == nil {\n+\t\treturn \"\"\n+\t}\n+\treturn c.cmd.ProcessState.String()\n+}\n+\n // NewCommand creates and returns a new Git Command based on given command and arguments.\n // Each argument should be safe to be trusted. User-provided arguments should be passed to AddDynamicArguments instead.\n func NewCommand(args ...internal.CmdArg) *Command {\ndiff --git a/modules/git/git.go b/modules/git/git.go\nindex 2b593910a2dc0..a2ffd6d289880 100644\n--- a/modules/git/git.go\n+++ b/modules/git/git.go\n@@ -30,6 +30,7 @@ type Features struct {\n \tSupportProcReceive     bool           // >= 2.29\n \tSupportHashSha256      bool           // >= 2.42, SHA-256 repositories no longer an ‘experimental curiosity’\n \tSupportedObjectFormats []ObjectFormat // sha1, sha256\n+\tSupportCheckAttrOnBare bool           // >= 2.40\n }\n \n var (\n@@ -77,6 +78,7 @@ func loadGitVersionFeatures() (*Features, error) {\n \tif features.SupportHashSha256 {\n \t\tfeatures.SupportedObjectFormats = append(features.SupportedObjectFormats, Sha256ObjectFormat)\n \t}\n+\tfeatures.SupportCheckAttrOnBare = features.CheckVersionAtLeast(\"2.40\")\n \treturn features, nil\n }\n \ndiff --git a/modules/git/repo_language_stats.go b/modules/git/languagestats/language_stats.go\nsimilarity index 59%\nrename from modules/git/repo_language_stats.go\nrename to modules/git/languagestats/language_stats.go\nindex 8551ea9d24e8b..a71284c3e446f 100644\n--- a/modules/git/repo_language_stats.go\n+++ b/modules/git/languagestats/language_stats.go\n@@ -1,13 +1,15 @@\n // Copyright 2020 The Gitea Authors. All rights reserved.\n // SPDX-License-Identifier: MIT\n \n-package git\n+package languagestats\n \n import (\n+\t\"context\"\n \t\"strings\"\n \t\"unicode\"\n \n-\t\"code.gitea.io/gitea/modules/optional\"\n+\t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/git/attribute\"\n )\n \n const (\n@@ -49,19 +51,15 @@ func mergeLanguageStats(stats map[string]int64) map[string]int64 {\n \treturn res\n }\n \n-func TryReadLanguageAttribute(attrs map[string]string) optional.Option[string] {\n-\tlanguage := AttributeToString(attrs, AttributeLinguistLanguage)\n-\tif language.Value() == \"\" {\n-\t\tlanguage = AttributeToString(attrs, AttributeGitlabLanguage)\n-\t\tif language.Has() {\n-\t\t\traw := language.Value()\n-\t\t\t// gitlab-language may have additional parameters after the language\n-\t\t\t// ignore them and just use the main language\n-\t\t\t// https://docs.gitlab.com/ee/user/project/highlighting.html#override-syntax-highlighting-for-a-file-type\n-\t\t\tif idx := strings.IndexByte(raw, '?'); idx >= 0 {\n-\t\t\t\tlanguage = optional.Some(raw[:idx])\n-\t\t\t}\n-\t\t}\n+// GetFileLanguage tries to get the (linguist) language of the file content\n+func GetFileLanguage(ctx context.Context, gitRepo *git.Repository, treeish, treePath string) (string, error) {\n+\tattributesMap, err := attribute.CheckAttributes(ctx, gitRepo, treeish, attribute.CheckAttributeOpts{\n+\t\tAttributes: []string{attribute.LinguistLanguage, attribute.GitlabLanguage},\n+\t\tFilenames:  []string{treePath},\n+\t})\n+\tif err != nil {\n+\t\treturn \"\", err\n \t}\n-\treturn language\n+\n+\treturn attributesMap[treePath].GetLanguage().Value(), nil\n }\ndiff --git a/modules/git/repo_language_stats_gogit.go b/modules/git/languagestats/language_stats_gogit.go\nsimilarity index 73%\nrename from modules/git/repo_language_stats_gogit.go\nrename to modules/git/languagestats/language_stats_gogit.go\nindex a34c03c781f55..418c05b15789f 100644\n--- a/modules/git/repo_language_stats_gogit.go\n+++ b/modules/git/languagestats/language_stats_gogit.go\n@@ -3,13 +3,15 @@\n \n //go:build gogit\n \n-package git\n+package languagestats\n \n import (\n \t\"bytes\"\n \t\"io\"\n \n \t\"code.gitea.io/gitea/modules/analyze\"\n+\tgit_module \"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/git/attribute\"\n \t\"code.gitea.io/gitea/modules/optional\"\n \n \t\"github.com/go-enry/go-enry/v2\"\n@@ -19,7 +21,7 @@ import (\n )\n \n // GetLanguageStats calculates language stats for git repository at specified commit\n-func (repo *Repository) GetLanguageStats(commitID string) (map[string]int64, error) {\n+func GetLanguageStats(repo *git_module.Repository, commitID string) (map[string]int64, error) {\n \tr, err := git.PlainOpen(repo.Path)\n \tif err != nil {\n \t\treturn nil, err\n@@ -40,8 +42,11 @@ func (repo *Repository) GetLanguageStats(commitID string) (map[string]int64, err\n \t\treturn nil, err\n \t}\n \n-\tchecker, deferable := repo.CheckAttributeReader(commitID)\n-\tdefer deferable()\n+\tchecker, err := attribute.NewBatchChecker(repo, commitID, attribute.LinguistAttributes)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer checker.Close()\n \n \t// sizes contains the current calculated size of all files by language\n \tsizes := make(map[string]int64)\n@@ -62,43 +67,41 @@ func (repo *Repository) GetLanguageStats(commitID string) (map[string]int64, err\n \t\tisDocumentation := optional.None[bool]()\n \t\tisDetectable := optional.None[bool]()\n \n-\t\tif checker != nil {\n-\t\t\tattrs, err := checker.CheckPath(f.Name)\n-\t\t\tif err == nil {\n-\t\t\t\tisVendored = AttributeToBool(attrs, AttributeLinguistVendored)\n-\t\t\t\tif isVendored.ValueOrDefault(false) {\n-\t\t\t\t\treturn nil\n-\t\t\t\t}\n-\n-\t\t\t\tisGenerated = AttributeToBool(attrs, AttributeLinguistGenerated)\n-\t\t\t\tif isGenerated.ValueOrDefault(false) {\n-\t\t\t\t\treturn nil\n-\t\t\t\t}\n+\t\tattrs, err := checker.CheckPath(f.Name)\n+\t\tif err == nil {\n+\t\t\tisVendored = attrs.GetVendored()\n+\t\t\tif isVendored.ValueOrDefault(false) {\n+\t\t\t\treturn nil\n+\t\t\t}\n \n-\t\t\t\tisDocumentation = AttributeToBool(attrs, AttributeLinguistDocumentation)\n-\t\t\t\tif isDocumentation.ValueOrDefault(false) {\n-\t\t\t\t\treturn nil\n-\t\t\t\t}\n+\t\t\tisGenerated = attrs.GetGenerated()\n+\t\t\tif isGenerated.ValueOrDefault(false) {\n+\t\t\t\treturn nil\n+\t\t\t}\n \n-\t\t\t\tisDetectable = AttributeToBool(attrs, AttributeLinguistDetectable)\n-\t\t\t\tif !isDetectable.ValueOrDefault(true) {\n-\t\t\t\t\treturn nil\n-\t\t\t\t}\n+\t\t\tisDocumentation = attrs.GetDocumentation()\n+\t\t\tif isDocumentation.ValueOrDefault(false) {\n+\t\t\t\treturn nil\n+\t\t\t}\n \n-\t\t\t\thasLanguage := TryReadLanguageAttribute(attrs)\n-\t\t\t\tif hasLanguage.Value() != \"\" {\n-\t\t\t\t\tlanguage := hasLanguage.Value()\n+\t\t\tisDetectable = attrs.GetDetectable()\n+\t\t\tif !isDetectable.ValueOrDefault(true) {\n+\t\t\t\treturn nil\n+\t\t\t}\n \n-\t\t\t\t\t// group languages, such as Pug -> HTML; SCSS -> CSS\n-\t\t\t\t\tgroup := enry.GetLanguageGroup(language)\n-\t\t\t\t\tif len(group) != 0 {\n-\t\t\t\t\t\tlanguage = group\n-\t\t\t\t\t}\n+\t\t\thasLanguage := attrs.GetLanguage()\n+\t\t\tif hasLanguage.Value() != \"\" {\n+\t\t\t\tlanguage := hasLanguage.Value()\n \n-\t\t\t\t\t// this language will always be added to the size\n-\t\t\t\t\tsizes[language] += f.Size\n-\t\t\t\t\treturn nil\n+\t\t\t\t// group languages, such as Pug -> HTML; SCSS -> CSS\n+\t\t\t\tgroup := enry.GetLanguageGroup(language)\n+\t\t\t\tif len(group) != 0 {\n+\t\t\t\t\tlanguage = group\n \t\t\t\t}\n+\n+\t\t\t\t// this language will always be added to the size\n+\t\t\t\tsizes[language] += f.Size\n+\t\t\t\treturn nil\n \t\t\t}\n \t\t}\n \ndiff --git a/modules/git/repo_language_stats_nogogit.go b/modules/git/languagestats/language_stats_nogogit.go\nsimilarity index 73%\nrename from modules/git/repo_language_stats_nogogit.go\nrename to modules/git/languagestats/language_stats_nogogit.go\nindex de7707bd6cd8b..34797263a603a 100644\n--- a/modules/git/repo_language_stats_nogogit.go\n+++ b/modules/git/languagestats/language_stats_nogogit.go\n@@ -3,13 +3,15 @@\n \n //go:build !gogit\n \n-package git\n+package languagestats\n \n import (\n \t\"bytes\"\n \t\"io\"\n \n \t\"code.gitea.io/gitea/modules/analyze\"\n+\t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/git/attribute\"\n \t\"code.gitea.io/gitea/modules/log\"\n \t\"code.gitea.io/gitea/modules/optional\"\n \n@@ -17,7 +19,7 @@ import (\n )\n \n // GetLanguageStats calculates language stats for git repository at specified commit\n-func (repo *Repository) GetLanguageStats(commitID string) (map[string]int64, error) {\n+func GetLanguageStats(repo *git.Repository, commitID string) (map[string]int64, error) {\n \t// We will feed the commit IDs in order into cat-file --batch, followed by blobs as necessary.\n \t// so let's create a batch stdin and stdout\n \tbatchStdinWriter, batchReader, cancel, err := repo.CatFileBatch(repo.Ctx)\n@@ -34,19 +36,19 @@ func (repo *Repository) GetLanguageStats(commitID string) (map[string]int64, err\n \tif err := writeID(commitID); err != nil {\n \t\treturn nil, err\n \t}\n-\tshaBytes, typ, size, err := ReadBatchLine(batchReader)\n+\tshaBytes, typ, size, err := git.ReadBatchLine(batchReader)\n \tif typ != \"commit\" {\n \t\tlog.Debug(\"Unable to get commit for: %s. Err: %v\", commitID, err)\n-\t\treturn nil, ErrNotExist{commitID, \"\"}\n+\t\treturn nil, git.ErrNotExist{ID: commitID}\n \t}\n \n-\tsha, err := NewIDFromString(string(shaBytes))\n+\tsha, err := git.NewIDFromString(string(shaBytes))\n \tif err != nil {\n \t\tlog.Debug(\"Unable to get commit for: %s. Err: %v\", commitID, err)\n-\t\treturn nil, ErrNotExist{commitID, \"\"}\n+\t\treturn nil, git.ErrNotExist{ID: commitID}\n \t}\n \n-\tcommit, err := CommitFromReader(repo, sha, io.LimitReader(batchReader, size))\n+\tcommit, err := git.CommitFromReader(repo, sha, io.LimitReader(batchReader, size))\n \tif err != nil {\n \t\tlog.Debug(\"Unable to get commit for: %s. Err: %v\", commitID, err)\n \t\treturn nil, err\n@@ -62,8 +64,11 @@ func (repo *Repository) GetLanguageStats(commitID string) (map[string]int64, err\n \t\treturn nil, err\n \t}\n \n-\tchecker, deferable := repo.CheckAttributeReader(commitID)\n-\tdefer deferable()\n+\tchecker, err := attribute.NewBatchChecker(repo, commitID, attribute.LinguistAttributes)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer checker.Close()\n \n \tcontentBuf := bytes.Buffer{}\n \tvar content []byte\n@@ -96,43 +101,36 @@ func (repo *Repository) GetLanguageStats(commitID string) (map[string]int64, err\n \t\tisDocumentation := optional.None[bool]()\n \t\tisDetectable := optional.None[bool]()\n \n-\t\tif checker != nil {\n-\t\t\tattrs, err := checker.CheckPath(f.Name())\n-\t\t\tif err == nil {\n-\t\t\t\tisVendored = AttributeToBool(attrs, AttributeLinguistVendored)\n-\t\t\t\tif isVendored.ValueOrDefault(false) {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\n-\t\t\t\tisGenerated = AttributeToBool(attrs, AttributeLinguistGenerated)\n-\t\t\t\tif isGenerated.ValueOrDefault(false) {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n+\t\tattrs, err := checker.CheckPath(f.Name())\n+\t\tif err == nil {\n+\t\t\tif isVendored = attrs.GetVendored(); isVendored.ValueOrDefault(false) {\n+\t\t\t\tcontinue\n+\t\t\t}\n \n-\t\t\t\tisDocumentation = AttributeToBool(attrs, AttributeLinguistDocumentation)\n-\t\t\t\tif isDocumentation.ValueOrDefault(false) {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n+\t\t\tif isGenerated = attrs.GetGenerated(); isGenerated.ValueOrDefault(false) {\n+\t\t\t\tcontinue\n+\t\t\t}\n \n-\t\t\t\tisDetectable = AttributeToBool(attrs, AttributeLinguistDetectable)\n-\t\t\t\tif !isDetectable.ValueOrDefault(true) {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n+\t\t\tif isDocumentation = attrs.GetDocumentation(); isDocumentation.ValueOrDefault(false) {\n+\t\t\t\tcontinue\n+\t\t\t}\n \n-\t\t\t\thasLanguage := TryReadLanguageAttribute(attrs)\n-\t\t\t\tif hasLanguage.Value() != \"\" {\n-\t\t\t\t\tlanguage := hasLanguage.Value()\n+\t\t\tif isDetectable = attrs.GetDetectable(); !isDetectable.ValueOrDefault(true) {\n+\t\t\t\tcontinue\n+\t\t\t}\n \n-\t\t\t\t\t// group languages, such as Pug -> HTML; SCSS -> CSS\n-\t\t\t\t\tgroup := enry.GetLanguageGroup(language)\n-\t\t\t\t\tif len(group) != 0 {\n-\t\t\t\t\t\tlanguage = group\n-\t\t\t\t\t}\n+\t\t\tif hasLanguage := attrs.GetLanguage(); hasLanguage.Value() != \"\" {\n+\t\t\t\tlanguage := hasLanguage.Value()\n \n-\t\t\t\t\t// this language will always be added to the size\n-\t\t\t\t\tsizes[language] += f.Size()\n-\t\t\t\t\tcontinue\n+\t\t\t\t// group languages, such as Pug -> HTML; SCSS -> CSS\n+\t\t\t\tgroup := enry.GetLanguageGroup(language)\n+\t\t\t\tif len(group) != 0 {\n+\t\t\t\t\tlanguage = group\n \t\t\t\t}\n+\n+\t\t\t\t// this language will always be added to the size\n+\t\t\t\tsizes[language] += f.Size()\n+\t\t\t\tcontinue\n \t\t\t}\n \t\t}\n \n@@ -149,7 +147,7 @@ func (repo *Repository) GetLanguageStats(commitID string) (map[string]int64, err\n \t\t\tif err := writeID(f.ID.String()); err != nil {\n \t\t\t\treturn nil, err\n \t\t\t}\n-\t\t\t_, _, size, err := ReadBatchLine(batchReader)\n+\t\t\t_, _, size, err := git.ReadBatchLine(batchReader)\n \t\t\tif err != nil {\n \t\t\t\tlog.Debug(\"Error reading blob: %s Err: %v\", f.ID.String(), err)\n \t\t\t\treturn nil, err\n@@ -167,7 +165,7 @@ func (repo *Repository) GetLanguageStats(commitID string) (map[string]int64, err\n \t\t\t\treturn nil, err\n \t\t\t}\n \t\t\tcontent = contentBuf.Bytes()\n-\t\t\tif err := DiscardFull(batchReader, discard); err != nil {\n+\t\t\tif err := git.DiscardFull(batchReader, discard); err != nil {\n \t\t\t\treturn nil, err\n \t\t\t}\n \t\t}\ndiff --git a/modules/git/repo_attribute.go b/modules/git/repo_attribute.go\ndeleted file mode 100644\nindex fde42d4730c1d..0000000000000\n--- a/modules/git/repo_attribute.go\n+++ /dev/null\n@@ -1,341 +0,0 @@\n-// Copyright 2019 The Gitea Authors. All rights reserved.\n-// SPDX-License-Identifier: MIT\n-\n-package git\n-\n-import (\n-\t\"bytes\"\n-\t\"context\"\n-\t\"errors\"\n-\t\"fmt\"\n-\t\"io\"\n-\t\"os\"\n-\t\"path/filepath\"\n-\t\"time\"\n-\n-\t\"code.gitea.io/gitea/modules/log\"\n-)\n-\n-// CheckAttributeOpts represents the possible options to CheckAttribute\n-type CheckAttributeOpts struct {\n-\tCachedOnly    bool\n-\tAllAttributes bool\n-\tAttributes    []string\n-\tFilenames     []string\n-\tIndexFile     string\n-\tWorkTree      string\n-}\n-\n-// CheckAttribute return the Blame object of file\n-func (repo *Repository) CheckAttribute(opts CheckAttributeOpts) (map[string]map[string]string, error) {\n-\tenv := []string{}\n-\n-\tif len(opts.IndexFile) > 0 {\n-\t\tenv = append(env, \"GIT_INDEX_FILE=\"+opts.IndexFile)\n-\t}\n-\tif len(opts.WorkTree) > 0 {\n-\t\tenv = append(env, \"GIT_WORK_TREE=\"+opts.WorkTree)\n-\t}\n-\n-\tif len(env) > 0 {\n-\t\tenv = append(os.Environ(), env...)\n-\t}\n-\n-\tstdOut := new(bytes.Buffer)\n-\tstdErr := new(bytes.Buffer)\n-\n-\tcmd := NewCommand(\"check-attr\", \"-z\")\n-\n-\tif opts.AllAttributes {\n-\t\tcmd.AddArguments(\"-a\")\n-\t} else {\n-\t\tfor _, attribute := range opts.Attributes {\n-\t\t\tif attribute != \"\" {\n-\t\t\t\tcmd.AddDynamicArguments(attribute)\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tif opts.CachedOnly {\n-\t\tcmd.AddArguments(\"--cached\")\n-\t}\n-\n-\tcmd.AddDashesAndList(opts.Filenames...)\n-\n-\tif err := cmd.Run(repo.Ctx, &RunOpts{\n-\t\tEnv:    env,\n-\t\tDir:    repo.Path,\n-\t\tStdout: stdOut,\n-\t\tStderr: stdErr,\n-\t}); err != nil {\n-\t\treturn nil, fmt.Errorf(\"failed to run check-attr: %w\\n%s\\n%s\", err, stdOut.String(), stdErr.String())\n-\t}\n-\n-\t// FIXME: This is incorrect on versions < 1.8.5\n-\tfields := bytes.Split(stdOut.Bytes(), []byte{'\\000'})\n-\n-\tif len(fields)%3 != 1 {\n-\t\treturn nil, errors.New(\"wrong number of fields in return from check-attr\")\n-\t}\n-\n-\tname2attribute2info := make(map[string]map[string]string)\n-\n-\tfor i := 0; i < (len(fields) / 3); i++ {\n-\t\tfilename := string(fields[3*i])\n-\t\tattribute := string(fields[3*i+1])\n-\t\tinfo := string(fields[3*i+2])\n-\t\tattribute2info := name2attribute2info[filename]\n-\t\tif attribute2info == nil {\n-\t\t\tattribute2info = make(map[string]string)\n-\t\t}\n-\t\tattribute2info[attribute] = info\n-\t\tname2attribute2info[filename] = attribute2info\n-\t}\n-\n-\treturn name2attribute2info, nil\n-}\n-\n-// CheckAttributeReader provides a reader for check-attribute content that can be long running\n-type CheckAttributeReader struct {\n-\t// params\n-\tAttributes []string\n-\tRepo       *Repository\n-\tIndexFile  string\n-\tWorkTree   string\n-\n-\tstdinReader io.ReadCloser\n-\tstdinWriter *os.File\n-\tstdOut      *nulSeparatedAttributeWriter\n-\tcmd         *Command\n-\tenv         []string\n-\tctx         context.Context\n-\tcancel      context.CancelFunc\n-}\n-\n-// Init initializes the CheckAttributeReader\n-func (c *CheckAttributeReader) Init(ctx context.Context) error {\n-\tif len(c.Attributes) == 0 {\n-\t\tlw := new(nulSeparatedAttributeWriter)\n-\t\tlw.attributes = make(chan attributeTriple)\n-\t\tlw.closed = make(chan struct{})\n-\n-\t\tc.stdOut = lw\n-\t\tc.stdOut.Close()\n-\t\treturn errors.New(\"no provided Attributes to check\")\n-\t}\n-\n-\tc.ctx, c.cancel = context.WithCancel(ctx)\n-\tc.cmd = NewCommand(\"check-attr\", \"--stdin\", \"-z\")\n-\n-\tif len(c.IndexFile) > 0 {\n-\t\tc.cmd.AddArguments(\"--cached\")\n-\t\tc.env = append(c.env, \"GIT_INDEX_FILE=\"+c.IndexFile)\n-\t}\n-\n-\tif len(c.WorkTree) > 0 {\n-\t\tc.env = append(c.env, \"GIT_WORK_TREE=\"+c.WorkTree)\n-\t}\n-\n-\tc.env = append(c.env, \"GIT_FLUSH=1\")\n-\n-\tc.cmd.AddDynamicArguments(c.Attributes...)\n-\n-\tvar err error\n-\n-\tc.stdinReader, c.stdinWriter, err = os.Pipe()\n-\tif err != nil {\n-\t\tc.cancel()\n-\t\treturn err\n-\t}\n-\n-\tlw := new(nulSeparatedAttributeWriter)\n-\tlw.attributes = make(chan attributeTriple, 5)\n-\tlw.closed = make(chan struct{})\n-\tc.stdOut = lw\n-\treturn nil\n-}\n-\n-func (c *CheckAttributeReader) Run() error {\n-\tdefer func() {\n-\t\t_ = c.stdinReader.Close()\n-\t\t_ = c.stdOut.Close()\n-\t}()\n-\tstdErr := new(bytes.Buffer)\n-\terr := c.cmd.Run(c.ctx, &RunOpts{\n-\t\tEnv:    c.env,\n-\t\tDir:    c.Repo.Path,\n-\t\tStdin:  c.stdinReader,\n-\t\tStdout: c.stdOut,\n-\t\tStderr: stdErr,\n-\t})\n-\tif err != nil && !IsErrCanceledOrKilled(err) {\n-\t\treturn fmt.Errorf(\"failed to run attr-check. Error: %w\\nStderr: %s\", err, stdErr.String())\n-\t}\n-\treturn nil\n-}\n-\n-// CheckPath check attr for given path\n-func (c *CheckAttributeReader) CheckPath(path string) (rs map[string]string, err error) {\n-\tdefer func() {\n-\t\tif err != nil && err != c.ctx.Err() {\n-\t\t\tlog.Error(\"Unexpected error when checking path %s in %s, error: %v\", path, filepath.Base(c.Repo.Path), err)\n-\t\t}\n-\t}()\n-\n-\tselect {\n-\tcase <-c.ctx.Done():\n-\t\treturn nil, c.ctx.Err()\n-\tdefault:\n-\t}\n-\n-\tif _, err = c.stdinWriter.Write([]byte(path + \"\\x00\")); err != nil {\n-\t\tdefer c.Close()\n-\t\treturn nil, err\n-\t}\n-\n-\treportTimeout := func() error {\n-\t\tstdOutClosed := false\n-\t\tselect {\n-\t\tcase <-c.stdOut.closed:\n-\t\t\tstdOutClosed = true\n-\t\tdefault:\n-\t\t}\n-\t\tdebugMsg := fmt.Sprintf(\"check path %q in repo %q\", path, filepath.Base(c.Repo.Path))\n-\t\tdebugMsg += fmt.Sprintf(\", stdOut: tmp=%q, pos=%d, closed=%v\", string(c.stdOut.tmp), c.stdOut.pos, stdOutClosed)\n-\t\tif c.cmd.cmd != nil {\n-\t\t\tdebugMsg += fmt.Sprintf(\", process state: %q\", c.cmd.cmd.ProcessState.String())\n-\t\t}\n-\t\t_ = c.Close()\n-\t\treturn fmt.Errorf(\"CheckPath timeout: %s\", debugMsg)\n-\t}\n-\n-\trs = make(map[string]string)\n-\tfor range c.Attributes {\n-\t\tselect {\n-\t\tcase <-time.After(5 * time.Second):\n-\t\t\t// There is a strange \"hang\" problem in gitdiff.GetDiff -> CheckPath\n-\t\t\t// So add a timeout here to mitigate the problem, and output more logs for debug purpose\n-\t\t\t// In real world, if CheckPath runs long than seconds, it blocks the end user's operation,\n-\t\t\t// and at the moment the CheckPath result is not so important, so we can just ignore it.\n-\t\t\treturn nil, reportTimeout()\n-\t\tcase attr, ok := <-c.stdOut.ReadAttribute():\n-\t\t\tif !ok {\n-\t\t\t\treturn nil, c.ctx.Err()\n-\t\t\t}\n-\t\t\trs[attr.Attribute] = attr.Value\n-\t\tcase <-c.ctx.Done():\n-\t\t\treturn nil, c.ctx.Err()\n-\t\t}\n-\t}\n-\treturn rs, nil\n-}\n-\n-func (c *CheckAttributeReader) Close() error {\n-\tc.cancel()\n-\terr := c.stdinWriter.Close()\n-\treturn err\n-}\n-\n-type attributeTriple struct {\n-\tFilename  string\n-\tAttribute string\n-\tValue     string\n-}\n-\n-type nulSeparatedAttributeWriter struct {\n-\ttmp        []byte\n-\tattributes chan attributeTriple\n-\tclosed     chan struct{}\n-\tworking    attributeTriple\n-\tpos        int\n-}\n-\n-func (wr *nulSeparatedAttributeWriter) Write(p []byte) (n int, err error) {\n-\tl, read := len(p), 0\n-\n-\tnulIdx := bytes.IndexByte(p, '\\x00')\n-\tfor nulIdx >= 0 {\n-\t\twr.tmp = append(wr.tmp, p[:nulIdx]...)\n-\t\tswitch wr.pos {\n-\t\tcase 0:\n-\t\t\twr.working = attributeTriple{\n-\t\t\t\tFilename: string(wr.tmp),\n-\t\t\t}\n-\t\tcase 1:\n-\t\t\twr.working.Attribute = string(wr.tmp)\n-\t\tcase 2:\n-\t\t\twr.working.Value = string(wr.tmp)\n-\t\t}\n-\t\twr.tmp = wr.tmp[:0]\n-\t\twr.pos++\n-\t\tif wr.pos > 2 {\n-\t\t\twr.attributes <- wr.working\n-\t\t\twr.pos = 0\n-\t\t}\n-\t\tread += nulIdx + 1\n-\t\tif l > read {\n-\t\t\tp = p[nulIdx+1:]\n-\t\t\tnulIdx = bytes.IndexByte(p, '\\x00')\n-\t\t} else {\n-\t\t\treturn l, nil\n-\t\t}\n-\t}\n-\twr.tmp = append(wr.tmp, p...)\n-\treturn l, nil\n-}\n-\n-func (wr *nulSeparatedAttributeWriter) ReadAttribute() <-chan attributeTriple {\n-\treturn wr.attributes\n-}\n-\n-func (wr *nulSeparatedAttributeWriter) Close() error {\n-\tselect {\n-\tcase <-wr.closed:\n-\t\treturn nil\n-\tdefault:\n-\t}\n-\tclose(wr.attributes)\n-\tclose(wr.closed)\n-\treturn nil\n-}\n-\n-// CheckAttributeReader creates a check attribute reader for the current repository and provided commit ID\n-func (repo *Repository) CheckAttributeReader(commitID string) (*CheckAttributeReader, context.CancelFunc) {\n-\tindexFilename, worktree, deleteTemporaryFile, err := repo.ReadTreeToTemporaryIndex(commitID)\n-\tif err != nil {\n-\t\treturn nil, func() {}\n-\t}\n-\n-\tchecker := &CheckAttributeReader{\n-\t\tAttributes: []string{\n-\t\t\tAttributeLinguistVendored,\n-\t\t\tAttributeLinguistGenerated,\n-\t\t\tAttributeLinguistDocumentation,\n-\t\t\tAttributeLinguistDetectable,\n-\t\t\tAttributeLinguistLanguage,\n-\t\t\tAttributeGitlabLanguage,\n-\t\t},\n-\t\tRepo:      repo,\n-\t\tIndexFile: indexFilename,\n-\t\tWorkTree:  worktree,\n-\t}\n-\tctx, cancel := context.WithCancel(repo.Ctx)\n-\tif err := checker.Init(ctx); err != nil {\n-\t\tlog.Error(\"Unable to open attribute checker for commit %s, error: %v\", commitID, err)\n-\t} else {\n-\t\tgo func() {\n-\t\t\terr := checker.Run()\n-\t\t\tif err != nil && !IsErrCanceledOrKilled(err) {\n-\t\t\t\tlog.Error(\"Attribute checker for commit %s exits with error: %v\", commitID, err)\n-\t\t\t}\n-\t\t\tcancel()\n-\t\t}()\n-\t}\n-\tdeferrable := func() {\n-\t\t_ = checker.Close()\n-\t\tcancel()\n-\t\tdeleteTemporaryFile()\n-\t}\n-\n-\treturn checker, deferrable\n-}\ndiff --git a/modules/indexer/stats/db.go b/modules/indexer/stats/db.go\nindex 067a6f609bdc8..199d493e97d21 100644\n--- a/modules/indexer/stats/db.go\n+++ b/modules/indexer/stats/db.go\n@@ -8,6 +8,7 @@ import (\n \n \trepo_model \"code.gitea.io/gitea/models/repo\"\n \t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/git/languagestats\"\n \t\"code.gitea.io/gitea/modules/gitrepo\"\n \t\"code.gitea.io/gitea/modules/graceful\"\n \t\"code.gitea.io/gitea/modules/log\"\n@@ -62,7 +63,7 @@ func (db *DBIndexer) Index(id int64) error {\n \t}\n \n \t// Calculate and save language statistics to database\n-\tstats, err := gitRepo.GetLanguageStats(commitID)\n+\tstats, err := languagestats.GetLanguageStats(gitRepo, commitID)\n \tif err != nil {\n \t\tif !setting.IsInTesting {\n \t\t\tlog.Error(\"Unable to get language stats for ID %s for default branch %s in %s. Error: %v\", commitID, repo.DefaultBranch, repo.FullName(), err)\ndiff --git a/routers/web/repo/blame.go b/routers/web/repo/blame.go\nindex efd85b9452798..e125267524c7b 100644\n--- a/routers/web/repo/blame.go\n+++ b/routers/web/repo/blame.go\n@@ -15,13 +15,13 @@ import (\n \tuser_model \"code.gitea.io/gitea/models/user\"\n \t\"code.gitea.io/gitea/modules/charset\"\n \t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/git/languagestats\"\n \t\"code.gitea.io/gitea/modules/highlight\"\n \t\"code.gitea.io/gitea/modules/log\"\n \t\"code.gitea.io/gitea/modules/setting\"\n \t\"code.gitea.io/gitea/modules/templates\"\n \t\"code.gitea.io/gitea/modules/util\"\n \t\"code.gitea.io/gitea/services/context\"\n-\tfiles_service \"code.gitea.io/gitea/services/repository/files\"\n )\n \n type blameRow struct {\n@@ -234,7 +234,7 @@ func processBlameParts(ctx *context.Context, blameParts []*git.BlamePart) map[st\n func renderBlame(ctx *context.Context, blameParts []*git.BlamePart, commitNames map[string]*user_model.UserCommit) {\n \trepoLink := ctx.Repo.RepoLink\n \n-\tlanguage, err := files_service.TryGetContentLanguage(ctx.Repo.GitRepo, ctx.Repo.CommitID, ctx.Repo.TreePath)\n+\tlanguage, err := languagestats.GetFileLanguage(ctx, ctx.Repo.GitRepo, ctx.Repo.CommitID, ctx.Repo.TreePath)\n \tif err != nil {\n \t\tlog.Error(\"Unable to get file language for %-v:%s. Error: %v\", ctx.Repo.Repository, ctx.Repo.TreePath, err)\n \t}\ndiff --git a/routers/web/repo/setting/lfs.go b/routers/web/repo/setting/lfs.go\nindex efda9bda58bd5..a065620b2b249 100644\n--- a/routers/web/repo/setting/lfs.go\n+++ b/routers/web/repo/setting/lfs.go\n@@ -18,6 +18,7 @@ import (\n \t\"code.gitea.io/gitea/modules/charset\"\n \t\"code.gitea.io/gitea/modules/container\"\n \t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/git/attribute\"\n \t\"code.gitea.io/gitea/modules/git/pipeline\"\n \t\"code.gitea.io/gitea/modules/lfs\"\n \t\"code.gitea.io/gitea/modules/log\"\n@@ -134,39 +135,24 @@ func LFSLocks(ctx *context.Context) {\n \t}\n \tdefer gitRepo.Close()\n \n-\tfilenames := make([]string, len(lfsLocks))\n-\n-\tfor i, lock := range lfsLocks {\n-\t\tfilenames[i] = lock.Path\n-\t}\n-\n-\tif err := gitRepo.ReadTreeToIndex(ctx.Repo.Repository.DefaultBranch); err != nil {\n-\t\tlog.Error(\"Unable to read the default branch to the index: %s (%v)\", ctx.Repo.Repository.DefaultBranch, err)\n-\t\tctx.ServerError(\"LFSLocks\", fmt.Errorf(\"unable to read the default branch to the index: %s (%w)\", ctx.Repo.Repository.DefaultBranch, err))\n-\t\treturn\n-\t}\n-\n-\tname2attribute2info, err := gitRepo.CheckAttribute(git.CheckAttributeOpts{\n-\t\tAttributes: []string{\"lockable\"},\n-\t\tFilenames:  filenames,\n-\t\tCachedOnly: true,\n-\t})\n+\tchecker, err := attribute.NewBatchChecker(gitRepo, ctx.Repo.Repository.DefaultBranch, []string{attribute.Lockable})\n \tif err != nil {\n \t\tlog.Error(\"Unable to check attributes in %s (%v)\", tmpBasePath, err)\n \t\tctx.ServerError(\"LFSLocks\", err)\n \t\treturn\n \t}\n+\tdefer checker.Close()\n \n \tlockables := make([]bool, len(lfsLocks))\n+\tfilenames := make([]string, len(lfsLocks))\n \tfor i, lock := range lfsLocks {\n-\t\tattribute2info, has := name2attribute2info[lock.Path]\n-\t\tif !has {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif attribute2info[\"lockable\"] != \"set\" {\n+\t\tfilenames[i] = lock.Path\n+\t\tattrs, err := checker.CheckPath(lock.Path)\n+\t\tif err != nil {\n+\t\t\tlog.Error(\"Unable to check attributes in %s: %s (%v)\", tmpBasePath, lock.Path, err)\n \t\t\tcontinue\n \t\t}\n-\t\tlockables[i] = true\n+\t\tlockables[i] = attrs.Get(attribute.Lockable).ToBool().Value()\n \t}\n \tctx.Data[\"Lockables\"] = lockables\n \ndiff --git a/routers/web/repo/view_file.go b/routers/web/repo/view_file.go\nindex 12083a1ced188..ff0e1b4d54c72 100644\n--- a/routers/web/repo/view_file.go\n+++ b/routers/web/repo/view_file.go\n@@ -18,6 +18,7 @@ import (\n \t\"code.gitea.io/gitea/modules/actions\"\n \t\"code.gitea.io/gitea/modules/charset\"\n \t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/git/attribute\"\n \t\"code.gitea.io/gitea/modules/highlight\"\n \t\"code.gitea.io/gitea/modules/log\"\n \t\"code.gitea.io/gitea/modules/markup\"\n@@ -25,7 +26,6 @@ import (\n \t\"code.gitea.io/gitea/modules/util\"\n \t\"code.gitea.io/gitea/services/context\"\n \tissue_service \"code.gitea.io/gitea/services/issue\"\n-\tfiles_service \"code.gitea.io/gitea/services/repository/files\"\n \n \t\"github.com/nektos/act/pkg/model\"\n )\n@@ -147,6 +147,23 @@ func prepareToRenderFile(ctx *context.Context, entry *git.TreeEntry) {\n \t\tctx.Data[\"EditFileTooltip\"] = ctx.Tr(\"repo.editor.cannot_edit_non_text_files\")\n \t}\n \n+\t// read all needed attributes which will be used later\n+\t// there should be no performance different between reading 2 or 4 here\n+\tattrsMap, err := attribute.CheckAttributes(ctx, ctx.Repo.GitRepo, ctx.Repo.CommitID, attribute.CheckAttributeOpts{\n+\t\tFilenames:  []string{ctx.Repo.TreePath},\n+\t\tAttributes: []string{attribute.LinguistGenerated, attribute.LinguistVendored, attribute.LinguistLanguage, attribute.GitlabLanguage},\n+\t})\n+\tif err != nil {\n+\t\tctx.ServerError(\"attribute.CheckAttributes\", err)\n+\t\treturn\n+\t}\n+\tattrs := attrsMap[ctx.Repo.TreePath]\n+\tif attrs == nil {\n+\t\t// this case shouldn't happen, just in case.\n+\t\tsetting.PanicInDevOrTesting(\"no attributes found for %s\", ctx.Repo.TreePath)\n+\t\tattrs = attribute.NewAttributes()\n+\t}\n+\n \tswitch {\n \tcase isRepresentableAsText:\n \t\tif fInfo.fileSize >= setting.UI.MaxDisplayFileSize {\n@@ -209,11 +226,7 @@ func prepareToRenderFile(ctx *context.Context, entry *git.TreeEntry) {\n \t\t\t\tctx.Data[\"NumLines\"] = bytes.Count(buf, []byte{'\\n'}) + 1\n \t\t\t}\n \n-\t\t\tlanguage, err := files_service.TryGetContentLanguage(ctx.Repo.GitRepo, ctx.Repo.CommitID, ctx.Repo.TreePath)\n-\t\t\tif err != nil {\n-\t\t\t\tlog.Error(\"Unable to get file language for %-v:%s. Error: %v\", ctx.Repo.Repository, ctx.Repo.TreePath, err)\n-\t\t\t}\n-\n+\t\t\tlanguage := attrs.GetLanguage().Value()\n \t\t\tfileContent, lexerName, err := highlight.File(blob.Name(), language, buf)\n \t\t\tctx.Data[\"LexerName\"] = lexerName\n \t\t\tif err != nil {\n@@ -283,17 +296,7 @@ func prepareToRenderFile(ctx *context.Context, entry *git.TreeEntry) {\n \t\t}\n \t}\n \n-\tif ctx.Repo.GitRepo != nil {\n-\t\tchecker, deferable := ctx.Repo.GitRepo.CheckAttributeReader(ctx.Repo.CommitID)\n-\t\tif checker != nil {\n-\t\t\tdefer deferable()\n-\t\t\tattrs, err := checker.CheckPath(ctx.Repo.TreePath)\n-\t\t\tif err == nil {\n-\t\t\t\tctx.Data[\"IsVendored\"] = git.AttributeToBool(attrs, git.AttributeLinguistVendored).Value()\n-\t\t\t\tctx.Data[\"IsGenerated\"] = git.AttributeToBool(attrs, git.AttributeLinguistGenerated).Value()\n-\t\t\t}\n-\t\t}\n-\t}\n+\tctx.Data[\"IsVendored\"], ctx.Data[\"IsGenerated\"] = attrs.GetVendored().Value(), attrs.GetGenerated().Value()\n \n \tif fInfo.st.IsImage() && !fInfo.st.IsSvgImage() {\n \t\timg, _, err := image.DecodeConfig(bytes.NewReader(buf))\ndiff --git a/services/gitdiff/gitdiff.go b/services/gitdiff/gitdiff.go\nindex b9781cf8d067b..9ee86d9dfc0f8 100644\n--- a/services/gitdiff/gitdiff.go\n+++ b/services/gitdiff/gitdiff.go\n@@ -25,6 +25,7 @@ import (\n \t\"code.gitea.io/gitea/modules/analyze\"\n \t\"code.gitea.io/gitea/modules/charset\"\n \t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/git/attribute\"\n \t\"code.gitea.io/gitea/modules/highlight\"\n \t\"code.gitea.io/gitea/modules/lfs\"\n \t\"code.gitea.io/gitea/modules/log\"\n@@ -1237,24 +1238,21 @@ func GetDiffForRender(ctx context.Context, gitRepo *git.Repository, opts *DiffOp\n \t\treturn nil, err\n \t}\n \n-\tchecker, deferrable := gitRepo.CheckAttributeReader(opts.AfterCommitID)\n-\tdefer deferrable()\n+\tchecker, err := attribute.NewBatchChecker(gitRepo, opts.AfterCommitID, []string{attribute.LinguistVendored, attribute.LinguistGenerated, attribute.LinguistLanguage, attribute.GitlabLanguage})\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer checker.Close()\n \n \tfor _, diffFile := range diff.Files {\n \t\tisVendored := optional.None[bool]()\n \t\tisGenerated := optional.None[bool]()\n-\t\tif checker != nil {\n-\t\t\tattrs, err := checker.CheckPath(diffFile.Name)\n-\t\t\tif err == nil {\n-\t\t\t\tisVendored = git.AttributeToBool(attrs, git.AttributeLinguistVendored)\n-\t\t\t\tisGenerated = git.AttributeToBool(attrs, git.AttributeLinguistGenerated)\n-\n-\t\t\t\tlanguage := git.TryReadLanguageAttribute(attrs)\n-\t\t\t\tif language.Has() {\n-\t\t\t\t\tdiffFile.Language = language.Value()\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tchecker = nil // CheckPath fails, it's not impossible to \"check\" anymore\n+\t\tattrs, err := checker.CheckPath(diffFile.Name)\n+\t\tif err == nil {\n+\t\t\tisVendored, isGenerated = attrs.GetVendored(), attrs.GetGenerated()\n+\t\t\tlanguage := attrs.GetLanguage()\n+\t\t\tif language.Has() {\n+\t\t\t\tdiffFile.Language = language.Value()\n \t\t\t}\n \t\t}\n \ndiff --git a/services/markup/renderhelper_codepreview.go b/services/markup/renderhelper_codepreview.go\nindex 28d11209846d8..fa1eb824a2f54 100644\n--- a/services/markup/renderhelper_codepreview.go\n+++ b/services/markup/renderhelper_codepreview.go\n@@ -14,13 +14,13 @@ import (\n \t\"code.gitea.io/gitea/models/repo\"\n \t\"code.gitea.io/gitea/models/unit\"\n \t\"code.gitea.io/gitea/modules/charset\"\n+\t\"code.gitea.io/gitea/modules/git/languagestats\"\n \t\"code.gitea.io/gitea/modules/gitrepo\"\n \t\"code.gitea.io/gitea/modules/indexer/code\"\n \t\"code.gitea.io/gitea/modules/markup\"\n \t\"code.gitea.io/gitea/modules/setting\"\n \t\"code.gitea.io/gitea/modules/util\"\n \tgitea_context \"code.gitea.io/gitea/services/context\"\n-\t\"code.gitea.io/gitea/services/repository/files\"\n )\n \n func renderRepoFileCodePreview(ctx context.Context, opts markup.RenderCodePreviewOptions) (template.HTML, error) {\n@@ -61,7 +61,7 @@ func renderRepoFileCodePreview(ctx context.Context, opts markup.RenderCodePrevie\n \t\treturn \"\", err\n \t}\n \n-\tlanguage, _ := files.TryGetContentLanguage(gitRepo, opts.CommitID, opts.FilePath)\n+\tlanguage, _ := languagestats.GetFileLanguage(ctx, gitRepo, opts.CommitID, opts.FilePath)\n \tblob, err := commit.GetBlobByPath(opts.FilePath)\n \tif err != nil {\n \t\treturn \"\", err\ndiff --git a/services/repository/files/content.go b/services/repository/files/content.go\nindex e23cd1abce610..0327e7f2cebeb 100644\n--- a/services/repository/files/content.go\n+++ b/services/repository/files/content.go\n@@ -277,28 +277,3 @@ func GetBlobBySHA(ctx context.Context, repo *repo_model.Repository, gitRepo *git\n \t\tContent:  content,\n \t}, nil\n }\n-\n-// TryGetContentLanguage tries to get the (linguist) language of the file content\n-func TryGetContentLanguage(gitRepo *git.Repository, commitID, treePath string) (string, error) {\n-\tindexFilename, worktree, deleteTemporaryFile, err := gitRepo.ReadTreeToTemporaryIndex(commitID)\n-\tif err != nil {\n-\t\treturn \"\", err\n-\t}\n-\n-\tdefer deleteTemporaryFile()\n-\n-\tfilename2attribute2info, err := gitRepo.CheckAttribute(git.CheckAttributeOpts{\n-\t\tCachedOnly: true,\n-\t\tAttributes: []string{git.AttributeLinguistLanguage, git.AttributeGitlabLanguage},\n-\t\tFilenames:  []string{treePath},\n-\t\tIndexFile:  indexFilename,\n-\t\tWorkTree:   worktree,\n-\t})\n-\tif err != nil {\n-\t\treturn \"\", err\n-\t}\n-\n-\tlanguage := git.TryReadLanguageAttribute(filename2attribute2info[treePath])\n-\n-\treturn language.Value(), nil\n-}\ndiff --git a/services/repository/files/update.go b/services/repository/files/update.go\nindex 3f6255e77a77c..75ede4976f9a2 100644\n--- a/services/repository/files/update.go\n+++ b/services/repository/files/update.go\n@@ -15,6 +15,7 @@ import (\n \trepo_model \"code.gitea.io/gitea/models/repo\"\n \tuser_model \"code.gitea.io/gitea/models/user\"\n \t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/git/attribute\"\n \t\"code.gitea.io/gitea/modules/gitrepo\"\n \t\"code.gitea.io/gitea/modules/lfs\"\n \t\"code.gitea.io/gitea/modules/log\"\n@@ -488,16 +489,15 @@ func CreateOrUpdateFile(ctx context.Context, t *TemporaryUploadRepository, file\n \tvar lfsMetaObject *git_model.LFSMetaObject\n \tif setting.LFS.StartServer && hasOldBranch {\n \t\t// Check there is no way this can return multiple infos\n-\t\tfilename2attribute2info, err := t.gitRepo.CheckAttribute(git.CheckAttributeOpts{\n-\t\t\tAttributes: []string{\"filter\"},\n+\t\tattributesMap, err := attribute.CheckAttributes(ctx, t.gitRepo, \"\" /* use temp repo's working dir */, attribute.CheckAttributeOpts{\n+\t\t\tAttributes: []string{attribute.Filter},\n \t\t\tFilenames:  []string{file.Options.treePath},\n-\t\t\tCachedOnly: true,\n \t\t})\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n \n-\t\tif filename2attribute2info[file.Options.treePath] != nil && filename2attribute2info[file.Options.treePath][\"filter\"] == \"lfs\" {\n+\t\tif attributesMap[file.Options.treePath] != nil && attributesMap[file.Options.treePath].Get(attribute.Filter).ToString().Value() == \"lfs\" {\n \t\t\t// OK so we are supposed to LFS this data!\n \t\t\tpointer, err := lfs.GeneratePointer(treeObjectContentReader)\n \t\t\tif err != nil {\ndiff --git a/services/repository/files/upload.go b/services/repository/files/upload.go\nindex 2e4ed1744ef7c..f348cb68ab543 100644\n--- a/services/repository/files/upload.go\n+++ b/services/repository/files/upload.go\n@@ -14,6 +14,7 @@ import (\n \trepo_model \"code.gitea.io/gitea/models/repo\"\n \tuser_model \"code.gitea.io/gitea/models/user\"\n \t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/git/attribute\"\n \t\"code.gitea.io/gitea/modules/lfs\"\n \t\"code.gitea.io/gitea/modules/setting\"\n )\n@@ -105,12 +106,11 @@ func UploadRepoFiles(ctx context.Context, repo *repo_model.Repository, doer *use\n \t\t}\n \t}\n \n-\tvar filename2attribute2info map[string]map[string]string\n+\tvar attributesMap map[string]*attribute.Attributes\n \tif setting.LFS.StartServer {\n-\t\tfilename2attribute2info, err = t.gitRepo.CheckAttribute(git.CheckAttributeOpts{\n-\t\t\tAttributes: []string{\"filter\"},\n+\t\tattributesMap, err = attribute.CheckAttributes(ctx, t.gitRepo, \"\" /* use temp repo's working dir */, attribute.CheckAttributeOpts{\n+\t\t\tAttributes: []string{attribute.Filter},\n \t\t\tFilenames:  names,\n-\t\t\tCachedOnly: true,\n \t\t})\n \t\tif err != nil {\n \t\t\treturn err\n@@ -119,7 +119,7 @@ func UploadRepoFiles(ctx context.Context, repo *repo_model.Repository, doer *use\n \n \t// Copy uploaded files into repository.\n \tfor i := range infos {\n-\t\tif err := copyUploadedLFSFileIntoRepository(ctx, &infos[i], filename2attribute2info, t, opts.TreePath); err != nil {\n+\t\tif err := copyUploadedLFSFileIntoRepository(ctx, &infos[i], attributesMap, t, opts.TreePath); err != nil {\n \t\t\treturn err\n \t\t}\n \t}\n@@ -176,7 +176,7 @@ func UploadRepoFiles(ctx context.Context, repo *repo_model.Repository, doer *use\n \treturn repo_model.DeleteUploads(ctx, uploads...)\n }\n \n-func copyUploadedLFSFileIntoRepository(ctx context.Context, info *uploadInfo, filename2attribute2info map[string]map[string]string, t *TemporaryUploadRepository, treePath string) error {\n+func copyUploadedLFSFileIntoRepository(ctx context.Context, info *uploadInfo, attributesMap map[string]*attribute.Attributes, t *TemporaryUploadRepository, treePath string) error {\n \tfile, err := os.Open(info.upload.LocalPath())\n \tif err != nil {\n \t\treturn err\n@@ -184,7 +184,7 @@ func copyUploadedLFSFileIntoRepository(ctx context.Context, info *uploadInfo, fi\n \tdefer file.Close()\n \n \tvar objectHash string\n-\tif setting.LFS.StartServer && filename2attribute2info[info.upload.Name] != nil && filename2attribute2info[info.upload.Name][\"filter\"] == \"lfs\" {\n+\tif setting.LFS.StartServer && attributesMap[info.upload.Name] != nil && attributesMap[info.upload.Name].Get(attribute.Filter).ToString().Value() == \"lfs\" {\n \t\t// Handle LFS\n \t\t// FIXME: Inefficient! this should probably happen in models.Upload\n \t\tpointer, err := lfs.GeneratePointer(file)\n", "test_patch": "diff --git a/modules/git/attribute/attribute_test.go b/modules/git/attribute/attribute_test.go\nnew file mode 100644\nindex 0000000000000..dadb5582a3cb5\n--- /dev/null\n+++ b/modules/git/attribute/attribute_test.go\n@@ -0,0 +1,37 @@\n+// Copyright 2025 The Gitea Authors. All rights reserved.\n+// SPDX-License-Identifier: MIT\n+\n+package attribute\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func Test_Attribute(t *testing.T) {\n+\tassert.Empty(t, Attribute(\"\").ToString().Value())\n+\tassert.Empty(t, Attribute(\"unspecified\").ToString().Value())\n+\tassert.Equal(t, \"python\", Attribute(\"python\").ToString().Value())\n+\tassert.Equal(t, \"Java\", Attribute(\"Java\").ToString().Value())\n+\n+\tattributes := Attributes{\n+\t\tm: map[string]Attribute{\n+\t\t\tLinguistGenerated:     \"true\",\n+\t\t\tLinguistDocumentation: \"false\",\n+\t\t\tLinguistDetectable:    \"set\",\n+\t\t\tLinguistLanguage:      \"Python\",\n+\t\t\tGitlabLanguage:        \"Java\",\n+\t\t\t\"filter\":              \"unspecified\",\n+\t\t\t\"test\":                \"\",\n+\t\t},\n+\t}\n+\n+\tassert.Empty(t, attributes.Get(\"test\").ToString().Value())\n+\tassert.Empty(t, attributes.Get(\"filter\").ToString().Value())\n+\tassert.Equal(t, \"Python\", attributes.Get(LinguistLanguage).ToString().Value())\n+\tassert.Equal(t, \"Java\", attributes.Get(GitlabLanguage).ToString().Value())\n+\tassert.True(t, attributes.Get(LinguistGenerated).ToBool().Value())\n+\tassert.False(t, attributes.Get(LinguistDocumentation).ToBool().Value())\n+\tassert.True(t, attributes.Get(LinguistDetectable).ToBool().Value())\n+}\ndiff --git a/modules/git/repo_attribute_test.go b/modules/git/attribute/batch_test.go\nsimilarity index 50%\nrename from modules/git/repo_attribute_test.go\nrename to modules/git/attribute/batch_test.go\nindex d8fd9f0e8d857..30a3d805fe983 100644\n--- a/modules/git/repo_attribute_test.go\n+++ b/modules/git/attribute/batch_test.go\n@@ -1,13 +1,19 @@\n // Copyright 2021 The Gitea Authors. All rights reserved.\n // SPDX-License-Identifier: MIT\n \n-package git\n+package attribute\n \n import (\n+\t\"path/filepath\"\n \t\"testing\"\n \t\"time\"\n \n+\t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/setting\"\n+\t\"code.gitea.io/gitea/modules/test\"\n+\n \t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n )\n \n func Test_nulSeparatedAttributeWriter_ReadAttribute(t *testing.T) {\n@@ -24,7 +30,7 @@ func Test_nulSeparatedAttributeWriter_ReadAttribute(t *testing.T) {\n \tselect {\n \tcase attr := <-wr.ReadAttribute():\n \t\tassert.Equal(t, \".gitignore\\\"\\n\", attr.Filename)\n-\t\tassert.Equal(t, AttributeLinguistVendored, attr.Attribute)\n+\t\tassert.Equal(t, LinguistVendored, attr.Attribute)\n \t\tassert.Equal(t, \"unspecified\", attr.Value)\n \tcase <-time.After(100 * time.Millisecond):\n \t\tassert.FailNow(t, \"took too long to read an attribute from the list\")\n@@ -38,7 +44,7 @@ func Test_nulSeparatedAttributeWriter_ReadAttribute(t *testing.T) {\n \tselect {\n \tcase attr := <-wr.ReadAttribute():\n \t\tassert.Equal(t, \".gitignore\\\"\\n\", attr.Filename)\n-\t\tassert.Equal(t, AttributeLinguistVendored, attr.Attribute)\n+\t\tassert.Equal(t, LinguistVendored, attr.Attribute)\n \t\tassert.Equal(t, \"unspecified\", attr.Value)\n \tcase <-time.After(100 * time.Millisecond):\n \t\tassert.FailNow(t, \"took too long to read an attribute from the list\")\n@@ -77,21 +83,90 @@ func Test_nulSeparatedAttributeWriter_ReadAttribute(t *testing.T) {\n \tassert.NoError(t, err)\n \tassert.Equal(t, attributeTriple{\n \t\tFilename:  \"shouldbe.vendor\",\n-\t\tAttribute: AttributeLinguistVendored,\n+\t\tAttribute: LinguistVendored,\n \t\tValue:     \"set\",\n \t}, attr)\n \tattr = <-wr.ReadAttribute()\n \tassert.NoError(t, err)\n \tassert.Equal(t, attributeTriple{\n \t\tFilename:  \"shouldbe.vendor\",\n-\t\tAttribute: AttributeLinguistGenerated,\n+\t\tAttribute: LinguistGenerated,\n \t\tValue:     \"unspecified\",\n \t}, attr)\n \tattr = <-wr.ReadAttribute()\n \tassert.NoError(t, err)\n \tassert.Equal(t, attributeTriple{\n \t\tFilename:  \"shouldbe.vendor\",\n-\t\tAttribute: AttributeLinguistLanguage,\n+\t\tAttribute: LinguistLanguage,\n \t\tValue:     \"unspecified\",\n \t}, attr)\n }\n+\n+func expectedAttrs() *Attributes {\n+\treturn &Attributes{\n+\t\tm: map[string]Attribute{\n+\t\t\tLinguistGenerated:     \"unspecified\",\n+\t\t\tLinguistDetectable:    \"unspecified\",\n+\t\t\tLinguistDocumentation: \"unspecified\",\n+\t\t\tLinguistVendored:      \"unspecified\",\n+\t\t\tLinguistLanguage:      \"Python\",\n+\t\t\tGitlabLanguage:        \"unspecified\",\n+\t\t},\n+\t}\n+}\n+\n+func Test_BatchChecker(t *testing.T) {\n+\tsetting.AppDataPath = t.TempDir()\n+\trepoPath := \"../tests/repos/language_stats_repo\"\n+\tgitRepo, err := git.OpenRepository(t.Context(), repoPath)\n+\trequire.NoError(t, err)\n+\tdefer gitRepo.Close()\n+\n+\tcommitID := \"8fee858da5796dfb37704761701bb8e800ad9ef3\"\n+\n+\tt.Run(\"Create index file to run git check-attr\", func(t *testing.T) {\n+\t\tdefer test.MockVariableValue(&git.DefaultFeatures().SupportCheckAttrOnBare, false)()\n+\t\tchecker, err := NewBatchChecker(gitRepo, commitID, LinguistAttributes)\n+\t\tassert.NoError(t, err)\n+\t\tdefer checker.Close()\n+\t\tattributes, err := checker.CheckPath(\"i-am-a-python.p\")\n+\t\tassert.NoError(t, err)\n+\t\tassert.Equal(t, expectedAttrs(), attributes)\n+\t})\n+\n+\t// run git check-attr on work tree\n+\tt.Run(\"Run git check-attr on git work tree\", func(t *testing.T) {\n+\t\tdir := filepath.Join(t.TempDir(), \"test-repo\")\n+\t\terr := git.Clone(t.Context(), repoPath, dir, git.CloneRepoOptions{\n+\t\t\tShared: true,\n+\t\t\tBranch: \"master\",\n+\t\t})\n+\t\tassert.NoError(t, err)\n+\n+\t\ttempRepo, err := git.OpenRepository(t.Context(), dir)\n+\t\tassert.NoError(t, err)\n+\t\tdefer tempRepo.Close()\n+\n+\t\tchecker, err := NewBatchChecker(tempRepo, \"\", LinguistAttributes)\n+\t\tassert.NoError(t, err)\n+\t\tdefer checker.Close()\n+\t\tattributes, err := checker.CheckPath(\"i-am-a-python.p\")\n+\t\tassert.NoError(t, err)\n+\t\tassert.Equal(t, expectedAttrs(), attributes)\n+\t})\n+\n+\tif !git.DefaultFeatures().SupportCheckAttrOnBare {\n+\t\tt.Skip(\"git version 2.40 is required to support run check-attr on bare repo\")\n+\t\treturn\n+\t}\n+\n+\tt.Run(\"Run git check-attr in bare repository\", func(t *testing.T) {\n+\t\tchecker, err := NewBatchChecker(gitRepo, commitID, LinguistAttributes)\n+\t\tassert.NoError(t, err)\n+\t\tdefer checker.Close()\n+\n+\t\tattributes, err := checker.CheckPath(\"i-am-a-python.p\")\n+\t\tassert.NoError(t, err)\n+\t\tassert.Equal(t, expectedAttrs(), attributes)\n+\t})\n+}\ndiff --git a/modules/git/attribute/checker_test.go b/modules/git/attribute/checker_test.go\nnew file mode 100644\nindex 0000000000000..97db43460bb81\n--- /dev/null\n+++ b/modules/git/attribute/checker_test.go\n@@ -0,0 +1,74 @@\n+// Copyright 2025 The Gitea Authors. All rights reserved.\n+// SPDX-License-Identifier: MIT\n+\n+package attribute\n+\n+import (\n+\t\"path/filepath\"\n+\t\"testing\"\n+\n+\t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/setting\"\n+\t\"code.gitea.io/gitea/modules/test\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+func Test_Checker(t *testing.T) {\n+\tsetting.AppDataPath = t.TempDir()\n+\trepoPath := \"../tests/repos/language_stats_repo\"\n+\tgitRepo, err := git.OpenRepository(t.Context(), repoPath)\n+\trequire.NoError(t, err)\n+\tdefer gitRepo.Close()\n+\n+\tcommitID := \"8fee858da5796dfb37704761701bb8e800ad9ef3\"\n+\n+\tt.Run(\"Create index file to run git check-attr\", func(t *testing.T) {\n+\t\tdefer test.MockVariableValue(&git.DefaultFeatures().SupportCheckAttrOnBare, false)()\n+\t\tattrs, err := CheckAttributes(t.Context(), gitRepo, commitID, CheckAttributeOpts{\n+\t\t\tFilenames:  []string{\"i-am-a-python.p\"},\n+\t\t\tAttributes: LinguistAttributes,\n+\t\t})\n+\t\tassert.NoError(t, err)\n+\t\tassert.Len(t, attrs, 1)\n+\t\tassert.Equal(t, expectedAttrs(), attrs[\"i-am-a-python.p\"])\n+\t})\n+\n+\t// run git check-attr on work tree\n+\tt.Run(\"Run git check-attr on git work tree\", func(t *testing.T) {\n+\t\tdir := filepath.Join(t.TempDir(), \"test-repo\")\n+\t\terr := git.Clone(t.Context(), repoPath, dir, git.CloneRepoOptions{\n+\t\t\tShared: true,\n+\t\t\tBranch: \"master\",\n+\t\t})\n+\t\tassert.NoError(t, err)\n+\n+\t\ttempRepo, err := git.OpenRepository(t.Context(), dir)\n+\t\tassert.NoError(t, err)\n+\t\tdefer tempRepo.Close()\n+\n+\t\tattrs, err := CheckAttributes(t.Context(), tempRepo, \"\", CheckAttributeOpts{\n+\t\t\tFilenames:  []string{\"i-am-a-python.p\"},\n+\t\t\tAttributes: LinguistAttributes,\n+\t\t})\n+\t\tassert.NoError(t, err)\n+\t\tassert.Len(t, attrs, 1)\n+\t\tassert.Equal(t, expectedAttrs(), attrs[\"i-am-a-python.p\"])\n+\t})\n+\n+\tif !git.DefaultFeatures().SupportCheckAttrOnBare {\n+\t\tt.Skip(\"git version 2.40 is required to support run check-attr on bare repo\")\n+\t\treturn\n+\t}\n+\n+\tt.Run(\"Run git check-attr in bare repository\", func(t *testing.T) {\n+\t\tattrs, err := CheckAttributes(t.Context(), gitRepo, commitID, CheckAttributeOpts{\n+\t\t\tFilenames:  []string{\"i-am-a-python.p\"},\n+\t\t\tAttributes: LinguistAttributes,\n+\t\t})\n+\t\tassert.NoError(t, err)\n+\t\tassert.Len(t, attrs, 1)\n+\t\tassert.Equal(t, expectedAttrs(), attrs[\"i-am-a-python.p\"])\n+\t})\n+}\ndiff --git a/modules/git/attribute/main_test.go b/modules/git/attribute/main_test.go\nnew file mode 100644\nindex 0000000000000..df8241bfb08d4\n--- /dev/null\n+++ b/modules/git/attribute/main_test.go\n@@ -0,0 +1,41 @@\n+// Copyright 2025 The Gitea Authors. All rights reserved.\n+// SPDX-License-Identifier: MIT\n+\n+package attribute\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"testing\"\n+\n+\t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/setting\"\n+\t\"code.gitea.io/gitea/modules/util\"\n+)\n+\n+func testRun(m *testing.M) error {\n+\tgitHomePath, err := os.MkdirTemp(os.TempDir(), \"git-home\")\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"unable to create temp dir: %w\", err)\n+\t}\n+\tdefer util.RemoveAll(gitHomePath)\n+\tsetting.Git.HomePath = gitHomePath\n+\n+\tif err = git.InitFull(context.Background()); err != nil {\n+\t\treturn fmt.Errorf(\"failed to call Init: %w\", err)\n+\t}\n+\n+\texitCode := m.Run()\n+\tif exitCode != 0 {\n+\t\treturn fmt.Errorf(\"run test failed, ExitCode=%d\", exitCode)\n+\t}\n+\treturn nil\n+}\n+\n+func TestMain(m *testing.M) {\n+\tif err := testRun(m); err != nil {\n+\t\t_, _ = fmt.Fprintf(os.Stderr, \"Test failed: %v\", err)\n+\t\tos.Exit(1)\n+\t}\n+}\ndiff --git a/modules/git/repo_language_stats_test.go b/modules/git/languagestats/language_stats_test.go\nsimilarity index 75%\nrename from modules/git/repo_language_stats_test.go\nrename to modules/git/languagestats/language_stats_test.go\nindex 12ce958c6e556..b908ae6413d72 100644\n--- a/modules/git/repo_language_stats_test.go\n+++ b/modules/git/languagestats/language_stats_test.go\n@@ -3,12 +3,12 @@\n \n //go:build !gogit\n \n-package git\n+package languagestats\n \n import (\n-\t\"path/filepath\"\n \t\"testing\"\n \n+\t\"code.gitea.io/gitea/modules/git\"\n \t\"code.gitea.io/gitea/modules/setting\"\n \n \t\"github.com/stretchr/testify/assert\"\n@@ -17,13 +17,12 @@ import (\n \n func TestRepository_GetLanguageStats(t *testing.T) {\n \tsetting.AppDataPath = t.TempDir()\n-\trepoPath := filepath.Join(testReposDir, \"language_stats_repo\")\n-\tgitRepo, err := openRepositoryWithDefaultContext(repoPath)\n+\trepoPath := \"../tests/repos/language_stats_repo\"\n+\tgitRepo, err := git.OpenRepository(t.Context(), repoPath)\n \trequire.NoError(t, err)\n-\n \tdefer gitRepo.Close()\n \n-\tstats, err := gitRepo.GetLanguageStats(\"8fee858da5796dfb37704761701bb8e800ad9ef3\")\n+\tstats, err := GetLanguageStats(gitRepo, \"8fee858da5796dfb37704761701bb8e800ad9ef3\")\n \trequire.NoError(t, err)\n \n \tassert.Equal(t, map[string]int64{\ndiff --git a/modules/git/languagestats/main_test.go b/modules/git/languagestats/main_test.go\nnew file mode 100644\nindex 0000000000000..707d268c818ef\n--- /dev/null\n+++ b/modules/git/languagestats/main_test.go\n@@ -0,0 +1,41 @@\n+// Copyright 2025 The Gitea Authors. All rights reserved.\n+// SPDX-License-Identifier: MIT\n+\n+package languagestats\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"testing\"\n+\n+\t\"code.gitea.io/gitea/modules/git\"\n+\t\"code.gitea.io/gitea/modules/setting\"\n+\t\"code.gitea.io/gitea/modules/util\"\n+)\n+\n+func testRun(m *testing.M) error {\n+\tgitHomePath, err := os.MkdirTemp(os.TempDir(), \"git-home\")\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"unable to create temp dir: %w\", err)\n+\t}\n+\tdefer util.RemoveAll(gitHomePath)\n+\tsetting.Git.HomePath = gitHomePath\n+\n+\tif err = git.InitFull(context.Background()); err != nil {\n+\t\treturn fmt.Errorf(\"failed to call Init: %w\", err)\n+\t}\n+\n+\texitCode := m.Run()\n+\tif exitCode != 0 {\n+\t\treturn fmt.Errorf(\"run test failed, ExitCode=%d\", exitCode)\n+\t}\n+\treturn nil\n+}\n+\n+func TestMain(m *testing.M) {\n+\tif err := testRun(m); err != nil {\n+\t\t_, _ = fmt.Fprintf(os.Stderr, \"Test failed: %v\", err)\n+\t\tos.Exit(1)\n+\t}\n+}\ndiff --git a/modules/git/tests/repos/language_stats_repo/config b/modules/git/tests/repos/language_stats_repo/config\nindex 515f4836297fd..a4ef456cbc233 100644\n--- a/modules/git/tests/repos/language_stats_repo/config\n+++ b/modules/git/tests/repos/language_stats_repo/config\n@@ -1,5 +1,5 @@\n [core]\n \trepositoryformatversion = 0\n \tfilemode = true\n-\tbare = false\n+\tbare = true\n \tlogallrefupdates = true\ndiff --git a/modules/git/tests/repos/repo3_notes/config b/modules/git/tests/repos/repo3_notes/config\nindex d545cdabdbdda..5ed22e23d15d7 100644\n--- a/modules/git/tests/repos/repo3_notes/config\n+++ b/modules/git/tests/repos/repo3_notes/config\n@@ -1,7 +1,7 @@\n [core]\n \trepositoryformatversion = 0\n \tfilemode = false\n-\tbare = false\n+\tbare = true\n \tlogallrefupdates = true\n \tsymlinks = false\n \tignorecase = true\ndiff --git a/modules/git/tests/repos/repo4_commitsbetween/config b/modules/git/tests/repos/repo4_commitsbetween/config\nindex d545cdabdbdda..5ed22e23d15d7 100644\n--- a/modules/git/tests/repos/repo4_commitsbetween/config\n+++ b/modules/git/tests/repos/repo4_commitsbetween/config\n@@ -1,7 +1,7 @@\n [core]\n \trepositoryformatversion = 0\n \tfilemode = false\n-\tbare = false\n+\tbare = true\n \tlogallrefupdates = true\n \tsymlinks = false\n \tignorecase = true\n"}
{"org": "gofiber", "repo": "fiber", "number": 3895, "state": "closed", "title": "⚡ perf: Improve performance of RebuildTree() by 68%", "body": "## Summary\r\n- This pull request focuses on improving the efficiency and memory management of the routing tree construction within the application. It refactors the buildTree function to simplify bucket allocation and ensure precise preallocation of data structures. Additionally, a new benchmark is added to track the performance of the tree rebuilding operation, providing a baseline for future optimizations.\r\n\r\n### Before\r\n\r\n```console\r\ngoos: linux\r\ngoarch: amd64\r\npkg: github.com/gofiber/fiber/v3\r\ncpu: AMD Ryzen 7 7800X3D 8-Core Processor           \r\nBenchmark_App_RebuildTree\r\nBenchmark_App_RebuildTree-4   \t   32095\t     37059 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   32386\t     37005 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   33099\t     36389 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   31860\t     36865 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   32568\t     37237 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   32446\t     36411 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   33307\t     36342 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   32185\t     36923 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   33567\t     36420 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   31746\t     36938 ns/op\t   26768 B/op\t     290 allocs/op\r\nPASS\r\nok  \tgithub.com/gofiber/fiber/v3\t11.972s\r\n```\r\n\r\n### After\r\n\r\n```console\r\ngoos: linux\r\ngoarch: amd64\r\npkg: github.com/gofiber/fiber/v3\r\ncpu: AMD Ryzen 7 7800X3D 8-Core Processor           \r\nBenchmark_App_RebuildTree\r\nBenchmark_App_RebuildTree-4   \t   88698\t     13380 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   87627\t     13122 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   89563\t     13367 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   90487\t     13846 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   83514\t     14268 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   81895\t     13929 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   84560\t     14110 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   81997\t     13364 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   87638\t     13045 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   91272\t     13427 ns/op\t   17952 B/op\t      93 allocs/op\r\nPASS\r\nok  \tgithub.com/gofiber/fiber/v3\t11.795s\r\n```\r\n\r\n### Benchstat\r\n\r\n```console\r\n$ go run golang.org/x/perf/cmd/benchstat@latest old.txt new.txt \r\ngoos: linux\r\ngoarch: amd64\r\npkg: github.com/gofiber/fiber/v3\r\ncpu: AMD Ryzen 7 7800X3D 8-Core Processor           \r\n                   │   old.txt   │               new.txt               │\r\n                   │   sec/op    │   sec/op     vs base                │\r\n_App_RebuildTree-4   36.89µ ± 1%   13.40µ ± 5%  -63.67% (p=0.000 n=10)\r\n\r\n                   │   old.txt    │               new.txt                │\r\n                   │     B/op     │     B/op      vs base                │\r\n_App_RebuildTree-4   26.14Ki ± 0%   17.53Ki ± 0%  -32.93% (p=0.000 n=10)\r\n\r\n                   │   old.txt   │              new.txt               │\r\n                   │  allocs/op  │ allocs/op   vs base                │\r\n_App_RebuildTree-4   290.00 ± 0%   93.00 ± 0%  -67.93% (p=0.000 n=10)\r\n```\r\n", "url": "https://api.github.com/repos/gofiber/fiber/pulls/3895", "id": 3038244364, "node_id": "PR_kwDODfYWS861F-4M", "html_url": "https://github.com/gofiber/fiber/pull/3895", "diff_url": "https://github.com/gofiber/fiber/pull/3895.diff", "patch_url": "https://github.com/gofiber/fiber/pull/3895.patch", "issue_url": "https://api.github.com/repos/gofiber/fiber/issues/3895", "created_at": "2025-11-24T02:46:25+00:00", "updated_at": "2025-11-24T12:11:23+00:00", "closed_at": "2025-11-24T12:11:11+00:00", "merged_at": "2025-11-24T12:11:11+00:00", "merge_commit_sha": "a477afdf84310dbc34f1ac9ec72ce2765cb7e004", "labels": ["🧹 Updates", "v3", "⚡️ Performance", "codex"], "draft": false, "commits_url": "https://api.github.com/repos/gofiber/fiber/pulls/3895/commits", "review_comments_url": "https://api.github.com/repos/gofiber/fiber/pulls/3895/comments", "review_comment_url": "https://api.github.com/repos/gofiber/fiber/pulls/comments{/number}", "comments_url": "https://api.github.com/repos/gofiber/fiber/issues/3895/comments", "base": {"label": "gofiber:main", "ref": "main", "sha": "5caa478c02c5eb6cd1c251ddc634ec0600e66a7b", "user": {"login": "gofiber", "id": 59947262, "node_id": "MDEyOk9yZ2FuaXphdGlvbjU5OTQ3MjYy", "avatar_url": "https://avatars.githubusercontent.com/u/59947262?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gofiber", "html_url": "https://github.com/gofiber", "followers_url": "https://api.github.com/users/gofiber/followers", "following_url": "https://api.github.com/users/gofiber/following{/other_user}", "gists_url": "https://api.github.com/users/gofiber/gists{/gist_id}", "starred_url": "https://api.github.com/users/gofiber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gofiber/subscriptions", "organizations_url": "https://api.github.com/users/gofiber/orgs", "repos_url": "https://api.github.com/users/gofiber/repos", "events_url": "https://api.github.com/users/gofiber/events{/privacy}", "received_events_url": "https://api.github.com/users/gofiber/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "repo": {"id": 234231371, "node_id": "MDEwOlJlcG9zaXRvcnkyMzQyMzEzNzE=", "name": "fiber", "full_name": "gofiber/fiber", "private": false, "owner": {"login": "gofiber", "id": 59947262, "node_id": "MDEyOk9yZ2FuaXphdGlvbjU5OTQ3MjYy", "avatar_url": "https://avatars.githubusercontent.com/u/59947262?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gofiber", "html_url": "https://github.com/gofiber", "followers_url": "https://api.github.com/users/gofiber/followers", "following_url": "https://api.github.com/users/gofiber/following{/other_user}", "gists_url": "https://api.github.com/users/gofiber/gists{/gist_id}", "starred_url": "https://api.github.com/users/gofiber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gofiber/subscriptions", "organizations_url": "https://api.github.com/users/gofiber/orgs", "repos_url": "https://api.github.com/users/gofiber/repos", "events_url": "https://api.github.com/users/gofiber/events{/privacy}", "received_events_url": "https://api.github.com/users/gofiber/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "html_url": "https://github.com/gofiber/fiber", "description": "⚡️ Express inspired web framework written in Go", "fork": false, "url": "https://api.github.com/repos/gofiber/fiber", "forks_url": "https://api.github.com/repos/gofiber/fiber/forks", "keys_url": "https://api.github.com/repos/gofiber/fiber/keys{/key_id}", "collaborators_url": "https://api.github.com/repos/gofiber/fiber/collaborators{/collaborator}", "teams_url": "https://api.github.com/repos/gofiber/fiber/teams", "hooks_url": "https://api.github.com/repos/gofiber/fiber/hooks", "issue_events_url": "https://api.github.com/repos/gofiber/fiber/issues/events{/number}", "events_url": "https://api.github.com/repos/gofiber/fiber/events", "assignees_url": "https://api.github.com/repos/gofiber/fiber/assignees{/user}", "branches_url": "https://api.github.com/repos/gofiber/fiber/branches{/branch}", "tags_url": "https://api.github.com/repos/gofiber/fiber/tags", "blobs_url": "https://api.github.com/repos/gofiber/fiber/git/blobs{/sha}", "git_tags_url": "https://api.github.com/repos/gofiber/fiber/git/tags{/sha}", "git_refs_url": "https://api.github.com/repos/gofiber/fiber/git/refs{/sha}", "trees_url": "https://api.github.com/repos/gofiber/fiber/git/trees{/sha}", "statuses_url": "https://api.github.com/repos/gofiber/fiber/statuses/{sha}", "languages_url": "https://api.github.com/repos/gofiber/fiber/languages", "stargazers_url": "https://api.github.com/repos/gofiber/fiber/stargazers", "contributors_url": "https://api.github.com/repos/gofiber/fiber/contributors", "subscribers_url": "https://api.github.com/repos/gofiber/fiber/subscribers", "subscription_url": "https://api.github.com/repos/gofiber/fiber/subscription", "commits_url": "https://api.github.com/repos/gofiber/fiber/commits{/sha}", "git_commits_url": "https://api.github.com/repos/gofiber/fiber/git/commits{/sha}", "comments_url": "https://api.github.com/repos/gofiber/fiber/comments{/number}", "issue_comment_url": "https://api.github.com/repos/gofiber/fiber/issues/comments{/number}", "contents_url": "https://api.github.com/repos/gofiber/fiber/contents/{+path}", "compare_url": "https://api.github.com/repos/gofiber/fiber/compare/{base}...{head}", "merges_url": "https://api.github.com/repos/gofiber/fiber/merges", "archive_url": "https://api.github.com/repos/gofiber/fiber/{archive_format}{/ref}", "downloads_url": "https://api.github.com/repos/gofiber/fiber/downloads", "issues_url": "https://api.github.com/repos/gofiber/fiber/issues{/number}", "pulls_url": "https://api.github.com/repos/gofiber/fiber/pulls{/number}", "milestones_url": "https://api.github.com/repos/gofiber/fiber/milestones{/number}", "notifications_url": "https://api.github.com/repos/gofiber/fiber/notifications{?since,all,participating}", "labels_url": "https://api.github.com/repos/gofiber/fiber/labels{/name}", "releases_url": "https://api.github.com/repos/gofiber/fiber/releases{/id}", "deployments_url": "https://api.github.com/repos/gofiber/fiber/deployments", "created_at": "2020-01-16T03:59:20Z", "updated_at": "2026-01-07T16:33:00Z", "pushed_at": "2026-01-07T14:22:10Z", "git_url": "git://github.com/gofiber/fiber.git", "ssh_url": "git@github.com:gofiber/fiber.git", "clone_url": "https://github.com/gofiber/fiber.git", "svn_url": "https://github.com/gofiber/fiber", "homepage": "https://gofiber.io", "size": 235074, "stargazers_count": 38919, "watchers_count": 38919, "language": "Go", "has_issues": true, "has_projects": true, "has_downloads": true, "has_wiki": false, "has_pages": true, "has_discussions": false, "forks_count": 1937, "mirror_url": null, "archived": false, "disabled": false, "open_issues_count": 73, "license": {"key": "mit", "name": "MIT License", "spdx_id": "MIT", "url": "https://api.github.com/licenses/mit", "node_id": "MDc6TGljZW5zZTEz"}, "allow_forking": true, "is_template": false, "web_commit_signoff_required": false, "topics": ["express", "expressjs", "fast", "fiber", "flexible", "framework", "friendly", "go", "golang", "hacktoberfest", "hacktoberfest2020", "nodejs", "performance", "rest-api", "web"], "visibility": "public", "forks": 1937, "open_issues": 73, "watchers": 38919, "default_branch": "main"}}, "commits": [{"sha": "ee1466ccc04f6df90b1f39d780a24227ec7c81fc", "parents": ["46651b0011ad28bde4b2f2ae54118fc08e64e8cc"], "message": "Add RebuildTree benchmark"}], "resolved_issues": [{"org": "gofiber", "repo": "fiber", "number": -1, "state": "unknown", "title": "⚡ perf: Improve performance of RebuildTree() by 68%", "body": "## Summary\r\n- This pull request focuses on improving the efficiency and memory management of the routing tree construction within the application. It refactors the buildTree function to simplify bucket allocation and ensure precise preallocation of data structures. Additionally, a new benchmark is added to track the performance of the tree rebuilding operation, providing a baseline for future optimizations.\r\n\r\n### Before\r\n\r\n```console\r\ngoos: linux\r\ngoarch: amd64\r\npkg: github.com/gofiber/fiber/v3\r\ncpu: AMD Ryzen 7 7800X3D 8-Core Processor           \r\nBenchmark_App_RebuildTree\r\nBenchmark_App_RebuildTree-4   \t   32095\t     37059 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   32386\t     37005 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   33099\t     36389 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   31860\t     36865 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   32568\t     37237 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   32446\t     36411 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   33307\t     36342 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   32185\t     36923 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   33567\t     36420 ns/op\t   26768 B/op\t     290 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   31746\t     36938 ns/op\t   26768 B/op\t     290 allocs/op\r\nPASS\r\nok  \tgithub.com/gofiber/fiber/v3\t11.972s\r\n```\r\n\r\n### After\r\n\r\n```console\r\ngoos: linux\r\ngoarch: amd64\r\npkg: github.com/gofiber/fiber/v3\r\ncpu: AMD Ryzen 7 7800X3D 8-Core Processor           \r\nBenchmark_App_RebuildTree\r\nBenchmark_App_RebuildTree-4   \t   88698\t     13380 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   87627\t     13122 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   89563\t     13367 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   90487\t     13846 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   83514\t     14268 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   81895\t     13929 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   84560\t     14110 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   81997\t     13364 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   87638\t     13045 ns/op\t   17952 B/op\t      93 allocs/op\r\nBenchmark_App_RebuildTree-4   \t   91272\t     13427 ns/op\t   17952 B/op\t      93 allocs/op\r\nPASS\r\nok  \tgithub.com/gofiber/fiber/v3\t11.795s\r\n```\r\n\r\n### Benchstat\r\n\r\n```console\r\n$ go run golang.org/x/perf/cmd/benchstat@latest old.txt new.txt \r\ngoos: linux\r\ngoarch: amd64\r\npkg: github.com/gofiber/fiber/v3\r\ncpu: AMD Ryzen 7 7800X3D 8-Core Processor           \r\n                   │   old.txt   │               new.txt               │\r\n                   │   sec/op    │   sec/op     vs base                │\r\n_App_RebuildTree-4   36.89µ ± 1%   13.40µ ± 5%  -63.67% (p=0.000 n=10)\r\n\r\n                   │   old.txt    │               new.txt                │\r\n                   │     B/op     │     B/op      vs base                │\r\n_App_RebuildTree-4   26.14Ki ± 0%   17.53Ki ± 0%  -32.93% (p=0.000 n=10)\r\n\r\n                   │   old.txt   │              new.txt               │\r\n                   │  allocs/op  │ allocs/op   vs base                │\r\n_App_RebuildTree-4   290.00 ± 0%   93.00 ± 0%  -67.93% (p=0.000 n=10)\r\n```\r\n"}], "fix_patch": "diff --git a/router.go b/router.go\nindex 917b7b1f33..a333b4a0ab 100644\n--- a/router.go\n+++ b/router.go\n@@ -710,52 +710,47 @@ func (app *App) buildTree() *App {\n \n \t// 1) First loop: determine all possible 3-char prefixes (\"treePaths\") for each method\n \tfor method := range app.config.RequestMethods {\n-\t\tprefixSet := map[int]struct{}{\n-\t\t\t0: {},\n-\t\t}\n-\t\tfor _, route := range app.stack[method] {\n+\t\troutes := app.stack[method]\n+\t\ttreePaths := make([]int, len(routes))\n+\n+\t\tglobalCount := 0\n+\t\tprefixCounts := make(map[int]int, len(routes))\n+\n+\t\tfor i, route := range routes {\n \t\t\tif len(route.routeParser.segs) > 0 && len(route.routeParser.segs[0].Const) >= maxDetectionPaths {\n-\t\t\t\tprefix := int(route.routeParser.segs[0].Const[0])<<16 |\n+\t\t\t\ttreePaths[i] = int(route.routeParser.segs[0].Const[0])<<16 |\n \t\t\t\t\tint(route.routeParser.segs[0].Const[1])<<8 |\n \t\t\t\t\tint(route.routeParser.segs[0].Const[2])\n-\t\t\t\tprefixSet[prefix] = struct{}{}\n \t\t\t}\n+\n+\t\t\tif treePaths[i] == 0 {\n+\t\t\t\tglobalCount++\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tprefixCounts[treePaths[i]]++\n \t\t}\n-\t\ttsMap := make(map[int][]*Route, len(prefixSet))\n-\t\tfor prefix := range prefixSet {\n-\t\t\ttsMap[prefix] = nil\n+\n+\t\ttsMap := make(map[int][]*Route, len(prefixCounts)+1)\n+\t\ttsMap[0] = make([]*Route, 0, globalCount)\n+\t\tfor treePath, count := range prefixCounts {\n+\t\t\ttsMap[treePath] = make([]*Route, 0, count+globalCount)\n \t\t}\n-\t\tapp.treeStack[method] = tsMap\n-\t}\n \n-\t// 2) Second loop: for each method and each discovered treePath, assign matching routes\n-\tfor method := range app.config.RequestMethods {\n-\t\t// get the map of buckets for this method\n-\t\ttsMap := app.treeStack[method]\n-\n-\t\t// for every treePath key (including the empty one)\n-\t\tfor treePath := range tsMap {\n-\t\t\t// iterate all routes of this method\n-\t\t\tfor _, route := range app.stack[method] {\n-\t\t\t\t// compute this route's own prefix (\"\" or first 3 chars)\n-\t\t\t\troutePath := 0\n-\t\t\t\tif len(route.routeParser.segs) > 0 && len(route.routeParser.segs[0].Const) >= 3 {\n-\t\t\t\t\troutePath = int(route.routeParser.segs[0].Const[0])<<16 |\n-\t\t\t\t\t\tint(route.routeParser.segs[0].Const[1])<<8 |\n-\t\t\t\t\t\tint(route.routeParser.segs[0].Const[2])\n-\t\t\t\t}\n+\t\tfor i, route := range routes {\n+\t\t\ttreePath := treePaths[i]\n \n-\t\t\t\t// if it's a global route, assign to every bucket\n-\t\t\t\t// If the route path is 0 (global route) or matches the current tree path,\n-\t\t\t\t// append this route to the current bucket\n-\t\t\t\tif routePath == 0 || routePath == treePath {\n-\t\t\t\t\ttsMap[treePath] = append(tsMap[treePath], route)\n+\t\t\tif treePath == 0 {\n+\t\t\t\tfor bucket := range tsMap {\n+\t\t\t\t\ttsMap[bucket] = append(tsMap[bucket], route)\n \t\t\t\t}\n+\t\t\t\tcontinue\n \t\t\t}\n \n-\t\t\t// after collecting, dedupe the bucket if it's not the global one\n-\t\t\ttsMap[treePath] = uniqueRouteStack(tsMap[treePath])\n+\t\t\ttsMap[treePath] = append(tsMap[treePath], route)\n \t\t}\n+\n+\t\tapp.treeStack[method] = tsMap\n \t}\n \n \t// reset the flag and return\n", "test_patch": "diff --git a/router_test.go b/router_test.go\nindex 6ad70ccbc7..9cbaa31ef0 100644\n--- a/router_test.go\n+++ b/router_test.go\n@@ -1454,6 +1454,20 @@ func registerDummyRoutes(app *App) {\n \t}\n }\n \n+// go test -v -run=^$ -bench=Benchmark_App_RebuildTree -benchmem -count=4\n+func Benchmark_App_RebuildTree(b *testing.B) {\n+\tapp := New()\n+\tregisterDummyRoutes(app)\n+\n+\tb.ReportAllocs()\n+\tb.ResetTimer()\n+\n+\tfor b.Loop() {\n+\t\tapp.routesRefreshed = true\n+\t\tapp.RebuildTree()\n+\t}\n+}\n+\n // go test -v -run=^$ -bench=Benchmark_App_MethodNotAllowed -benchmem -count=4\n func Benchmark_App_MethodNotAllowed(b *testing.B) {\n \tapp := New()\n"}
