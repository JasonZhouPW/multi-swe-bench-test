{"org": "ipfs", "repo": "kubo", "number": 11031, "state": "closed", "title": "feat(provider): resume cycle", "body": "Depends on https://github.com/libp2p/go-libp2p-kad-dht/pull/1170/\r\n\r\nNew features:\r\n* Detect all keyspace regions that weren't reprovided in the last `ReprovideInterval` and add them to the reprovide queue\r\n  * On a fresh start with a non-empty repo, it means that all CIDs matching provide strategy will be provided ASAP\r\n  * If offline for X hours, it means that the regions that were supposed to be reprovided during these X hours haven't been reprovided. On restart, these regions are added to the reprovide queue to be reprovided ASAP.\r\n * Resume reprovide cycle\r\n   * If kubo ran for 2h, and reprovided the first regions of the cycle, then stopped and started again it would continue to cycle that was started in the initial run.\r\n   * Previously it would start again from the start of the cycle, meaning that CIDs matching regions by the end of the cycle would only be provided if node was online for a full cycle.\r\n * Persist provide queue\r\n   * On provider shutdown, the provide queue is persisted to the datastore (unless empty)\r\n   * On provider start, we load any CIDs that were in the provide queue during the last run, and put them back in the provide queue, so that they are provided consistently\r\n * ~`ipfs daemon --provider-fresh-start`~ changed to a config Flag \r\n   * flag to disable resuming the reprovide cycle and loading provide queue items from datastore\r\n   * Disabled by default (default is to resume the reprovide cycle)\r\n\r\n## Example\r\n\r\n* Reprovide Interval: `22h`\r\n\r\n1. Start kubo\r\n2. Add many CIDs.\r\n3. Let it run for 26h (22h+4h).\r\n    * All CIDs are provided once, after being added\r\n    * All CIDs are reprovided according to keyspace region schedule during the first reprovide cycle\r\n    * In the second reprovide cycle, only the regions scheduled in the first 4h of the cycle will be reprovided\r\n5. Shutdown kubo for 6h\r\n6. Start again kubo\r\n    * All keyspace regions that were scheduled between 4h and 10h in the reprovide cycle are added to the reprovide queue, to be reprovided ASAP\r\n    * The reprovide cycle continues with an offset of 10h (4h in the cycle before shutdown + 6h down = 10h into the cycle)\r\n    * If any CIDs were in the provide queue during shutdown, they are put back to the provide queue on restart (persisted from datastore)\r\n\r\n## Checklist\r\n\r\n- [x] Merge https://github.com/libp2p/go-libp2p-kad-dht/pull/1170/\r\n- [x] Merge https://github.com/libp2p/go-libp2p-kad-dht/pull/1176\r\n- [x] Depend on latest `go-libp2p-kad-dht:master`", "url": "https://api.github.com/repos/ipfs/kubo/pulls/11031", "id": 2934675944, "node_id": "PR_kwDOAUP-J86u65no", "html_url": "https://github.com/ipfs/kubo/pull/11031", "diff_url": "https://github.com/ipfs/kubo/pull/11031.diff", "patch_url": "https://github.com/ipfs/kubo/pull/11031.patch", "issue_url": "https://api.github.com/repos/ipfs/kubo/issues/11031", "created_at": "2025-10-21T20:00:31+00:00", "updated_at": "2025-10-29T10:07:49+00:00", "closed_at": "2025-10-29T10:07:46+00:00", "merged_at": "2025-10-29T10:07:46+00:00", "merge_commit_sha": "c2bf0f9515040b83c09072f30032390c8fa6b5f1", "labels": [], "draft": false, "commits_url": "https://api.github.com/repos/ipfs/kubo/pulls/11031/commits", "review_comments_url": "https://api.github.com/repos/ipfs/kubo/pulls/11031/comments", "review_comment_url": "https://api.github.com/repos/ipfs/kubo/pulls/comments{/number}", "comments_url": "https://api.github.com/repos/ipfs/kubo/issues/11031/comments", "base": {"label": "ipfs:master", "ref": "master", "sha": "2e9c4ec5002353d78ff43636337b58bd87130245", "user": {"login": "ipfs", "id": 10536621, "node_id": "MDEyOk9yZ2FuaXphdGlvbjEwNTM2NjIx", "avatar_url": "https://avatars.githubusercontent.com/u/10536621?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ipfs", "html_url": "https://github.com/ipfs", "followers_url": "https://api.github.com/users/ipfs/followers", "following_url": "https://api.github.com/users/ipfs/following{/other_user}", "gists_url": "https://api.github.com/users/ipfs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ipfs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ipfs/subscriptions", "organizations_url": "https://api.github.com/users/ipfs/orgs", "repos_url": "https://api.github.com/users/ipfs/repos", "events_url": "https://api.github.com/users/ipfs/events{/privacy}", "received_events_url": "https://api.github.com/users/ipfs/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "repo": {"id": 21233191, "node_id": "MDEwOlJlcG9zaXRvcnkyMTIzMzE5MQ==", "name": "kubo", "full_name": "ipfs/kubo", "private": false, "owner": {"login": "ipfs", "id": 10536621, "node_id": "MDEyOk9yZ2FuaXphdGlvbjEwNTM2NjIx", "avatar_url": "https://avatars.githubusercontent.com/u/10536621?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ipfs", "html_url": "https://github.com/ipfs", "followers_url": "https://api.github.com/users/ipfs/followers", "following_url": "https://api.github.com/users/ipfs/following{/other_user}", "gists_url": "https://api.github.com/users/ipfs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ipfs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ipfs/subscriptions", "organizations_url": "https://api.github.com/users/ipfs/orgs", "repos_url": "https://api.github.com/users/ipfs/repos", "events_url": "https://api.github.com/users/ipfs/events{/privacy}", "received_events_url": "https://api.github.com/users/ipfs/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "html_url": "https://github.com/ipfs/kubo", "description": "An IPFS implementation in Go", "fork": false, "url": "https://api.github.com/repos/ipfs/kubo", "forks_url": "https://api.github.com/repos/ipfs/kubo/forks", "keys_url": "https://api.github.com/repos/ipfs/kubo/keys{/key_id}", "collaborators_url": "https://api.github.com/repos/ipfs/kubo/collaborators{/collaborator}", "teams_url": "https://api.github.com/repos/ipfs/kubo/teams", "hooks_url": "https://api.github.com/repos/ipfs/kubo/hooks", "issue_events_url": "https://api.github.com/repos/ipfs/kubo/issues/events{/number}", "events_url": "https://api.github.com/repos/ipfs/kubo/events", "assignees_url": "https://api.github.com/repos/ipfs/kubo/assignees{/user}", "branches_url": "https://api.github.com/repos/ipfs/kubo/branches{/branch}", "tags_url": "https://api.github.com/repos/ipfs/kubo/tags", "blobs_url": "https://api.github.com/repos/ipfs/kubo/git/blobs{/sha}", "git_tags_url": "https://api.github.com/repos/ipfs/kubo/git/tags{/sha}", "git_refs_url": "https://api.github.com/repos/ipfs/kubo/git/refs{/sha}", "trees_url": "https://api.github.com/repos/ipfs/kubo/git/trees{/sha}", "statuses_url": "https://api.github.com/repos/ipfs/kubo/statuses/{sha}", "languages_url": "https://api.github.com/repos/ipfs/kubo/languages", "stargazers_url": "https://api.github.com/repos/ipfs/kubo/stargazers", "contributors_url": "https://api.github.com/repos/ipfs/kubo/contributors", "subscribers_url": "https://api.github.com/repos/ipfs/kubo/subscribers", "subscription_url": "https://api.github.com/repos/ipfs/kubo/subscription", "commits_url": "https://api.github.com/repos/ipfs/kubo/commits{/sha}", "git_commits_url": "https://api.github.com/repos/ipfs/kubo/git/commits{/sha}", "comments_url": "https://api.github.com/repos/ipfs/kubo/comments{/number}", "issue_comment_url": "https://api.github.com/repos/ipfs/kubo/issues/comments{/number}", "contents_url": "https://api.github.com/repos/ipfs/kubo/contents/{+path}", "compare_url": "https://api.github.com/repos/ipfs/kubo/compare/{base}...{head}", "merges_url": "https://api.github.com/repos/ipfs/kubo/merges", "archive_url": "https://api.github.com/repos/ipfs/kubo/{archive_format}{/ref}", "downloads_url": "https://api.github.com/repos/ipfs/kubo/downloads", "issues_url": "https://api.github.com/repos/ipfs/kubo/issues{/number}", "pulls_url": "https://api.github.com/repos/ipfs/kubo/pulls{/number}", "milestones_url": "https://api.github.com/repos/ipfs/kubo/milestones{/number}", "notifications_url": "https://api.github.com/repos/ipfs/kubo/notifications{?since,all,participating}", "labels_url": "https://api.github.com/repos/ipfs/kubo/labels{/name}", "releases_url": "https://api.github.com/repos/ipfs/kubo/releases{/id}", "deployments_url": "https://api.github.com/repos/ipfs/kubo/deployments", "created_at": "2014-06-26T08:14:34Z", "updated_at": "2026-01-07T06:50:52Z", "pushed_at": "2026-01-07T07:41:28Z", "git_url": "git://github.com/ipfs/kubo.git", "ssh_url": "git@github.com:ipfs/kubo.git", "clone_url": "https://github.com/ipfs/kubo.git", "svn_url": "https://github.com/ipfs/kubo", "homepage": "https://docs.ipfs.tech/how-to/command-line-quick-start/", "size": 58609, "stargazers_count": 16869, "watchers_count": 16869, "language": "Go", "has_issues": true, "has_projects": false, "has_downloads": true, "has_wiki": true, "has_pages": false, "has_discussions": false, "forks_count": 3145, "mirror_url": null, "archived": false, "disabled": false, "open_issues_count": 1057, "license": {"key": "other", "name": "Other", "spdx_id": "NOASSERTION", "url": null, "node_id": "MDc6TGljZW5zZTA="}, "allow_forking": true, "is_template": false, "web_commit_signoff_required": false, "topics": ["ipfs"], "visibility": "public", "forks": 3145, "open_issues": 1057, "watchers": 16869, "default_branch": "master"}}, "commits": [{"sha": "d5aaad6f126451281885363de09c188688849987", "parents": ["f9dc7399334df37fcda50b60b608c419b5ebc412"], "message": "bump kad-dht: resume reprovide cycle"}, {"sha": "3797ce22f40840aef02c538077ad510f268f232a", "parents": ["d5aaad6f126451281885363de09c188688849987"], "message": "daemon: --provide-fresh-start flag"}, {"sha": "a2d510f4984224d542538af6b011314288e88429", "parents": ["3797ce22f40840aef02c538077ad510f268f232a"], "message": "changelog"}, {"sha": "378f9a1030cc28ad3eff15a40a7dd5b79f924280", "parents": ["a2d510f4984224d542538af6b011314288e88429"], "message": "docs"}, {"sha": "9bc34cbe1beb4ab72d49d0c7c8f8fec32a36879d", "parents": ["378f9a1030cc28ad3eff15a40a7dd5b79f924280"], "message": "go-fmt"}, {"sha": "cde29699e9a9b8132746635ed9c5355595b359a3", "parents": ["9bc34cbe1beb4ab72d49d0c7c8f8fec32a36879d"], "message": "chore: latest go-libp2p-kad-dht#1170\n\nafter conflict resolution, to confirm CI is still green"}, {"sha": "4b200e3a62d46583053cc6b791d79b8f911ed550", "parents": ["cde29699e9a9b8132746635ed9c5355595b359a3"], "message": "kad-dht: depend on latest master"}, {"sha": "062b74d37c2b09b7ad459521bc6ae7a33037001d", "parents": ["4b200e3a62d46583053cc6b791d79b8f911ed550"], "message": "move daemon flag to Provider.DHT.ResumeEnabled config"}, {"sha": "5eae6dd8cdbe21592b5a90aec33ca266a2cdece3", "parents": ["062b74d37c2b09b7ad459521bc6ae7a33037001d"], "message": "refactor: sweep provider datastore"}, {"sha": "fc32e72bc46678697b80bc6850d835791b3aa279", "parents": ["5eae6dd8cdbe21592b5a90aec33ca266a2cdece3"], "message": "bump kad-dht"}, {"sha": "2141c898dadadd7f8fbea12e9c13edb575d7458c", "parents": ["fc32e72bc46678697b80bc6850d835791b3aa279", "16479ec6922bcfc9e90c8042788d239b03337e78"], "message": "Merge branch 'master' into resume-reprovide-cycle"}, {"sha": "708bcb8c9106f5c486ee1b162074b0d52f770898", "parents": ["2141c898dadadd7f8fbea12e9c13edb575d7458c"], "message": "bump kad-dht"}, {"sha": "957589366a2c489a1b37643015cacbe1312b79b7", "parents": ["708bcb8c9106f5c486ee1b162074b0d52f770898"], "message": "bump kad-dht"}, {"sha": "ec0646a407555858834e6d2c0c9d157c056af120", "parents": ["957589366a2c489a1b37643015cacbe1312b79b7", "886ac220050284a6a922cf4f18b984740283c259"], "message": "Merge branch 'master' into resume-reprovide-cycle"}, {"sha": "a9717ca313b4b98b952fbc499b90c6d663ed376e", "parents": ["ec0646a407555858834e6d2c0c9d157c056af120"], "message": "make datastore keys constant"}, {"sha": "64c7b1f80c9412bab7e6a9928fe43d6c9bf3b0de", "parents": ["a9717ca313b4b98b952fbc499b90c6d663ed376e"], "message": "use kad-dht master"}, {"sha": "38508101cbf320527d9b9d8ea08987612b2b5c3f", "parents": ["64c7b1f80c9412bab7e6a9928fe43d6c9bf3b0de", "ae78c7821c98b00438b2cb32c5699a40276299b7"], "message": "Merge branch 'master' into resume-reprovide-cycle"}, {"sha": "5a0fc5c463812a1262b78e0622cf798ee89585ea", "parents": ["38508101cbf320527d9b9d8ea08987612b2b5c3f"], "message": "add emoji to changelog entry"}, {"sha": "ea5a2eb8112c7793b72879d7c2fa73b05614dcfa", "parents": ["5a0fc5c463812a1262b78e0622cf798ee89585ea"], "message": "go-fmt"}, {"sha": "c36469802e3a87e094b2ba317496c2b8e2ee5773", "parents": ["ea5a2eb8112c7793b72879d7c2fa73b05614dcfa"], "message": "bump kad-dht"}, {"sha": "db6780372a44a59fcccbb26a8c41eef192d0b448", "parents": ["c36469802e3a87e094b2ba317496c2b8e2ee5773"], "message": "test(provider): add tests for resume cycle feature\n\nvalidates Provide.DHT.ResumeEnabled behavior:\n- preserves cycle state when enabled (default)\n- resets cycle when disabled\n\ntests verify current_time_offset across restarts using JSON output"}, {"sha": "01bf6cfaccc00ae542f339f0e714e9e3b8232aa1", "parents": ["db6780372a44a59fcccbb26a8c41eef192d0b448", "2e9c4ec5002353d78ff43636337b58bd87130245"], "message": "merge origin/master"}], "resolved_issues": [{"org": "ipfs", "repo": "kubo", "number": -1, "state": "unknown", "title": "feat(provider): resume cycle", "body": "Depends on https://github.com/libp2p/go-libp2p-kad-dht/pull/1170/\r\n\r\nNew features:\r\n* Detect all keyspace regions that weren't reprovided in the last `ReprovideInterval` and add them to the reprovide queue\r\n  * On a fresh start with a non-empty repo, it means that all CIDs matching provide strategy will be provided ASAP\r\n  * If offline for X hours, it means that the regions that were supposed to be reprovided during these X hours haven't been reprovided. On restart, these regions are added to the reprovide queue to be reprovided ASAP.\r\n * Resume reprovide cycle\r\n   * If kubo ran for 2h, and reprovided the first regions of the cycle, then stopped and started again it would continue to cycle that was started in the initial run.\r\n   * Previously it would start again from the start of the cycle, meaning that CIDs matching regions by the end of the cycle would only be provided if node was online for a full cycle.\r\n * Persist provide queue\r\n   * On provider shutdown, the provide queue is persisted to the datastore (unless empty)\r\n   * On provider start, we load any CIDs that were in the provide queue during the last run, and put them back in the provide queue, so that they are provided consistently\r\n * ~`ipfs daemon --provider-fresh-start`~ changed to a config Flag \r\n   * flag to disable resuming the reprovide cycle and loading provide queue items from datastore\r\n   * Disabled by default (default is to resume the reprovide cycle)\r\n\r\n## Example\r\n\r\n* Reprovide Interval: `22h`\r\n\r\n1. Start kubo\r\n2. Add many CIDs.\r\n3. Let it run for 26h (22h+4h).\r\n    * All CIDs are provided once, after being added\r\n    * All CIDs are reprovided according to keyspace region schedule during the first reprovide cycle\r\n    * In the second reprovide cycle, only the regions scheduled in the first 4h of the cycle will be reprovided\r\n5. Shutdown kubo for 6h\r\n6. Start again kubo\r\n    * All keyspace regions that were scheduled between 4h and 10h in the reprovide cycle are added to the reprovide queue, to be reprovided ASAP\r\n    * The reprovide cycle continues with an offset of 10h (4h in the cycle before shutdown + 6h down = 10h into the cycle)\r\n    * If any CIDs were in the provide queue during shutdown, they are put back to the provide queue on restart (persisted from datastore)\r\n\r\n## Checklist\r\n\r\n- [x] Merge https://github.com/libp2p/go-libp2p-kad-dht/pull/1170/\r\n- [x] Merge https://github.com/libp2p/go-libp2p-kad-dht/pull/1176\r\n- [x] Depend on latest `go-libp2p-kad-dht:master`"}], "fix_patch": "diff --git a/config/provide.go b/config/provide.go\nindex 9d3f24ccbd4..fd72c057641 100644\n--- a/config/provide.go\n+++ b/config/provide.go\n@@ -16,6 +16,7 @@ const (\n \tDefaultProvideDHTInterval                 = 22 * time.Hour // https://github.com/ipfs/kubo/pull/9326\n \tDefaultProvideDHTMaxWorkers               = 16             // Unified default for both sweep and legacy providers\n \tDefaultProvideDHTSweepEnabled             = false\n+\tDefaultProvideDHTResumeEnabled            = true\n \tDefaultProvideDHTDedicatedPeriodicWorkers = 2\n \tDefaultProvideDHTDedicatedBurstWorkers    = 1\n \tDefaultProvideDHTMaxProvideConnsPerWorker = 20\n@@ -86,6 +87,12 @@ type ProvideDHT struct {\n \t// OfflineDelay sets the delay after which the provider switches from Disconnected to Offline state (sweep mode only).\n \t// Default: DefaultProvideDHTOfflineDelay\n \tOfflineDelay *OptionalDuration `json:\",omitempty\"`\n+\n+\t// ResumeEnabled controls whether the provider resumes from its previous state on restart.\n+\t// When enabled, the provider persists its reprovide cycle state and provide queue to the datastore,\n+\t// and restores them on restart. When disabled, the provider starts fresh on each restart.\n+\t// Default: true\n+\tResumeEnabled Flag `json:\",omitempty\"`\n }\n \n func ParseProvideStrategy(s string) ProvideStrategy {\ndiff --git a/core/node/provider.go b/core/node/provider.go\nindex ef17057e5f7..52de235c8b4 100644\n--- a/core/node/provider.go\n+++ b/core/node/provider.go\n@@ -14,6 +14,7 @@ import (\n \t\"github.com/ipfs/boxo/provider\"\n \t\"github.com/ipfs/go-cid\"\n \t\"github.com/ipfs/go-datastore\"\n+\t\"github.com/ipfs/go-datastore/namespace\"\n \t\"github.com/ipfs/go-datastore/query\"\n \t\"github.com/ipfs/kubo/config\"\n \t\"github.com/ipfs/kubo/repo\"\n@@ -36,14 +37,21 @@ import (\n \t\"go.uber.org/fx\"\n )\n \n-// The size of a batch that will be used for calculating average announcement\n-// time per CID, inside of boxo/provider.ThroughputReport\n-// and in 'ipfs stats provide' report.\n-// Used when Provide.DHT.SweepEnabled=false\n-const sampledBatchSize = 1000\n+const (\n+\t// The size of a batch that will be used for calculating average announcement\n+\t// time per CID, inside of boxo/provider.ThroughputReport\n+\t// and in 'ipfs stats provide' report.\n+\t// Used when Provide.DHT.SweepEnabled=false\n+\tsampledBatchSize = 1000\n \n-// Datastore key used to store previous reprovide strategy.\n-const reprovideStrategyKey = \"/reprovideStrategy\"\n+\t// Datastore key used to store previous reprovide strategy.\n+\treprovideStrategyKey = \"/reprovideStrategy\"\n+\n+\t// Datastore namespace prefix for provider data.\n+\tproviderDatastorePrefix = \"provider\"\n+\t// Datastore path for the provider keystore.\n+\tkeystoreDatastorePath = \"keystore\"\n+)\n \n // Interval between reprovide queue monitoring checks for slow reprovide alerts.\n // Used when Provide.DHT.SweepEnabled=true\n@@ -324,10 +332,10 @@ func SweepingProviderOpt(cfg *config.Config) fx.Option {\n \t\tRepo repo.Repo\n \t}\n \tsweepingReprovider := fx.Provide(func(in providerInput) (DHTProvider, *keystore.ResettableKeystore, error) {\n-\t\tds := in.Repo.Datastore()\n+\t\tds := namespace.Wrap(in.Repo.Datastore(), datastore.NewKey(providerDatastorePrefix))\n \t\tks, err := keystore.NewResettableKeystore(ds,\n \t\t\tkeystore.WithPrefixBits(16),\n-\t\t\tkeystore.WithDatastorePath(\"/provider/keystore\"),\n+\t\t\tkeystore.WithDatastorePath(keystoreDatastorePath),\n \t\t\tkeystore.WithBatchSize(int(cfg.Provide.DHT.KeystoreBatchSize.WithDefault(config.DefaultProvideDHTKeystoreBatchSize))),\n \t\t)\n \t\tif err != nil {\n@@ -370,6 +378,8 @@ func SweepingProviderOpt(cfg *config.Config) fx.Option {\n \t\t\tif inDht != nil {\n \t\t\t\tprov, err := ddhtprovider.New(inDht,\n \t\t\t\t\tddhtprovider.WithKeystore(ks),\n+\t\t\t\t\tddhtprovider.WithDatastore(ds),\n+\t\t\t\t\tddhtprovider.WithResumeCycle(cfg.Provide.DHT.ResumeEnabled.WithDefault(config.DefaultProvideDHTResumeEnabled)),\n \n \t\t\t\t\tddhtprovider.WithReprovideInterval(reprovideInterval),\n \t\t\t\t\tddhtprovider.WithMaxReprovideDelay(time.Hour),\n@@ -403,6 +413,8 @@ func SweepingProviderOpt(cfg *config.Config) fx.Option {\n \t\t}\n \t\topts := []dhtprovider.Option{\n \t\t\tdhtprovider.WithKeystore(ks),\n+\t\t\tdhtprovider.WithDatastore(ds),\n+\t\t\tdhtprovider.WithResumeCycle(cfg.Provide.DHT.ResumeEnabled.WithDefault(config.DefaultProvideDHTResumeEnabled)),\n \t\t\tdhtprovider.WithPeerID(impl.Host().ID()),\n \t\t\tdhtprovider.WithRouter(impl),\n \t\t\tdhtprovider.WithMessageSender(impl.MessageSender()),\n@@ -576,7 +588,7 @@ func SweepingProviderOpt(cfg *config.Config) fx.Option {\n \n \t\t\t\t\t\tstats := prov.Stats()\n \t\t\t\t\t\tqueuedWorkers = stats.Workers.QueuedPeriodic > 0\n-\t\t\t\t\t\tqueueSize = stats.Queues.PendingRegionReprovides\n+\t\t\t\t\t\tqueueSize = int64(stats.Queues.PendingRegionReprovides)\n \n \t\t\t\t\t\t// Alert if reprovide queue keeps growing and all periodic workers are busy.\n \t\t\t\t\t\t// Requires consecutiveAlertsThreshold intervals of sustained growth.\ndiff --git a/docs/changelogs/v0.39.md b/docs/changelogs/v0.39.md\nindex d5cfe876da4..60a0a05601b 100644\n--- a/docs/changelogs/v0.39.md\n+++ b/docs/changelogs/v0.39.md\n@@ -11,6 +11,7 @@ This release was brought to you by the [Shipyard](https://ipshipyard.com/) team.\n - [Overview](#overview)\n - [ðŸ”¦ Highlights](#-highlights)\n   - [ðŸ“Š Detailed statistics for Sweep provider with `ipfs provide stat`](#-detailed-statistics-for-sweep-provider-with-ipfs-provide-stat)\n+  - [â¯ï¸ Provider resume cycle for improved reproviding reliability](#provider-resume-cycle-for-improved-reproviding-reliability)\n   - [ðŸ”” Sweep provider slow reprovide warnings](#-sweep-provider-slow-reprovide-warnings)\n   - [ðŸ”§ Fixed UPnP port forwarding after router restarts](#-fixed-upnp-port-forwarding-after-router-restarts)\n   - [ðŸ–¥ï¸ RISC-V support with prebuilt binaries](#ï¸-risc-v-support-with-prebuilt-binaries)\n@@ -64,6 +65,30 @@ provider statistics instead of the default WAN DHT stats.\n > [`Provide.DHT.SweepEnabled`](https://github.com/ipfs/kubo/blob/master/docs/config.md#providedhtsweepenabled)).\n > Legacy provider shows basic statistics without flag support.\n \n+#### â¯ï¸ Provider resume cycle for improved reproviding reliability\n+\n+When using the sweeping provider (`Provide.DHT.SweepEnabled`), Kubo now\n+persists the reprovide cycle state and automatically resumes where it left off\n+after a restart. This brings several improvements:\n+\n+- **Persistent progress**: The provider now saves its position in the reprovide\n+cycle to the datastore. On restart, it continues from where it stopped instead\n+of starting from scratch.\n+- **Catch-up reproviding**: If the node was offline for an extended period, all\n+CIDs that haven't been reprovided within the configured reprovide interval are\n+immediately queued for reproviding when the node starts up. This ensures\n+content availability is maintained even after downtime.\n+- **Persistent provide queue**: The provide queue is now persisted to the\n+datastore on shutdown. When the node restarts, queued CIDs are restored and\n+provided as expected, preventing loss of pending provide operations.\n+- **Resume control**: The resume behavior is now controlled via the\n+`Provide.DHT.ResumeEnabled` config option (default: `true`). If you don't want\n+to keep the persisted provider state from a previous run, you can set\n+`Provide.DHT.ResumeEnabled=false` in your config.\n+\n+This feature significantly improves the reliability of content providing,\n+especially for nodes that experience intermittent connectivity or restarts.\n+\n #### ðŸ”” Sweep provider slow reprovide warnings\n \n Kubo now monitors DHT reprovide operations when `Provide.DHT.SweepEnabled=true`\ndiff --git a/docs/config.md b/docs/config.md\nindex 1c3f7f24ccb..8e0eb4dd550 100644\n--- a/docs/config.md\n+++ b/docs/config.md\n@@ -132,6 +132,7 @@ config file at runtime.\n       - [`Provide.DHT.MaxWorkers`](#providedhtmaxworkers)\n       - [`Provide.DHT.Interval`](#providedhtinterval)\n       - [`Provide.DHT.SweepEnabled`](#providedhtsweepenabled)\n+      - [`Provide.DHT.ResumeEnabled`](#providedhtresumeenabled)\n       - [`Provide.DHT.DedicatedPeriodicWorkers`](#providedhtdedicatedperiodicworkers)\n       - [`Provide.DHT.DedicatedBurstWorkers`](#providedhtdedicatedburstworkers)\n       - [`Provide.DHT.MaxProvideConnsPerWorker`](#providedhtmaxprovideconnsperworker)\n@@ -2139,6 +2140,17 @@ gets batched by keyspace region. The keystore is periodically refreshed at each\n [`Provide.Strategy`](#providestrategy) to ensure only current content remains\n scheduled. This handles cases where content is unpinned or removed.\n \n+**Persistent reprovide cycle state:** When Provide Sweep is enabled, the\n+reprovide cycle state is persisted to the datastore by default. On restart, Kubo\n+automatically resumes from where it left off. If the node was offline for an\n+extended period, all CIDs that haven't been reprovided within the configured\n+[`Provide.DHT.Interval`](#providedhtinterval) are immediately queued for\n+reproviding. Additionally, the provide queue is persisted on shutdown and\n+restored on startup, ensuring no pending provide operations are lost. If you\n+don't want to keep the persisted provider state from a previous run, you can\n+disable this behavior by setting [`Provide.DHT.ResumeEnabled`](#providedhtresumeenabled)\n+to `false`.\n+\n > <picture>\n >   <source media=\"(prefers-color-scheme: dark)\" srcset=\"https://github.com/user-attachments/assets/f6e06b08-7fee-490c-a681-1bf440e16e27\">\n >   <source media=\"(prefers-color-scheme: light)\" srcset=\"https://github.com/user-attachments/assets/e1662d7c-f1be-4275-a9ed-f2752fcdcabe\">\n@@ -2163,9 +2175,42 @@ Default: `false`\n \n Type: `flag`\n \n+#### `Provide.DHT.ResumeEnabled`\n+\n+Controls whether the provider resumes from its previous state on restart. Only\n+applies when `Provide.DHT.SweepEnabled` is true.\n+\n+When enabled (the default), the provider persists its reprovide cycle state and\n+provide queue to the datastore, and restores them on restart. This ensures:\n+\n+- The reprovide cycle continues from where it left off instead of starting over\n+- Any CIDs in the provide queue during shutdown are restored and provided after\n+restart\n+- CIDs that missed their reprovide window while the node was offline are queued\n+for immediate reproviding\n+\n+When disabled, the provider starts fresh on each restart, discarding any\n+previous reprovide cycle state and provide queue. On a fresh start, all CIDs\n+matching the [`Provide.Strategy`](#providestrategy) will be provided ASAP (as\n+burst provides), and then keyspace regions are reprovided according to the\n+regular schedule starting from the beginning of the reprovide cycle.\n+\n+> [!NOTE]\n+> Disabling this option means the provider will provide all content matching\n+> your strategy on every restart (which can be resource-intensive for large\n+> datasets), then start from the beginning of the reprovide cycle. For nodes\n+> with large datasets or frequent restarts, keeping this enabled (the default)\n+> is recommended for better resource efficiency and more consistent reproviding\n+> behavior.\n+\n+Default: `true`\n+\n+Type: `flag`\n+\n #### `Provide.DHT.DedicatedPeriodicWorkers`\n \n-Number of workers dedicated to periodic keyspace region reprovides. Only applies when `Provide.DHT.SweepEnabled` is true.\n+Number of workers dedicated to periodic keyspace region reprovides. Only\n+applies when `Provide.DHT.SweepEnabled` is true.\n \n Among the [`Provide.DHT.MaxWorkers`](#providedhtmaxworkers), this\n number of workers will be dedicated to the periodic region reprovide only. The sum of\ndiff --git a/docs/examples/kubo-as-a-library/go.mod b/docs/examples/kubo-as-a-library/go.mod\nindex f02577a5c8b..21ab11ded23 100644\n--- a/docs/examples/kubo-as-a-library/go.mod\n+++ b/docs/examples/kubo-as-a-library/go.mod\n@@ -115,7 +115,7 @@ require (\n \tgithub.com/libp2p/go-doh-resolver v0.5.0 // indirect\n \tgithub.com/libp2p/go-flow-metrics v0.3.0 // indirect\n \tgithub.com/libp2p/go-libp2p-asn-util v0.4.1 // indirect\n-\tgithub.com/libp2p/go-libp2p-kad-dht v0.35.2-0.20251028150720-c3f8d33dc781 // indirect\n+\tgithub.com/libp2p/go-libp2p-kad-dht v0.35.2-0.20251025120456-f33906fd2f32 // indirect\n \tgithub.com/libp2p/go-libp2p-kbucket v0.8.0 // indirect\n \tgithub.com/libp2p/go-libp2p-pubsub v0.14.2 // indirect\n \tgithub.com/libp2p/go-libp2p-pubsub-router v0.6.0 // indirect\ndiff --git a/docs/examples/kubo-as-a-library/go.sum b/docs/examples/kubo-as-a-library/go.sum\nindex a2f1b948fe5..a0510b70c68 100644\n--- a/docs/examples/kubo-as-a-library/go.sum\n+++ b/docs/examples/kubo-as-a-library/go.sum\n@@ -434,8 +434,8 @@ github.com/libp2p/go-libp2p-asn-util v0.4.1 h1:xqL7++IKD9TBFMgnLPZR6/6iYhawHKHl9\n github.com/libp2p/go-libp2p-asn-util v0.4.1/go.mod h1:d/NI6XZ9qxw67b4e+NgpQexCIiFYJjErASrYW4PFDN8=\n github.com/libp2p/go-libp2p-core v0.2.4/go.mod h1:STh4fdfa5vDYr0/SzYYeqnt+E6KfEV5VxfIrm0bcI0g=\n github.com/libp2p/go-libp2p-core v0.3.0/go.mod h1:ACp3DmS3/N64c2jDzcV429ukDpicbL6+TrrxANBjPGw=\n-github.com/libp2p/go-libp2p-kad-dht v0.35.2-0.20251028150720-c3f8d33dc781 h1:oTzgZExvlcixPXIXO7Knojv5yYoBB5SMLUmgtNzBGfY=\n-github.com/libp2p/go-libp2p-kad-dht v0.35.2-0.20251028150720-c3f8d33dc781/go.mod h1:aHMTg23iseX9grGSfA5gFUzLrqzmYbA8PqgGPqM8VkI=\n+github.com/libp2p/go-libp2p-kad-dht v0.35.2-0.20251025120456-f33906fd2f32 h1:xZj18PsLD157snR/BFo547jwOkGDH7jZjMEkBDOoD4Q=\n+github.com/libp2p/go-libp2p-kad-dht v0.35.2-0.20251025120456-f33906fd2f32/go.mod h1:aHMTg23iseX9grGSfA5gFUzLrqzmYbA8PqgGPqM8VkI=\n github.com/libp2p/go-libp2p-kbucket v0.3.1/go.mod h1:oyjT5O7tS9CQurok++ERgc46YLwEpuGoFq9ubvoUOio=\n github.com/libp2p/go-libp2p-kbucket v0.8.0 h1:QAK7RzKJpYe+EuSEATAaaHYMYLkPDGC18m9jxPLnU8s=\n github.com/libp2p/go-libp2p-kbucket v0.8.0/go.mod h1:JMlxqcEyKwO6ox716eyC0hmiduSWZZl6JY93mGaaqc4=\ndiff --git a/go.mod b/go.mod\nindex 818e53db3ae..afb2e01a3ab 100644\n--- a/go.mod\n+++ b/go.mod\n@@ -53,7 +53,7 @@ require (\n \tgithub.com/libp2p/go-doh-resolver v0.5.0\n \tgithub.com/libp2p/go-libp2p v0.44.0\n \tgithub.com/libp2p/go-libp2p-http v0.5.0\n-\tgithub.com/libp2p/go-libp2p-kad-dht v0.35.2-0.20251028150720-c3f8d33dc781\n+\tgithub.com/libp2p/go-libp2p-kad-dht v0.35.2-0.20251025120456-f33906fd2f32\n \tgithub.com/libp2p/go-libp2p-kbucket v0.8.0\n \tgithub.com/libp2p/go-libp2p-pubsub v0.14.2\n \tgithub.com/libp2p/go-libp2p-pubsub-router v0.6.0\ndiff --git a/go.sum b/go.sum\nindex 2bef40d2cff..f258b123f70 100644\n--- a/go.sum\n+++ b/go.sum\n@@ -518,8 +518,8 @@ github.com/libp2p/go-libp2p-gostream v0.6.0 h1:QfAiWeQRce6pqnYfmIVWJFXNdDyfiR/qk\n github.com/libp2p/go-libp2p-gostream v0.6.0/go.mod h1:Nywu0gYZwfj7Jc91PQvbGU8dIpqbQQkjWgDuOrFaRdA=\n github.com/libp2p/go-libp2p-http v0.5.0 h1:+x0AbLaUuLBArHubbbNRTsgWz0RjNTy6DJLOxQ3/QBc=\n github.com/libp2p/go-libp2p-http v0.5.0/go.mod h1:glh87nZ35XCQyFsdzZps6+F4HYI6DctVFY5u1fehwSg=\n-github.com/libp2p/go-libp2p-kad-dht v0.35.2-0.20251028150720-c3f8d33dc781 h1:oTzgZExvlcixPXIXO7Knojv5yYoBB5SMLUmgtNzBGfY=\n-github.com/libp2p/go-libp2p-kad-dht v0.35.2-0.20251028150720-c3f8d33dc781/go.mod h1:aHMTg23iseX9grGSfA5gFUzLrqzmYbA8PqgGPqM8VkI=\n+github.com/libp2p/go-libp2p-kad-dht v0.35.2-0.20251025120456-f33906fd2f32 h1:xZj18PsLD157snR/BFo547jwOkGDH7jZjMEkBDOoD4Q=\n+github.com/libp2p/go-libp2p-kad-dht v0.35.2-0.20251025120456-f33906fd2f32/go.mod h1:aHMTg23iseX9grGSfA5gFUzLrqzmYbA8PqgGPqM8VkI=\n github.com/libp2p/go-libp2p-kbucket v0.3.1/go.mod h1:oyjT5O7tS9CQurok++ERgc46YLwEpuGoFq9ubvoUOio=\n github.com/libp2p/go-libp2p-kbucket v0.8.0 h1:QAK7RzKJpYe+EuSEATAaaHYMYLkPDGC18m9jxPLnU8s=\n github.com/libp2p/go-libp2p-kbucket v0.8.0/go.mod h1:JMlxqcEyKwO6ox716eyC0hmiduSWZZl6JY93mGaaqc4=\n", "test_patch": "diff --git a/test/cli/provider_test.go b/test/cli/provider_test.go\nindex debeddcd016..ccd16486066 100644\n--- a/test/cli/provider_test.go\n+++ b/test/cli/provider_test.go\n@@ -3,6 +3,7 @@ package cli\n import (\n \t\"bytes\"\n \t\"encoding/json\"\n+\t\"fmt\"\n \t\"net/http\"\n \t\"net/http/httptest\"\n \t\"strings\"\n@@ -608,6 +609,124 @@ func runProviderSuite(t *testing.T, reprovide bool, apply cfgApplier) {\n \t})\n }\n \n+// runResumeTests validates Provide.DHT.ResumeEnabled behavior for SweepingProvider.\n+//\n+// Background: The provider tracks current_time_offset = (now - cycleStart) % interval\n+// where cycleStart is the timestamp marking the beginning of the reprovide cycle.\n+// With ResumeEnabled=true, cycleStart persists in the datastore across restarts.\n+// With ResumeEnabled=false, cycleStart resets to 'now' on each startup.\n+func runResumeTests(t *testing.T, apply cfgApplier) {\n+\tt.Helper()\n+\n+\tconst (\n+\t\treprovideInterval = 30 * time.Second\n+\t\tinitialRuntime    = 10 * time.Second // Let cycle progress\n+\t\tdowntime          = 5 * time.Second  // Simulated offline period\n+\t\trestartTime       = 2 * time.Second  // Daemon restart stabilization\n+\n+\t\t// Thresholds account for timing jitter (~2-3s margin)\n+\t\tminOffsetBeforeRestart = 8 * time.Second  // Expect ~10s\n+\t\tminOffsetAfterResume   = 12 * time.Second // Expect ~17s (10s + 5s + 2s)\n+\t\tmaxOffsetAfterReset    = 5 * time.Second  // Expect ~2s (fresh start)\n+\t)\n+\n+\tsetupNode := func(t *testing.T, resumeEnabled bool) *harness.Node {\n+\t\tnode := harness.NewT(t).NewNode().Init()\n+\t\tapply(node) // Sets Provide.DHT.SweepEnabled=true\n+\t\tnode.SetIPFSConfig(\"Provide.DHT.ResumeEnabled\", resumeEnabled)\n+\t\tnode.SetIPFSConfig(\"Provide.DHT.Interval\", reprovideInterval.String())\n+\t\tnode.SetIPFSConfig(\"Bootstrap\", []string{})\n+\t\tnode.StartDaemon()\n+\t\treturn node\n+\t}\n+\n+\tt.Run(\"preserves cycle state across restart\", func(t *testing.T) {\n+\t\tt.Parallel()\n+\n+\t\tnode := setupNode(t, true)\n+\t\tdefer node.StopDaemon()\n+\n+\t\tfor i := 0; i < 10; i++ {\n+\t\t\tnode.IPFSAddStr(fmt.Sprintf(\"resume-test-%d-%d\", i, time.Now().UnixNano()))\n+\t\t}\n+\n+\t\ttime.Sleep(initialRuntime)\n+\n+\t\tbeforeRestart := node.IPFS(\"provide\", \"stat\", \"--enc=json\")\n+\t\toffsetBeforeRestart, _, err := parseProvideStatJSON(beforeRestart.Stdout.String())\n+\t\trequire.NoError(t, err)\n+\t\trequire.Greater(t, offsetBeforeRestart, minOffsetBeforeRestart,\n+\t\t\t\"cycle should have progressed\")\n+\n+\t\tnode.StopDaemon()\n+\t\ttime.Sleep(downtime)\n+\t\tnode.StartDaemon()\n+\t\ttime.Sleep(restartTime)\n+\n+\t\tafterRestart := node.IPFS(\"provide\", \"stat\", \"--enc=json\")\n+\t\toffsetAfterRestart, _, err := parseProvideStatJSON(afterRestart.Stdout.String())\n+\t\trequire.NoError(t, err)\n+\n+\t\tassert.GreaterOrEqual(t, offsetAfterRestart, minOffsetAfterResume,\n+\t\t\t\"offset should account for downtime\")\n+\t})\n+\n+\tt.Run(\"resets cycle when disabled\", func(t *testing.T) {\n+\t\tt.Parallel()\n+\n+\t\tnode := setupNode(t, false)\n+\t\tdefer node.StopDaemon()\n+\n+\t\tfor i := 0; i < 10; i++ {\n+\t\t\tnode.IPFSAddStr(fmt.Sprintf(\"no-resume-%d-%d\", i, time.Now().UnixNano()))\n+\t\t}\n+\n+\t\ttime.Sleep(initialRuntime)\n+\n+\t\tbeforeRestart := node.IPFS(\"provide\", \"stat\", \"--enc=json\")\n+\t\toffsetBeforeRestart, _, err := parseProvideStatJSON(beforeRestart.Stdout.String())\n+\t\trequire.NoError(t, err)\n+\t\trequire.Greater(t, offsetBeforeRestart, minOffsetBeforeRestart,\n+\t\t\t\"cycle should have progressed\")\n+\n+\t\tnode.StopDaemon()\n+\t\ttime.Sleep(downtime)\n+\t\tnode.StartDaemon()\n+\t\ttime.Sleep(restartTime)\n+\n+\t\tafterRestart := node.IPFS(\"provide\", \"stat\", \"--enc=json\")\n+\t\toffsetAfterRestart, _, err := parseProvideStatJSON(afterRestart.Stdout.String())\n+\t\trequire.NoError(t, err)\n+\n+\t\tassert.Less(t, offsetAfterRestart, maxOffsetAfterReset,\n+\t\t\t\"offset should reset to near zero\")\n+\t})\n+}\n+\n+type provideStatJSON struct {\n+\tSweep struct {\n+\t\tTiming struct {\n+\t\t\tCurrentTimeOffset int64 `json:\"current_time_offset\"` // nanoseconds\n+\t\t} `json:\"timing\"`\n+\t\tSchedule struct {\n+\t\t\tNextReprovidePrefix string `json:\"next_reprovide_prefix\"`\n+\t\t} `json:\"schedule\"`\n+\t} `json:\"Sweep\"`\n+}\n+\n+// parseProvideStatJSON extracts timing and schedule information from\n+// the JSON output of 'ipfs provide stat --enc=json'.\n+// Note: prefix is unused in current tests but kept for potential future use.\n+func parseProvideStatJSON(output string) (offset time.Duration, prefix string, err error) {\n+\tvar stat provideStatJSON\n+\tif err := json.Unmarshal([]byte(output), &stat); err != nil {\n+\t\treturn 0, \"\", err\n+\t}\n+\toffset = time.Duration(stat.Sweep.Timing.CurrentTimeOffset)\n+\tprefix = stat.Sweep.Schedule.NextReprovidePrefix\n+\treturn offset, prefix, nil\n+}\n+\n func TestProvider(t *testing.T) {\n \tt.Parallel()\n \n@@ -637,6 +756,11 @@ func TestProvider(t *testing.T) {\n \t\tt.Run(v.name, func(t *testing.T) {\n \t\t\t// t.Parallel()\n \t\t\trunProviderSuite(t, v.reprovide, v.apply)\n+\n+\t\t\t// Resume tests only apply to SweepingProvider\n+\t\t\tif v.name == \"SweepingProvider\" {\n+\t\t\t\trunResumeTests(t, v.apply)\n+\t\t\t}\n \t\t})\n \t}\n }\ndiff --git a/test/dependencies/go.mod b/test/dependencies/go.mod\nindex 3e7729f9d16..95dc09d5221 100644\n--- a/test/dependencies/go.mod\n+++ b/test/dependencies/go.mod\n@@ -184,7 +184,7 @@ require (\n \tgithub.com/libp2p/go-flow-metrics v0.3.0 // indirect\n \tgithub.com/libp2p/go-libp2p v0.44.0 // indirect\n \tgithub.com/libp2p/go-libp2p-asn-util v0.4.1 // indirect\n-\tgithub.com/libp2p/go-libp2p-kad-dht v0.35.2-0.20251028150720-c3f8d33dc781 // indirect\n+\tgithub.com/libp2p/go-libp2p-kad-dht v0.35.2-0.20251025120456-f33906fd2f32 // indirect\n \tgithub.com/libp2p/go-libp2p-kbucket v0.8.0 // indirect\n \tgithub.com/libp2p/go-libp2p-record v0.3.1 // indirect\n \tgithub.com/libp2p/go-libp2p-routing-helpers v0.7.5 // indirect\ndiff --git a/test/dependencies/go.sum b/test/dependencies/go.sum\nindex 70d00e97780..37e2a6ed4e4 100644\n--- a/test/dependencies/go.sum\n+++ b/test/dependencies/go.sum\n@@ -468,8 +468,8 @@ github.com/libp2p/go-libp2p v0.44.0 h1:5Gtt8OrF8yiXmH+Mx4+/iBeFRMK1TY3a8OrEBDEqA\n github.com/libp2p/go-libp2p v0.44.0/go.mod h1:NovCojezAt4dnDd4fH048K7PKEqH0UFYYqJRjIIu8zc=\n github.com/libp2p/go-libp2p-asn-util v0.4.1 h1:xqL7++IKD9TBFMgnLPZR6/6iYhawHKHl950SO9L6n94=\n github.com/libp2p/go-libp2p-asn-util v0.4.1/go.mod h1:d/NI6XZ9qxw67b4e+NgpQexCIiFYJjErASrYW4PFDN8=\n-github.com/libp2p/go-libp2p-kad-dht v0.35.2-0.20251028150720-c3f8d33dc781 h1:oTzgZExvlcixPXIXO7Knojv5yYoBB5SMLUmgtNzBGfY=\n-github.com/libp2p/go-libp2p-kad-dht v0.35.2-0.20251028150720-c3f8d33dc781/go.mod h1:aHMTg23iseX9grGSfA5gFUzLrqzmYbA8PqgGPqM8VkI=\n+github.com/libp2p/go-libp2p-kad-dht v0.35.2-0.20251025120456-f33906fd2f32 h1:xZj18PsLD157snR/BFo547jwOkGDH7jZjMEkBDOoD4Q=\n+github.com/libp2p/go-libp2p-kad-dht v0.35.2-0.20251025120456-f33906fd2f32/go.mod h1:aHMTg23iseX9grGSfA5gFUzLrqzmYbA8PqgGPqM8VkI=\n github.com/libp2p/go-libp2p-kbucket v0.8.0 h1:QAK7RzKJpYe+EuSEATAaaHYMYLkPDGC18m9jxPLnU8s=\n github.com/libp2p/go-libp2p-kbucket v0.8.0/go.mod h1:JMlxqcEyKwO6ox716eyC0hmiduSWZZl6JY93mGaaqc4=\n github.com/libp2p/go-libp2p-record v0.3.1 h1:cly48Xi5GjNw5Wq+7gmjfBiG9HCzQVkiZOUZ8kUl+Fg=\n"}
{"org": "influxdata", "repo": "telegraf", "number": 16532, "state": "closed", "title": "feat(inputs.opcua_listener): Allow to subscribe to OPCUA events", "body": "## Summary\r\nThis new feature in opcua_listener is useful to subscribe to OPC UA node ids to receive upcoming events on the subscribed nodes.\r\n\r\n## Checklist\r\n- [x] No AI generated code was used in this PR\r\n\r\n## Related issues\r\nresolves #16275\r\nreplaces #16300\r\n", "url": "https://api.github.com/repos/influxdata/telegraf/pulls/16532", "id": 2345140858, "node_id": "PR_kwDOAft93c6LyAJ6", "html_url": "https://github.com/influxdata/telegraf/pull/16532", "diff_url": "https://github.com/influxdata/telegraf/pull/16532.diff", "patch_url": "https://github.com/influxdata/telegraf/pull/16532.patch", "issue_url": "https://api.github.com/repos/influxdata/telegraf/issues/16532", "created_at": "2025-02-19T17:06:37+00:00", "updated_at": "2025-04-16T13:15:28+00:00", "closed_at": "2025-04-16T13:15:12+00:00", "merged_at": "2025-04-16T13:15:12+00:00", "merge_commit_sha": "508398d4542d2828f4641429ddbb0892c0e98454", "labels": ["feat", "area/opcua", "ready for final review", "plugin/input"], "draft": false, "commits_url": "https://api.github.com/repos/influxdata/telegraf/pulls/16532/commits", "review_comments_url": "https://api.github.com/repos/influxdata/telegraf/pulls/16532/comments", "review_comment_url": "https://api.github.com/repos/influxdata/telegraf/pulls/comments{/number}", "comments_url": "https://api.github.com/repos/influxdata/telegraf/issues/16532/comments", "base": {"label": "influxdata:master", "ref": "master", "sha": "58b696bc59d4e5176bd42724d34e6a0cf6c8b9c1", "user": {"login": "influxdata", "id": 5713248, "node_id": "MDEyOk9yZ2FuaXphdGlvbjU3MTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/5713248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/influxdata", "html_url": "https://github.com/influxdata", "followers_url": "https://api.github.com/users/influxdata/followers", "following_url": "https://api.github.com/users/influxdata/following{/other_user}", "gists_url": "https://api.github.com/users/influxdata/gists{/gist_id}", "starred_url": "https://api.github.com/users/influxdata/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/influxdata/subscriptions", "organizations_url": "https://api.github.com/users/influxdata/orgs", "repos_url": "https://api.github.com/users/influxdata/repos", "events_url": "https://api.github.com/users/influxdata/events{/privacy}", "received_events_url": "https://api.github.com/users/influxdata/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "repo": {"id": 33258973, "node_id": "MDEwOlJlcG9zaXRvcnkzMzI1ODk3Mw==", "name": "telegraf", "full_name": "influxdata/telegraf", "private": false, "owner": {"login": "influxdata", "id": 5713248, "node_id": "MDEyOk9yZ2FuaXphdGlvbjU3MTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/5713248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/influxdata", "html_url": "https://github.com/influxdata", "followers_url": "https://api.github.com/users/influxdata/followers", "following_url": "https://api.github.com/users/influxdata/following{/other_user}", "gists_url": "https://api.github.com/users/influxdata/gists{/gist_id}", "starred_url": "https://api.github.com/users/influxdata/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/influxdata/subscriptions", "organizations_url": "https://api.github.com/users/influxdata/orgs", "repos_url": "https://api.github.com/users/influxdata/repos", "events_url": "https://api.github.com/users/influxdata/events{/privacy}", "received_events_url": "https://api.github.com/users/influxdata/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "html_url": "https://github.com/influxdata/telegraf", "description": "Agent for collecting, processing, aggregating, and writing metrics, logs, and other arbitrary data.", "fork": false, "url": "https://api.github.com/repos/influxdata/telegraf", "forks_url": "https://api.github.com/repos/influxdata/telegraf/forks", "keys_url": "https://api.github.com/repos/influxdata/telegraf/keys{/key_id}", "collaborators_url": "https://api.github.com/repos/influxdata/telegraf/collaborators{/collaborator}", "teams_url": "https://api.github.com/repos/influxdata/telegraf/teams", "hooks_url": "https://api.github.com/repos/influxdata/telegraf/hooks", "issue_events_url": "https://api.github.com/repos/influxdata/telegraf/issues/events{/number}", "events_url": "https://api.github.com/repos/influxdata/telegraf/events", "assignees_url": "https://api.github.com/repos/influxdata/telegraf/assignees{/user}", "branches_url": "https://api.github.com/repos/influxdata/telegraf/branches{/branch}", "tags_url": "https://api.github.com/repos/influxdata/telegraf/tags", "blobs_url": "https://api.github.com/repos/influxdata/telegraf/git/blobs{/sha}", "git_tags_url": "https://api.github.com/repos/influxdata/telegraf/git/tags{/sha}", "git_refs_url": "https://api.github.com/repos/influxdata/telegraf/git/refs{/sha}", "trees_url": "https://api.github.com/repos/influxdata/telegraf/git/trees{/sha}", "statuses_url": "https://api.github.com/repos/influxdata/telegraf/statuses/{sha}", "languages_url": "https://api.github.com/repos/influxdata/telegraf/languages", "stargazers_url": "https://api.github.com/repos/influxdata/telegraf/stargazers", "contributors_url": "https://api.github.com/repos/influxdata/telegraf/contributors", "subscribers_url": "https://api.github.com/repos/influxdata/telegraf/subscribers", "subscription_url": "https://api.github.com/repos/influxdata/telegraf/subscription", "commits_url": "https://api.github.com/repos/influxdata/telegraf/commits{/sha}", "git_commits_url": "https://api.github.com/repos/influxdata/telegraf/git/commits{/sha}", "comments_url": "https://api.github.com/repos/influxdata/telegraf/comments{/number}", "issue_comment_url": "https://api.github.com/repos/influxdata/telegraf/issues/comments{/number}", "contents_url": "https://api.github.com/repos/influxdata/telegraf/contents/{+path}", "compare_url": "https://api.github.com/repos/influxdata/telegraf/compare/{base}...{head}", "merges_url": "https://api.github.com/repos/influxdata/telegraf/merges", "archive_url": "https://api.github.com/repos/influxdata/telegraf/{archive_format}{/ref}", "downloads_url": "https://api.github.com/repos/influxdata/telegraf/downloads", "issues_url": "https://api.github.com/repos/influxdata/telegraf/issues{/number}", "pulls_url": "https://api.github.com/repos/influxdata/telegraf/pulls{/number}", "milestones_url": "https://api.github.com/repos/influxdata/telegraf/milestones{/number}", "notifications_url": "https://api.github.com/repos/influxdata/telegraf/notifications{?since,all,participating}", "labels_url": "https://api.github.com/repos/influxdata/telegraf/labels{/name}", "releases_url": "https://api.github.com/repos/influxdata/telegraf/releases{/id}", "deployments_url": "https://api.github.com/repos/influxdata/telegraf/deployments", "created_at": "2015-04-01T16:28:44Z", "updated_at": "2026-01-07T06:24:01Z", "pushed_at": "2026-01-06T18:49:35Z", "git_url": "git://github.com/influxdata/telegraf.git", "ssh_url": "git@github.com:influxdata/telegraf.git", "clone_url": "https://github.com/influxdata/telegraf.git", "svn_url": "https://github.com/influxdata/telegraf", "homepage": "https://influxdata.com/telegraf", "size": 80485, "stargazers_count": 16621, "watchers_count": 16621, "language": "Go", "has_issues": true, "has_projects": true, "has_downloads": true, "has_wiki": false, "has_pages": false, "has_discussions": false, "forks_count": 5747, "mirror_url": null, "archived": false, "disabled": false, "open_issues_count": 430, "license": {"key": "mit", "name": "MIT License", "spdx_id": "MIT", "url": "https://api.github.com/licenses/mit", "node_id": "MDc6TGljZW5zZTEz"}, "allow_forking": true, "is_template": false, "web_commit_signoff_required": false, "topics": ["gnmi", "golang", "hacktoberfest", "influxdb", "json", "kafka", "logs", "metrics", "modbus", "monitoring", "mqtt", "opcua", "telegraf", "time-series", "windows-eventlog", "windows-management-instrumentation", "xpath"], "visibility": "public", "forks": 5747, "open_issues": 430, "watchers": 16621, "default_branch": "master"}}, "commits": [{"sha": "a8bceba3cbe812fb10b115aa257abf692fded803", "parents": ["8d369edc5719e5d8d59eef28813e6bc6c3a1c4a0"], "message": "merged event streming into listener plugin"}, {"sha": "092d191d430a264f0e31655a13cc6feeaebb613a", "parents": ["a8bceba3cbe812fb10b115aa257abf692fded803"], "message": "adjusted subscription creation after testing"}, {"sha": "88ed9741bf8d12bd4ea5e9dbcfe4d92d6d800c13", "parents": ["092d191d430a264f0e31655a13cc6feeaebb613a"], "message": "adjusted after integration tests"}, {"sha": "d47ce62c09082c18f2cb8e9702bae3ca3bc2dc40", "parents": ["88ed9741bf8d12bd4ea5e9dbcfe4d92d6d800c13"], "message": "added testcases"}, {"sha": "3061950040bce18284a71fe46ee389fa709b54b1", "parents": ["d47ce62c09082c18f2cb8e9702bae3ca3bc2dc40"], "message": "small adjusts"}, {"sha": "8d023c249f330eba36112df7d206848c1eff1d49", "parents": ["3061950040bce18284a71fe46ee389fa709b54b1"], "message": "code clearence"}, {"sha": "f6f85855ca5a059e10486ee99ea329fda93d8b33", "parents": ["8d023c249f330eba36112df7d206848c1eff1d49"], "message": "after linting"}, {"sha": "93c27bf4bfd1e183ba266003dcbc946e70b0e743", "parents": ["f6f85855ca5a059e10486ee99ea329fda93d8b33"], "message": "readme linter"}, {"sha": "a82641497dd7d0766a7b85903488f697d83f7e0e", "parents": ["93c27bf4bfd1e183ba266003dcbc946e70b0e743"], "message": "linter adjusts"}, {"sha": "07fb9204fb7f82ad5f0a77e6cf92800e28b90ed8", "parents": ["a82641497dd7d0766a7b85903488f697d83f7e0e"], "message": "adjusted errer returning"}, {"sha": "c32aa8b089b7f5d5500154ffde70e14ef698906a", "parents": ["07fb9204fb7f82ad5f0a77e6cf92800e28b90ed8"], "message": "adjusted requested changes"}, {"sha": "fec47b78653f9e610f5c0998ad696825f321fff8", "parents": ["c32aa8b089b7f5d5500154ffde70e14ef698906a"], "message": "implemented group of event definitions"}, {"sha": "e91350545c706fb9178a4121b5b6223f32b23777", "parents": ["fec47b78653f9e610f5c0998ad696825f321fff8"], "message": "added default config values, adjusted sample conf and readme"}, {"sha": "26a5f5fc40116b08daf47ab8f0562d600e962b40", "parents": ["e91350545c706fb9178a4121b5b6223f32b23777"], "message": "after testing"}, {"sha": "caf9409450e2c5d5d39a27f89a171c4826cf248f", "parents": ["26a5f5fc40116b08daf47ab8f0562d600e962b40"], "message": "after linting"}, {"sha": "a1d74c5eff51235430802d56fab2a1958804b8dc", "parents": ["caf9409450e2c5d5d39a27f89a171c4826cf248f"], "message": "rewview adjustements"}, {"sha": "72c18d239af0c683d57368033da95cf93d2a9c7e", "parents": ["a1d74c5eff51235430802d56fab2a1958804b8dc"], "message": "readme linter"}, {"sha": "83242ef506519dce4f458f6ce28ea8c14408ca22", "parents": ["72c18d239af0c683d57368033da95cf93d2a9c7e"], "message": "changed attribut id in monitoring item"}, {"sha": "3290f2a3f6d33bde2122dfdfc9491d9487c8339f", "parents": ["83242ef506519dce4f458f6ce28ea8c14408ca22"], "message": "added queue_size to event parameters"}, {"sha": "caf38a991845d9269efb419b1c60ad786d0bfc77", "parents": ["3290f2a3f6d33bde2122dfdfc9491d9487c8339f"], "message": "make docs"}, {"sha": "a55b38959766fcd57cb8a976427fbe37fd5a9e13", "parents": ["caf38a991845d9269efb419b1c60ad786d0bfc77"], "message": "adjusted non nil slice"}, {"sha": "515aa070b99f10c9b160e7324334179cd78082a5", "parents": ["a55b38959766fcd57cb8a976427fbe37fd5a9e13"], "message": "debuged missing events"}, {"sha": "4fc10e883e6aa6cfe5ae511ca64636c3e4a8f6c1", "parents": ["515aa070b99f10c9b160e7324334179cd78082a5"], "message": "updated readme"}, {"sha": "8b45b93495dcbb039c8a7a5db4a2f1f62f2fd492", "parents": ["4fc10e883e6aa6cfe5ae511ca64636c3e4a8f6c1"], "message": "adjusted metadata"}, {"sha": "c88574705b4d64b9b1bae6f8821e5d3377bb731d", "parents": ["8b45b93495dcbb039c8a7a5db4a2f1f62f2fd492"], "message": "make docs"}, {"sha": "bfd1dca2cdd004aade169a7b2a845f095ff8058b", "parents": ["c88574705b4d64b9b1bae6f8821e5d3377bb731d"], "message": "removed readme_linter file"}, {"sha": "e3593e05671f6971df289c40d8e7d617f281b3c6", "parents": ["bfd1dca2cdd004aade169a7b2a845f095ff8058b"], "message": "Remove duplicate code and reorder functions"}, {"sha": "3dbf7c471c48425d08dad3f28fe0be4e0a506fad", "parents": ["e3593e05671f6971df289c40d8e7d617f281b3c6"], "message": "Fix linter issues"}, {"sha": "1326bccf8830b4476f8480938fad9f3706f1cb6c", "parents": ["3dbf7c471c48425d08dad3f28fe0be4e0a506fad"], "message": "Fix documentation"}, {"sha": "e4e30ae804dfd263118fad73afdb37570e1031a6", "parents": ["1326bccf8830b4476f8480938fad9f3706f1cb6c", "58b696bc59d4e5176bd42724d34e6a0cf6c8b9c1"], "message": "Merge branch 'influxdata:master' into master"}, {"sha": "b0aa6610d7c774bfdaa95528cab1101f9745df11", "parents": ["e4e30ae804dfd263118fad73afdb37570e1031a6"], "message": "renamed eventgroup to events in sample and readme"}], "resolved_issues": [{"org": "influxdata", "repo": "telegraf", "number": 16275, "state": "closed", "title": "OPCUA Event Subscription", "body": "### Use Case\n\nCurrently, Telegraf supports subscribing to OPC UA data changes, such as updated sensor readings or metrics. However, event notificationsâ€”critical for alarms, warnings, and operational logsâ€”are not natively supported. This limits usersâ€™ ability to monitor real-time events and system alerts effectively.\r\n\r\nI have implemented an Input Plugin that can subscribe to one or multiple Node_IDs and capture upcoming events.\r\n\r\nBenefits:\r\n1.\tEnhanced Monitoring: Receive real-time alerts for events, filling the gap left by data-change-only monitoring.\r\n2.\tFlexible Filtering: Focus on relevant events using event type, source name, and specific fields.\r\n3.\tImproved Security: Supports encrypted OPC UA communication with certificates and security policies.\r\n\r\n\n\n### Expected behavior\n\nUse this Input Plugin to subscribe to OPC UA node IDs and fetch upcoming events and hand over the received fields to the telegraf accumulator.\n\n### Actual behavior\n\nNot possible currently\n\n### Additional info\n\nPlugin is developed and fully tested. This Feature Request is only created to fulfill all the steps in the pull request process."}], "fix_patch": "diff --git a/plugins/common/opcua/input/input_client.go b/plugins/common/opcua/input/input_client.go\nindex 7e741a9997571..4116739452c06 100644\n--- a/plugins/common/opcua/input/input_client.go\n+++ b/plugins/common/opcua/input/input_client.go\n@@ -9,6 +9,7 @@ import (\n \t\"strings\"\n \t\"time\"\n \n+\t\"github.com/gopcua/opcua/id\"\n \t\"github.com/gopcua/opcua/ua\"\n \n \t\"github.com/influxdata/telegraf\"\n@@ -75,6 +76,80 @@ type NodeGroupSettings struct {\n \tSamplingInterval config.Duration   `toml:\"sampling_interval\"` // Can be overridden by monitoring parameters\n }\n \n+type EventNodeSettings struct {\n+\tNamespace      string `toml:\"namespace\"`\n+\tIdentifierType string `toml:\"identifier_type\"`\n+\tIdentifier     string `toml:\"identifier\"`\n+}\n+\n+func (e *EventNodeSettings) NodeID() string {\n+\treturn \"ns=\" + e.Namespace + \";\" + e.IdentifierType + \"=\" + e.Identifier\n+}\n+\n+type EventGroupSettings struct {\n+\tSamplingInterval config.Duration     `toml:\"sampling_interval\"`\n+\tQueueSize        uint32              `toml:\"queue_size\"`\n+\tEventTypeNode    EventNodeSettings   `toml:\"event_type_node\"`\n+\tNamespace        string              `toml:\"namespace\"`\n+\tIdentifierType   string              `toml:\"identifier_type\"`\n+\tNodeIDSettings   []EventNodeSettings `toml:\"node_ids\"`\n+\tSourceNames      []string            `toml:\"source_names\"`\n+\tFields           []string            `toml:\"fields\"`\n+}\n+\n+func (e *EventGroupSettings) UpdateNodeIDSettings() {\n+\tfor i := range e.NodeIDSettings {\n+\t\tn := &e.NodeIDSettings[i]\n+\t\tif n.Namespace == \"\" {\n+\t\t\tn.Namespace = e.Namespace\n+\t\t}\n+\t\tif n.IdentifierType == \"\" {\n+\t\t\tn.IdentifierType = e.IdentifierType\n+\t\t}\n+\t}\n+}\n+\n+func (e *EventGroupSettings) Validate() error {\n+\tif err := e.EventTypeNode.validateEventNodeSettings(); err != nil {\n+\t\treturn fmt.Errorf(\"invalid event_type_node_settings: %w\", err)\n+\t}\n+\n+\tif len(e.NodeIDSettings) == 0 {\n+\t\treturn errors.New(\"at least one node_id must be specified\")\n+\t}\n+\n+\tfor _, node := range e.NodeIDSettings {\n+\t\tif err := node.validateEventNodeSettings(); err != nil {\n+\t\t\treturn fmt.Errorf(\"invalid node_id_settings: %w\", err)\n+\t\t}\n+\t}\n+\n+\tif len(e.Fields) == 0 {\n+\t\treturn errors.New(\"at least one Field must be specified\")\n+\t}\n+\tfor _, field := range e.Fields {\n+\t\tif field == \"\" {\n+\t\t\treturn errors.New(\"empty field name in fields stanza\")\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (e EventNodeSettings) validateEventNodeSettings() error {\n+\tvar defaultNodeSettings EventNodeSettings\n+\tif e == defaultNodeSettings {\n+\t\treturn errors.New(\"node settings can't be empty\")\n+\t}\n+\tif e.Identifier == \"\" {\n+\t\treturn errors.New(\"identifier must be set\")\n+\t} else if e.IdentifierType == \"\" {\n+\t\treturn errors.New(\"identifier_type must be set\")\n+\t} else if e.Namespace == \"\" {\n+\t\treturn errors.New(\"namespace must be set\")\n+\t}\n+\treturn nil\n+}\n+\n type TimestampSource string\n \n const (\n@@ -86,11 +161,12 @@ const (\n // InputClientConfig a configuration for the input client\n type InputClientConfig struct {\n \topcua.OpcUAClientConfig\n-\tMetricName      string              `toml:\"name\"`\n-\tTimestamp       TimestampSource     `toml:\"timestamp\"`\n-\tTimestampFormat string              `toml:\"timestamp_format\"`\n-\tRootNodes       []NodeSettings      `toml:\"nodes\"`\n-\tGroups          []NodeGroupSettings `toml:\"group\"`\n+\tMetricName      string               `toml:\"name\"`\n+\tTimestamp       TimestampSource      `toml:\"timestamp\"`\n+\tTimestampFormat string               `toml:\"timestamp_format\"`\n+\tRootNodes       []NodeSettings       `toml:\"nodes\"`\n+\tGroups          []NodeGroupSettings  `toml:\"group\"`\n+\tEventGroups     []EventGroupSettings `toml:\"events\"`\n }\n \n func (o *InputClientConfig) Validate() error {\n@@ -107,8 +183,8 @@ func (o *InputClientConfig) Validate() error {\n \t\to.TimestampFormat = time.RFC3339Nano\n \t}\n \n-\tif len(o.Groups) == 0 && len(o.RootNodes) == 0 {\n-\t\treturn errors.New(\"no groups or root nodes provided to gather from\")\n+\tif len(o.Groups) == 0 && len(o.RootNodes) == 0 && o.EventGroups == nil {\n+\t\treturn errors.New(\"no groups, root nodes or events provided to gather from\")\n \t}\n \tfor _, group := range o.Groups {\n \t\tif len(group.Nodes) == 0 {\n@@ -124,6 +200,15 @@ func (o *InputClientConfig) CreateInputClient(log telegraf.Logger) (*OpcUAInputC\n \t\treturn nil, err\n \t}\n \n+\tif o.EventGroups != nil {\n+\t\tfor _, eventGroup := range o.EventGroups {\n+\t\t\teventGroup.UpdateNodeIDSettings()\n+\t\t\tif err := eventGroup.Validate(); err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"invalid event_settings: %w\", err)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tlog.Debug(\"Initialising OpcUAInputClient\")\n \topcClient, err := o.OpcUAClientConfig.CreateClient(log)\n \tif err != nil {\n@@ -134,6 +219,7 @@ func (o *InputClientConfig) CreateInputClient(log telegraf.Logger) (*OpcUAInputC\n \t\tOpcUAClient: opcClient,\n \t\tLog:         log,\n \t\tConfig:      *o,\n+\t\tEventGroups: o.EventGroups,\n \t}\n \n \tlog.Debug(\"Initialising node to metric mapping\")\n@@ -185,6 +271,15 @@ func NewNodeMetricMapping(metricName string, node NodeSettings, groupTags map[st\n \t}, nil\n }\n \n+type EventNodeMetricMapping struct {\n+\tNodeID           *ua.NodeID\n+\tSamplingInterval *config.Duration\n+\tQueueSize        *uint32\n+\tEventTypeNode    *ua.NodeID\n+\tSourceNames      []string\n+\tFields           []string\n+}\n+\n // NodeValue The received value for a node\n type NodeValue struct {\n \tTagName    string\n@@ -203,9 +298,11 @@ type OpcUAInputClient struct {\n \tConfig InputClientConfig\n \tLog    telegraf.Logger\n \n-\tNodeMetricMapping []NodeMetricMapping\n-\tNodeIDs           []*ua.NodeID\n-\tLastReceivedData  []NodeValue\n+\tNodeMetricMapping      []NodeMetricMapping\n+\tNodeIDs                []*ua.NodeID\n+\tLastReceivedData       []NodeValue\n+\tEventGroups            []EventGroupSettings\n+\tEventNodeMetricMapping []EventNodeMetricMapping\n }\n \n // Stop the connection to the client\n@@ -381,6 +478,33 @@ func (o *OpcUAInputClient) InitNodeIDs() error {\n \treturn nil\n }\n \n+func (o *OpcUAInputClient) InitEventNodeIDs() error {\n+\tfor _, eventSetting := range o.EventGroups {\n+\t\teid, err := ua.ParseNodeID(eventSetting.EventTypeNode.NodeID())\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tfor _, node := range eventSetting.NodeIDSettings {\n+\t\t\tnid, err := ua.ParseNodeID(node.NodeID())\n+\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tnmm := EventNodeMetricMapping{\n+\t\t\t\tNodeID:           nid,\n+\t\t\t\tSamplingInterval: &eventSetting.SamplingInterval,\n+\t\t\t\tQueueSize:        &eventSetting.QueueSize,\n+\t\t\t\tEventTypeNode:    eid,\n+\t\t\t\tSourceNames:      eventSetting.SourceNames,\n+\t\t\t\tFields:           eventSetting.Fields,\n+\t\t\t}\n+\t\t\to.EventNodeMetricMapping = append(o.EventNodeMetricMapping, nmm)\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n func (o *OpcUAInputClient) initLastReceivedValues() {\n \to.LastReceivedData = make([]NodeValue, len(o.NodeMetricMapping))\n \tfor nodeIdx, nmm := range o.NodeMetricMapping {\n@@ -448,3 +572,151 @@ func (o *OpcUAInputClient) MetricForNode(nodeIdx int) telegraf.Metric {\n \n \treturn metric.New(nmm.metricName, tags, fields, t)\n }\n+\n+func (o *OpcUAInputClient) MetricForEvent(nodeIdx int, event *ua.EventFieldList) telegraf.Metric {\n+\tnode := o.EventNodeMetricMapping[nodeIdx]\n+\tfields := make(map[string]interface{}, len(event.EventFields))\n+\tfor i, field := range event.EventFields {\n+\t\tname := node.Fields[i]\n+\t\tvalue := field.Value()\n+\n+\t\tif value == nil {\n+\t\t\to.Log.Warnf(\"Field %s has no value\", name)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tswitch v := value.(type) {\n+\t\tcase *ua.LocalizedText:\n+\t\t\tfields[name] = v.Text\n+\t\tcase time.Time:\n+\t\t\tfields[name] = v.Format(time.RFC3339)\n+\t\tdefault:\n+\t\t\tfields[name] = v\n+\t\t}\n+\t}\n+\ttags := map[string]string{\n+\t\t\"node_id\": node.NodeID.String(),\n+\t\t\"source\":  o.Config.Endpoint,\n+\t}\n+\tvar t time.Time\n+\tswitch o.Config.Timestamp {\n+\tcase TimestampSourceServer:\n+\t\tt = o.LastReceivedData[nodeIdx].ServerTime\n+\tcase TimestampSourceSource:\n+\t\tt = o.LastReceivedData[nodeIdx].SourceTime\n+\tdefault:\n+\t\tt = time.Now()\n+\t}\n+\n+\treturn metric.New(\"opcua_event\", tags, fields, t)\n+}\n+\n+// Creation of event filter for event streaming\n+func (node *EventNodeMetricMapping) CreateEventFilter() (*ua.ExtensionObject, error) {\n+\tselects, err := node.createSelectClauses()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\twheres, err := node.createWhereClauses()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &ua.ExtensionObject{\n+\t\tEncodingMask: ua.ExtensionObjectBinary,\n+\t\tTypeID:       &ua.ExpandedNodeID{NodeID: ua.NewNumericNodeID(0, id.EventFilter_Encoding_DefaultBinary)},\n+\t\tValue: ua.EventFilter{\n+\t\t\tSelectClauses: selects,\n+\t\t\tWhereClause:   wheres,\n+\t\t},\n+\t}, nil\n+}\n+\n+func (node *EventNodeMetricMapping) createSelectClauses() ([]*ua.SimpleAttributeOperand, error) {\n+\tselects := make([]*ua.SimpleAttributeOperand, len(node.Fields))\n+\ttypeDefinition, err := node.determineNodeIDType()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tfor i, name := range node.Fields {\n+\t\tselects[i] = &ua.SimpleAttributeOperand{\n+\t\t\tTypeDefinitionID: typeDefinition,\n+\t\t\tBrowsePath:       []*ua.QualifiedName{{NamespaceIndex: 0, Name: name}},\n+\t\t\tAttributeID:      ua.AttributeIDValue,\n+\t\t}\n+\t}\n+\treturn selects, nil\n+}\n+\n+func (node *EventNodeMetricMapping) createWhereClauses() (*ua.ContentFilter, error) {\n+\tif len(node.SourceNames) == 0 {\n+\t\treturn &ua.ContentFilter{\n+\t\t\tElements: make([]*ua.ContentFilterElement, 0),\n+\t\t}, nil\n+\t}\n+\toperands := make([]*ua.ExtensionObject, 0)\n+\tfor _, sourceName := range node.SourceNames {\n+\t\tliteralOperand := &ua.ExtensionObject{\n+\t\t\tEncodingMask: 1,\n+\t\t\tTypeID: &ua.ExpandedNodeID{\n+\t\t\t\tNodeID: ua.NewNumericNodeID(0, id.LiteralOperand_Encoding_DefaultBinary),\n+\t\t\t},\n+\t\t\tValue: ua.LiteralOperand{\n+\t\t\t\tValue: ua.MustVariant(sourceName),\n+\t\t\t},\n+\t\t}\n+\t\toperands = append(operands, literalOperand)\n+\t}\n+\n+\ttypeDefinition, err := node.determineNodeIDType()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tattributeOperand := &ua.ExtensionObject{\n+\t\tEncodingMask: ua.ExtensionObjectBinary,\n+\t\tTypeID: &ua.ExpandedNodeID{\n+\t\t\tNodeID: ua.NewNumericNodeID(0, id.SimpleAttributeOperand_Encoding_DefaultBinary),\n+\t\t},\n+\t\tValue: &ua.SimpleAttributeOperand{\n+\t\t\tTypeDefinitionID: typeDefinition,\n+\t\t\tBrowsePath: []*ua.QualifiedName{\n+\t\t\t\t{NamespaceIndex: 0, Name: \"SourceName\"},\n+\t\t\t},\n+\t\t\tAttributeID: ua.AttributeIDValue,\n+\t\t},\n+\t}\n+\n+\tfilterElement := &ua.ContentFilterElement{\n+\t\tFilterOperator: ua.FilterOperatorInList,\n+\t\tFilterOperands: append([]*ua.ExtensionObject{attributeOperand}, operands...),\n+\t}\n+\n+\twheres := &ua.ContentFilter{\n+\t\tElements: []*ua.ContentFilterElement{filterElement},\n+\t}\n+\n+\treturn wheres, nil\n+}\n+\n+func (node *EventNodeMetricMapping) determineNodeIDType() (*ua.NodeID, error) {\n+\tswitch node.EventTypeNode.Type() {\n+\tcase ua.NodeIDTypeGUID:\n+\t\treturn ua.NewGUIDNodeID(node.EventTypeNode.Namespace(), node.EventTypeNode.StringID()), nil\n+\tcase ua.NodeIDTypeString:\n+\t\treturn ua.NewStringNodeID(node.EventTypeNode.Namespace(), node.EventTypeNode.StringID()), nil\n+\tcase ua.NodeIDTypeByteString:\n+\t\treturn ua.NewByteStringNodeID(node.EventTypeNode.Namespace(), []byte(node.EventTypeNode.StringID())), nil\n+\tcase ua.NodeIDTypeTwoByte:\n+\t\tnodeID := node.EventTypeNode.IntID()\n+\t\tif nodeID > 255 {\n+\t\t\treturn nil, fmt.Errorf(\"twoByte EventType requires a value in the range 0-255, got %d\", nodeID)\n+\t\t}\n+\t\treturn ua.NewTwoByteNodeID(uint8(node.EventTypeNode.IntID())), nil\n+\tcase ua.NodeIDTypeFourByte:\n+\t\treturn ua.NewFourByteNodeID(uint8(node.EventTypeNode.Namespace()), uint16(node.EventTypeNode.IntID())), nil\n+\tcase ua.NodeIDTypeNumeric:\n+\t\treturn ua.NewNumericNodeID(node.EventTypeNode.Namespace(), node.EventTypeNode.IntID()), nil\n+\tdefault:\n+\t\treturn nil, fmt.Errorf(\"unsupported NodeID type: %v\", node.EventTypeNode.String())\n+\t}\n+}\ndiff --git a/plugins/inputs/opcua_listener/README.md b/plugins/inputs/opcua_listener/README.md\nindex 37bbef5e3b9cd..c4cfe7238b66a 100644\n--- a/plugins/inputs/opcua_listener/README.md\n+++ b/plugins/inputs/opcua_listener/README.md\n@@ -1,9 +1,13 @@\n # OPC UA Client Listener Input Plugin\n \n-The `opcua_listener` plugin subscribes to data from OPC UA Server devices.\n+This service plugin subscribes to data and events from an [OPC UA][opcua]\n+erver.\n \n-Telegraf minimum version: Telegraf 1.25\n-Plugin minimum tested version: 1.25\n+â­ Telegraf v1.25.0\n+ðŸ·ï¸ network\n+ðŸ’» linux, windows\n+\n+[opcua]: https://opcfoundation.org/\n \n ## Service Input <!-- @/docs/includes/service_input.md -->\n \n@@ -250,17 +254,42 @@ to use them.\n   #       deadband_value = 0.0\n   #\n \n+  ## Multiple event groups are allowed.\n+  # [[inputs.opcua_listener.events]]\n+  #   ## Polling interval for data collection\n+  #   # sampling_interval = \"10s\"\n+  #   ## Size of the notification queue\n+  #   # queue_size = 10\n+  #   ## Node parameter defaults for node definitions below\n+  #   # namespace = \"\"\n+  #   # identifier_type = \"\"\n+  #   ## Specifies OPCUA Event sources to filter on\n+  #   # source_names = [\"SourceName1\", \"SourceName2\"]\n+  #   ## Fields to capture from event notifications\n+  #   fields = [\"Severity\", \"Message\", \"Time\"]\n+  #\n+  #   ## Type or level of events to capture from the monitored nodes.\n+  #   [inputs.opcua_listener.events.event_type_node]\n+  #     namespace = \"\"\n+  #     identifier_type = \"\"\n+  #     identifier = \"\"\n+  #\n+  #   ## Nodes to monitor for event notifications associated with the defined\n+  #   ## event type\n+  #   [[inputs.opcua_listener.events.node_ids]]\n+  #     namespace = \"\"\n+  #     identifier_type = \"\"\n+  #     identifier = \"\"\n+\n   ## Enable workarounds required by some devices to work correctly\n   # [inputs.opcua_listener.workarounds]\n-    ## Set additional valid status codes, StatusOK (0x0) is always considered valid\n-    # additional_valid_status_codes = [\"0xC0\"]\n-\n-  # [inputs.opcua_listener.request_workarounds]\n-    ## Use unregistered reads instead of registered reads\n-    # use_unregistered_reads = false\n+  #  ## Set additional valid status codes, StatusOK (0x0) is always considered valid\n+  #  # additional_valid_status_codes = [\"0xC0\"]\n+  #  ## Use unregistered reads instead of registered reads\n+  #  # use_unregistered_reads = false\n ```\n \n-## Node Configuration\n+### Node Configuration\n \n An OPC UA node ID may resemble: \"ns=3;s=Temperature\". In this example:\n \n@@ -286,7 +315,7 @@ produces a metric like this:\n opcua,id=ns\\=3;s\\=Temperature temp=79.0,Quality=\"OK (0x0)\",DataType=\"Float\" 1597820490000000000\n ```\n \n-## Group Configuration\n+#### Group Configuration\n \n Groups can set default values for the namespace, identifier type, tags\n settings and sampling interval.  The default values apply to all the\n@@ -342,16 +371,68 @@ This example group configuration has three groups with two nodes each:\n     ]\n ```\n \n-## Connection Service\n+### Event Configuration\n+\n+Defining events allows subscribing to events with the specific node IDs and\n+filtering criteria based on the event type and source. The plugin subscribes to\n+the specified `event_type` Node-IDs and collects events that meet the defined\n+criteria. The `node_ids` parameter specifies the nodes to monitor for events\n+(monitored items). However, the actual subscription is based on the\n+`event_type_node` determining the events to capture.\n+\n+#### Event Group Configuration\n \n-This plugin subscribes to the specified nodes to receive data from\n-the OPC server. The updates are received at most as fast as the\n-`subscription_interval`.\n+You can define multiple groups for the event streaming to subscribe to different\n+event types. Each group allows to specify defaults for `namespace` and\n+`identifier_type` being overwritten by settings in `node_ids`. The group\n+defaults for node information will not affected the `event_type_node` setting\n+and all paramters must be set in this section.\n+\n+This example group configuration shows how to use group settings:\n+\n+```toml\n+# Group 1\n+[[inputs.opcua_listener.events]]\n+   sampling_interval = \"10s\"\n+   queue_size = \"100\"\n+   source_names = [\"SourceName1\", \"SourceName2\"]\n+   fields = [\"Severity\", \"Message\", \"Time\"]\n+\n+   [inputs.opcua_listener.events.event_type_node]\n+     namespace = \"1\"\n+     identifier_type = \"i\"\n+     identifier = \"1234\"\n+\n+   [[inputs.opcua_listener.events.node_ids]]\n+     namespace = \"2\"\n+     identifier_type = \"i\"\n+     identifier = \"2345\"\n+\n+# Group 2\n+[[inputs.opcua_listener.events]]\n+   sampling_interval = \"10s\"\n+   queue_size = \"100\"\n+   namespace = \"3\"\n+   identifier_type = \"s\"\n+   source_names = [\"SourceName1\", \"SourceName2\"]\n+   fields = [\"Severity\", \"Message\", \"Time\"]\n+\n+   [inputs.opcua_listener.events.event_type_node]\n+     namespace = \"1\"\n+     identifier_type = \"i\"\n+     identifier = \"5678\"\n+\n+    node_ids = [\n+      {identifier=\"Sensor1\"}, // default values will be used for namespace and identifier_type\n+      {namespace=\"2\", identifier=\"TemperatureSensor\"}, // default values will be used for identifier_type\n+      {namespace=\"5\", identifier_type=\"i\", identifier=\"2002\"} // no default values will be used\n+    ]\n+```\n \n ## Metrics\n \n-The metrics collected by this input plugin will depend on the\n-configured `nodes` and `group`.\n+The metrics collected by this input plugin will depend on the configured\n+`nodes`, `events` and the corresponding groups.\n \n ## Example Output\n \ndiff --git a/plugins/inputs/opcua_listener/opcua_listener.go b/plugins/inputs/opcua_listener/opcua_listener.go\nindex 6085c90c9f94c..6fd9fca36651f 100644\n--- a/plugins/inputs/opcua_listener/opcua_listener.go\n+++ b/plugins/inputs/opcua_listener/opcua_listener.go\n@@ -64,7 +64,7 @@ func (o *OpcUaListener) Stop() {\n \n func (o *OpcUaListener) connect(acc telegraf.Accumulator) error {\n \tctx := context.Background()\n-\tch, err := o.client.startStreamValues(ctx)\n+\tch, err := o.client.startMonitoring(ctx)\n \tif err != nil {\n \t\treturn err\n \t}\ndiff --git a/plugins/inputs/opcua_listener/sample.conf b/plugins/inputs/opcua_listener/sample.conf\nindex bc6ff6019ad50..2b820c49fb593 100644\n--- a/plugins/inputs/opcua_listener/sample.conf\n+++ b/plugins/inputs/opcua_listener/sample.conf\n@@ -211,11 +211,36 @@\n   #       deadband_value = 0.0\n   #\n \n+  ## Multiple event groups are allowed.\n+  # [[inputs.opcua_listener.events]]\n+  #   ## Polling interval for data collection\n+  #   # sampling_interval = \"10s\"\n+  #   ## Size of the notification queue\n+  #   # queue_size = 10\n+  #   ## Node parameter defaults for node definitions below\n+  #   # namespace = \"\"\n+  #   # identifier_type = \"\"\n+  #   ## Specifies OPCUA Event sources to filter on\n+  #   # source_names = [\"SourceName1\", \"SourceName2\"]\n+  #   ## Fields to capture from event notifications\n+  #   fields = [\"Severity\", \"Message\", \"Time\"]\n+  #\n+  #   ## Type or level of events to capture from the monitored nodes.\n+  #   [inputs.opcua_listener.events.event_type_node]\n+  #     namespace = \"\"\n+  #     identifier_type = \"\"\n+  #     identifier = \"\"\n+  #\n+  #   ## Nodes to monitor for event notifications associated with the defined\n+  #   ## event type\n+  #   [[inputs.opcua_listener.events.node_ids]]\n+  #     namespace = \"\"\n+  #     identifier_type = \"\"\n+  #     identifier = \"\"\n+\n   ## Enable workarounds required by some devices to work correctly\n   # [inputs.opcua_listener.workarounds]\n-    ## Set additional valid status codes, StatusOK (0x0) is always considered valid\n-    # additional_valid_status_codes = [\"0xC0\"]\n-\n-  # [inputs.opcua_listener.request_workarounds]\n-    ## Use unregistered reads instead of registered reads\n-    # use_unregistered_reads = false\n+  #  ## Set additional valid status codes, StatusOK (0x0) is always considered valid\n+  #  # additional_valid_status_codes = [\"0xC0\"]\n+  #  ## Use unregistered reads instead of registered reads\n+  #  # use_unregistered_reads = false\ndiff --git a/plugins/inputs/opcua_listener/subscribe_client.go b/plugins/inputs/opcua_listener/subscribe_client.go\nindex 1f70f006e7b6b..572f17f943c1c 100644\n--- a/plugins/inputs/opcua_listener/subscribe_client.go\n+++ b/plugins/inputs/opcua_listener/subscribe_client.go\n@@ -28,6 +28,7 @@ type subscribeClient struct {\n \n \tsub                *opcua.Subscription\n \tmonitoredItemsReqs []*ua.MonitoredItemCreateRequest\n+\teventItemsReqs     []*ua.MonitoredItemCreateRequest\n \tdataNotifications  chan *opcua.PublishNotificationData\n \tmetrics            chan telegraf.Metric\n \n@@ -91,11 +92,17 @@ func (sc *subscribeClientConfig) createSubscribeClient(log telegraf.Logger) (*su\n \t\treturn nil, err\n \t}\n \n+\tif err := client.InitEventNodeIDs(); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n \tprocessingCtx, processingCancel := context.WithCancel(context.Background())\n+\n \tsubClient := &subscribeClient{\n \t\tOpcUAInputClient:   client,\n \t\tConfig:             *sc,\n \t\tmonitoredItemsReqs: make([]*ua.MonitoredItemCreateRequest, len(client.NodeIDs)),\n+\t\teventItemsReqs:     make([]*ua.MonitoredItemCreateRequest, len(client.EventNodeMetricMapping)),\n \t\t// 100 was chosen to make sure that the channels will not block when multiple changes come in at the same time.\n \t\t// The channel size should be increased if reports come in on Telegraf blocking when many changes come in at\n \t\t// the same time. It could be made dependent on the number of nodes subscribed to and the subscription interval.\n@@ -115,6 +122,23 @@ func (sc *subscribeClientConfig) createSubscribeClient(log telegraf.Logger) (*su\n \t\tsubClient.monitoredItemsReqs[i] = req\n \t}\n \n+\tlog.Debugf(\"Creating event streaming items\")\n+\tfor i, node := range client.EventNodeMetricMapping {\n+\t\treq := opcua.NewMonitoredItemCreateRequestWithDefaults(node.NodeID, ua.AttributeIDEventNotifier, uint32(i))\n+\t\tif node.SamplingInterval != nil {\n+\t\t\treq.RequestedParameters.SamplingInterval = float64(time.Duration(*node.SamplingInterval) / time.Millisecond)\n+\t\t}\n+\t\tif node.QueueSize != nil {\n+\t\t\treq.RequestedParameters.QueueSize = *node.QueueSize\n+\t\t}\n+\n+\t\tfilterExtObj, err := node.CreateEventFilter()\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to create event filter: %w\", err)\n+\t\t}\n+\t\treq.RequestedParameters.Filter = filterExtObj\n+\t\tsubClient.eventItemsReqs[i] = req\n+\t}\n \treturn subClient, nil\n }\n \n@@ -152,7 +176,7 @@ func (o *subscribeClient) stop(ctx context.Context) <-chan struct{} {\n \treturn closing\n }\n \n-func (o *subscribeClient) startStreamValues(ctx context.Context) (<-chan telegraf.Metric, error) {\n+func (o *subscribeClient) startMonitoring(ctx context.Context) (<-chan telegraf.Metric, error) {\n \terr := o.connect()\n \tif err != nil {\n \t\tswitch o.Config.ConnectFailBehavior {\n@@ -166,23 +190,38 @@ func (o *subscribeClient) startStreamValues(ctx context.Context) (<-chan telegra\n \t\treturn nil, err\n \t}\n \n-\tresp, err := o.sub.Monitor(ctx, ua.TimestampsToReturnBoth, o.monitoredItemsReqs...)\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"failed to start monitoring items: %w\", err)\n-\t}\n-\to.Log.Debug(\"Monitoring items\")\n-\n-\tfor idx, res := range resp.Results {\n-\t\tif !o.StatusCodeOK(res.StatusCode) {\n-\t\t\t// Verify NodeIDs array has been built before trying to get item; otherwise show '?' for node id\n-\t\t\tif len(o.OpcUAInputClient.NodeIDs) > idx {\n-\t\t\t\to.Log.Debugf(\"Failed to create monitored item for node %v (%v)\",\n-\t\t\t\t\to.OpcUAInputClient.NodeMetricMapping[idx].Tag.FieldName, o.OpcUAInputClient.NodeIDs[idx].String())\n-\t\t\t} else {\n-\t\t\t\to.Log.Debugf(\"Failed to create monitored item for node %v (%v)\", o.OpcUAInputClient.NodeMetricMapping[idx].Tag.FieldName, '?')\n+\tif len(o.monitoredItemsReqs) != 0 {\n+\t\tresp, err := o.sub.Monitor(ctx, ua.TimestampsToReturnBoth, o.monitoredItemsReqs...)\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to start monitoring items: %w\", err)\n+\t\t}\n+\t\to.Log.Debug(\"Monitoring items\")\n+\n+\t\tfor idx, res := range resp.Results {\n+\t\t\tif !o.StatusCodeOK(res.StatusCode) {\n+\t\t\t\t// Verify NodeIDs array has been built before trying to get item; otherwise show '?' for node id\n+\t\t\t\tif len(o.OpcUAInputClient.NodeIDs) > idx {\n+\t\t\t\t\to.Log.Debugf(\"Failed to create monitored item for node %v (%v)\",\n+\t\t\t\t\t\to.OpcUAInputClient.NodeMetricMapping[idx].Tag.FieldName, o.OpcUAInputClient.NodeIDs[idx].String())\n+\t\t\t\t} else {\n+\t\t\t\t\to.Log.Debugf(\"Failed to create monitored item for node %v (%v)\", o.OpcUAInputClient.NodeMetricMapping[idx].Tag.FieldName, '?')\n+\t\t\t\t}\n+\t\t\t\treturn nil, fmt.Errorf(\"creating monitored item failed with status code: %w\", res.StatusCode)\n \t\t\t}\n+\t\t}\n+\t}\n+\n+\tif len(o.eventItemsReqs) != 0 {\n+\t\tresp, err := o.sub.Monitor(ctx, ua.TimestampsToReturnBoth, o.eventItemsReqs...)\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"failed to start monitoring event stream: %w\", err)\n+\t\t}\n+\t\to.Log.Debug(\"Monitoring events\")\n \n-\t\t\treturn nil, fmt.Errorf(\"creating monitored item failed with status code: %w\", res.StatusCode)\n+\t\tfor _, res := range resp.Results {\n+\t\t\tif !o.StatusCodeOK(res.StatusCode) {\n+\t\t\t\treturn nil, fmt.Errorf(\"creating monitored event streaming item failed with status code: %w\", res.StatusCode)\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -207,6 +246,10 @@ func (o *subscribeClient) processReceivedNotifications() {\n \t\t\t\to.Log.Error(res.Error)\n \t\t\t\tcontinue\n \t\t\t}\n+\t\t\tif res.Value == nil {\n+\t\t\t\to.Log.Error(\"Received nil notification\")\n+\t\t\t\treturn\n+\t\t\t}\n \n \t\t\tswitch notif := res.Value.(type) {\n \t\t\tcase *ua.DataChangeNotification:\n@@ -220,7 +263,13 @@ func (o *subscribeClient) processReceivedNotifications() {\n \t\t\t\t\t\to.NodeIDs[i].String(), oldValue, o.LastReceivedData[i].Value)\n \t\t\t\t\to.metrics <- o.MetricForNode(i)\n \t\t\t\t}\n-\n+\t\t\tcase *ua.EventNotificationList:\n+\t\t\t\to.Log.Debugf(\"Processing event notification with %d events\", len(notif.Events))\n+\t\t\t\t// It is assumed the events are ordered chronologically\n+\t\t\t\tfor _, event := range notif.Events {\n+\t\t\t\t\ti := int(event.ClientHandle)\n+\t\t\t\t\to.metrics <- o.MetricForEvent(i, event)\n+\t\t\t\t}\n \t\t\tdefault:\n \t\t\t\to.Log.Warnf(\"Received notification has unexpected type %s\", reflect.TypeOf(res.Value))\n \t\t\t}\n", "test_patch": "diff --git a/plugins/inputs/opcua_listener/opcua_listener_test.go b/plugins/inputs/opcua_listener/opcua_listener_test.go\nindex 7fc29ae03e945..4937155f75985 100644\n--- a/plugins/inputs/opcua_listener/opcua_listener_test.go\n+++ b/plugins/inputs/opcua_listener/opcua_listener_test.go\n@@ -193,7 +193,7 @@ func TestSubscribeClientIntegration(t *testing.T) {\n \n \tctx, cancel := context.WithTimeout(t.Context(), time.Second*10)\n \tdefer cancel()\n-\tres, err := o.startStreamValues(ctx)\n+\tres, err := o.startMonitoring(ctx)\n \trequire.Equal(t, opcua.Connected, o.State())\n \trequire.NoError(t, err)\n \n@@ -336,7 +336,7 @@ func TestSubscribeClientIntegrationAdditionalFields(t *testing.T) {\n \n \tctx, cancel := context.WithTimeout(t.Context(), time.Second*10)\n \tdefer cancel()\n-\tres, err := o.startStreamValues(ctx)\n+\tres, err := o.startMonitoring(ctx)\n \trequire.NoError(t, err)\n \n \tfor {\n@@ -814,3 +814,482 @@ func TestSubscribeClientConfigValidMonitoringParams(t *testing.T) {\n \t\t),\n \t}, subClient.monitoredItemsReqs[0].RequestedParameters)\n }\n+\n+func TestSubscribeClientConfigValidMonitoringAndEventParams(t *testing.T) {\n+\tsubscribeConfig := subscribeClientConfig{\n+\t\tInputClientConfig: input.InputClientConfig{\n+\t\t\tOpcUAClientConfig: opcua.OpcUAClientConfig{\n+\t\t\t\tEndpoint:       \"opc.tcp://localhost:4840\",\n+\t\t\t\tSecurityPolicy: \"None\",\n+\t\t\t\tSecurityMode:   \"None\",\n+\t\t\t\tAuthMethod:     \"Anonymous\",\n+\t\t\t\tConnectTimeout: config.Duration(10 * time.Second),\n+\t\t\t\tRequestTimeout: config.Duration(1 * time.Second),\n+\t\t\t\tWorkarounds:    opcua.OpcUAWorkarounds{},\n+\t\t\t},\n+\t\t\tMetricName:  \"testing\",\n+\t\t\tRootNodes:   make([]input.NodeSettings, 0),\n+\t\t\tGroups:      make([]input.NodeGroupSettings, 0),\n+\t\t\tEventGroups: make([]input.EventGroupSettings, 0),\n+\t\t},\n+\t\tSubscriptionInterval: 0,\n+\t}\n+\n+\tvar queueSize uint32 = 10\n+\tdiscardOldest := true\n+\tdeadbandValue := 10.0\n+\tsubscribeConfig.RootNodes = append(subscribeConfig.RootNodes, input.NodeSettings{\n+\t\tFieldName:      \"foo\",\n+\t\tNamespace:      \"3\",\n+\t\tIdentifier:     \"1\",\n+\t\tIdentifierType: \"i\",\n+\t\tMonitoringParams: input.MonitoringParameters{\n+\t\t\tSamplingInterval: 50000000,\n+\t\t\tQueueSize:        &queueSize,\n+\t\t\tDiscardOldest:    &discardOldest,\n+\t\t\tDataChangeFilter: &input.DataChangeFilter{\n+\t\t\t\tTrigger:       \"Status\",\n+\t\t\t\tDeadbandType:  \"Absolute\",\n+\t\t\t\tDeadbandValue: &deadbandValue,\n+\t\t\t},\n+\t\t},\n+\t})\n+\tsubscribeConfig.EventGroups = append(subscribeConfig.EventGroups, input.EventGroupSettings{\n+\t\tSamplingInterval: 1.0,\n+\t\tEventTypeNode: input.EventNodeSettings{\n+\t\t\tNamespace:      \"3\",\n+\t\t\tIdentifierType: \"i\",\n+\t\t\tIdentifier:     \"1234\",\n+\t\t},\n+\t\tNamespace:      \"3\",\n+\t\tIdentifierType: \"i\",\n+\t\tNodeIDSettings: []input.EventNodeSettings{\n+\t\t\t{\n+\t\t\t\tNamespace:      \"3\",\n+\t\t\t\tIdentifierType: \"i\",\n+\t\t\t\tIdentifier:     \"12\",\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tNamespace:      \"3\",\n+\t\t\t\tIdentifierType: \"i\",\n+\t\t\t\tIdentifier:     \"13\",\n+\t\t\t},\n+\t\t},\n+\t\tSourceNames: []string{\"SensorXYZ\"},\n+\t\tFields:      []string{\"PressureValue\"},\n+\t})\n+\n+\tsubClient, err := subscribeConfig.createSubscribeClient(testutil.Logger{})\n+\trequire.NoError(t, err)\n+\trequire.Equal(t, &ua.MonitoringParameters{\n+\t\tSamplingInterval: 50,\n+\t\tQueueSize:        queueSize,\n+\t\tDiscardOldest:    discardOldest,\n+\t\tFilter: ua.NewExtensionObject(\n+\t\t\t&ua.DataChangeFilter{\n+\t\t\t\tTrigger:       ua.DataChangeTriggerStatus,\n+\t\t\t\tDeadbandType:  uint32(ua.DeadbandTypeAbsolute),\n+\t\t\t\tDeadbandValue: deadbandValue,\n+\t\t\t},\n+\t\t),\n+\t}, subClient.monitoredItemsReqs[0].RequestedParameters)\n+}\n+\n+func TestSubscribeClientConfigValidEventStreamingParams(t *testing.T) {\n+\tsubscribeConfig := subscribeClientConfig{\n+\t\tInputClientConfig: input.InputClientConfig{\n+\t\t\tOpcUAClientConfig: opcua.OpcUAClientConfig{\n+\t\t\t\tEndpoint:       \"opc.tcp://opcua.demo-this.com:62544/Quickstarts/AlarmConditionServer\",\n+\t\t\t\tSecurityPolicy: \"None\",\n+\t\t\t\tSecurityMode:   \"None\",\n+\t\t\t\tAuthMethod:     \"Anonymous\",\n+\t\t\t\tConnectTimeout: config.Duration(10 * time.Second),\n+\t\t\t\tRequestTimeout: config.Duration(1 * time.Second),\n+\t\t\t\tWorkarounds:    opcua.OpcUAWorkarounds{},\n+\t\t\t},\n+\t\t\tMetricName:  \"testing\",\n+\t\t\tEventGroups: make([]input.EventGroupSettings, 0),\n+\t\t},\n+\t\tSubscriptionInterval: 0,\n+\t}\n+\tsubscribeConfig.EventGroups = append(subscribeConfig.EventGroups, input.EventGroupSettings{\n+\t\tSamplingInterval: 1.0,\n+\t\tEventTypeNode: input.EventNodeSettings{\n+\t\t\tNamespace:      \"3\",\n+\t\t\tIdentifierType: \"i\",\n+\t\t\tIdentifier:     \"1234\",\n+\t\t},\n+\t\tNamespace:      \"3\",\n+\t\tIdentifierType: \"i\",\n+\t\tNodeIDSettings: []input.EventNodeSettings{\n+\t\t\t{\n+\t\t\t\tNamespace:      \"3\",\n+\t\t\t\tIdentifierType: \"i\",\n+\t\t\t\tIdentifier:     \"12\",\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tNamespace:      \"3\",\n+\t\t\t\tIdentifierType: \"i\",\n+\t\t\t\tIdentifier:     \"13\",\n+\t\t\t},\n+\t\t},\n+\t\tSourceNames: []string{\"SensorXYZ\"},\n+\t\tFields:      []string{\"PressureValue\"},\n+\t})\n+\n+\t_, err := subscribeConfig.createSubscribeClient(testutil.Logger{})\n+\trequire.NoError(t, err)\n+}\n+\n+func TestSubscribeClientConfigEventInputMissingSamplingInterval(t *testing.T) {\n+\tsubscribeConfig := subscribeClientConfig{\n+\t\tInputClientConfig: input.InputClientConfig{\n+\t\t\tOpcUAClientConfig: opcua.OpcUAClientConfig{\n+\t\t\t\tEndpoint:       \"opc.tcp://opcua.demo-this.com:62544/Quickstarts/AlarmConditionServer\",\n+\t\t\t\tSecurityPolicy: \"None\",\n+\t\t\t\tSecurityMode:   \"None\",\n+\t\t\t\tAuthMethod:     \"Anonymous\",\n+\t\t\t\tConnectTimeout: config.Duration(10 * time.Second),\n+\t\t\t\tRequestTimeout: config.Duration(1 * time.Second),\n+\t\t\t\tWorkarounds:    opcua.OpcUAWorkarounds{},\n+\t\t\t},\n+\t\t\tMetricName:  \"testing\",\n+\t\t\tEventGroups: make([]input.EventGroupSettings, 0),\n+\t\t},\n+\t\tSubscriptionInterval: 0,\n+\t}\n+\tsubscribeConfig.EventGroups = append(subscribeConfig.EventGroups, input.EventGroupSettings{\n+\t\tEventTypeNode: input.EventNodeSettings{\n+\t\t\tNamespace:      \"3\",\n+\t\t\tIdentifierType: \"i\",\n+\t\t\tIdentifier:     \"1234\",\n+\t\t},\n+\t\tNamespace:      \"3\",\n+\t\tIdentifierType: \"i\",\n+\t\tNodeIDSettings: []input.EventNodeSettings{\n+\t\t\t{\n+\t\t\t\tNamespace:      \"3\",\n+\t\t\t\tIdentifierType: \"i\",\n+\t\t\t\tIdentifier:     \"12\",\n+\t\t\t},\n+\t\t},\n+\t\tSourceNames: []string{\"SensorXYZ\"},\n+\t\tFields:      []string{\"PressureValue\"},\n+\t})\n+\n+\t_, err := subscribeConfig.createSubscribeClient(testutil.Logger{})\n+\trequire.NoError(t, err)\n+}\n+\n+func TestSubscribeClientConfigEventInputMissingEventType(t *testing.T) {\n+\tsubscribeConfig := subscribeClientConfig{\n+\t\tInputClientConfig: input.InputClientConfig{\n+\t\t\tOpcUAClientConfig: opcua.OpcUAClientConfig{\n+\t\t\t\tEndpoint:       \"opc.tcp://opcua.demo-this.com:62544/Quickstarts/AlarmConditionServer\",\n+\t\t\t\tSecurityPolicy: \"None\",\n+\t\t\t\tSecurityMode:   \"None\",\n+\t\t\t\tAuthMethod:     \"Anonymous\",\n+\t\t\t\tConnectTimeout: config.Duration(10 * time.Second),\n+\t\t\t\tRequestTimeout: config.Duration(1 * time.Second),\n+\t\t\t\tWorkarounds:    opcua.OpcUAWorkarounds{},\n+\t\t\t},\n+\t\t\tMetricName:  \"testing\",\n+\t\t\tEventGroups: make([]input.EventGroupSettings, 0),\n+\t\t},\n+\t\tSubscriptionInterval: 0,\n+\t}\n+\tsubscribeConfig.EventGroups = append(subscribeConfig.EventGroups, input.EventGroupSettings{\n+\t\tSamplingInterval: 1.0,\n+\t\tNamespace:        \"3\",\n+\t\tIdentifierType:   \"i\",\n+\t\tNodeIDSettings: []input.EventNodeSettings{\n+\t\t\t{\n+\t\t\t\tNamespace:      \"3\",\n+\t\t\t\tIdentifierType: \"i\",\n+\t\t\t\tIdentifier:     \"12\",\n+\t\t\t},\n+\t\t},\n+\t\tSourceNames: []string{\"SensorXYZ\"},\n+\t\tFields:      []string{\"PressureValue\"},\n+\t})\n+\n+\t_, err := subscribeConfig.createSubscribeClient(testutil.Logger{})\n+\trequire.ErrorContains(t, err, \"invalid event_type_node_settings\")\n+}\n+\n+func TestSubscribeClientConfigEventMissingEventTypeNamespace(t *testing.T) {\n+\tsubscribeConfig := subscribeClientConfig{\n+\t\tInputClientConfig: input.InputClientConfig{\n+\t\t\tOpcUAClientConfig: opcua.OpcUAClientConfig{\n+\t\t\t\tEndpoint:       \"opc.tcp://opcua.demo-this.com:62544/Quickstarts/AlarmConditionServer\",\n+\t\t\t\tSecurityPolicy: \"None\",\n+\t\t\t\tSecurityMode:   \"None\",\n+\t\t\t\tAuthMethod:     \"Anonymous\",\n+\t\t\t\tConnectTimeout: config.Duration(10 * time.Second),\n+\t\t\t\tRequestTimeout: config.Duration(1 * time.Second),\n+\t\t\t\tWorkarounds:    opcua.OpcUAWorkarounds{},\n+\t\t\t},\n+\t\t\tMetricName:  \"testing\",\n+\t\t\tEventGroups: make([]input.EventGroupSettings, 0),\n+\t\t},\n+\t\tSubscriptionInterval: 0,\n+\t}\n+\tsubscribeConfig.EventGroups = append(subscribeConfig.EventGroups, input.EventGroupSettings{\n+\t\tSamplingInterval: 1.0,\n+\t\tEventTypeNode: input.EventNodeSettings{\n+\t\t\tIdentifierType: \"i\",\n+\t\t\tIdentifier:     \"1234\",\n+\t\t},\n+\t\tNamespace:      \"3\",\n+\t\tIdentifierType: \"i\",\n+\t\tNodeIDSettings: []input.EventNodeSettings{\n+\t\t\t{\n+\t\t\t\tNamespace:      \"3\",\n+\t\t\t\tIdentifierType: \"i\",\n+\t\t\t\tIdentifier:     \"12\",\n+\t\t\t},\n+\t\t},\n+\t\tSourceNames: []string{\"SensorXYZ\"},\n+\t\tFields:      []string{\"PressureValue\"},\n+\t})\n+\n+\t_, err := subscribeConfig.createSubscribeClient(testutil.Logger{})\n+\trequire.ErrorContains(t, err, \"namespace must be set\")\n+}\n+\n+func TestSubscribeClientConfigEventMissingEventTypeIdentifierType(t *testing.T) {\n+\tsubscribeConfig := subscribeClientConfig{\n+\t\tInputClientConfig: input.InputClientConfig{\n+\t\t\tOpcUAClientConfig: opcua.OpcUAClientConfig{\n+\t\t\t\tEndpoint:       \"opc.tcp://opcua.demo-this.com:62544/Quickstarts/AlarmConditionServer\",\n+\t\t\t\tSecurityPolicy: \"None\",\n+\t\t\t\tSecurityMode:   \"None\",\n+\t\t\t\tAuthMethod:     \"Anonymous\",\n+\t\t\t\tConnectTimeout: config.Duration(10 * time.Second),\n+\t\t\t\tRequestTimeout: config.Duration(1 * time.Second),\n+\t\t\t\tWorkarounds:    opcua.OpcUAWorkarounds{},\n+\t\t\t},\n+\t\t\tMetricName:  \"testing\",\n+\t\t\tEventGroups: make([]input.EventGroupSettings, 0),\n+\t\t},\n+\t\tSubscriptionInterval: 0,\n+\t}\n+\tsubscribeConfig.EventGroups = append(subscribeConfig.EventGroups, input.EventGroupSettings{\n+\t\tSamplingInterval: 1.0,\n+\t\tEventTypeNode: input.EventNodeSettings{\n+\t\t\tNamespace:  \"3\",\n+\t\t\tIdentifier: \"1234\",\n+\t\t},\n+\t\tNamespace:      \"3\",\n+\t\tIdentifierType: \"i\",\n+\t\tNodeIDSettings: []input.EventNodeSettings{\n+\t\t\t{\n+\t\t\t\tNamespace:      \"3\",\n+\t\t\t\tIdentifierType: \"i\",\n+\t\t\t\tIdentifier:     \"12\",\n+\t\t\t},\n+\t\t},\n+\t\tSourceNames: []string{\"SensorXYZ\"},\n+\t\tFields:      []string{\"PressureValue\"},\n+\t})\n+\n+\t_, err := subscribeConfig.createSubscribeClient(testutil.Logger{})\n+\trequire.ErrorContains(t, err, \"identifier_type must be set\")\n+}\n+\n+func TestSubscribeClientConfigEventMissingEventTypeIdentifier(t *testing.T) {\n+\tsubscribeConfig := subscribeClientConfig{\n+\t\tInputClientConfig: input.InputClientConfig{\n+\t\t\tOpcUAClientConfig: opcua.OpcUAClientConfig{\n+\t\t\t\tEndpoint:       \"opc.tcp://opcua.demo-this.com:62544/Quickstarts/AlarmConditionServer\",\n+\t\t\t\tSecurityPolicy: \"None\",\n+\t\t\t\tSecurityMode:   \"None\",\n+\t\t\t\tAuthMethod:     \"Anonymous\",\n+\t\t\t\tConnectTimeout: config.Duration(10 * time.Second),\n+\t\t\t\tRequestTimeout: config.Duration(1 * time.Second),\n+\t\t\t\tWorkarounds:    opcua.OpcUAWorkarounds{},\n+\t\t\t},\n+\t\t\tMetricName:  \"testing\",\n+\t\t\tEventGroups: make([]input.EventGroupSettings, 0),\n+\t\t},\n+\t\tSubscriptionInterval: 0,\n+\t}\n+\tsubscribeConfig.EventGroups = append(subscribeConfig.EventGroups, input.EventGroupSettings{\n+\t\tSamplingInterval: 1.0,\n+\t\tEventTypeNode: input.EventNodeSettings{\n+\t\t\tNamespace:      \"3\",\n+\t\t\tIdentifierType: \"i\",\n+\t\t},\n+\t\tNamespace:      \"3\",\n+\t\tIdentifierType: \"i\",\n+\t\tNodeIDSettings: []input.EventNodeSettings{\n+\t\t\t{\n+\t\t\t\tNamespace:      \"3\",\n+\t\t\t\tIdentifierType: \"i\",\n+\t\t\t\tIdentifier:     \"12\",\n+\t\t\t},\n+\t\t},\n+\t\tSourceNames: []string{\"SensorXYZ\"},\n+\t\tFields:      []string{\"PressureValue\"},\n+\t})\n+\n+\t_, err := subscribeConfig.createSubscribeClient(testutil.Logger{})\n+\trequire.ErrorContains(t, err, \"identifier must be set\")\n+}\n+\n+func TestSubscribeClientConfigEventInputMissingNodeIDs(t *testing.T) {\n+\tsubscribeConfig := subscribeClientConfig{\n+\t\tInputClientConfig: input.InputClientConfig{\n+\t\t\tOpcUAClientConfig: opcua.OpcUAClientConfig{\n+\t\t\t\tEndpoint:       \"opc.tcp://opcua.demo-this.com:62544/Quickstarts/AlarmConditionServer\",\n+\t\t\t\tSecurityPolicy: \"None\",\n+\t\t\t\tSecurityMode:   \"None\",\n+\t\t\t\tAuthMethod:     \"Anonymous\",\n+\t\t\t\tConnectTimeout: config.Duration(10 * time.Second),\n+\t\t\t\tRequestTimeout: config.Duration(1 * time.Second),\n+\t\t\t\tWorkarounds:    opcua.OpcUAWorkarounds{},\n+\t\t\t},\n+\t\t\tMetricName:  \"testing\",\n+\t\t\tEventGroups: make([]input.EventGroupSettings, 0),\n+\t\t},\n+\t\tSubscriptionInterval: 0,\n+\t}\n+\tsubscribeConfig.EventGroups = append(subscribeConfig.EventGroups, input.EventGroupSettings{\n+\t\tEventTypeNode: input.EventNodeSettings{\n+\t\t\tNamespace:      \"3\",\n+\t\t\tIdentifierType: \"i\",\n+\t\t\tIdentifier:     \"1234\",\n+\t\t},\n+\t\tNamespace:      \"3\",\n+\t\tIdentifierType: \"i\",\n+\t\tSourceNames:    []string{\"SensorXYZ\"},\n+\t\tFields:         []string{\"PressureValue\"},\n+\t})\n+\n+\t_, err := subscribeConfig.createSubscribeClient(testutil.Logger{})\n+\trequire.ErrorContains(t, err, \"at least one node_id must be specified\")\n+}\n+\n+func TestSubscribeClientConfigEventInputMissingFields(t *testing.T) {\n+\tsubscribeConfig := subscribeClientConfig{\n+\t\tInputClientConfig: input.InputClientConfig{\n+\t\t\tOpcUAClientConfig: opcua.OpcUAClientConfig{\n+\t\t\t\tEndpoint:       \"opc.tcp://opcua.demo-this.com:62544/Quickstarts/AlarmConditionServer\",\n+\t\t\t\tSecurityPolicy: \"None\",\n+\t\t\t\tSecurityMode:   \"None\",\n+\t\t\t\tAuthMethod:     \"Anonymous\",\n+\t\t\t\tConnectTimeout: config.Duration(10 * time.Second),\n+\t\t\t\tRequestTimeout: config.Duration(1 * time.Second),\n+\t\t\t\tWorkarounds:    opcua.OpcUAWorkarounds{},\n+\t\t\t},\n+\t\t\tMetricName:  \"testing\",\n+\t\t\tEventGroups: make([]input.EventGroupSettings, 0),\n+\t\t},\n+\t\tSubscriptionInterval: 0,\n+\t}\n+\tsubscribeConfig.EventGroups = append(subscribeConfig.EventGroups, input.EventGroupSettings{\n+\t\tSamplingInterval: 1.0,\n+\t\tEventTypeNode: input.EventNodeSettings{\n+\t\t\tNamespace:      \"3\",\n+\t\t\tIdentifierType: \"i\",\n+\t\t\tIdentifier:     \"1234\",\n+\t\t},\n+\t\tNamespace:      \"3\",\n+\t\tIdentifierType: \"i\",\n+\t\tNodeIDSettings: []input.EventNodeSettings{\n+\t\t\t{\n+\t\t\t\tNamespace:      \"3\",\n+\t\t\t\tIdentifierType: \"i\",\n+\t\t\t\tIdentifier:     \"12\",\n+\t\t\t},\n+\t\t},\n+\t\tSourceNames: []string{\"SensorXYZ\"},\n+\t})\n+\n+\t_, err := subscribeConfig.createSubscribeClient(testutil.Logger{})\n+\trequire.ErrorContains(t, err, \"at least one Field must be specified\")\n+}\n+\n+func TestSubscribeClientConfigEventInputInvalidFields(t *testing.T) {\n+\tsubscribeConfig := subscribeClientConfig{\n+\t\tInputClientConfig: input.InputClientConfig{\n+\t\t\tOpcUAClientConfig: opcua.OpcUAClientConfig{\n+\t\t\t\tEndpoint:       \"opc.tcp://opcua.demo-this.com:62544/Quickstarts/AlarmConditionServer\",\n+\t\t\t\tSecurityPolicy: \"None\",\n+\t\t\t\tSecurityMode:   \"None\",\n+\t\t\t\tAuthMethod:     \"Anonymous\",\n+\t\t\t\tConnectTimeout: config.Duration(10 * time.Second),\n+\t\t\t\tRequestTimeout: config.Duration(1 * time.Second),\n+\t\t\t\tWorkarounds:    opcua.OpcUAWorkarounds{},\n+\t\t\t},\n+\t\t\tMetricName:  \"testing\",\n+\t\t\tEventGroups: make([]input.EventGroupSettings, 0),\n+\t\t},\n+\t\tSubscriptionInterval: 0,\n+\t}\n+\tsubscribeConfig.EventGroups = append(subscribeConfig.EventGroups, input.EventGroupSettings{\n+\t\tSamplingInterval: 1.0,\n+\t\tEventTypeNode: input.EventNodeSettings{\n+\t\t\tNamespace:      \"3\",\n+\t\t\tIdentifierType: \"i\",\n+\t\t\tIdentifier:     \"1234\",\n+\t\t},\n+\t\tNamespace:      \"3\",\n+\t\tIdentifierType: \"i\",\n+\t\tNodeIDSettings: []input.EventNodeSettings{\n+\t\t\t{\n+\t\t\t\tNamespace:      \"3\",\n+\t\t\t\tIdentifierType: \"i\",\n+\t\t\t\tIdentifier:     \"12\",\n+\t\t\t},\n+\t\t},\n+\t\tSourceNames: []string{\"SensorXYZ\"},\n+\t\tFields:      []string{\"Fieldname\", \"\"},\n+\t})\n+\n+\t_, err := subscribeConfig.createSubscribeClient(testutil.Logger{})\n+\trequire.ErrorContains(t, err, \"empty field name in fields stanza\")\n+}\n+\n+func TestSubscribeClientConfigValidEventStreamingDefaultNodeParams(t *testing.T) {\n+\tsubscribeConfig := subscribeClientConfig{\n+\t\tInputClientConfig: input.InputClientConfig{\n+\t\t\tOpcUAClientConfig: opcua.OpcUAClientConfig{\n+\t\t\t\tEndpoint:       \"opc.tcp://opcua.demo-this.com:62544/Quickstarts/AlarmConditionServer\",\n+\t\t\t\tSecurityPolicy: \"None\",\n+\t\t\t\tSecurityMode:   \"None\",\n+\t\t\t\tAuthMethod:     \"Anonymous\",\n+\t\t\t\tConnectTimeout: config.Duration(10 * time.Second),\n+\t\t\t\tRequestTimeout: config.Duration(1 * time.Second),\n+\t\t\t\tWorkarounds:    opcua.OpcUAWorkarounds{},\n+\t\t\t},\n+\t\t\tMetricName:  \"testing\",\n+\t\t\tEventGroups: make([]input.EventGroupSettings, 0),\n+\t\t},\n+\t\tSubscriptionInterval: 0,\n+\t}\n+\tsubscribeConfig.EventGroups = append(subscribeConfig.EventGroups, input.EventGroupSettings{\n+\t\tSamplingInterval: 1.0,\n+\t\tEventTypeNode: input.EventNodeSettings{\n+\t\t\tNamespace:      \"3\",\n+\t\t\tIdentifierType: \"i\",\n+\t\t\tIdentifier:     \"1234\",\n+\t\t},\n+\t\tNamespace:      \"3\",\n+\t\tIdentifierType: \"i\",\n+\t\tNodeIDSettings: []input.EventNodeSettings{\n+\t\t\t{\n+\t\t\t\tIdentifier: \"12\",\n+\t\t\t},\n+\t\t},\n+\t\tSourceNames: []string{\"SensorXYZ\"},\n+\t\tFields:      []string{\"PressureValue\"},\n+\t})\n+\n+\t_, err := subscribeConfig.createSubscribeClient(testutil.Logger{})\n+\trequire.NoError(t, err)\n+\n+\to := subscribeConfig.InputClientConfig.EventGroups[0].NodeIDSettings[0]\n+\trequire.Equal(t, \"i\", o.IdentifierType)\n+\trequire.Equal(t, \"3\", o.Namespace)\n+}\n"}
{"org": "authelia", "repo": "authelia", "number": 7230, "state": "closed", "title": "feat(regulation): ip bans and unbanning", "body": "This adds several new features to the regulation functionality including IP banning and the ability to unban users.\r\n\r\nCloses #48, Closes #4730", "url": "https://api.github.com/repos/authelia/authelia/pulls/7230", "id": 1840278570, "node_id": "PR_kwDOBIRkGM5tsGwq", "html_url": "https://github.com/authelia/authelia/pull/7230", "diff_url": "https://github.com/authelia/authelia/pull/7230.diff", "patch_url": "https://github.com/authelia/authelia/pull/7230.patch", "issue_url": "https://api.github.com/repos/authelia/authelia/issues/7230", "created_at": "2024-04-25T07:39:58+00:00", "updated_at": "2025-02-23T11:11:40+00:00", "closed_at": "2025-02-23T11:10:31+00:00", "merged_at": "2025-02-23T11:10:31+00:00", "merge_commit_sha": "5e40d974e9a8ef6ff0fce09873d2c03720e7ca45", "labels": [], "draft": false, "commits_url": "https://api.github.com/repos/authelia/authelia/pulls/7230/commits", "review_comments_url": "https://api.github.com/repos/authelia/authelia/pulls/7230/comments", "review_comment_url": "https://api.github.com/repos/authelia/authelia/pulls/comments{/number}", "comments_url": "https://api.github.com/repos/authelia/authelia/issues/7230/comments", "base": {"label": "authelia:master", "ref": "master", "sha": "3dad392ea455d9a63dd79ad788a9aebfc02fca3e", "user": {"login": "authelia", "id": 59122411, "node_id": "MDEyOk9yZ2FuaXphdGlvbjU5MTIyNDEx", "avatar_url": "https://avatars.githubusercontent.com/u/59122411?v=4", "gravatar_id": "", "url": "https://api.github.com/users/authelia", "html_url": "https://github.com/authelia", "followers_url": "https://api.github.com/users/authelia/followers", "following_url": "https://api.github.com/users/authelia/following{/other_user}", "gists_url": "https://api.github.com/users/authelia/gists{/gist_id}", "starred_url": "https://api.github.com/users/authelia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/authelia/subscriptions", "organizations_url": "https://api.github.com/users/authelia/orgs", "repos_url": "https://api.github.com/users/authelia/repos", "events_url": "https://api.github.com/users/authelia/events{/privacy}", "received_events_url": "https://api.github.com/users/authelia/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "repo": {"id": 75785240, "node_id": "MDEwOlJlcG9zaXRvcnk3NTc4NTI0MA==", "name": "authelia", "full_name": "authelia/authelia", "private": false, "owner": {"login": "authelia", "id": 59122411, "node_id": "MDEyOk9yZ2FuaXphdGlvbjU5MTIyNDEx", "avatar_url": "https://avatars.githubusercontent.com/u/59122411?v=4", "gravatar_id": "", "url": "https://api.github.com/users/authelia", "html_url": "https://github.com/authelia", "followers_url": "https://api.github.com/users/authelia/followers", "following_url": "https://api.github.com/users/authelia/following{/other_user}", "gists_url": "https://api.github.com/users/authelia/gists{/gist_id}", "starred_url": "https://api.github.com/users/authelia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/authelia/subscriptions", "organizations_url": "https://api.github.com/users/authelia/orgs", "repos_url": "https://api.github.com/users/authelia/repos", "events_url": "https://api.github.com/users/authelia/events{/privacy}", "received_events_url": "https://api.github.com/users/authelia/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "html_url": "https://github.com/authelia/authelia", "description": "The Single Sign-On Multi-Factor portal for web apps, now OpenID Certifiedâ„¢", "fork": false, "url": "https://api.github.com/repos/authelia/authelia", "forks_url": "https://api.github.com/repos/authelia/authelia/forks", "keys_url": "https://api.github.com/repos/authelia/authelia/keys{/key_id}", "collaborators_url": "https://api.github.com/repos/authelia/authelia/collaborators{/collaborator}", "teams_url": "https://api.github.com/repos/authelia/authelia/teams", "hooks_url": "https://api.github.com/repos/authelia/authelia/hooks", "issue_events_url": "https://api.github.com/repos/authelia/authelia/issues/events{/number}", "events_url": "https://api.github.com/repos/authelia/authelia/events", "assignees_url": "https://api.github.com/repos/authelia/authelia/assignees{/user}", "branches_url": "https://api.github.com/repos/authelia/authelia/branches{/branch}", "tags_url": "https://api.github.com/repos/authelia/authelia/tags", "blobs_url": "https://api.github.com/repos/authelia/authelia/git/blobs{/sha}", "git_tags_url": "https://api.github.com/repos/authelia/authelia/git/tags{/sha}", "git_refs_url": "https://api.github.com/repos/authelia/authelia/git/refs{/sha}", "trees_url": "https://api.github.com/repos/authelia/authelia/git/trees{/sha}", "statuses_url": "https://api.github.com/repos/authelia/authelia/statuses/{sha}", "languages_url": "https://api.github.com/repos/authelia/authelia/languages", "stargazers_url": "https://api.github.com/repos/authelia/authelia/stargazers", "contributors_url": "https://api.github.com/repos/authelia/authelia/contributors", "subscribers_url": "https://api.github.com/repos/authelia/authelia/subscribers", "subscription_url": "https://api.github.com/repos/authelia/authelia/subscription", "commits_url": "https://api.github.com/repos/authelia/authelia/commits{/sha}", "git_commits_url": "https://api.github.com/repos/authelia/authelia/git/commits{/sha}", "comments_url": "https://api.github.com/repos/authelia/authelia/comments{/number}", "issue_comment_url": "https://api.github.com/repos/authelia/authelia/issues/comments{/number}", "contents_url": "https://api.github.com/repos/authelia/authelia/contents/{+path}", "compare_url": "https://api.github.com/repos/authelia/authelia/compare/{base}...{head}", "merges_url": "https://api.github.com/repos/authelia/authelia/merges", "archive_url": "https://api.github.com/repos/authelia/authelia/{archive_format}{/ref}", "downloads_url": "https://api.github.com/repos/authelia/authelia/downloads", "issues_url": "https://api.github.com/repos/authelia/authelia/issues{/number}", "pulls_url": "https://api.github.com/repos/authelia/authelia/pulls{/number}", "milestones_url": "https://api.github.com/repos/authelia/authelia/milestones{/number}", "notifications_url": "https://api.github.com/repos/authelia/authelia/notifications{?since,all,participating}", "labels_url": "https://api.github.com/repos/authelia/authelia/labels{/name}", "releases_url": "https://api.github.com/repos/authelia/authelia/releases{/id}", "deployments_url": "https://api.github.com/repos/authelia/authelia/deployments", "created_at": "2016-12-07T00:56:57Z", "updated_at": "2026-01-07T01:03:31Z", "pushed_at": "2026-01-07T05:51:31Z", "git_url": "git://github.com/authelia/authelia.git", "ssh_url": "git@github.com:authelia/authelia.git", "clone_url": "https://github.com/authelia/authelia.git", "svn_url": "https://github.com/authelia/authelia", "homepage": "https://www.authelia.com", "size": 69062, "stargazers_count": 26316, "watchers_count": 26316, "language": "Go", "has_issues": true, "has_projects": true, "has_downloads": true, "has_wiki": false, "has_pages": true, "has_discussions": true, "forks_count": 1316, "mirror_url": null, "archived": false, "disabled": false, "open_issues_count": 118, "license": {"key": "apache-2.0", "name": "Apache License 2.0", "spdx_id": "Apache-2.0", "url": "https://api.github.com/licenses/apache-2.0", "node_id": "MDc6TGljZW5zZTI="}, "allow_forking": true, "is_template": false, "web_commit_signoff_required": true, "topics": ["2fa", "authentication", "docker", "golang", "kubernetes", "ldap", "mfa", "multifactor", "oauth2", "openid-connect", "passkeys", "push-notifications", "security", "sso", "sso-authentication", "totp", "two-factor", "two-factor-authentication", "webauthn", "yubikey"], "visibility": "public", "forks": 1316, "open_issues": 118, "watchers": 26316, "default_branch": "master"}}, "commits": [{"sha": "f56bb0eae3ef3d632daf7d104c1342381716203a", "parents": ["3dad392ea455d9a63dd79ad788a9aebfc02fca3e"], "message": "feat(regulation): ip bans and unbanning\n\nThis adds several new features to the regulation functionality including IP banning and the ability to unban users.\n\nSigned-off-by: James Elliott <james-d-elliott@users.noreply.github.com>"}, {"sha": "46e992fa89f1344eace1aa584774828acc40122b", "parents": ["f56bb0eae3ef3d632daf7d104c1342381716203a"], "message": "refactor: review\n\nSigned-off-by: James Elliott <james-d-elliott@users.noreply.github.com>"}], "resolved_issues": [{"org": "authelia", "repo": "authelia", "number": 4730, "state": "closed", "title": "Regulation Rework", "body": "### Description\r\n\r\nImplement the following improvements to the regulator:\r\n\r\n- Misc:\r\n    - [ ] Add UI view for users\r\n    - [x] Add Password Reset Regulation (#3859)\r\n- Add 2FA Regulations:\r\n    - [ ] Duo\r\n    - [ ] Webauthn\r\n    - [ ] TOTP (Both Failed Attempts and Successful Attempts)\r\n- Add Modes:\r\n    - [x] Mode `user` only blocks the user (current functionality and the default)\r\n    - [x] Mode `remote_ip` only blocks the remote IP\r\n    - [x] Mode `full` blocks all (recommended mode)\r\n\r\n### Use Case\r\n\r\nEnhances the regulation provider significantly.\r\n\r\n### Details\r\n\r\n_No response_\r\n\r\n### Documentation\r\n\r\n_No response_\r\n\r\n### Pre-Submission Checklist\r\n\r\n- [X] I agree to follow the [Code of Conduct](http://www.authelia.com/code-of-conduct)\r\n- [X] I have checked for related issues and checked the documentation"}], "fix_patch": "diff --git a/config.template.yml b/config.template.yml\nindex 0fd1756e95101..4fcc0f509aa73 100644\n--- a/config.template.yml\n+++ b/config.template.yml\n@@ -974,6 +974,10 @@ session:\n ## This mechanism prevents attackers from brute forcing the first factor. It bans the user if too many attempts are made\n ## in a short period of time.\n # regulation:\n+  ## Regulation Mode.\n+  # modes:\n+    # - 'user'\n+\n   ## The number of failed login attempts before user is banned. Set it to 0 to disable regulation.\n   # max_retries: 3\n \ndiff --git a/docs/content/configuration/security/regulation.md b/docs/content/configuration/security/regulation.md\nindex 6a977c6db17f0..6d22e0bbf15c1 100644\n--- a/docs/content/configuration/security/regulation.md\n+++ b/docs/content/configuration/security/regulation.md\n@@ -26,6 +26,9 @@ authentication attempts. This helps prevent brute-force attacks.\n \n ```yaml {title=\"configuration.yml\"}\n regulation:\n+  modes:\n+    - 'user'\n+    - 'ip'\n   max_retries: 3\n   find_time: '2m'\n   ban_time: '5m'\n@@ -35,6 +38,20 @@ regulation:\n \n This section describes the individual configuration options.\n \n+### mode\n+\n+{{< confkey type=\"list(string)\" default=\"['user']\" required=\"no\" >}}\n+\n+The mode for regulation. The table below describes each option. The recommended mode is `ip`. It should be noted that,\n+regardless of the ban mode, if bans exist in the database, the user or IP will be denied access. See the\n+[authelia storage bans](../../reference/cli/authelia/authelia_storage_bans.md) command for information on managing\n+ban entries.\n+\n+| Mode |                             Description                             |\n+|:----:|:-------------------------------------------------------------------:|\n+| user |        The user account is the subject of any automatic bans        |\n+|  ip  |         The remote ip is the subject of any automatic bans          |\n+\n ### max_retries\n \n {{< confkey type=\"integer\" default=\"3\" required=\"no\" >}}\ndiff --git a/docs/content/reference/cli/authelia/authelia_storage.md b/docs/content/reference/cli/authelia/authelia_storage.md\nindex d96f82a3b991a..434e0c503d948 100644\n--- a/docs/content/reference/cli/authelia/authelia_storage.md\n+++ b/docs/content/reference/cli/authelia/authelia_storage.md\n@@ -65,6 +65,7 @@ authelia storage --help\n ### SEE ALSO\n \n * [authelia](authelia.md)\t - authelia untagged-unknown-dirty (master, unknown)\n+* [authelia storage bans](authelia_storage_bans.md)\t - Manages user and ip bans\n * [authelia storage cache](authelia_storage_cache.md)\t - Manage storage cache\n * [authelia storage encryption](authelia_storage_encryption.md)\t - Manage storage encryption\n * [authelia storage migrate](authelia_storage_migrate.md)\t - Perform or list migrations\ndiff --git a/docs/content/reference/cli/authelia/authelia_storage_bans.md b/docs/content/reference/cli/authelia/authelia_storage_bans.md\nnew file mode 100644\nindex 0000000000000..89ed9379d3db9\n--- /dev/null\n+++ b/docs/content/reference/cli/authelia/authelia_storage_bans.md\n@@ -0,0 +1,68 @@\n+---\n+title: \"authelia storage bans\"\n+description: \"Reference for the authelia storage bans command.\"\n+lead: \"\"\n+date: 2022-06-15T17:51:47+10:00\n+draft: false\n+images: []\n+weight: 905\n+toc: true\n+seo:\n+  title: \"\" # custom title (optional)\n+  description: \"\" # custom description (recommended)\n+  canonical: \"\" # custom canonical URL (optional)\n+  noindex: false # false (default) or true\n+---\n+\n+## authelia storage bans\n+\n+Manages user and ip bans\n+\n+### Synopsis\n+\n+Manages user and ip bans.\n+\n+This subcommand allows listing, creating, and revoking user and ip bans from the regulation system.\n+\n+### Examples\n+\n+```\n+authelia storage bans --help\n+```\n+\n+### Options\n+\n+```\n+  -h, --help   help for bans\n+```\n+\n+### Options inherited from parent commands\n+\n+```\n+  -c, --config strings                         configuration files or directories to load, for more information run 'authelia -h authelia config' (default [configuration.yml])\n+      --config.experimental.filters strings    list of filters to apply to all configuration files, for more information run 'authelia -h authelia filters'\n+      --encryption-key string                  the storage encryption key to use\n+      --mysql.database string                  the MySQL database name (default \"authelia\")\n+      --mysql.host string                      the MySQL hostname\n+      --mysql.password string                  the MySQL password\n+      --mysql.port int                         the MySQL port (default 3306)\n+      --mysql.username string                  the MySQL username (default \"authelia\")\n+      --postgres.database string               the PostgreSQL database name (default \"authelia\")\n+      --postgres.host string                   the PostgreSQL hostname\n+      --postgres.password string               the PostgreSQL password\n+      --postgres.port int                      the PostgreSQL port (default 5432)\n+      --postgres.schema string                 the PostgreSQL schema name (default \"public\")\n+      --postgres.ssl.certificate string        the PostgreSQL ssl certificate file location\n+      --postgres.ssl.key string                the PostgreSQL ssl key file location\n+      --postgres.ssl.mode string               the PostgreSQL ssl mode (default \"disable\")\n+      --postgres.ssl.root_certificate string   the PostgreSQL ssl root certificate file location\n+      --postgres.username string               the PostgreSQL username (default \"authelia\")\n+      --sqlite.path string                     the SQLite database path\n+```\n+\n+### SEE ALSO\n+\n+* [authelia storage](authelia_storage.md)\t - Manage the Authelia storage\n+* [authelia storage bans ip](authelia_storage_bans_ip.md)\t - Manages ip bans\n+* [authelia storage bans user](authelia_storage_bans_user.md)\t - Manages user bans\n+\ndiff --git a/docs/content/reference/cli/authelia/authelia_storage_bans_ip.md b/docs/content/reference/cli/authelia/authelia_storage_bans_ip.md\nnew file mode 100644\nindex 0000000000000..b1fd9a31eb59d\n--- /dev/null\n+++ b/docs/content/reference/cli/authelia/authelia_storage_bans_ip.md\n@@ -0,0 +1,69 @@\n+---\n+title: \"authelia storage bans ip\"\n+description: \"Reference for the authelia storage bans ip command.\"\n+lead: \"\"\n+date: 2022-06-15T17:51:47+10:00\n+draft: false\n+images: []\n+weight: 905\n+toc: true\n+seo:\n+  title: \"\" # custom title (optional)\n+  description: \"\" # custom description (recommended)\n+  canonical: \"\" # custom canonical URL (optional)\n+  noindex: false # false (default) or true\n+---\n+\n+## authelia storage bans ip\n+\n+Manages ip bans\n+\n+### Synopsis\n+\n+Manages ip bans.\n+\n+This subcommand allows listing, creating, and revoking ip bans from the regulation system.\n+\n+### Examples\n+\n+```\n+authelia storage bans ip --help\n+```\n+\n+### Options\n+\n+```\n+  -h, --help   help for ip\n+```\n+\n+### Options inherited from parent commands\n+\n+```\n+  -c, --config strings                         configuration files or directories to load, for more information run 'authelia -h authelia config' (default [configuration.yml])\n+      --config.experimental.filters strings    list of filters to apply to all configuration files, for more information run 'authelia -h authelia filters'\n+      --encryption-key string                  the storage encryption key to use\n+      --mysql.database string                  the MySQL database name (default \"authelia\")\n+      --mysql.host string                      the MySQL hostname\n+      --mysql.password string                  the MySQL password\n+      --mysql.port int                         the MySQL port (default 3306)\n+      --mysql.username string                  the MySQL username (default \"authelia\")\n+      --postgres.database string               the PostgreSQL database name (default \"authelia\")\n+      --postgres.host string                   the PostgreSQL hostname\n+      --postgres.password string               the PostgreSQL password\n+      --postgres.port int                      the PostgreSQL port (default 5432)\n+      --postgres.schema string                 the PostgreSQL schema name (default \"public\")\n+      --postgres.ssl.certificate string        the PostgreSQL ssl certificate file location\n+      --postgres.ssl.key string                the PostgreSQL ssl key file location\n+      --postgres.ssl.mode string               the PostgreSQL ssl mode (default \"disable\")\n+      --postgres.ssl.root_certificate string   the PostgreSQL ssl root certificate file location\n+      --postgres.username string               the PostgreSQL username (default \"authelia\")\n+      --sqlite.path string                     the SQLite database path\n+```\n+\n+### SEE ALSO\n+\n+* [authelia storage bans](authelia_storage_bans.md)\t - Manages user and ip bans\n+* [authelia storage bans ip add](authelia_storage_bans_ip_add.md)\t - Adds ip bans\n+* [authelia storage bans ip list](authelia_storage_bans_ip_list.md)\t - Lists ip bans\n+* [authelia storage bans ip revoke](authelia_storage_bans_ip_revoke.md)\t - Revokes ip bans\n+\ndiff --git a/docs/content/reference/cli/authelia/authelia_storage_bans_ip_add.md b/docs/content/reference/cli/authelia/authelia_storage_bans_ip_add.md\nnew file mode 100644\nindex 0000000000000..3fa175dfa2890\n--- /dev/null\n+++ b/docs/content/reference/cli/authelia/authelia_storage_bans_ip_add.md\n@@ -0,0 +1,73 @@\n+---\n+title: \"authelia storage bans ip add\"\n+description: \"Reference for the authelia storage bans ip add command.\"\n+lead: \"\"\n+date: 2022-06-15T17:51:47+10:00\n+draft: false\n+images: []\n+weight: 905\n+toc: true\n+seo:\n+  title: \"\" # custom title (optional)\n+  description: \"\" # custom description (recommended)\n+  canonical: \"\" # custom canonical URL (optional)\n+  noindex: false # false (default) or true\n+---\n+\n+## authelia storage bans ip add\n+\n+Adds ip bans\n+\n+### Synopsis\n+\n+Adds ip bans.\n+\n+This subcommand allows adding ip bans to the regulation system.\n+\n+```\n+authelia storage bans ip add <ip> [flags]\n+```\n+\n+### Examples\n+\n+```\n+authelia storage bans ip add --help\n+```\n+\n+### Options\n+\n+```\n+  -d, --duration string   the duration for the ban (default \"1 day\")\n+  -h, --help              help for add\n+  -p, --permanent         makes the ban effectively permanent\n+  -r, --reason string     includes a reason for the ban\n+```\n+\n+### Options inherited from parent commands\n+\n+```\n+  -c, --config strings                         configuration files or directories to load, for more information run 'authelia -h authelia config' (default [configuration.yml])\n+      --config.experimental.filters strings    list of filters to apply to all configuration files, for more information run 'authelia -h authelia filters'\n+      --encryption-key string                  the storage encryption key to use\n+      --mysql.database string                  the MySQL database name (default \"authelia\")\n+      --mysql.host string                      the MySQL hostname\n+      --mysql.password string                  the MySQL password\n+      --mysql.port int                         the MySQL port (default 3306)\n+      --mysql.username string                  the MySQL username (default \"authelia\")\n+      --postgres.database string               the PostgreSQL database name (default \"authelia\")\n+      --postgres.host string                   the PostgreSQL hostname\n+      --postgres.password string               the PostgreSQL password\n+      --postgres.port int                      the PostgreSQL port (default 5432)\n+      --postgres.schema string                 the PostgreSQL schema name (default \"public\")\n+      --postgres.ssl.certificate string        the PostgreSQL ssl certificate file location\n+      --postgres.ssl.key string                the PostgreSQL ssl key file location\n+      --postgres.ssl.mode string               the PostgreSQL ssl mode (default \"disable\")\n+      --postgres.ssl.root_certificate string   the PostgreSQL ssl root certificate file location\n+      --postgres.username string               the PostgreSQL username (default \"authelia\")\n+      --sqlite.path string                     the SQLite database path\n+```\n+\n+### SEE ALSO\n+\n+* [authelia storage bans ip](authelia_storage_bans_ip.md)\t - Manages ip bans\n+\ndiff --git a/docs/content/reference/cli/authelia/authelia_storage_bans_ip_list.md b/docs/content/reference/cli/authelia/authelia_storage_bans_ip_list.md\nnew file mode 100644\nindex 0000000000000..d18e9baf6254d\n--- /dev/null\n+++ b/docs/content/reference/cli/authelia/authelia_storage_bans_ip_list.md\n@@ -0,0 +1,70 @@\n+---\n+title: \"authelia storage bans ip list\"\n+description: \"Reference for the authelia storage bans ip list command.\"\n+lead: \"\"\n+date: 2022-06-15T17:51:47+10:00\n+draft: false\n+images: []\n+weight: 905\n+toc: true\n+seo:\n+  title: \"\" # custom title (optional)\n+  description: \"\" # custom description (recommended)\n+  canonical: \"\" # custom canonical URL (optional)\n+  noindex: false # false (default) or true\n+---\n+\n+## authelia storage bans ip list\n+\n+Lists ip bans\n+\n+### Synopsis\n+\n+Lists ip bans.\n+\n+This subcommand allows listing ip bans from the regulation system.\n+\n+```\n+authelia storage bans ip list [flags]\n+```\n+\n+### Examples\n+\n+```\n+authelia storage bans ip --help\n+```\n+\n+### Options\n+\n+```\n+  -h, --help   help for list\n+```\n+\n+### Options inherited from parent commands\n+\n+```\n+  -c, --config strings                         configuration files or directories to load, for more information run 'authelia -h authelia config' (default [configuration.yml])\n+      --config.experimental.filters strings    list of filters to apply to all configuration files, for more information run 'authelia -h authelia filters'\n+      --encryption-key string                  the storage encryption key to use\n+      --mysql.database string                  the MySQL database name (default \"authelia\")\n+      --mysql.host string                      the MySQL hostname\n+      --mysql.password string                  the MySQL password\n+      --mysql.port int                         the MySQL port (default 3306)\n+      --mysql.username string                  the MySQL username (default \"authelia\")\n+      --postgres.database string               the PostgreSQL database name (default \"authelia\")\n+      --postgres.host string                   the PostgreSQL hostname\n+      --postgres.password string               the PostgreSQL password\n+      --postgres.port int                      the PostgreSQL port (default 5432)\n+      --postgres.schema string                 the PostgreSQL schema name (default \"public\")\n+      --postgres.ssl.certificate string        the PostgreSQL ssl certificate file location\n+      --postgres.ssl.key string                the PostgreSQL ssl key file location\n+      --postgres.ssl.mode string               the PostgreSQL ssl mode (default \"disable\")\n+      --postgres.ssl.root_certificate string   the PostgreSQL ssl root certificate file location\n+      --postgres.username string               the PostgreSQL username (default \"authelia\")\n+      --sqlite.path string                     the SQLite database path\n+```\n+\n+### SEE ALSO\n+\n+* [authelia storage bans ip](authelia_storage_bans_ip.md)\t - Manages ip bans\n+\ndiff --git a/docs/content/reference/cli/authelia/authelia_storage_bans_ip_revoke.md b/docs/content/reference/cli/authelia/authelia_storage_bans_ip_revoke.md\nnew file mode 100644\nindex 0000000000000..1362fe996bea2\n--- /dev/null\n+++ b/docs/content/reference/cli/authelia/authelia_storage_bans_ip_revoke.md\n@@ -0,0 +1,71 @@\n+---\n+title: \"authelia storage bans ip revoke\"\n+description: \"Reference for the authelia storage bans ip revoke command.\"\n+lead: \"\"\n+date: 2022-06-15T17:51:47+10:00\n+draft: false\n+images: []\n+weight: 905\n+toc: true\n+seo:\n+  title: \"\" # custom title (optional)\n+  description: \"\" # custom description (recommended)\n+  canonical: \"\" # custom canonical URL (optional)\n+  noindex: false # false (default) or true\n+---\n+\n+## authelia storage bans ip revoke\n+\n+Revokes ip bans\n+\n+### Synopsis\n+\n+Revokes ip bans.\n+\n+This subcommand allows revoking ip bans in the regulation system.\n+\n+```\n+authelia storage bans ip revoke [ip] [flags]\n+```\n+\n+### Examples\n+\n+```\n+authelia storage bans ip revoke --help\n+```\n+\n+### Options\n+\n+```\n+  -h, --help     help for revoke\n+  -i, --id int   revokes the ban with the given id instead of the ip value\n+```\n+\n+### Options inherited from parent commands\n+\n+```\n+  -c, --config strings                         configuration files or directories to load, for more information run 'authelia -h authelia config' (default [configuration.yml])\n+      --config.experimental.filters strings    list of filters to apply to all configuration files, for more information run 'authelia -h authelia filters'\n+      --encryption-key string                  the storage encryption key to use\n+      --mysql.database string                  the MySQL database name (default \"authelia\")\n+      --mysql.host string                      the MySQL hostname\n+      --mysql.password string                  the MySQL password\n+      --mysql.port int                         the MySQL port (default 3306)\n+      --mysql.username string                  the MySQL username (default \"authelia\")\n+      --postgres.database string               the PostgreSQL database name (default \"authelia\")\n+      --postgres.host string                   the PostgreSQL hostname\n+      --postgres.password string               the PostgreSQL password\n+      --postgres.port int                      the PostgreSQL port (default 5432)\n+      --postgres.schema string                 the PostgreSQL schema name (default \"public\")\n+      --postgres.ssl.certificate string        the PostgreSQL ssl certificate file location\n+      --postgres.ssl.key string                the PostgreSQL ssl key file location\n+      --postgres.ssl.mode string               the PostgreSQL ssl mode (default \"disable\")\n+      --postgres.ssl.root_certificate string   the PostgreSQL ssl root certificate file location\n+      --postgres.username string               the PostgreSQL username (default \"authelia\")\n+      --sqlite.path string                     the SQLite database path\n+```\n+\n+### SEE ALSO\n+\n+* [authelia storage bans ip](authelia_storage_bans_ip.md)\t - Manages ip bans\n+\ndiff --git a/docs/content/reference/cli/authelia/authelia_storage_bans_user.md b/docs/content/reference/cli/authelia/authelia_storage_bans_user.md\nnew file mode 100644\nindex 0000000000000..10f36843d42a4\n--- /dev/null\n+++ b/docs/content/reference/cli/authelia/authelia_storage_bans_user.md\n@@ -0,0 +1,69 @@\n+---\n+title: \"authelia storage bans user\"\n+description: \"Reference for the authelia storage bans user command.\"\n+lead: \"\"\n+date: 2022-06-15T17:51:47+10:00\n+draft: false\n+images: []\n+weight: 905\n+toc: true\n+seo:\n+  title: \"\" # custom title (optional)\n+  description: \"\" # custom description (recommended)\n+  canonical: \"\" # custom canonical URL (optional)\n+  noindex: false # false (default) or true\n+---\n+\n+## authelia storage bans user\n+\n+Manages user bans\n+\n+### Synopsis\n+\n+Manages user bans.\n+\n+This subcommand allows listing, creating, and revoking user bans from the regulation system.\n+\n+### Examples\n+\n+```\n+authelia storage bans user --help\n+```\n+\n+### Options\n+\n+```\n+  -h, --help   help for user\n+```\n+\n+### Options inherited from parent commands\n+\n+```\n+  -c, --config strings                         configuration files or directories to load, for more information run 'authelia -h authelia config' (default [configuration.yml])\n+      --config.experimental.filters strings    list of filters to apply to all configuration files, for more information run 'authelia -h authelia filters'\n+      --encryption-key string                  the storage encryption key to use\n+      --mysql.database string                  the MySQL database name (default \"authelia\")\n+      --mysql.host string                      the MySQL hostname\n+      --mysql.password string                  the MySQL password\n+      --mysql.port int                         the MySQL port (default 3306)\n+      --mysql.username string                  the MySQL username (default \"authelia\")\n+      --postgres.database string               the PostgreSQL database name (default \"authelia\")\n+      --postgres.host string                   the PostgreSQL hostname\n+      --postgres.password string               the PostgreSQL password\n+      --postgres.port int                      the PostgreSQL port (default 5432)\n+      --postgres.schema string                 the PostgreSQL schema name (default \"public\")\n+      --postgres.ssl.certificate string        the PostgreSQL ssl certificate file location\n+      --postgres.ssl.key string                the PostgreSQL ssl key file location\n+      --postgres.ssl.mode string               the PostgreSQL ssl mode (default \"disable\")\n+      --postgres.ssl.root_certificate string   the PostgreSQL ssl root certificate file location\n+      --postgres.username string               the PostgreSQL username (default \"authelia\")\n+      --sqlite.path string                     the SQLite database path\n+```\n+\n+### SEE ALSO\n+\n+* [authelia storage bans](authelia_storage_bans.md)\t - Manages user and ip bans\n+* [authelia storage bans user add](authelia_storage_bans_user_add.md)\t - Adds user bans\n+* [authelia storage bans user list](authelia_storage_bans_user_list.md)\t - Lists user bans\n+* [authelia storage bans user revoke](authelia_storage_bans_user_revoke.md)\t - Revokes user bans\n+\ndiff --git a/docs/content/reference/cli/authelia/authelia_storage_bans_user_add.md b/docs/content/reference/cli/authelia/authelia_storage_bans_user_add.md\nnew file mode 100644\nindex 0000000000000..733ab7822ee60\n--- /dev/null\n+++ b/docs/content/reference/cli/authelia/authelia_storage_bans_user_add.md\n@@ -0,0 +1,73 @@\n+---\n+title: \"authelia storage bans user add\"\n+description: \"Reference for the authelia storage bans user add command.\"\n+lead: \"\"\n+date: 2022-06-15T17:51:47+10:00\n+draft: false\n+images: []\n+weight: 905\n+toc: true\n+seo:\n+  title: \"\" # custom title (optional)\n+  description: \"\" # custom description (recommended)\n+  canonical: \"\" # custom canonical URL (optional)\n+  noindex: false # false (default) or true\n+---\n+\n+## authelia storage bans user add\n+\n+Adds user bans\n+\n+### Synopsis\n+\n+Adds user bans.\n+\n+This subcommand allows adding user bans to the regulation system.\n+\n+```\n+authelia storage bans user add <user> [flags]\n+```\n+\n+### Examples\n+\n+```\n+authelia storage bans user add --help\n+```\n+\n+### Options\n+\n+```\n+  -d, --duration string   the duration for the ban (default \"1 day\")\n+  -h, --help              help for add\n+  -p, --permanent         makes the ban effectively permanent\n+  -r, --reason string     includes a reason for the ban\n+```\n+\n+### Options inherited from parent commands\n+\n+```\n+  -c, --config strings                         configuration files or directories to load, for more information run 'authelia -h authelia config' (default [configuration.yml])\n+      --config.experimental.filters strings    list of filters to apply to all configuration files, for more information run 'authelia -h authelia filters'\n+      --encryption-key string                  the storage encryption key to use\n+      --mysql.database string                  the MySQL database name (default \"authelia\")\n+      --mysql.host string                      the MySQL hostname\n+      --mysql.password string                  the MySQL password\n+      --mysql.port int                         the MySQL port (default 3306)\n+      --mysql.username string                  the MySQL username (default \"authelia\")\n+      --postgres.database string               the PostgreSQL database name (default \"authelia\")\n+      --postgres.host string                   the PostgreSQL hostname\n+      --postgres.password string               the PostgreSQL password\n+      --postgres.port int                      the PostgreSQL port (default 5432)\n+      --postgres.schema string                 the PostgreSQL schema name (default \"public\")\n+      --postgres.ssl.certificate string        the PostgreSQL ssl certificate file location\n+      --postgres.ssl.key string                the PostgreSQL ssl key file location\n+      --postgres.ssl.mode string               the PostgreSQL ssl mode (default \"disable\")\n+      --postgres.ssl.root_certificate string   the PostgreSQL ssl root certificate file location\n+      --postgres.username string               the PostgreSQL username (default \"authelia\")\n+      --sqlite.path string                     the SQLite database path\n+```\n+\n+### SEE ALSO\n+\n+* [authelia storage bans user](authelia_storage_bans_user.md)\t - Manages user bans\n+\ndiff --git a/docs/content/reference/cli/authelia/authelia_storage_bans_user_list.md b/docs/content/reference/cli/authelia/authelia_storage_bans_user_list.md\nnew file mode 100644\nindex 0000000000000..97ec92b32ef97\n--- /dev/null\n+++ b/docs/content/reference/cli/authelia/authelia_storage_bans_user_list.md\n@@ -0,0 +1,70 @@\n+---\n+title: \"authelia storage bans user list\"\n+description: \"Reference for the authelia storage bans user list command.\"\n+lead: \"\"\n+date: 2022-06-15T17:51:47+10:00\n+draft: false\n+images: []\n+weight: 905\n+toc: true\n+seo:\n+  title: \"\" # custom title (optional)\n+  description: \"\" # custom description (recommended)\n+  canonical: \"\" # custom canonical URL (optional)\n+  noindex: false # false (default) or true\n+---\n+\n+## authelia storage bans user list\n+\n+Lists user bans\n+\n+### Synopsis\n+\n+Lists user bans.\n+\n+This subcommand allows listing user bans from the regulation system.\n+\n+```\n+authelia storage bans user list [flags]\n+```\n+\n+### Examples\n+\n+```\n+authelia storage bans user --help\n+```\n+\n+### Options\n+\n+```\n+  -h, --help   help for list\n+```\n+\n+### Options inherited from parent commands\n+\n+```\n+  -c, --config strings                         configuration files or directories to load, for more information run 'authelia -h authelia config' (default [configuration.yml])\n+      --config.experimental.filters strings    list of filters to apply to all configuration files, for more information run 'authelia -h authelia filters'\n+      --encryption-key string                  the storage encryption key to use\n+      --mysql.database string                  the MySQL database name (default \"authelia\")\n+      --mysql.host string                      the MySQL hostname\n+      --mysql.password string                  the MySQL password\n+      --mysql.port int                         the MySQL port (default 3306)\n+      --mysql.username string                  the MySQL username (default \"authelia\")\n+      --postgres.database string               the PostgreSQL database name (default \"authelia\")\n+      --postgres.host string                   the PostgreSQL hostname\n+      --postgres.password string               the PostgreSQL password\n+      --postgres.port int                      the PostgreSQL port (default 5432)\n+      --postgres.schema string                 the PostgreSQL schema name (default \"public\")\n+      --postgres.ssl.certificate string        the PostgreSQL ssl certificate file location\n+      --postgres.ssl.key string                the PostgreSQL ssl key file location\n+      --postgres.ssl.mode string               the PostgreSQL ssl mode (default \"disable\")\n+      --postgres.ssl.root_certificate string   the PostgreSQL ssl root certificate file location\n+      --postgres.username string               the PostgreSQL username (default \"authelia\")\n+      --sqlite.path string                     the SQLite database path\n+```\n+\n+### SEE ALSO\n+\n+* [authelia storage bans user](authelia_storage_bans_user.md)\t - Manages user bans\n+\ndiff --git a/docs/content/reference/cli/authelia/authelia_storage_bans_user_revoke.md b/docs/content/reference/cli/authelia/authelia_storage_bans_user_revoke.md\nnew file mode 100644\nindex 0000000000000..d4c26ab6d4586\n--- /dev/null\n+++ b/docs/content/reference/cli/authelia/authelia_storage_bans_user_revoke.md\n@@ -0,0 +1,71 @@\n+---\n+title: \"authelia storage bans user revoke\"\n+description: \"Reference for the authelia storage bans user revoke command.\"\n+lead: \"\"\n+date: 2022-06-15T17:51:47+10:00\n+draft: false\n+images: []\n+weight: 905\n+toc: true\n+seo:\n+  title: \"\" # custom title (optional)\n+  description: \"\" # custom description (recommended)\n+  canonical: \"\" # custom canonical URL (optional)\n+  noindex: false # false (default) or true\n+---\n+\n+## authelia storage bans user revoke\n+\n+Revokes user bans\n+\n+### Synopsis\n+\n+Revokes user bans.\n+\n+This subcommand allows revoking user bans in the regulation system.\n+\n+```\n+authelia storage bans user revoke [user] [flags]\n+```\n+\n+### Examples\n+\n+```\n+authelia storage bans user revoke --help\n+```\n+\n+### Options\n+\n+```\n+  -h, --help     help for revoke\n+  -i, --id int   revokes the ban with the given id instead of the user value\n+```\n+\n+### Options inherited from parent commands\n+\n+```\n+  -c, --config strings                         configuration files or directories to load, for more information run 'authelia -h authelia config' (default [configuration.yml])\n+      --config.experimental.filters strings    list of filters to apply to all configuration files, for more information run 'authelia -h authelia filters'\n+      --encryption-key string                  the storage encryption key to use\n+      --mysql.database string                  the MySQL database name (default \"authelia\")\n+      --mysql.host string                      the MySQL hostname\n+      --mysql.password string                  the MySQL password\n+      --mysql.port int                         the MySQL port (default 3306)\n+      --mysql.username string                  the MySQL username (default \"authelia\")\n+      --postgres.database string               the PostgreSQL database name (default \"authelia\")\n+      --postgres.host string                   the PostgreSQL hostname\n+      --postgres.password string               the PostgreSQL password\n+      --postgres.port int                      the PostgreSQL port (default 5432)\n+      --postgres.schema string                 the PostgreSQL schema name (default \"public\")\n+      --postgres.ssl.certificate string        the PostgreSQL ssl certificate file location\n+      --postgres.ssl.key string                the PostgreSQL ssl key file location\n+      --postgres.ssl.mode string               the PostgreSQL ssl mode (default \"disable\")\n+      --postgres.ssl.root_certificate string   the PostgreSQL ssl root certificate file location\n+      --postgres.username string               the PostgreSQL username (default \"authelia\")\n+      --sqlite.path string                     the SQLite database path\n+```\n+\n+### SEE ALSO\n+\n+* [authelia storage bans user](authelia_storage_bans_user.md)\t - Manages user bans\n+\ndiff --git a/docs/data/configkeys.json b/docs/data/configkeys.json\nindex 19ff5d878f0a0..dd621ea174458 100644\n--- a/docs/data/configkeys.json\n+++ b/docs/data/configkeys.json\n@@ -764,6 +764,11 @@\n         \"secret\": false,\n         \"env\": \"AUTHELIA_REGULATION_MAX_RETRIES\"\n     },\n+    {\n+        \"path\": \"regulation.modes\",\n+        \"secret\": false,\n+        \"env\": \"AUTHELIA_REGULATION_MODES\"\n+    },\n     {\n         \"path\": \"server.address\",\n         \"secret\": false,\ndiff --git a/docs/static/schemas/v4.39/json-schema/configuration.json b/docs/static/schemas/v4.39/json-schema/configuration.json\nindex 2e72ef96c8309..532545a9a8cb9 100644\n--- a/docs/static/schemas/v4.39/json-schema/configuration.json\n+++ b/docs/static/schemas/v4.39/json-schema/configuration.json\n@@ -770,7 +770,7 @@\n             \"filter\",\n             \"memberof\"\n           ],\n-          \"title\": \"Groups Search Mode\",\n+          \"title\": \"Groups Search Modes\",\n           \"description\": \"The LDAP group search mode used to search for group objects.\",\n           \"default\": \"filter\"\n         },\n@@ -1597,8 +1597,8 @@\n             \"explicit\",\n             \"implicit\"\n           ],\n-          \"title\": \"Requested Audience Mode\",\n-          \"description\": \"The Requested Audience Mode used for this client.\"\n+          \"title\": \"Requested Audience Modes\",\n+          \"description\": \"The Requested Audience Modes used for this client.\"\n         },\n         \"consent_mode\": {\n           \"type\": \"string\",\n@@ -1608,8 +1608,8 @@\n             \"implicit\",\n             \"pre-configured\"\n           ],\n-          \"title\": \"Consent Mode\",\n-          \"description\": \"The Consent Mode used for this client.\"\n+          \"title\": \"Consent Modes\",\n+          \"description\": \"The Consent Modes used for this client.\"\n         },\n         \"pre_configured_consent_duration\": {\n           \"oneOf\": [\n@@ -1623,7 +1623,7 @@\n             }\n           ],\n           \"title\": \"Pre-Configured Consent Duration\",\n-          \"description\": \"The Pre-Configured Consent Duration when using Consent Mode pre-configured for this client.\"\n+          \"description\": \"The Pre-Configured Consent Duration when using Consent Modes pre-configured for this client.\"\n         },\n         \"require_pushed_authorization_requests\": {\n           \"type\": \"boolean\",\n@@ -2435,7 +2435,7 @@\n             }\n           ],\n           \"title\": \"JARM\",\n-          \"description\": \"Allows tuning the token lifespan for the JWT Secured Authorization Response Mode (JARM).\"\n+          \"description\": \"Allows tuning the token lifespan for the JWT Secured Authorization Response Modes (JARM).\"\n         },\n         \"custom\": {\n           \"patternProperties\": {\n@@ -3057,6 +3057,21 @@\n     },\n     \"Regulation\": {\n       \"properties\": {\n+        \"modes\": {\n+          \"items\": {\n+            \"type\": \"string\",\n+            \"enum\": [\n+              \"user\",\n+              \"ip\"\n+            ]\n+          },\n+          \"type\": \"array\",\n+          \"title\": \"Regulation Modes\",\n+          \"description\": \"The modes to use for regulation.\",\n+          \"default\": [\n+            \"user\"\n+          ]\n+        },\n         \"max_retries\": {\n           \"type\": \"integer\",\n           \"title\": \"Maximum Retries\",\ndiff --git a/internal/authorization/types.go b/internal/authorization/types.go\nindex 9f3f1d918c221..e8ebdf9d4d3f9 100644\n--- a/internal/authorization/types.go\n+++ b/internal/authorization/types.go\n@@ -74,6 +74,10 @@ type Object struct {\n \n // String is a string representation of the Object.\n func (o Object) String() string {\n+\tif o.URL == nil {\n+\t\treturn \"\"\n+\t}\n+\n \treturn o.URL.String()\n }\n \ndiff --git a/internal/commands/const.go b/internal/commands/const.go\nindex f8dbb2f2f67ab..ffe4164720101 100644\n--- a/internal/commands/const.go\n+++ b/internal/commands/const.go\n@@ -170,6 +170,54 @@ This subcommand allows you to change the encryption key of an Authelia SQL datab\n \tcmdAutheliaStorageEncryptionChangeKeyExample = `authelia storage encryption change-key --config config.yml --new-encryption-key 0e95cb49-5804-4ad9-be82-bb04a9ddecd8\n authelia storage encryption change-key --encryption-key b3453fde-ecc2-4a1f-9422-2707ddbed495 --new-encryption-key 0e95cb49-5804-4ad9-be82-bb04a9ddecd8 --postgres.host postgres --postgres.password autheliapw`\n \n+\tcmdAutheliaStorageBansShort = \"Manages user and ip bans\"\n+\n+\tcmdAutheliaStorageBansLong = `Manages user and ip bans.\n+\n+This subcommand allows listing, creating, and revoking user and ip bans from the regulation system.`\n+\n+\tcmdAutheliaStorageBansExample = `authelia storage bans --help`\n+\n+\tcmdAutheliaStorageBansUserShort = \"Manages user bans\"\n+\n+\tcmdAutheliaStorageBansUserLong = `Manages user bans.\n+\n+This subcommand allows listing, creating, and revoking user bans from the regulation system.`\n+\n+\tcmdAutheliaStorageBansUserExample = `authelia storage bans user --help`\n+\n+\tcmdAutheliaStorageBansIPShort = \"Manages ip bans\"\n+\n+\tcmdAutheliaStorageBansIPLong = `Manages ip bans.\n+\n+This subcommand allows listing, creating, and revoking ip bans from the regulation system.`\n+\n+\tcmdAutheliaStorageBansIPExample = `authelia storage bans ip --help`\n+\n+\tcmdAutheliaStorageBansListShort = \"Lists %s bans\"\n+\n+\tcmdAutheliaStorageBansListLong = `Lists %s bans.\n+\n+This subcommand allows listing %s bans from the regulation system.`\n+\n+\tcmdAutheliaStorageBansListExample = `authelia storage bans %s --help`\n+\n+\tcmdAutheliaStorageBansAddShort = \"Adds %s bans\"\n+\n+\tcmdAutheliaStorageBansAddLong = `Adds %s bans.\n+\n+This subcommand allows adding %s bans to the regulation system.`\n+\n+\tcmdAutheliaStorageBansAddExample = `authelia storage bans %s add --help`\n+\n+\tcmdAutheliaStorageBansRevokeShort = \"Revokes %s bans\"\n+\n+\tcmdAutheliaStorageBansRevokeLong = `Revokes %s bans.\n+\n+This subcommand allows revoking %s bans in the regulation system.`\n+\n+\tcmdAutheliaStorageBansRevokeExample = `authelia storage bans %s revoke --help`\n+\n \tcmdAutheliaStorageUserShort = \"Manages user settings\"\n \n \tcmdAutheliaStorageUserLong = `Manages user settings.\n@@ -754,6 +802,8 @@ const (\n \tcmdUseRSA         = \"rsa\"\n \tcmdUseECDSA       = \"ecdsa\"\n \tcmdUseEd25519     = \"ed25519\"\n+\tcmdUseUser        = \"user\"\n+\tcmdUseIP          = \"ip\"\n )\n \n const (\ndiff --git a/internal/commands/storage.go b/internal/commands/storage.go\nindex 4784a66b56fbf..d67e46f602b93 100644\n--- a/internal/commands/storage.go\n+++ b/internal/commands/storage.go\n@@ -53,6 +53,7 @@ func newStorageCmd(ctx *CmdCtx) (cmd *cobra.Command) {\n \t\tnewStorageSchemaInfoCmd(ctx),\n \t\tnewStorageEncryptionCmd(ctx),\n \t\tnewStorageUserCmd(ctx),\n+\t\tnewStorageBansCmd(ctx),\n \t)\n \n \treturn cmd\n@@ -211,9 +212,126 @@ func newStorageEncryptionChangeKeyCmd(ctx *CmdCtx) (cmd *cobra.Command) {\n \treturn cmd\n }\n \n+func newStorageBansCmd(ctx *CmdCtx) (cmd *cobra.Command) {\n+\tcmd = &cobra.Command{\n+\t\tUse:     \"bans\",\n+\t\tShort:   cmdAutheliaStorageBansShort,\n+\t\tLong:    cmdAutheliaStorageBansLong,\n+\t\tExample: cmdAutheliaStorageBansExample,\n+\t\tArgs:    cobra.NoArgs,\n+\n+\t\tDisableAutoGenTag: true,\n+\t}\n+\n+\tcmd.AddCommand(\n+\t\tnewStorageBansUserCmd(ctx),\n+\t\tnewStorageBansIPCmd(ctx),\n+\t)\n+\n+\treturn cmd\n+}\n+\n+func newStorageBansUserCmd(ctx *CmdCtx) (cmd *cobra.Command) {\n+\tcmd = &cobra.Command{\n+\t\tUse:     cmdUseUser,\n+\t\tShort:   cmdAutheliaStorageBansUserShort,\n+\t\tLong:    cmdAutheliaStorageBansUserLong,\n+\t\tExample: cmdAutheliaStorageBansUserExample,\n+\t\tArgs:    cobra.NoArgs,\n+\n+\t\tDisableAutoGenTag: true,\n+\t}\n+\n+\tcmd.AddCommand(\n+\t\tnewStorageBansListCmd(ctx, cmdUseUser),\n+\t\tnewStorageBansRevokeCmd(ctx, cmdUseUser),\n+\t\tnewStorageBansAddCmd(ctx, cmdUseUser),\n+\t)\n+\n+\treturn cmd\n+}\n+\n+func newStorageBansIPCmd(ctx *CmdCtx) (cmd *cobra.Command) {\n+\tcmd = &cobra.Command{\n+\t\tUse:     cmdUseIP,\n+\t\tShort:   cmdAutheliaStorageBansIPShort,\n+\t\tLong:    cmdAutheliaStorageBansIPLong,\n+\t\tExample: cmdAutheliaStorageBansIPExample,\n+\t\tArgs:    cobra.NoArgs,\n+\n+\t\tDisableAutoGenTag: true,\n+\t}\n+\n+\tcmd.AddCommand(\n+\t\tnewStorageBansListCmd(ctx, cmdUseIP),\n+\t\tnewStorageBansRevokeCmd(ctx, cmdUseIP),\n+\t\tnewStorageBansAddCmd(ctx, cmdUseIP),\n+\t)\n+\n+\treturn cmd\n+}\n+\n+func newStorageBansListCmd(ctx *CmdCtx, use string) (cmd *cobra.Command) {\n+\tcmd = &cobra.Command{\n+\t\tUse:     \"list\",\n+\t\tShort:   fmt.Sprintf(cmdAutheliaStorageBansListShort, use),\n+\t\tLong:    fmt.Sprintf(cmdAutheliaStorageBansListLong, use, use),\n+\t\tExample: fmt.Sprintf(cmdAutheliaStorageBansListExample, use),\n+\t\tArgs:    cobra.NoArgs,\n+\t\tRunE:    ctx.StorageBansListRunE(use),\n+\n+\t\tDisableAutoGenTag: true,\n+\t}\n+\n+\treturn cmd\n+}\n+\n+func newStorageBansRevokeCmd(ctx *CmdCtx, use string) (cmd *cobra.Command) {\n+\tcmd = &cobra.Command{\n+\t\tUse:     fmt.Sprintf(\"revoke [%s]\", use),\n+\t\tShort:   fmt.Sprintf(cmdAutheliaStorageBansRevokeShort, use),\n+\t\tLong:    fmt.Sprintf(cmdAutheliaStorageBansRevokeLong, use, use),\n+\t\tExample: fmt.Sprintf(cmdAutheliaStorageBansRevokeExample, use),\n+\t\tArgs:    cobra.RangeArgs(0, 1),\n+\t\tRunE:    ctx.StorageBansRevokeRunE(use),\n+\n+\t\tDisableAutoGenTag: true,\n+\t}\n+\n+\tcmd.Flags().IntP(\"id\", \"i\", 0, fmt.Sprintf(\"revokes the ban with the given id instead of the %s value\", use))\n+\n+\treturn cmd\n+}\n+\n+func newStorageBansAddCmd(ctx *CmdCtx, use string) (cmd *cobra.Command) {\n+\tcmd = &cobra.Command{\n+\t\tUse:     fmt.Sprintf(\"add <%s>\", use),\n+\t\tShort:   fmt.Sprintf(cmdAutheliaStorageBansAddShort, use),\n+\t\tLong:    fmt.Sprintf(cmdAutheliaStorageBansAddLong, use, use),\n+\t\tExample: fmt.Sprintf(cmdAutheliaStorageBansAddExample, use),\n+\t\tArgs:    cobra.ExactArgs(1),\n+\t\tPreRunE: func(cmd *cobra.Command, args []string) error {\n+\t\t\tif cmd.Flags().Changed(\"permanent\") && cmd.Flags().Changed(cmdFlagNameDuration) {\n+\t\t\t\treturn fmt.Errorf(\"invalid flag combination specified: both duration and permanent flags can't be uesd at the same time\")\n+\t\t\t}\n+\n+\t\t\treturn nil\n+\t\t},\n+\t\tRunE: ctx.StorageBansAddRunE(use),\n+\n+\t\tDisableAutoGenTag: true,\n+\t}\n+\n+\tcmd.Flags().BoolP(\"permanent\", \"p\", false, \"makes the ban effectively permanent\")\n+\tcmd.Flags().StringP(\"reason\", \"r\", \"\", \"includes a reason for the ban\")\n+\tcmd.Flags().StringP(\"duration\", \"d\", \"1 day\", \"the duration for the ban\")\n+\n+\treturn cmd\n+}\n+\n func newStorageUserCmd(ctx *CmdCtx) (cmd *cobra.Command) {\n \tcmd = &cobra.Command{\n-\t\tUse:     \"user\",\n+\t\tUse:     cmdUseUser,\n \t\tShort:   cmdAutheliaStorageUserShort,\n \t\tLong:    cmdAutheliaStorageUserLong,\n \t\tExample: cmdAutheliaStorageUserExample,\ndiff --git a/internal/commands/storage_run.go b/internal/commands/storage_run.go\nindex 3f13fa1dabea6..d7514c2f0cc9a 100644\n--- a/internal/commands/storage_run.go\n+++ b/internal/commands/storage_run.go\n@@ -2,16 +2,19 @@ package commands\n \n import (\n \t\"bytes\"\n+\t\"context\"\n \t\"database/sql\"\n \t\"errors\"\n \t\"fmt\"\n \t\"image\"\n \t\"image/png\"\n+\t\"net\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"sort\"\n \t\"strings\"\n \t\"text/tabwriter\"\n+\t\"time\"\n \n \t\"github.com/go-webauthn/webauthn/metadata\"\n \t\"github.com/google/uuid\"\n@@ -22,6 +25,7 @@ import (\n \t\"github.com/authelia/authelia/v4/internal/configuration/validator\"\n \t\"github.com/authelia/authelia/v4/internal/model\"\n \t\"github.com/authelia/authelia/v4/internal/random\"\n+\t\"github.com/authelia/authelia/v4/internal/regulation\"\n \t\"github.com/authelia/authelia/v4/internal/storage\"\n \t\"github.com/authelia/authelia/v4/internal/totp\"\n \t\"github.com/authelia/authelia/v4/internal/utils\"\n@@ -619,6 +623,284 @@ func (ctx *CmdCtx) StorageSchemaInfoRunE(_ *cobra.Command, _ []string) (err erro\n \treturn nil\n }\n \n+func (ctx *CmdCtx) StorageBansListRunE(use string) func(cmd *cobra.Command, args []string) (err error) {\n+\treturn func(cmd *cobra.Command, args []string) (err error) {\n+\t\tdefer func() {\n+\t\t\t_ = ctx.providers.StorageProvider.Close()\n+\t\t}()\n+\n+\t\tif err = ctx.CheckSchema(); err != nil {\n+\t\t\treturn storageWrapCheckSchemaErr(err)\n+\t\t}\n+\n+\t\tswitch use {\n+\t\tcase cmdUseIP:\n+\t\t\tvar results []model.BannedIP\n+\n+\t\t\tlimit := 10\n+\t\t\tcount := 0\n+\n+\t\t\tfor page := 0; true; page++ {\n+\t\t\t\tvar bans []model.BannedIP\n+\n+\t\t\t\tif bans, err = ctx.providers.StorageProvider.LoadBannedIPs(context.Background(), limit, page); err != nil {\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\n+\t\t\t\tl := len(bans)\n+\n+\t\t\t\tcount += l\n+\n+\t\t\t\tresults = append(results, bans...)\n+\n+\t\t\t\tif l < limit {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif count == 0 {\n+\t\t\t\tfmt.Printf(\"No results.\\n\")\n+\n+\t\t\t\treturn nil\n+\t\t\t}\n+\n+\t\t\tw := tabwriter.NewWriter(os.Stdout, 1, 1, 1, ' ', 0)\n+\n+\t\t\t_, _ = fmt.Fprintln(w, \"ID\\tIP\\tExpires\\tSource\\tReason\")\n+\n+\t\t\tfor _, ban := range results {\n+\t\t\t\t_, _ = fmt.Fprintf(w, \"%d\\t%s\\t%s\\t%s\\t%s\\n\", ban.ID, ban.IP, regulation.FormatExpiresShort(ban.Expires), ban.Source, ban.Reason.String)\n+\t\t\t}\n+\n+\t\t\treturn w.Flush()\n+\t\tcase cmdUseUser:\n+\t\t\tvar results []model.BannedUser\n+\n+\t\t\tlimit := 10\n+\t\t\tcount := 0\n+\n+\t\t\tfor page := 0; true; page++ {\n+\t\t\t\tvar bans []model.BannedUser\n+\n+\t\t\t\tif bans, err = ctx.providers.StorageProvider.LoadBannedUsers(context.Background(), limit, page); err != nil {\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\n+\t\t\t\tl := len(bans)\n+\n+\t\t\t\tcount += l\n+\n+\t\t\t\tresults = append(results, bans...)\n+\n+\t\t\t\tif l < limit {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif count == 0 {\n+\t\t\t\tfmt.Printf(\"No results.\\n\")\n+\n+\t\t\t\treturn nil\n+\t\t\t}\n+\n+\t\t\tw := tabwriter.NewWriter(os.Stdout, 1, 1, 1, ' ', 0)\n+\n+\t\t\t_, _ = fmt.Fprintln(w, \"ID\\tUsername\\tExpires\\tSource\\tReason\")\n+\n+\t\t\tfor _, ban := range results {\n+\t\t\t\t_, _ = fmt.Fprintf(w, \"%d\\t%s\\t%s\\t%s\\t%s\\n\", ban.ID, ban.Username, regulation.FormatExpiresShort(ban.Expires), ban.Source, ban.Reason.String)\n+\t\t\t}\n+\n+\t\t\treturn w.Flush()\n+\t\tdefault:\n+\t\t\treturn fmt.Errorf(\"unknown command %q\", use)\n+\t\t}\n+\t}\n+}\n+\n+//nolint:gocyclo\n+func (ctx *CmdCtx) StorageBansRevokeRunE(use string) func(cmd *cobra.Command, args []string) (err error) {\n+\treturn func(cmd *cobra.Command, args []string) (err error) {\n+\t\tdefer func() {\n+\t\t\t_ = ctx.providers.StorageProvider.Close()\n+\t\t}()\n+\n+\t\tif err = ctx.CheckSchema(); err != nil {\n+\t\t\treturn storageWrapCheckSchemaErr(err)\n+\t\t}\n+\n+\t\tvar (\n+\t\t\tid     int\n+\t\t\ttarget string\n+\t\t)\n+\n+\t\tif id, err = cmd.Flags().GetInt(\"id\"); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tif len(args) != 0 {\n+\t\t\ttarget = args[0]\n+\t\t}\n+\n+\t\tswitch use {\n+\t\tcase cmdUseIP:\n+\t\t\tip := net.ParseIP(target)\n+\n+\t\t\tvar bans []model.BannedIP\n+\n+\t\t\tif id == 0 {\n+\t\t\t\tif bans, err = ctx.providers.StorageProvider.LoadBannedIP(ctx, model.NewIP(ip)); err != nil {\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvar ban model.BannedIP\n+\n+\t\t\t\tif ban, err = ctx.providers.StorageProvider.LoadBannedIPByID(ctx, id); err != nil {\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\n+\t\t\t\tbans = []model.BannedIP{ban}\n+\t\t\t}\n+\n+\t\t\tfor _, ban := range bans {\n+\t\t\t\tif ban.Revoked {\n+\t\t\t\t\tfmt.Printf(\"SKIPPED\\tIP ban with id '%d' for '%s is already revoked.\\n\", ban.ID, ban.IP)\n+\t\t\t\t} else {\n+\t\t\t\t\tif err = ctx.providers.StorageProvider.RevokeBannedIP(ctx, ban.ID, time.Now()); err != nil {\n+\t\t\t\t\t\tfmt.Printf(\"ERROR\\tIP ban with id '%d' for '%s' had error when being revoked: %+v\\n\", ban.ID, ban.IP, err)\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tfmt.Printf(\"REVOKED\\tIP ban with id '%d' for '%s' has been revoked\\n\", ban.ID, ban.IP)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\tcase cmdUseUser:\n+\t\t\tvar bans []model.BannedUser\n+\n+\t\t\tif id == 0 {\n+\t\t\t\tif bans, err = ctx.providers.StorageProvider.LoadBannedUser(ctx, target); err != nil {\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tvar ban model.BannedUser\n+\n+\t\t\t\tif ban, err = ctx.providers.StorageProvider.LoadBannedUserByID(ctx, id); err != nil {\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\n+\t\t\t\tbans = []model.BannedUser{ban}\n+\t\t\t}\n+\n+\t\t\tfor _, ban := range bans {\n+\t\t\t\tif ban.Revoked {\n+\t\t\t\t\tfmt.Printf(\"SKIPPED\\tUser ban with id '%d' for '%s is already revoked.\\n\", ban.ID, ban.Username)\n+\t\t\t\t} else {\n+\t\t\t\t\tif err = ctx.providers.StorageProvider.RevokeBannedUser(ctx, ban.ID, time.Now()); err != nil {\n+\t\t\t\t\t\tfmt.Printf(\"ERROR\\tUser ban with id '%d' for '%s' had error when being revoked: %+v\\n\", ban.ID, ban.Username, err)\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tfmt.Printf(\"REVOKED\\tUser ban with id '%d' for '%s' has been revoked\\n\", ban.ID, ban.Username)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\tdefault:\n+\t\t\treturn fmt.Errorf(\"unknown command %q\", use)\n+\t\t}\n+\n+\t\treturn nil\n+\t}\n+}\n+\n+//nolint:gocyclo\n+func (ctx *CmdCtx) StorageBansAddRunE(use string) func(cmd *cobra.Command, args []string) (err error) {\n+\treturn func(cmd *cobra.Command, args []string) (err error) {\n+\t\tdefer func() {\n+\t\t\t_ = ctx.providers.StorageProvider.Close()\n+\t\t}()\n+\n+\t\tif err = ctx.CheckSchema(); err != nil {\n+\t\t\treturn storageWrapCheckSchemaErr(err)\n+\t\t}\n+\n+\t\tvar (\n+\t\t\tpermanent           bool\n+\t\t\treason, durationStr string\n+\t\t)\n+\n+\t\tif permanent, err = cmd.Flags().GetBool(\"permanent\"); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tif reason, err = cmd.Flags().GetString(\"reason\"); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tif durationStr, err = cmd.Flags().GetString(\"duration\"); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tduration, err := utils.ParseDurationString(durationStr)\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"failed to parse duration string: %w\", err)\n+\t\t}\n+\n+\t\tif duration <= 0 {\n+\t\t\treturn fmt.Errorf(\"duration must be a positive value\")\n+\t\t}\n+\n+\t\ttarget := args[0]\n+\n+\t\tswitch use {\n+\t\tcase cmdUseIP:\n+\t\t\t// TODO: Check for existing ban and revoke it?\n+\t\t\tip := net.ParseIP(target)\n+\n+\t\t\tif ip == nil {\n+\t\t\t\treturn fmt.Errorf(\"invalid IP address: %s\", target)\n+\t\t\t}\n+\n+\t\t\tban := &model.BannedIP{\n+\t\t\t\tIP:     model.NewIP(ip),\n+\t\t\t\tSource: \"cli\",\n+\t\t\t}\n+\n+\t\t\tif reason != \"\" {\n+\t\t\t\tban.Reason = sql.NullString{Valid: true, String: reason}\n+\t\t\t}\n+\n+\t\t\tif !permanent {\n+\t\t\t\tban.Expires = sql.NullTime{Valid: true, Time: time.Now().Add(duration)}\n+\t\t\t}\n+\n+\t\t\tif err = ctx.providers.StorageProvider.SaveBannedIP(ctx, ban); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\n+\t\t\treturn nil\n+\t\tcase cmdUseUser:\n+\t\t\t// TODO: Check for existing ban and revoke it?\n+\t\t\tban := &model.BannedUser{\n+\t\t\t\tUsername: target,\n+\t\t\t\tSource:   \"cli\",\n+\t\t\t}\n+\n+\t\t\tif reason != \"\" {\n+\t\t\t\tban.Reason = sql.NullString{Valid: true, String: reason}\n+\t\t\t}\n+\n+\t\t\tif !permanent {\n+\t\t\t\tban.Expires = sql.NullTime{Valid: true, Time: time.Now().Add(duration)}\n+\t\t\t}\n+\n+\t\t\tif err = ctx.providers.StorageProvider.SaveBannedUser(ctx, ban); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\n+\t\t\treturn nil\n+\t\tdefault:\n+\t\t\treturn fmt.Errorf(\"unknown command %q\", use)\n+\t\t}\n+\t}\n+}\n+\n func (ctx *CmdCtx) StorageUserWebAuthnExportRunE(cmd *cobra.Command, args []string) (err error) {\n \tdefer func() {\n \t\t_ = ctx.providers.StorageProvider.Close()\ndiff --git a/internal/configuration/config.template.yml b/internal/configuration/config.template.yml\nindex 0fd1756e95101..4fcc0f509aa73 100644\n--- a/internal/configuration/config.template.yml\n+++ b/internal/configuration/config.template.yml\n@@ -974,6 +974,10 @@ session:\n ## This mechanism prevents attackers from brute forcing the first factor. It bans the user if too many attempts are made\n ## in a short period of time.\n # regulation:\n+  ## Regulation Mode.\n+  # modes:\n+    # - 'user'\n+\n   ## The number of failed login attempts before user is banned. Set it to 0 to disable regulation.\n   # max_retries: 3\n \ndiff --git a/internal/configuration/schema/authentication.go b/internal/configuration/schema/authentication.go\nindex 010262abfbaa6..4cd6c7055341d 100644\n--- a/internal/configuration/schema/authentication.go\n+++ b/internal/configuration/schema/authentication.go\n@@ -136,7 +136,7 @@ type AuthenticationBackendLDAP struct {\n \n \tAdditionalGroupsDN string `koanf:\"additional_groups_dn\" json:\"additional_groups_dn\" jsonschema:\"title=Additional Group Base\" jsonschema_description:\"The base in addition to the Base DN for all directory server operations for groups.\"`\n \tGroupsFilter       string `koanf:\"groups_filter\" json:\"groups_filter\" jsonschema:\"title=Groups Filter\" jsonschema_description:\"The LDAP filter used to search for group objects.\"`\n-\tGroupSearchMode    string `koanf:\"group_search_mode\" json:\"group_search_mode\" jsonschema:\"default=filter,enum=filter,enum=memberof,title=Groups Search Mode\" jsonschema_description:\"The LDAP group search mode used to search for group objects.\"`\n+\tGroupSearchMode    string `koanf:\"group_search_mode\" json:\"group_search_mode\" jsonschema:\"default=filter,enum=filter,enum=memberof,title=Groups Search Modes\" jsonschema_description:\"The LDAP group search mode used to search for group objects.\"`\n \n \tAttributes AuthenticationBackendLDAPAttributes `koanf:\"attributes\" json:\"attributes\"`\n \ndiff --git a/internal/configuration/schema/identity_providers.go b/internal/configuration/schema/identity_providers.go\nindex 39e34aeaa01c2..84382c8ef4c66 100644\n--- a/internal/configuration/schema/identity_providers.go\n+++ b/internal/configuration/schema/identity_providers.go\n@@ -95,7 +95,7 @@ type IdentityProvidersOpenIDConnectDiscovery struct {\n \n type IdentityProvidersOpenIDConnectLifespans struct {\n \tIdentityProvidersOpenIDConnectLifespanToken `koanf:\",squash\"`\n-\tJWTSecuredAuthorization                     time.Duration `koanf:\"jwt_secured_authorization\" json:\"jwt_secured_authorization\" jsonschema:\"default=5 minutes,title=JARM\" jsonschema_description:\"Allows tuning the token lifespan for the JWT Secured Authorization Response Mode (JARM).\"`\n+\tJWTSecuredAuthorization                     time.Duration `koanf:\"jwt_secured_authorization\" json:\"jwt_secured_authorization\" jsonschema:\"default=5 minutes,title=JARM\" jsonschema_description:\"Allows tuning the token lifespan for the JWT Secured Authorization Response Modes (JARM).\"`\n \n \tCustom map[string]IdentityProvidersOpenIDConnectLifespan `koanf:\"custom\" json:\"custom\" jsonschema:\"title=Custom Lifespans\" jsonschema_description:\"Allows creating custom lifespans to be used by individual clients.\"`\n }\n@@ -153,9 +153,9 @@ type IdentityProvidersOpenIDConnectClient struct {\n \tLifespan            string `koanf:\"lifespan\" json:\"lifespan\" jsonschema:\"title=Lifespan Name\" jsonschema_description:\"The name of the custom lifespan to utilize for this client.\"`\n \tClaimsPolicy        string `koanf:\"claims_policy\" json:\"claims_policy\" jsonschema:\"title=Claims Policy\" jsonschema_description:\"The claims policy to apply to this client.\"`\n \n-\tRequestedAudienceMode        string         `koanf:\"requested_audience_mode\" json:\"requested_audience_mode\" jsonschema:\"enum=explicit,enum=implicit,title=Requested Audience Mode\" jsonschema_description:\"The Requested Audience Mode used for this client.\"`\n-\tConsentMode                  string         `koanf:\"consent_mode\" json:\"consent_mode\" jsonschema:\"enum=auto,enum=explicit,enum=implicit,enum=pre-configured,title=Consent Mode\" jsonschema_description:\"The Consent Mode used for this client.\"`\n-\tConsentPreConfiguredDuration *time.Duration `koanf:\"pre_configured_consent_duration\" json:\"pre_configured_consent_duration\" jsonschema:\"default=7 days,title=Pre-Configured Consent Duration\" jsonschema_description:\"The Pre-Configured Consent Duration when using Consent Mode pre-configured for this client.\"`\n+\tRequestedAudienceMode        string         `koanf:\"requested_audience_mode\" json:\"requested_audience_mode\" jsonschema:\"enum=explicit,enum=implicit,title=Requested Audience Modes\" jsonschema_description:\"The Requested Audience Modes used for this client.\"`\n+\tConsentMode                  string         `koanf:\"consent_mode\" json:\"consent_mode\" jsonschema:\"enum=auto,enum=explicit,enum=implicit,enum=pre-configured,title=Consent Modes\" jsonschema_description:\"The Consent Modes used for this client.\"`\n+\tConsentPreConfiguredDuration *time.Duration `koanf:\"pre_configured_consent_duration\" json:\"pre_configured_consent_duration\" jsonschema:\"default=7 days,title=Pre-Configured Consent Duration\" jsonschema_description:\"The Pre-Configured Consent Duration when using Consent Modes pre-configured for this client.\"`\n \n \tRequirePushedAuthorizationRequests bool `koanf:\"require_pushed_authorization_requests\" json:\"require_pushed_authorization_requests\" jsonschema:\"default=false,title=Require Pushed Authorization Requests\" jsonschema_description:\"Requires Pushed Authorization Requests for this client to perform an authorization.\"`\n \tRequirePKCE                        bool `koanf:\"require_pkce\" json:\"require_pkce\" jsonschema:\"default=false,title=Require PKCE\" jsonschema_description:\"Requires a Proof Key for this client to perform Code Exchange.\"`\ndiff --git a/internal/configuration/schema/keys.go b/internal/configuration/schema/keys.go\nindex fbab487ef5fb1..3bc9084b4f2f4 100644\n--- a/internal/configuration/schema/keys.go\n+++ b/internal/configuration/schema/keys.go\n@@ -317,6 +317,7 @@ var Keys = []string{\n \t\"regulation.ban_time\",\n \t\"regulation.find_time\",\n \t\"regulation.max_retries\",\n+\t\"regulation.modes\",\n \t\"server.address\",\n \t\"server.asset_path\",\n \t\"server.buffers.read\",\ndiff --git a/internal/configuration/schema/regulation.go b/internal/configuration/schema/regulation.go\nindex 72c26faead0a5..62acadc3c7970 100644\n--- a/internal/configuration/schema/regulation.go\n+++ b/internal/configuration/schema/regulation.go\n@@ -6,6 +6,7 @@ import (\n \n // Regulation represents the configuration related to regulation.\n type Regulation struct {\n+\tModes      []string      `koanf:\"modes\" json:\"modes\" jsonschema:\"default=user,enum=user,enum=ip,title=Regulation Modes\" jsonschema_description:\"The modes to use for regulation.\"`\n \tMaxRetries int           `koanf:\"max_retries\" json:\"max_retries\" jsonschema:\"default=3,title=Maximum Retries\" jsonschema_description:\"The maximum number of failed attempts permitted before banning a user.\"`\n \tFindTime   time.Duration `koanf:\"find_time\" json:\"find_time\" jsonschema:\"default=2 minutes,title=Find Time\" jsonschema_description:\"The amount of time to consider when determining the number of failed attempts.\"`\n \tBanTime    time.Duration `koanf:\"ban_time\" json:\"ban_time\" jsonschema:\"default=5 minutes,title=Ban Time\" jsonschema_description:\"The amount of time to ban the user for when it's determined the maximum retries has been exceeded.\"`\n@@ -13,6 +14,7 @@ type Regulation struct {\n \n // DefaultRegulationConfiguration represents default configuration parameters for the regulator.\n var DefaultRegulationConfiguration = Regulation{\n+\tModes:      []string{\"user\"},\n \tMaxRetries: 3,\n \tFindTime:   time.Minute * 2,\n \tBanTime:    time.Minute * 5,\ndiff --git a/internal/configuration/validator/const.go b/internal/configuration/validator/const.go\nindex a13e4ee38376f..37f04308d8bdd 100644\n--- a/internal/configuration/validator/const.go\n+++ b/internal/configuration/validator/const.go\n@@ -405,6 +405,7 @@ const (\n // Regulation Error Consts.\n const (\n \terrFmtRegulationFindTimeGreaterThanBanTime = \"regulation: option 'find_time' must be less than or equal to option 'ban_time'\"\n+\terrFmtRegulationInvalidMode                = \"regulation: option 'modes' must only contain the values 'user' and 'ip' but contains the value '%s'\"\n )\n \n // Server Error constants.\ndiff --git a/internal/configuration/validator/regulation.go b/internal/configuration/validator/regulation.go\nindex 69e67d1af48de..0125b6eafa268 100644\n--- a/internal/configuration/validator/regulation.go\n+++ b/internal/configuration/validator/regulation.go\n@@ -2,12 +2,26 @@ package validator\n \n import (\n \t\"errors\"\n+\t\"fmt\"\n \n \t\"github.com/authelia/authelia/v4/internal/configuration/schema\"\n )\n \n // ValidateRegulation validates and update regulator configuration.\n func ValidateRegulation(config *schema.Configuration, validator *schema.StructValidator) {\n+\tif len(config.Regulation.Modes) == 0 {\n+\t\tconfig.Regulation.Modes = schema.DefaultRegulationConfiguration.Modes\n+\t} else {\n+\t\tfor _, mode := range config.Regulation.Modes {\n+\t\t\tswitch mode {\n+\t\t\tcase \"ip\", \"user\":\n+\t\t\t\tbreak\n+\t\t\tdefault:\n+\t\t\t\tvalidator.Push(fmt.Errorf(errFmtRegulationInvalidMode, mode))\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tif config.Regulation.FindTime <= 0 {\n \t\tconfig.Regulation.FindTime = schema.DefaultRegulationConfiguration.FindTime // 2 min.\n \t}\ndiff --git a/internal/handlers/handler_authz_authn.go b/internal/handlers/handler_authz_authn.go\nindex 2742f21cfac10..66a5b62c5a460 100644\n--- a/internal/handlers/handler_authz_authn.go\n+++ b/internal/handlers/handler_authz_authn.go\n@@ -20,6 +20,7 @@ import (\n \t\"github.com/authelia/authelia/v4/internal/middlewares\"\n \t\"github.com/authelia/authelia/v4/internal/model\"\n \t\"github.com/authelia/authelia/v4/internal/oidc\"\n+\t\"github.com/authelia/authelia/v4/internal/regulation\"\n \t\"github.com/authelia/authelia/v4/internal/session\"\n \t\"github.com/authelia/authelia/v4/internal/utils\"\n )\n@@ -256,15 +257,46 @@ func (s *HeaderAuthnStrategy) Get(ctx *middlewares.AutheliaCtx, _ *session.Sessi\n \treturn authn, nil\n }\n \n-func (s *HeaderAuthnStrategy) handleGetBasic(ctx *middlewares.AutheliaCtx, authn *Authn, _ *authorization.Object) (username string, level authentication.Level, err error) {\n+func (s *HeaderAuthnStrategy) handleGetBasic(ctx *middlewares.AutheliaCtx, authn *Authn, object *authorization.Object) (username string, level authentication.Level, err error) {\n \tvar (\n-\t\tvalid bool\n+\t\tvalid    bool\n+\t\tpassword string\n \t)\n \n-\tif valid, err = ctx.Providers.UserProvider.CheckUserPassword(authn.Header.Authorization.Basic()); err != nil {\n-\t\treturn \"\", authentication.NotAuthenticated, fmt.Errorf(\"failed to validate parsed credentials of %s header for user '%s': %w\", s.headerAuthorize, authn.Header.Authorization.BasicUsername(), err)\n+\tusername, password = authn.Header.Authorization.Basic()\n+\n+\tif valid, err = ctx.Providers.UserProvider.CheckUserPassword(username, password); err != nil {\n+\t\tdoMarkAuthenticationAttemptWithRequest(ctx, false, regulation.NewBan(regulation.BanTypeNone, username, nil), regulation.AuthType1FA, object.String(), object.Method, err)\n+\n+\t\treturn \"\", authentication.NotAuthenticated, fmt.Errorf(\"failed to validate parsed credentials of %s header for user '%s': %w\", s.headerAuthorize, username, err)\n \t}\n \n+\tvar (\n+\t\tban     regulation.BanType\n+\t\tvalue   string\n+\t\texpires *time.Time\n+\t)\n+\n+\tif ban, value, expires, err = ctx.Providers.Regulator.BanCheck(ctx, username); err != nil {\n+\t\tif errors.Is(err, regulation.ErrUserIsBanned) {\n+\t\t\tdoMarkAuthenticationAttemptWithRequest(ctx, false, regulation.NewBan(ban, value, expires), regulation.AuthType1FA, object.String(), object.Method, nil)\n+\n+\t\t\treturn \"\", authentication.NotAuthenticated, fmt.Errorf(\"validated parsed credentials of %s header for user '%s' but they are currently banned: %w\", s.headerAuthorize, username, err)\n+\t\t}\n+\n+\t\tctx.Logger.WithError(err).Errorf(logFmtErrRegulationFail, regulation.AuthType1FA, username)\n+\n+\t\treturn \"\", authentication.NotAuthenticated, fmt.Errorf(\"validated parsed credentials of %s header for user '%s' but an error occurred checking the regulation status of the user: %w\", s.headerAuthorize, username, err)\n+\t}\n+\n+\tif !valid {\n+\t\tdoMarkAuthenticationAttemptWithRequest(ctx, false, regulation.NewBan(regulation.BanTypeNone, username, nil), regulation.AuthType1FA, object.String(), object.Method, nil)\n+\n+\t\treturn \"\", authentication.NotAuthenticated, fmt.Errorf(\"failed to validate parsed credentials of %s header valid for user '%s': the username and password do not match\", s.headerAuthorize, username)\n+\t}\n+\n+\tdoMarkAuthenticationAttemptWithRequest(ctx, true, regulation.NewBan(regulation.BanTypeNone, username, nil), regulation.AuthType1FA, object.String(), object.Method, nil)\n+\n \tif !valid {\n \t\treturn \"\", authentication.NotAuthenticated, fmt.Errorf(\"validated parsed credentials of %s header but they are not valid for user '%s': %w\", s.headerAuthorize, authn.Header.Authorization.BasicUsername(), err)\n \t}\ndiff --git a/internal/handlers/handler_firstfactor_passkey.go b/internal/handlers/handler_firstfactor_passkey.go\nindex c6436f2384d0f..f9dae85639b7b 100644\n--- a/internal/handlers/handler_firstfactor_passkey.go\n+++ b/internal/handlers/handler_firstfactor_passkey.go\n@@ -259,14 +259,7 @@ func FirstFactorPasskeyPOST(ctx *middlewares.AutheliaCtx) {\n \t\treturn\n \t}\n \n-\tif err = markAuthenticationAttempt(ctx, true, nil, details.Username, regulation.AuthTypePasskey, nil); err != nil {\n-\t\tctx.SetStatusCode(fasthttp.StatusForbidden)\n-\t\tctx.SetJSONError(messageMFAValidationFailed)\n-\n-\t\tctx.Logger.WithError(err).Errorf(logFmtErrPasskeyAuthenticationChallengeValidateUser, details.Username, \"error occurred recording the authentication attempt\")\n-\n-\t\treturn\n-\t}\n+\tdoMarkAuthenticationAttempt(ctx, true, regulation.NewBan(regulation.BanTypeNone, details.Username, nil), regulation.AuthTypePasskey, nil)\n \n \tif ctx.Configuration.AuthenticationBackend.RefreshInterval.Update() {\n \t\tuserSession.RefreshTTL = ctx.Clock.Now().Add(ctx.Configuration.AuthenticationBackend.RefreshInterval.Value())\ndiff --git a/internal/handlers/handler_firstfactor_password.go b/internal/handlers/handler_firstfactor_password.go\nindex 6d1e9dfab4038..03433298d9000 100644\n--- a/internal/handlers/handler_firstfactor_password.go\n+++ b/internal/handlers/handler_firstfactor_password.go\n@@ -46,9 +46,9 @@ func FirstFactorPasswordPOST(delayFunc middlewares.TimingAttackDelayFunc) middle\n \t\t\treturn\n \t\t}\n \n-\t\tif bannedUntil, err := ctx.Providers.Regulator.Regulate(ctx, details.Username); err != nil {\n+\t\tif ban, value, expires, err := ctx.Providers.Regulator.BanCheck(ctx, details.Username); err != nil {\n \t\t\tif errors.Is(err, regulation.ErrUserIsBanned) {\n-\t\t\t\t_ = markAuthenticationAttempt(ctx, false, &bannedUntil, details.Username, regulation.AuthType1FA, nil)\n+\t\t\t\tdoMarkAuthenticationAttempt(ctx, false, regulation.NewBan(ban, value, expires), regulation.AuthType1FA, nil)\n \n \t\t\t\trespondUnauthorized(ctx, messageAuthenticationFailed)\n \n@@ -64,7 +64,7 @@ func FirstFactorPasswordPOST(delayFunc middlewares.TimingAttackDelayFunc) middle\n \n \t\tuserPasswordOk, err := ctx.Providers.UserProvider.CheckUserPassword(details.Username, bodyJSON.Password)\n \t\tif err != nil {\n-\t\t\t_ = markAuthenticationAttempt(ctx, false, nil, details.Username, regulation.AuthType1FA, err)\n+\t\t\tdoMarkAuthenticationAttempt(ctx, false, regulation.NewBan(regulation.BanTypeNone, details.Username, nil), regulation.AuthType1FA, err)\n \n \t\t\trespondUnauthorized(ctx, messageAuthenticationFailed)\n \n@@ -72,18 +72,14 @@ func FirstFactorPasswordPOST(delayFunc middlewares.TimingAttackDelayFunc) middle\n \t\t}\n \n \t\tif !userPasswordOk {\n-\t\t\t_ = markAuthenticationAttempt(ctx, false, nil, details.Username, regulation.AuthType1FA, nil)\n+\t\t\tdoMarkAuthenticationAttempt(ctx, false, regulation.NewBan(regulation.BanTypeNone, details.Username, nil), regulation.AuthType1FA, nil)\n \n \t\t\trespondUnauthorized(ctx, messageAuthenticationFailed)\n \n \t\t\treturn\n \t\t}\n \n-\t\tif err = markAuthenticationAttempt(ctx, true, nil, details.Username, regulation.AuthType1FA, nil); err != nil {\n-\t\t\trespondUnauthorized(ctx, messageAuthenticationFailed)\n-\n-\t\t\treturn\n-\t\t}\n+\t\tdoMarkAuthenticationAttempt(ctx, true, regulation.NewBan(regulation.BanTypeNone, details.Username, nil), regulation.AuthType1FA, nil)\n \n \t\tvar provider *session.Session\n \n@@ -174,7 +170,9 @@ func FirstFactorReauthenticatePOST(delayFunc middlewares.TimingAttackDelayFunc)\n \n \t\tbodyJSON := bodyFirstFactorReauthenticateRequest{}\n \n-\t\tif err := ctx.ParseBody(&bodyJSON); err != nil {\n+\t\tvar err error\n+\n+\t\tif err = ctx.ParseBody(&bodyJSON); err != nil {\n \t\t\tctx.Logger.WithError(err).Errorf(logFmtErrParseRequestBody, regulation.AuthType1FA)\n \n \t\t\trespondUnauthorized(ctx, messageAuthenticationFailed)\n@@ -182,8 +180,12 @@ func FirstFactorReauthenticatePOST(delayFunc middlewares.TimingAttackDelayFunc)\n \t\t\treturn\n \t\t}\n \n-\t\tprovider, err := ctx.GetSessionProvider()\n-\t\tif err != nil {\n+\t\tvar (\n+\t\t\tprovider    *session.Session\n+\t\t\tuserSession session.UserSession\n+\t\t)\n+\n+\t\tif provider, err = ctx.GetSessionProvider(); err != nil {\n \t\t\tctx.Logger.WithError(err).Error(\"Failed to get session provider during 1FA attempt\")\n \n \t\t\trespondUnauthorized(ctx, messageAuthenticationFailed)\n@@ -191,8 +193,7 @@ func FirstFactorReauthenticatePOST(delayFunc middlewares.TimingAttackDelayFunc)\n \t\t\treturn\n \t\t}\n \n-\t\tuserSession, err := provider.GetSession(ctx.RequestCtx)\n-\t\tif err != nil {\n+\t\tif userSession, err = provider.GetSession(ctx.RequestCtx); err != nil {\n \t\t\tctx.Logger.WithError(err).Errorf(\"Error occurred attempting to load session.\")\n \n \t\t\trespondUnauthorized(ctx, messageAuthenticationFailed)\n@@ -200,9 +201,15 @@ func FirstFactorReauthenticatePOST(delayFunc middlewares.TimingAttackDelayFunc)\n \t\t\treturn\n \t\t}\n \n-\t\tif bannedUntil, err := ctx.Providers.Regulator.Regulate(ctx, userSession.Username); err != nil {\n+\t\tvar (\n+\t\t\tban     regulation.BanType\n+\t\t\tvalue   string\n+\t\t\texpires *time.Time\n+\t\t)\n+\n+\t\tif ban, value, expires, err = ctx.Providers.Regulator.BanCheck(ctx, userSession.Username); err != nil {\n \t\t\tif errors.Is(err, regulation.ErrUserIsBanned) {\n-\t\t\t\t_ = markAuthenticationAttempt(ctx, false, &bannedUntil, userSession.Username, regulation.AuthType1FA, nil)\n+\t\t\t\tdoMarkAuthenticationAttempt(ctx, false, regulation.NewBan(ban, value, expires), regulation.AuthType1FA, nil)\n \n \t\t\t\trespondUnauthorized(ctx, messageAuthenticationFailed)\n \n@@ -218,7 +225,7 @@ func FirstFactorReauthenticatePOST(delayFunc middlewares.TimingAttackDelayFunc)\n \n \t\tuserPasswordOk, err := ctx.Providers.UserProvider.CheckUserPassword(userSession.Username, bodyJSON.Password)\n \t\tif err != nil {\n-\t\t\t_ = markAuthenticationAttempt(ctx, false, nil, userSession.Username, regulation.AuthType1FA, err)\n+\t\t\tdoMarkAuthenticationAttempt(ctx, false, regulation.NewBan(regulation.BanTypeNone, userSession.Username, nil), regulation.AuthType1FA, err)\n \n \t\t\trespondUnauthorized(ctx, messageAuthenticationFailed)\n \n@@ -226,18 +233,14 @@ func FirstFactorReauthenticatePOST(delayFunc middlewares.TimingAttackDelayFunc)\n \t\t}\n \n \t\tif !userPasswordOk {\n-\t\t\t_ = markAuthenticationAttempt(ctx, false, nil, userSession.Username, regulation.AuthType1FA, nil)\n+\t\t\tdoMarkAuthenticationAttempt(ctx, false, regulation.NewBan(regulation.BanTypeNone, userSession.Username, nil), regulation.AuthType1FA, nil)\n \n \t\t\trespondUnauthorized(ctx, messageAuthenticationFailed)\n \n \t\t\treturn\n \t\t}\n \n-\t\tif err = markAuthenticationAttempt(ctx, true, nil, userSession.Username, regulation.AuthType1FA, nil); err != nil {\n-\t\t\trespondUnauthorized(ctx, messageAuthenticationFailed)\n-\n-\t\t\treturn\n-\t\t}\n+\t\tdoMarkAuthenticationAttempt(ctx, true, regulation.NewBan(regulation.BanTypeNone, userSession.Username, nil), regulation.AuthType1FA, nil)\n \n \t\tif err = ctx.RegenerateSession(); err != nil {\n \t\t\tctx.Logger.WithError(err).Errorf(logFmtErrSessionRegenerate, regulation.AuthType1FA, userSession.Username)\n@@ -247,9 +250,11 @@ func FirstFactorReauthenticatePOST(delayFunc middlewares.TimingAttackDelayFunc)\n \t\t\treturn\n \t\t}\n \n-\t\t// Get the details of the given user from the user provider.\n-\t\tuserDetails, err := ctx.Providers.UserProvider.GetDetails(userSession.Username)\n-\t\tif err != nil {\n+\t\tvar (\n+\t\t\tuserDetails *authentication.UserDetails\n+\t\t)\n+\n+\t\tif userDetails, err = ctx.Providers.UserProvider.GetDetails(userSession.Username); err != nil {\n \t\t\tctx.Logger.WithError(err).Errorf(logFmtErrObtainProfileDetails, regulation.AuthType1FA, userSession.Username)\n \n \t\t\trespondUnauthorized(ctx, messageAuthenticationFailed)\ndiff --git a/internal/handlers/handler_oidc_authorization.go b/internal/handlers/handler_oidc_authorization.go\nindex 1df8b7ab23842..a7d95a6b3ca42 100644\n--- a/internal/handlers/handler_oidc_authorization.go\n+++ b/internal/handlers/handler_oidc_authorization.go\n@@ -198,7 +198,7 @@ func OpenIDConnectPushedAuthorizationRequest(ctx *middlewares.AutheliaCtx, rw ht\n \t}\n \n \tif err = client.ValidateResponseModePolicy(requester); err != nil {\n-\t\tctx.Logger.Errorf(\"Pushed Authorization Request with id '%s' on client with id '%s' failed to validate the Response Mode: %s\", requester.GetID(), client.GetID(), oauthelia2.ErrorToDebugRFC6749Error(err))\n+\t\tctx.Logger.Errorf(\"Pushed Authorization Request with id '%s' on client with id '%s' failed to validate the Response Modes: %s\", requester.GetID(), client.GetID(), oauthelia2.ErrorToDebugRFC6749Error(err))\n \n \t\tctx.Providers.OpenIDConnect.WritePushedAuthorizeError(ctx, rw, requester, err)\n \ndiff --git a/internal/handlers/handler_sign_duo.go b/internal/handlers/handler_sign_duo.go\nindex 95961f6bdb175..00ab47a011840 100644\n--- a/internal/handlers/handler_sign_duo.go\n+++ b/internal/handlers/handler_sign_duo.go\n@@ -78,7 +78,7 @@ func DuoPOST(duoAPI duo.API) middlewares.RequestHandler {\n \t\t}\n \n \t\tif authResponse.Result != allow {\n-\t\t\t_ = markAuthenticationAttempt(ctx, false, nil, userSession.Username, regulation.AuthTypeDuo,\n+\t\t\tdoMarkAuthenticationAttempt(ctx, false, regulation.NewBan(regulation.BanTypeNone, userSession.Username, nil), regulation.AuthTypeDuo,\n \t\t\t\tfmt.Errorf(\"duo auth result: %s, status: %s, message: %s\", authResponse.Result, authResponse.Status,\n \t\t\t\t\tauthResponse.StatusMessage))\n \n@@ -87,10 +87,7 @@ func DuoPOST(duoAPI duo.API) middlewares.RequestHandler {\n \t\t\treturn\n \t\t}\n \n-\t\tif err = markAuthenticationAttempt(ctx, true, nil, userSession.Username, regulation.AuthTypeDuo, nil); err != nil {\n-\t\t\trespondUnauthorized(ctx, messageMFAValidationFailed)\n-\t\t\treturn\n-\t\t}\n+\t\tdoMarkAuthenticationAttempt(ctx, true, regulation.NewBan(regulation.BanTypeNone, userSession.Username, nil), regulation.AuthTypeDuo, nil)\n \n \t\tHandleAllow(ctx, &userSession, bodyJSON)\n \t}\ndiff --git a/internal/handlers/handler_sign_password.go b/internal/handlers/handler_sign_password.go\nindex 8a674cc3aca95..fb6ef29fafc84 100644\n--- a/internal/handlers/handler_sign_password.go\n+++ b/internal/handlers/handler_sign_password.go\n@@ -5,6 +5,7 @@ import (\n \n \t\"github.com/authelia/authelia/v4/internal/middlewares\"\n \t\"github.com/authelia/authelia/v4/internal/regulation\"\n+\t\"github.com/authelia/authelia/v4/internal/session\"\n )\n \n // SecondFactorPasswordPOST is the handler performing the knowledge based authentication factor after a user utilizes a\n@@ -21,7 +22,9 @@ func SecondFactorPasswordPOST(delayFunc middlewares.TimingAttackDelayFunc) middl\n \n \t\tbodyJSON := bodySecondFactorPasswordRequest{}\n \n-\t\tif err := ctx.ParseBody(&bodyJSON); err != nil {\n+\t\tvar err error\n+\n+\t\tif err = ctx.ParseBody(&bodyJSON); err != nil {\n \t\t\tctx.Logger.WithError(err).Errorf(logFmtErrParseRequestBody, regulation.AuthType1FA)\n \n \t\t\trespondUnauthorized(ctx, messageAuthenticationFailed)\n@@ -29,8 +32,12 @@ func SecondFactorPasswordPOST(delayFunc middlewares.TimingAttackDelayFunc) middl\n \t\t\treturn\n \t\t}\n \n-\t\tprovider, err := ctx.GetSessionProvider()\n-\t\tif err != nil {\n+\t\tvar (\n+\t\t\tprovider    *session.Session\n+\t\t\tuserSession session.UserSession\n+\t\t)\n+\n+\t\tif provider, err = ctx.GetSessionProvider(); err != nil {\n \t\t\tctx.Logger.WithError(err).Error(\"Failed to get session provider during 2FA attempt\")\n \n \t\t\trespondUnauthorized(ctx, messageAuthenticationFailed)\n@@ -38,8 +45,7 @@ func SecondFactorPasswordPOST(delayFunc middlewares.TimingAttackDelayFunc) middl\n \t\t\treturn\n \t\t}\n \n-\t\tuserSession, err := provider.GetSession(ctx.RequestCtx)\n-\t\tif err != nil {\n+\t\tif userSession, err = provider.GetSession(ctx.RequestCtx); err != nil {\n \t\t\tctx.Logger.Errorf(\"%s\", err)\n \n \t\t\trespondUnauthorized(ctx, messageAuthenticationFailed)\n@@ -47,9 +53,12 @@ func SecondFactorPasswordPOST(delayFunc middlewares.TimingAttackDelayFunc) middl\n \t\t\treturn\n \t\t}\n \n-\t\tuserPasswordOk, err := ctx.Providers.UserProvider.CheckUserPassword(userSession.Username, bodyJSON.Password)\n-\t\tif err != nil {\n-\t\t\t_ = markAuthenticationAttempt(ctx, false, nil, userSession.Username, regulation.AuthTypePassword, err)\n+\t\tvar (\n+\t\t\tuserPasswordOk bool\n+\t\t)\n+\n+\t\tif userPasswordOk, err = ctx.Providers.UserProvider.CheckUserPassword(userSession.Username, bodyJSON.Password); err != nil {\n+\t\t\tdoMarkAuthenticationAttempt(ctx, false, regulation.NewBan(regulation.BanTypeNone, userSession.Username, nil), regulation.AuthTypePassword, err)\n \n \t\t\trespondUnauthorized(ctx, messageAuthenticationFailed)\n \n@@ -57,18 +66,14 @@ func SecondFactorPasswordPOST(delayFunc middlewares.TimingAttackDelayFunc) middl\n \t\t}\n \n \t\tif !userPasswordOk {\n-\t\t\t_ = markAuthenticationAttempt(ctx, false, nil, userSession.Username, regulation.AuthTypePassword, nil)\n+\t\t\tdoMarkAuthenticationAttempt(ctx, false, regulation.NewBan(regulation.BanTypeNone, userSession.Username, nil), regulation.AuthTypePassword, nil)\n \n \t\t\trespondUnauthorized(ctx, messageAuthenticationFailed)\n \n \t\t\treturn\n \t\t}\n \n-\t\tif err = markAuthenticationAttempt(ctx, true, nil, userSession.Username, regulation.AuthTypePassword, nil); err != nil {\n-\t\t\trespondUnauthorized(ctx, messageAuthenticationFailed)\n-\n-\t\t\treturn\n-\t\t}\n+\t\tdoMarkAuthenticationAttempt(ctx, true, regulation.NewBan(regulation.BanTypeNone, userSession.Username, nil), regulation.AuthTypePassword, nil)\n \n \t\tuserSession.SetTwoFactorPassword(ctx.Clock.Now())\n \ndiff --git a/internal/handlers/handler_sign_totp.go b/internal/handlers/handler_sign_totp.go\nindex 516eb6e747c4e..5317ced4dc9b5 100644\n--- a/internal/handlers/handler_sign_totp.go\n+++ b/internal/handlers/handler_sign_totp.go\n@@ -135,7 +135,7 @@ func TimeBasedOneTimePasswordPOST(ctx *middlewares.AutheliaCtx) {\n \tif !valid {\n \t\tctx.Logger.WithError(fmt.Errorf(\"the user input wasn't valid\")).Errorf(\"Error occurred validating a TOTP authentication for user '%s': error occurred validating the user input\", userSession.Username)\n \n-\t\t_ = markAuthenticationAttempt(ctx, false, nil, userSession.Username, regulation.AuthTypeTOTP, nil)\n+\t\tdoMarkAuthenticationAttempt(ctx, false, regulation.NewBan(regulation.BanTypeNone, userSession.Username, nil), regulation.AuthTypeTOTP, nil)\n \n \t\tctx.SetStatusCode(fasthttp.StatusForbidden)\n \t\tctx.SetJSONError(messageMFAValidationFailed)\n@@ -172,12 +172,7 @@ func TimeBasedOneTimePasswordPOST(ctx *middlewares.AutheliaCtx) {\n \t\treturn\n \t}\n \n-\tif err = markAuthenticationAttempt(ctx, true, nil, userSession.Username, regulation.AuthTypeTOTP, nil); err != nil {\n-\t\tctx.SetStatusCode(fasthttp.StatusForbidden)\n-\t\tctx.SetJSONError(messageMFAValidationFailed)\n-\n-\t\treturn\n-\t}\n+\tdoMarkAuthenticationAttempt(ctx, true, regulation.NewBan(regulation.BanTypeNone, userSession.Username, nil), regulation.AuthTypeTOTP, nil)\n \n \tif err = ctx.RegenerateSession(); err != nil {\n \t\tctx.Logger.WithError(err).Errorf(\"Error occurred validating a TOTP authentication for user '%s': error regenerating the user session\", userSession.Username)\ndiff --git a/internal/handlers/handler_sign_webauthn.go b/internal/handlers/handler_sign_webauthn.go\nindex 441a0cc3a2c48..c36ac6f7e35fb 100644\n--- a/internal/handlers/handler_sign_webauthn.go\n+++ b/internal/handlers/handler_sign_webauthn.go\n@@ -206,7 +206,7 @@ func WebAuthnAssertionPOST(ctx *middlewares.AutheliaCtx) {\n \t}\n \n \tif c, err = w.ValidateLogin(user, *userSession.WebAuthn.SessionData, response); err != nil {\n-\t\t_ = markAuthenticationAttempt(ctx, false, nil, userSession.Username, regulation.AuthTypeWebAuthn, iwebauthn.FormatError(err))\n+\t\tdoMarkAuthenticationAttempt(ctx, false, regulation.NewBan(regulation.BanTypeNone, userSession.Username, nil), regulation.AuthTypeWebAuthn, iwebauthn.FormatError(err))\n \n \t\tctx.SetStatusCode(fasthttp.StatusForbidden)\n \t\tctx.SetJSONError(messageMFAValidationFailed)\n@@ -270,12 +270,7 @@ func WebAuthnAssertionPOST(ctx *middlewares.AutheliaCtx) {\n \t\treturn\n \t}\n \n-\tif err = markAuthenticationAttempt(ctx, true, nil, userSession.Username, regulation.AuthTypeWebAuthn, nil); err != nil {\n-\t\tctx.SetStatusCode(fasthttp.StatusForbidden)\n-\t\tctx.SetJSONError(messageMFAValidationFailed)\n-\n-\t\treturn\n-\t}\n+\tdoMarkAuthenticationAttempt(ctx, true, regulation.NewBan(regulation.BanTypeNone, userSession.Username, nil), regulation.AuthTypeWebAuthn, nil)\n \n \tuserSession.SetTwoFactorWebAuthn(ctx.Clock.Now(),\n \t\tresponse.ParsedPublicKeyCredential.AuthenticatorAttachment == protocol.CrossPlatform,\ndiff --git a/internal/handlers/response.go b/internal/handlers/response.go\nindex 4045c5d0afb9f..9dc8e2f0faa0b 100644\n--- a/internal/handlers/response.go\n+++ b/internal/handlers/response.go\n@@ -3,7 +3,6 @@ package handlers\n import (\n \t\"fmt\"\n \t\"net/url\"\n-\t\"time\"\n \n \t\"github.com/google/uuid\"\n \t\"github.com/valyala/fasthttp\"\n@@ -12,6 +11,7 @@ import (\n \t\"github.com/authelia/authelia/v4/internal/middlewares\"\n \t\"github.com/authelia/authelia/v4/internal/model\"\n \t\"github.com/authelia/authelia/v4/internal/oidc\"\n+\t\"github.com/authelia/authelia/v4/internal/regulation\"\n \t\"github.com/authelia/authelia/v4/internal/session\"\n )\n \n@@ -240,12 +240,10 @@ func handleOIDCWorkflowResponse(ctx *middlewares.AutheliaCtx, userSession *sessi\n \t}\n }\n \n-func markAuthenticationAttempt(ctx *middlewares.AutheliaCtx, successful bool, bannedUntil *time.Time, username string, authType string, errAuth error) (err error) {\n-\t// We only Mark if there was no underlying error.\n-\tctx.Logger.Debugf(\"Mark %s authentication attempt made by user '%s'\", authType, username)\n-\n+func doMarkAuthenticationAttempt(ctx *middlewares.AutheliaCtx, successful bool, ban *regulation.Ban, authType string, errAuth error) {\n \tvar (\n \t\trequestURI, requestMethod string\n+\t\terr                       error\n \t)\n \n \tif referer := ctx.Request.Header.Referer(); referer != nil {\n@@ -257,26 +255,27 @@ func markAuthenticationAttempt(ctx *middlewares.AutheliaCtx, successful bool, ba\n \t\t}\n \t}\n \n-\tif err = ctx.Providers.Regulator.Mark(ctx, successful, bannedUntil != nil, username, requestURI, requestMethod, authType); err != nil {\n-\t\tctx.Logger.WithError(err).Errorf(\"Unable to mark %s authentication attempt by user '%s'\", authType, username)\n+\tdoMarkAuthenticationAttemptWithRequest(ctx, successful, ban, authType, requestURI, requestMethod, errAuth)\n+}\n \n-\t\treturn err\n-\t}\n+func doMarkAuthenticationAttemptWithRequest(ctx *middlewares.AutheliaCtx, successful bool, ban *regulation.Ban, authType, requestURI, requestMethod string, errAuth error) {\n+\t// We only Mark if there was no underlying error.\n+\tctx.Logger.Debugf(\"Mark %s authentication attempt made by user '%s'\", authType, ban.Value())\n+\n+\tctx.Providers.Regulator.HandleAttempt(ctx, successful, ban.IsBanned(), ban.Value(), requestURI, requestMethod, authType)\n \n \tif successful {\n-\t\tctx.Logger.Debugf(\"Successful %s authentication attempt made by user '%s'\", authType, username)\n+\t\tctx.Logger.Debugf(\"Successful %s authentication attempt made by user '%s'\", authType, ban.Value())\n \t} else {\n \t\tswitch {\n \t\tcase errAuth != nil:\n-\t\t\tctx.Logger.WithError(errAuth).Errorf(\"Unsuccessful %s authentication attempt by user '%s'\", authType, username)\n-\t\tcase bannedUntil != nil:\n-\t\t\tctx.Logger.Errorf(\"Unsuccessful %s authentication attempt by user '%s' and they are banned until %s\", authType, username, bannedUntil)\n+\t\t\tctx.Logger.WithError(errAuth).Errorf(\"Unsuccessful %s authentication attempt by user '%s'\", authType, ban.Value())\n+\t\tcase ban.IsBanned():\n+\t\t\tctx.Logger.Errorf(\"Unsuccessful %s authentication attempt by user '%s' and they are banned until %s\", authType, ban.Value(), ban.FormatExpires())\n \t\tdefault:\n-\t\t\tctx.Logger.Errorf(\"Unsuccessful %s authentication attempt by user '%s'\", authType, username)\n+\t\t\tctx.Logger.Errorf(\"Unsuccessful %s authentication attempt by user '%s'\", authType, ban.Value())\n \t\t}\n \t}\n-\n-\treturn nil\n }\n \n func respondUnauthorized(ctx *middlewares.AutheliaCtx, message string) {\ndiff --git a/internal/middlewares/authelia_context.go b/internal/middlewares/authelia_context.go\nindex 1051a690cf20c..17ca8a81c444d 100644\n--- a/internal/middlewares/authelia_context.go\n+++ b/internal/middlewares/authelia_context.go\n@@ -733,3 +733,8 @@ func (ctx *AutheliaCtx) Value(key any) any {\n \n \treturn ctx.RequestCtx.Value(key)\n }\n+\n+// GetLogger returns the logger for this request.\n+func (ctx *AutheliaCtx) GetLogger() *logrus.Entry {\n+\treturn ctx.Logger\n+}\ndiff --git a/internal/mocks/storage.go b/internal/mocks/storage.go\nindex e00b61b00c9ea..d28c9c3f77ea4 100644\n--- a/internal/mocks/storage.go\n+++ b/internal/mocks/storage.go\n@@ -272,19 +272,94 @@ func (mr *MockStorageMockRecorder) FindIdentityVerification(ctx, jti any) *gomoc\n \treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindIdentityVerification\", reflect.TypeOf((*MockStorage)(nil).FindIdentityVerification), ctx, jti)\n }\n \n-// LoadAuthenticationLogs mocks base method.\n-func (m *MockStorage) LoadAuthenticationLogs(ctx context.Context, username string, fromDate time.Time, limit, page int) ([]model.AuthenticationAttempt, error) {\n+// LoadBannedIP mocks base method.\n+func (m *MockStorage) LoadBannedIP(ctx context.Context, remoteIP model.IP) ([]model.BannedIP, error) {\n \tm.ctrl.T.Helper()\n-\tret := m.ctrl.Call(m, \"LoadAuthenticationLogs\", ctx, username, fromDate, limit, page)\n-\tret0, _ := ret[0].([]model.AuthenticationAttempt)\n+\tret := m.ctrl.Call(m, \"LoadBannedIP\", ctx, remoteIP)\n+\tret0, _ := ret[0].([]model.BannedIP)\n \tret1, _ := ret[1].(error)\n \treturn ret0, ret1\n }\n \n-// LoadAuthenticationLogs indicates an expected call of LoadAuthenticationLogs.\n-func (mr *MockStorageMockRecorder) LoadAuthenticationLogs(ctx, username, fromDate, limit, page any) *gomock.Call {\n+// LoadBannedIP indicates an expected call of LoadBannedIP.\n+func (mr *MockStorageMockRecorder) LoadBannedIP(ctx, remoteIP any) *gomock.Call {\n \tmr.mock.ctrl.T.Helper()\n-\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"LoadAuthenticationLogs\", reflect.TypeOf((*MockStorage)(nil).LoadAuthenticationLogs), ctx, username, fromDate, limit, page)\n+\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"LoadBannedIP\", reflect.TypeOf((*MockStorage)(nil).LoadBannedIP), ctx, remoteIP)\n+}\n+\n+// LoadBannedIPByID mocks base method.\n+func (m *MockStorage) LoadBannedIPByID(ctx context.Context, id int) (model.BannedIP, error) {\n+\tm.ctrl.T.Helper()\n+\tret := m.ctrl.Call(m, \"LoadBannedIPByID\", ctx, id)\n+\tret0, _ := ret[0].(model.BannedIP)\n+\tret1, _ := ret[1].(error)\n+\treturn ret0, ret1\n+}\n+\n+// LoadBannedIPByID indicates an expected call of LoadBannedIPByID.\n+func (mr *MockStorageMockRecorder) LoadBannedIPByID(ctx, id any) *gomock.Call {\n+\tmr.mock.ctrl.T.Helper()\n+\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"LoadBannedIPByID\", reflect.TypeOf((*MockStorage)(nil).LoadBannedIPByID), ctx, id)\n+}\n+\n+// LoadBannedIPs mocks base method.\n+func (m *MockStorage) LoadBannedIPs(ctx context.Context, limit, page int) ([]model.BannedIP, error) {\n+\tm.ctrl.T.Helper()\n+\tret := m.ctrl.Call(m, \"LoadBannedIPs\", ctx, limit, page)\n+\tret0, _ := ret[0].([]model.BannedIP)\n+\tret1, _ := ret[1].(error)\n+\treturn ret0, ret1\n+}\n+\n+// LoadBannedIPs indicates an expected call of LoadBannedIPs.\n+func (mr *MockStorageMockRecorder) LoadBannedIPs(ctx, limit, page any) *gomock.Call {\n+\tmr.mock.ctrl.T.Helper()\n+\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"LoadBannedIPs\", reflect.TypeOf((*MockStorage)(nil).LoadBannedIPs), ctx, limit, page)\n+}\n+\n+// LoadBannedUser mocks base method.\n+func (m *MockStorage) LoadBannedUser(ctx context.Context, username string) ([]model.BannedUser, error) {\n+\tm.ctrl.T.Helper()\n+\tret := m.ctrl.Call(m, \"LoadBannedUser\", ctx, username)\n+\tret0, _ := ret[0].([]model.BannedUser)\n+\tret1, _ := ret[1].(error)\n+\treturn ret0, ret1\n+}\n+\n+// LoadBannedUser indicates an expected call of LoadBannedUser.\n+func (mr *MockStorageMockRecorder) LoadBannedUser(ctx, username any) *gomock.Call {\n+\tmr.mock.ctrl.T.Helper()\n+\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"LoadBannedUser\", reflect.TypeOf((*MockStorage)(nil).LoadBannedUser), ctx, username)\n+}\n+\n+// LoadBannedUserByID mocks base method.\n+func (m *MockStorage) LoadBannedUserByID(ctx context.Context, id int) (model.BannedUser, error) {\n+\tm.ctrl.T.Helper()\n+\tret := m.ctrl.Call(m, \"LoadBannedUserByID\", ctx, id)\n+\tret0, _ := ret[0].(model.BannedUser)\n+\tret1, _ := ret[1].(error)\n+\treturn ret0, ret1\n+}\n+\n+// LoadBannedUserByID indicates an expected call of LoadBannedUserByID.\n+func (mr *MockStorageMockRecorder) LoadBannedUserByID(ctx, id any) *gomock.Call {\n+\tmr.mock.ctrl.T.Helper()\n+\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"LoadBannedUserByID\", reflect.TypeOf((*MockStorage)(nil).LoadBannedUserByID), ctx, id)\n+}\n+\n+// LoadBannedUsers mocks base method.\n+func (m *MockStorage) LoadBannedUsers(ctx context.Context, limit, page int) ([]model.BannedUser, error) {\n+\tm.ctrl.T.Helper()\n+\tret := m.ctrl.Call(m, \"LoadBannedUsers\", ctx, limit, page)\n+\tret0, _ := ret[0].([]model.BannedUser)\n+\tret1, _ := ret[1].(error)\n+\treturn ret0, ret1\n+}\n+\n+// LoadBannedUsers indicates an expected call of LoadBannedUsers.\n+func (mr *MockStorageMockRecorder) LoadBannedUsers(ctx, limit, page any) *gomock.Call {\n+\tmr.mock.ctrl.T.Helper()\n+\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"LoadBannedUsers\", reflect.TypeOf((*MockStorage)(nil).LoadBannedUsers), ctx, limit, page)\n }\n \n // LoadCachedData mocks base method.\n@@ -512,6 +587,36 @@ func (mr *MockStorageMockRecorder) LoadPreferredDuoDevice(ctx, username any) *go\n \treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"LoadPreferredDuoDevice\", reflect.TypeOf((*MockStorage)(nil).LoadPreferredDuoDevice), ctx, username)\n }\n \n+// LoadRegulationRecordsByIP mocks base method.\n+func (m *MockStorage) LoadRegulationRecordsByIP(ctx context.Context, ip model.IP, since time.Time, limit int) ([]model.RegulationRecord, error) {\n+\tm.ctrl.T.Helper()\n+\tret := m.ctrl.Call(m, \"LoadRegulationRecordsByIP\", ctx, ip, since, limit)\n+\tret0, _ := ret[0].([]model.RegulationRecord)\n+\tret1, _ := ret[1].(error)\n+\treturn ret0, ret1\n+}\n+\n+// LoadRegulationRecordsByIP indicates an expected call of LoadRegulationRecordsByIP.\n+func (mr *MockStorageMockRecorder) LoadRegulationRecordsByIP(ctx, ip, since, limit any) *gomock.Call {\n+\tmr.mock.ctrl.T.Helper()\n+\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"LoadRegulationRecordsByIP\", reflect.TypeOf((*MockStorage)(nil).LoadRegulationRecordsByIP), ctx, ip, since, limit)\n+}\n+\n+// LoadRegulationRecordsByUser mocks base method.\n+func (m *MockStorage) LoadRegulationRecordsByUser(ctx context.Context, username string, since time.Time, limit int) ([]model.RegulationRecord, error) {\n+\tm.ctrl.T.Helper()\n+\tret := m.ctrl.Call(m, \"LoadRegulationRecordsByUser\", ctx, username, since, limit)\n+\tret0, _ := ret[0].([]model.RegulationRecord)\n+\tret1, _ := ret[1].(error)\n+\treturn ret0, ret1\n+}\n+\n+// LoadRegulationRecordsByUser indicates an expected call of LoadRegulationRecordsByUser.\n+func (mr *MockStorageMockRecorder) LoadRegulationRecordsByUser(ctx, username, since, limit any) *gomock.Call {\n+\tmr.mock.ctrl.T.Helper()\n+\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"LoadRegulationRecordsByUser\", reflect.TypeOf((*MockStorage)(nil).LoadRegulationRecordsByUser), ctx, username, since, limit)\n+}\n+\n // LoadTOTPConfiguration mocks base method.\n func (m *MockStorage) LoadTOTPConfiguration(ctx context.Context, username string) (*model.TOTPConfiguration, error) {\n \tm.ctrl.T.Helper()\n@@ -692,6 +797,34 @@ func (mr *MockStorageMockRecorder) LoadWebAuthnUserByUserID(ctx, rpid, userID an\n \treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"LoadWebAuthnUserByUserID\", reflect.TypeOf((*MockStorage)(nil).LoadWebAuthnUserByUserID), ctx, rpid, userID)\n }\n \n+// RevokeBannedIP mocks base method.\n+func (m *MockStorage) RevokeBannedIP(ctx context.Context, id int, expired time.Time) error {\n+\tm.ctrl.T.Helper()\n+\tret := m.ctrl.Call(m, \"RevokeBannedIP\", ctx, id, expired)\n+\tret0, _ := ret[0].(error)\n+\treturn ret0\n+}\n+\n+// RevokeBannedIP indicates an expected call of RevokeBannedIP.\n+func (mr *MockStorageMockRecorder) RevokeBannedIP(ctx, id, expired any) *gomock.Call {\n+\tmr.mock.ctrl.T.Helper()\n+\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"RevokeBannedIP\", reflect.TypeOf((*MockStorage)(nil).RevokeBannedIP), ctx, id, expired)\n+}\n+\n+// RevokeBannedUser mocks base method.\n+func (m *MockStorage) RevokeBannedUser(ctx context.Context, id int, expired time.Time) error {\n+\tm.ctrl.T.Helper()\n+\tret := m.ctrl.Call(m, \"RevokeBannedUser\", ctx, id, expired)\n+\tret0, _ := ret[0].(error)\n+\treturn ret0\n+}\n+\n+// RevokeBannedUser indicates an expected call of RevokeBannedUser.\n+func (mr *MockStorageMockRecorder) RevokeBannedUser(ctx, id, expired any) *gomock.Call {\n+\tmr.mock.ctrl.T.Helper()\n+\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"RevokeBannedUser\", reflect.TypeOf((*MockStorage)(nil).RevokeBannedUser), ctx, id, expired)\n+}\n+\n // RevokeIdentityVerification mocks base method.\n func (m *MockStorage) RevokeIdentityVerification(ctx context.Context, jti string, ip model.NullIP) error {\n \tm.ctrl.T.Helper()\n@@ -790,6 +923,34 @@ func (mr *MockStorageMockRecorder) SaveCachedData(ctx, data any) *gomock.Call {\n \treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SaveCachedData\", reflect.TypeOf((*MockStorage)(nil).SaveCachedData), ctx, data)\n }\n \n+// SaveBannedIP mocks base method.\n+func (m *MockStorage) SaveBannedIP(ctx context.Context, ban *model.BannedIP) error {\n+\tm.ctrl.T.Helper()\n+\tret := m.ctrl.Call(m, \"SaveBannedIP\", ctx, ban)\n+\tret0, _ := ret[0].(error)\n+\treturn ret0\n+}\n+\n+// SaveBannedIP indicates an expected call of SaveBannedIP.\n+func (mr *MockStorageMockRecorder) SaveBannedIP(ctx, ban any) *gomock.Call {\n+\tmr.mock.ctrl.T.Helper()\n+\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SaveBannedIP\", reflect.TypeOf((*MockStorage)(nil).SaveBannedIP), ctx, ban)\n+}\n+\n+// SaveBannedUser mocks base method.\n+func (m *MockStorage) SaveBannedUser(ctx context.Context, ban *model.BannedUser) error {\n+\tm.ctrl.T.Helper()\n+\tret := m.ctrl.Call(m, \"SaveBannedUser\", ctx, ban)\n+\tret0, _ := ret[0].(error)\n+\treturn ret0\n+}\n+\n+// SaveBannedUser indicates an expected call of SaveBannedUser.\n+func (mr *MockStorageMockRecorder) SaveBannedUser(ctx, ban any) *gomock.Call {\n+\tmr.mock.ctrl.T.Helper()\n+\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SaveBannedUser\", reflect.TypeOf((*MockStorage)(nil).SaveBannedUser), ctx, ban)\n+}\n+\n // SaveIdentityVerification mocks base method.\n func (m *MockStorage) SaveIdentityVerification(ctx context.Context, verification model.IdentityVerification) error {\n \tm.ctrl.T.Helper()\ndiff --git a/internal/model/authentication_attempt.go b/internal/model/authentication_attempt.go\ndeleted file mode 100644\nindex 6c5f84db957bb..0000000000000\n--- a/internal/model/authentication_attempt.go\n+++ /dev/null\n@@ -1,18 +0,0 @@\n-package model\n-\n-import (\n-\t\"time\"\n-)\n-\n-// AuthenticationAttempt represents an authentication attempt row in the database.\n-type AuthenticationAttempt struct {\n-\tID            int       `db:\"id\"`\n-\tTime          time.Time `db:\"time\"`\n-\tSuccessful    bool      `db:\"successful\"`\n-\tBanned        bool      `db:\"banned\"`\n-\tUsername      string    `db:\"username\"`\n-\tType          string    `db:\"auth_type\"`\n-\tRemoteIP      NullIP    `db:\"remote_ip\"`\n-\tRequestURI    string    `db:\"request_uri\"`\n-\tRequestMethod string    `db:\"request_method\"`\n-}\ndiff --git a/internal/model/regulation.go b/internal/model/regulation.go\nnew file mode 100644\nindex 0000000000000..1741ec1ee1f39\n--- /dev/null\n+++ b/internal/model/regulation.go\n@@ -0,0 +1,46 @@\n+package model\n+\n+import (\n+\t\"database/sql\"\n+\t\"time\"\n+)\n+\n+// AuthenticationAttempt represents an authentication attempt row in the database.\n+type AuthenticationAttempt struct {\n+\tID            int       `db:\"id\"`\n+\tTime          time.Time `db:\"time\"`\n+\tSuccessful    bool      `db:\"successful\"`\n+\tBanned        bool      `db:\"banned\"`\n+\tUsername      string    `db:\"username\"`\n+\tType          string    `db:\"auth_type\"`\n+\tRemoteIP      NullIP    `db:\"remote_ip\"`\n+\tRequestURI    string    `db:\"request_uri\"`\n+\tRequestMethod string    `db:\"request_method\"`\n+}\n+\n+type RegulationRecord struct {\n+\tTime       time.Time `db:\"time\"`\n+\tSuccessful bool      `db:\"successful\"`\n+}\n+\n+type BannedUser struct {\n+\tID       int            `db:\"id\"`\n+\tTime     time.Time      `db:\"time\"`\n+\tExpires  sql.NullTime   `db:\"expires\"`\n+\tExpired  sql.NullTime   `db:\"expired\"`\n+\tRevoked  bool           `db:\"revoked\"`\n+\tUsername string         `db:\"username\"`\n+\tSource   string         `db:\"source\"`\n+\tReason   sql.NullString `db:\"reason\"`\n+}\n+\n+type BannedIP struct {\n+\tID      int            `db:\"id\"`\n+\tTime    time.Time      `db:\"time\"`\n+\tExpires sql.NullTime   `db:\"expires\"`\n+\tExpired sql.NullTime   `db:\"expired\"`\n+\tRevoked bool           `db:\"revoked\"`\n+\tIP      IP             `db:\"ip\"`\n+\tSource  string         `db:\"source\"`\n+\tReason  sql.NullString `db:\"reason\"`\n+}\ndiff --git a/internal/model/types.go b/internal/model/types.go\nindex 30b306a496111..caed90500e1f6 100644\n--- a/internal/model/types.go\n+++ b/internal/model/types.go\n@@ -42,6 +42,10 @@ type IP struct {\n \tIP net.IP\n }\n \n+func (ip IP) String() string {\n+\treturn ip.IP.String()\n+}\n+\n // Value is the IP implementation of the databases/sql driver.Valuer.\n func (ip IP) Value() (value driver.Value, err error) {\n \tif ip.IP == nil {\n@@ -78,6 +82,14 @@ type NullIP struct {\n \tIP net.IP\n }\n \n+func (ip NullIP) String() string {\n+\tif ip.IP == nil {\n+\t\treturn \"nil\"\n+\t}\n+\n+\treturn ip.IP.String()\n+}\n+\n // Value is the NullIP implementation of the databases/sql driver.Valuer.\n func (ip NullIP) Value() (value driver.Value, err error) {\n \tif ip.IP == nil {\ndiff --git a/internal/oidc/config.go b/internal/oidc/config.go\nindex 619b0cd076e4f..7434df15bf307 100644\n--- a/internal/oidc/config.go\n+++ b/internal/oidc/config.go\n@@ -341,7 +341,7 @@ func (c *Config) LoadHandlers(store *Store) {\n \t\t\tConfig:  c,\n \t\t},\n \n-\t\t// Response Mode Handling.\n+\t\t// Response Modes Handling.\n \t\t&oauthelia2.DefaultResponseModeHandler{\n \t\t\tConfig: c,\n \t\t},\ndiff --git a/internal/oidc/const.go b/internal/oidc/const.go\nindex 2cf81bebd4963..f30bfbabcdf61 100644\n--- a/internal/oidc/const.go\n+++ b/internal/oidc/const.go\n@@ -91,7 +91,7 @@ const (\n \tClaimEmailAlts = \"alt_emails\"\n )\n \n-// Response Mode strings.\n+// Response Modes strings.\n const (\n \tResponseModeFormPost    = \"form_post\"\n \tResponseModeQuery       = \"query\"\ndiff --git a/internal/oidc/types.go b/internal/oidc/types.go\nindex 987b62b5287ee..c2aeab0c11a8d 100644\n--- a/internal/oidc/types.go\n+++ b/internal/oidc/types.go\n@@ -916,7 +916,7 @@ type OpenIDConnectClientInitiatedBackChannelAuthFlowDiscoveryOptions struct {\n }\n \n // OpenIDConnectJWTSecuredAuthorizationResponseModeDiscoveryOptions represents the discovery options specific to\n-// JWT Secured Authorization Response Mode for OAuth 2.0 (JARM).\n+// JWT Secured Authorization Response Modes for OAuth 2.0 (JARM).\n //\n // Authorization servers SHOULD publish the supported algorithms for signing and encrypting the JWT of an authorization\n // response by utilizing OAuth 2.0 Authorization Server Metadata [RFC8414] parameters. The following parameters are\n@@ -924,7 +924,7 @@ type OpenIDConnectClientInitiatedBackChannelAuthFlowDiscoveryOptions struct {\n //\n // See Also:\n //\n-// JWT Secured Authorization Response Mode for OAuth 2.0 (JARM):\n+// JWT Secured Authorization Response Modes for OAuth 2.0 (JARM):\n // https://openid.net/specs/oauth-v2-jarm.html#name-authorization-server-metada\n type OpenIDConnectJWTSecuredAuthorizationResponseModeDiscoveryOptions struct {\n \t/*\ndiff --git a/internal/regulation/const.go b/internal/regulation/const.go\nindex 8082d604d3a3e..9863d5995bc4f 100644\n--- a/internal/regulation/const.go\n+++ b/internal/regulation/const.go\n@@ -24,3 +24,11 @@ const (\n \t// AuthTypePassword is the string representing an auth log for second-factor authentication via a Password.\n \tAuthTypePassword = \"Password\"\n )\n+\n+const (\n+\ttypeUser        = \"user\"\n+\ttypeIP          = \"ip\"\n+\tfieldBanType    = \"ban_type\"\n+\tfieldUsername   = \"username\"\n+\tfieldRecordType = \"record_type\"\n+)\ndiff --git a/internal/regulation/regulator.go b/internal/regulation/regulator.go\nindex e1c35062149da..0b1c00d54481b 100644\n--- a/internal/regulation/regulator.go\n+++ b/internal/regulation/regulator.go\n@@ -1,7 +1,7 @@\n package regulation\n \n import (\n-\t\"context\"\n+\t\"database/sql\"\n \t\"strings\"\n \t\"time\"\n \n@@ -9,24 +9,24 @@ import (\n \t\"github.com/authelia/authelia/v4/internal/configuration/schema\"\n \t\"github.com/authelia/authelia/v4/internal/model\"\n \t\"github.com/authelia/authelia/v4/internal/storage\"\n+\t\"github.com/authelia/authelia/v4/internal/utils\"\n )\n \n // NewRegulator create a regulator instance.\n func NewRegulator(config schema.Regulation, store storage.RegulatorProvider, clock clock.Provider) *Regulator {\n \treturn &Regulator{\n-\t\tenabled: config.MaxRetries > 0,\n-\t\tstore:   store,\n-\t\tclock:   clock,\n-\t\tconfig:  config,\n+\t\tusers:  config.MaxRetries > 0 && utils.IsStringInSlice(typeUser, config.Modes),\n+\t\tips:    config.MaxRetries > 0 && utils.IsStringInSlice(typeIP, config.Modes),\n+\t\tstore:  store,\n+\t\tclock:  clock,\n+\t\tconfig: config,\n \t}\n }\n \n-// Mark an authentication attempt.\n-// We split Mark and Regulate in order to avoid timing attacks.\n-func (r *Regulator) Mark(ctx Context, successful, banned bool, username, requestURI, requestMethod, authType string) error {\n+func (r *Regulator) HandleAttempt(ctx Context, successful, banned bool, username, requestURI, requestMethod, authType string) {\n \tctx.RecordAuthn(successful, banned, strings.ToLower(authType))\n \n-\treturn r.store.AppendAuthenticationLog(ctx, model.AuthenticationAttempt{\n+\tattempt := model.AuthenticationAttempt{\n \t\tTime:          r.clock.Now(),\n \t\tSuccessful:    successful,\n \t\tBanned:        banned,\n@@ -35,49 +35,160 @@ func (r *Regulator) Mark(ctx Context, successful, banned bool, username, request\n \t\tRemoteIP:      model.NewNullIP(ctx.RemoteIP()),\n \t\tRequestURI:    requestURI,\n \t\tRequestMethod: requestMethod,\n-\t})\n+\t}\n+\n+\tvar err error\n+\n+\tif err = r.store.AppendAuthenticationLog(ctx, attempt); err != nil {\n+\t\tctx.GetLogger().WithFields(map[string]any{fieldUsername: username, \"successful\": successful}).WithError(err).Errorf(\"Failed to record %s authentication attempt\", authType)\n+\t}\n+\n+\t// We only need to perform the ban checks when; the attempt is unsuccessful, there is not an effective ban in place,\n+\t// regulation is enabled, and the authentication type is 1FA. Thus if this is not the case we can return here.\n+\tif successful || banned || (!r.ips && !r.users) || authType != AuthType1FA {\n+\t\treturn\n+\t}\n+\n+\tsince := r.clock.Now().Add(-r.config.FindTime)\n+\n+\tr.handleAttemptPossibleBannedIP(ctx, since)\n+\tr.handleAttemptPossibleBannedUser(ctx, since, username)\n+}\n+\n+func (r *Regulator) handleAttemptPossibleBannedIP(ctx Context, since time.Time) {\n+\tif !r.ips {\n+\t\treturn\n+\t}\n+\n+\tvar (\n+\t\trecords []model.RegulationRecord\n+\t\terr     error\n+\t)\n+\n+\tip := model.NewIP(ctx.RemoteIP())\n+\n+\tlog := ctx.GetLogger()\n+\n+\tif records, err = r.store.LoadRegulationRecordsByIP(ctx, ip, since, r.config.MaxRetries); err != nil {\n+\t\tlog.WithFields(map[string]any{fieldRecordType: typeIP}).WithError(err).Error(\"Failed to load regulation records\")\n+\n+\t\treturn\n+\t}\n+\n+\tbanexp := r.expires(since, records)\n+\n+\tif banexp == nil {\n+\t\treturn\n+\t}\n+\n+\tsqlban := &model.BannedIP{\n+\t\tExpires: sql.NullTime{Valid: true, Time: *banexp},\n+\t\tIP:      ip,\n+\t\tSource:  \"regulation\",\n+\t\tReason:  sql.NullString{Valid: true, String: \"Exceeding Maximum Retries\"},\n+\t}\n+\n+\tif err = r.store.SaveBannedIP(ctx, sqlban); err != nil {\n+\t\tlog.WithFields(map[string]any{fieldBanType: typeIP}).WithError(err).Error(\"Failed to save ban\")\n+\n+\t\treturn\n+\t}\n+}\n+\n+func (r *Regulator) handleAttemptPossibleBannedUser(ctx Context, since time.Time, username string) {\n+\tif !r.users {\n+\t\treturn\n+\t}\n+\n+\tvar (\n+\t\trecords []model.RegulationRecord\n+\t\terr     error\n+\t)\n+\n+\tlog := ctx.GetLogger()\n+\n+\tif records, err = r.store.LoadRegulationRecordsByUser(ctx, username, since, r.config.MaxRetries); err != nil {\n+\t\tlog.WithFields(map[string]any{fieldRecordType: typeUser, fieldUsername: username}).WithError(err).Error(\"Failed to load regulation records\")\n+\n+\t\treturn\n+\t}\n+\n+\tbanexp := r.expires(since, records)\n+\n+\tif banexp == nil {\n+\t\treturn\n+\t}\n+\n+\tsqlban := &model.BannedUser{\n+\t\tExpires:  sql.NullTime{Valid: true, Time: *banexp},\n+\t\tUsername: username,\n+\t\tSource:   \"regulation\",\n+\t\tReason:   sql.NullString{Valid: true, String: \"Exceeding Maximum Retries\"},\n+\t}\n+\n+\tif err = r.store.SaveBannedUser(ctx, sqlban); err != nil {\n+\t\tlog.WithFields(map[string]any{fieldBanType: typeUser, fieldUsername: username}).WithError(err).Error(\"Failed to save ban\")\n+\n+\t\treturn\n+\t}\n }\n \n-// Regulate the authentication attempts for a given user.\n-// This method returns ErrUserIsBanned if the user is banned along with the time until when the user is banned.\n-func (r *Regulator) Regulate(ctx context.Context, username string) (time.Time, error) {\n-\t// If there is regulation configuration, no regulation applies.\n-\tif !r.enabled {\n-\t\treturn time.Time{}, nil\n+func (r *Regulator) BanCheck(ctx Context, username string) (ban BanType, value string, expires *time.Time, err error) {\n+\tip := model.NewIP(ctx.RemoteIP())\n+\n+\tvar bansIP []model.BannedIP\n+\n+\tif bansIP, err = r.store.LoadBannedIP(ctx, ip); err != nil {\n+\t\treturn BanTypeNone, \"\", nil, err\n \t}\n \n-\tattempts, err := r.store.LoadAuthenticationLogs(ctx, username, r.clock.Now().Add(-r.config.BanTime), 10, 0)\n-\tif err != nil {\n-\t\treturn time.Time{}, nil\n+\tif len(bansIP) != 0 {\n+\t\tb := bansIP[0]\n+\n+\t\treturn returnBanResult(BanTypeIP, ip.String(), b.Expires)\n \t}\n \n-\tlatestFailedAttempts := make([]model.AuthenticationAttempt, 0, r.config.MaxRetries)\n+\tvar bansUser []model.BannedUser\n \n-\tfor _, attempt := range attempts {\n-\t\tif attempt.Successful || len(latestFailedAttempts) >= r.config.MaxRetries {\n+\tif bansUser, err = r.store.LoadBannedUser(ctx, username); err != nil {\n+\t\treturn BanTypeNone, \"\", nil, err\n+\t}\n+\n+\tif len(bansUser) != 0 {\n+\t\tb := bansUser[0]\n+\n+\t\treturn returnBanResult(BanTypeUser, username, b.Expires)\n+\t}\n+\n+\treturn BanTypeNone, \"\", nil, nil\n+}\n+\n+func (r *Regulator) expires(since time.Time, records []model.RegulationRecord) *time.Time {\n+\tfailures := make([]model.RegulationRecord, 0, len(records))\n+\n+loop:\n+\tfor _, record := range records {\n+\t\tswitch {\n+\t\tcase record.Successful:\n+\t\t\tbreak loop\n+\t\tcase len(failures) >= r.config.MaxRetries:\n+\t\t\tcontinue\n+\t\tcase record.Time.Before(since):\n+\t\t\tcontinue\n+\t\tdefault:\n \t\t\t// We stop appending failed attempts once we find the first successful attempts or we reach\n \t\t\t// the configured number of retries, meaning the user is already banned.\n-\t\t\tbreak\n-\t\t} else {\n-\t\t\tlatestFailedAttempts = append(latestFailedAttempts, attempt)\n+\t\t\tfailures = append(failures, record)\n \t\t}\n \t}\n \n \t// If the number of failed attempts within the ban time is less than the max number of retries\n \t// then the user is not banned.\n-\tif len(latestFailedAttempts) < r.config.MaxRetries {\n-\t\treturn time.Time{}, nil\n+\tif len(failures) < r.config.MaxRetries {\n+\t\treturn nil\n \t}\n \n-\t// Now we compute the time between the latest attempt and the MaxRetry-th one. If it's\n-\t// within the FindTime then it means that the user has been banned.\n-\tdurationBetweenLatestAttempts := latestFailedAttempts[0].Time.Sub(\n-\t\tlatestFailedAttempts[r.config.MaxRetries-1].Time)\n-\n-\tif durationBetweenLatestAttempts < r.config.FindTime {\n-\t\tbannedUntil := latestFailedAttempts[0].Time.Add(r.config.BanTime)\n-\t\treturn bannedUntil, ErrUserIsBanned\n-\t}\n+\texpires := failures[0].Time.Add(r.config.BanTime)\n \n-\treturn time.Time{}, nil\n+\treturn &expires\n }\ndiff --git a/internal/regulation/types.go b/internal/regulation/types.go\nindex e765c9e690095..988668fccb4ba 100644\n--- a/internal/regulation/types.go\n+++ b/internal/regulation/types.go\n@@ -3,6 +3,9 @@ package regulation\n import (\n \t\"context\"\n \t\"net\"\n+\t\"time\"\n+\n+\t\"github.com/sirupsen/logrus\"\n \n \t\"github.com/authelia/authelia/v4/internal/clock\"\n \t\"github.com/authelia/authelia/v4/internal/configuration/schema\"\n@@ -11,8 +14,8 @@ import (\n \n // Regulator an authentication regulator preventing attackers to brute force the service.\n type Regulator struct {\n-\t// Is the regulation enabled.\n-\tenabled bool\n+\tusers bool\n+\tips   bool\n \n \tconfig schema.Regulation\n \n@@ -26,6 +29,7 @@ type Context interface {\n \tcontext.Context\n \tMetricsRecorder\n \n+\tGetLogger() *logrus.Entry\n \tRemoteIP() (ip net.IP)\n }\n \n@@ -33,3 +37,62 @@ type Context interface {\n type MetricsRecorder interface {\n \tRecordAuthn(success, banned bool, authType string)\n }\n+\n+// NewBan constructs a friendly version of ban information for easy formatting.\n+func NewBan(ban BanType, value string, expires *time.Time) *Ban {\n+\treturn &Ban{\n+\t\tban:     ban,\n+\t\tvalue:   value,\n+\t\texpires: expires,\n+\t}\n+}\n+\n+type Ban struct {\n+\tban     BanType\n+\tvalue   string\n+\texpires *time.Time\n+}\n+\n+func (b *Ban) IsBanned() bool {\n+\treturn b.Type() != BanTypeNone\n+}\n+\n+func (b *Ban) Value() string {\n+\tif b == nil {\n+\t\treturn \"\"\n+\t}\n+\n+\treturn b.value\n+}\n+\n+func (b *Ban) Type() BanType {\n+\tif b == nil {\n+\t\treturn BanTypeNone\n+\t}\n+\n+\treturn b.ban\n+}\n+\n+func (b *Ban) Expires() *time.Time {\n+\tif b == nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn b.expires\n+}\n+\n+func (b *Ban) FormatExpires() string {\n+\tif b == nil || b.expires == nil {\n+\t\tFormatExpiresLong(nil)\n+\t}\n+\n+\treturn FormatExpiresLong(b.expires)\n+}\n+\n+type BanType int\n+\n+const (\n+\tBanTypeNone BanType = iota\n+\tBanTypeIP\n+\tBanTypeUser\n+)\ndiff --git a/internal/regulation/util.go b/internal/regulation/util.go\nnew file mode 100644\nindex 0000000000000..c82e89c314db8\n--- /dev/null\n+++ b/internal/regulation/util.go\n@@ -0,0 +1,30 @@\n+package regulation\n+\n+import (\n+\t\"database/sql\"\n+\t\"time\"\n+)\n+\n+func returnBanResult(b BanType, v string, t sql.NullTime) (ban BanType, value string, expires *time.Time, err error) {\n+\tif t.Valid {\n+\t\texpires = &t.Time\n+\t}\n+\n+\treturn b, v, expires, ErrUserIsBanned\n+}\n+\n+func FormatExpiresLong(expires *time.Time) string {\n+\tif expires == nil {\n+\t\treturn \"never expires\"\n+\t}\n+\n+\treturn expires.Format(\"expires at 3:04:05PM on January 2 2006 (-07:00)\")\n+}\n+\n+func FormatExpiresShort(expires sql.NullTime) string {\n+\tif !expires.Valid {\n+\t\treturn \"never\"\n+\t}\n+\n+\treturn expires.Time.Format(time.DateTime)\n+}\ndiff --git a/internal/storage/const.go b/internal/storage/const.go\nindex 75d96dea50722..acd34b26fd869 100644\n--- a/internal/storage/const.go\n+++ b/internal/storage/const.go\n@@ -6,6 +6,8 @@ import (\n \n const (\n \ttableAuthenticationLogs   = \"authentication_logs\"\n+\ttableBannedUser           = \"banned_user\"\n+\ttableBannedIP             = \"banned_ip\"\n \ttableCachedData           = \"cached_data\"\n \ttableDuoDevices           = \"duo_devices\"\n \ttableIdentityVerification = \"identity_verification\"\ndiff --git a/internal/storage/errors.go b/internal/storage/errors.go\nindex 72f1be7975d04..ca18a3840f7c5 100644\n--- a/internal/storage/errors.go\n+++ b/internal/storage/errors.go\n@@ -8,6 +8,9 @@ var (\n \t// ErrNoAuthenticationLogs error thrown when no matching authentication logs have been found in DB.\n \tErrNoAuthenticationLogs = errors.New(\"no matching authentication logs found\")\n \n+\t// ErrNoCurrentBans is an error which indicates no bans were found.\n+\tErrNoCurrentBans = errors.New(\"no current bans found\")\n+\n \t// ErrNoTOTPConfiguration error thrown when no TOTP configuration has been found in DB.\n \tErrNoTOTPConfiguration = errors.New(\"no TOTP configuration for user\")\n \ndiff --git a/internal/storage/migrations/mysql/V0020.Regulation.down.sql b/internal/storage/migrations/mysql/V0020.Regulation.down.sql\nnew file mode 100644\nindex 0000000000000..86db3f933b020\n--- /dev/null\n+++ b/internal/storage/migrations/mysql/V0020.Regulation.down.sql\n@@ -0,0 +1,2 @@\n+DROP TABLE IF EXISTS banned_user;\n+DROP TABLE IF EXISTS banned_ip;\ndiff --git a/internal/storage/migrations/mysql/V0020.Regulation.up.sql b/internal/storage/migrations/mysql/V0020.Regulation.up.sql\nnew file mode 100644\nindex 0000000000000..5c178e882befe\n--- /dev/null\n+++ b/internal/storage/migrations/mysql/V0020.Regulation.up.sql\n@@ -0,0 +1,29 @@\n+CREATE TABLE IF NOT EXISTS banned_user (\n+    id INTEGER NOT NULL PRIMARY KEY AUTO_INCREMENT,\n+    time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n+    expires TIMESTAMP NULL DEFAULT NULL,\n+    expired TIMESTAMP NULL DEFAULT NULL,\n+    revoked BOOLEAN NOT NULL DEFAULT FALSE,\n+    username VARCHAR(100) NOT NULL,\n+    source VARCHAR(10) NOT NULL,\n+    reason VARCHAR(100) NULL DEFAULT NULL\n+) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;\n+\n+CREATE INDEX banned_user_username_idx ON banned_user (username);\n+CREATE INDEX banned_user_lookup_idx ON banned_user (username, revoked, expires, expired);\n+CREATE INDEX banned_user_list_idx ON banned_user (revoked, expires, expired);\n+\n+CREATE TABLE IF NOT EXISTS banned_ip (\n+    id INTEGER NOT NULL PRIMARY KEY AUTO_INCREMENT,\n+    time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n+    expires TIMESTAMP NULL DEFAULT NULL,\n+    expired TIMESTAMP NULL DEFAULT NULL,\n+    revoked BOOLEAN NOT NULL DEFAULT FALSE,\n+    ip VARCHAR(39) NOT NULL,\n+    source VARCHAR(10) NOT NULL,\n+    reason VARCHAR(100) NULL DEFAULT NULL\n+) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;\n+\n+CREATE INDEX banned_ip_ip_idx ON banned_ip (ip);\n+CREATE INDEX banned_ip_lookup_idx ON banned_ip (ip, revoked, expires, expired);\n+CREATE INDEX banned_ip_list_idx ON banned_ip (revoked, expires, expired);\ndiff --git a/internal/storage/migrations/postgres/V0020.Regulation.down.sql b/internal/storage/migrations/postgres/V0020.Regulation.down.sql\nnew file mode 100644\nindex 0000000000000..86db3f933b020\n--- /dev/null\n+++ b/internal/storage/migrations/postgres/V0020.Regulation.down.sql\n@@ -0,0 +1,2 @@\n+DROP TABLE IF EXISTS banned_user;\n+DROP TABLE IF EXISTS banned_ip;\ndiff --git a/internal/storage/migrations/postgres/V0020.Regulation.up.sql b/internal/storage/migrations/postgres/V0020.Regulation.up.sql\nnew file mode 100644\nindex 0000000000000..f6b79e19f8d36\n--- /dev/null\n+++ b/internal/storage/migrations/postgres/V0020.Regulation.up.sql\n@@ -0,0 +1,29 @@\n+CREATE TABLE IF NOT EXISTS banned_user (\n+    id SERIAL CONSTRAINT banned_user_pkey PRIMARY KEY,\n+    time TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,\n+    expires TIMESTAMP WITH TIME ZONE NULL DEFAULT NULL,\n+    expired TIMESTAMP WITH TIME ZONE NULL DEFAULT NULL,\n+    revoked BOOLEAN NOT NULL DEFAULT FALSE,\n+    username VARCHAR(100) NOT NULL,\n+    source VARCHAR(10) NOT NULL,\n+    reason VARCHAR(100) NULL DEFAULT NULL\n+);\n+\n+CREATE INDEX banned_user_username_idx ON banned_user (username);\n+CREATE INDEX banned_user_lookup_idx ON banned_user (username, revoked, expires, expired);\n+CREATE INDEX banned_user_list_idx ON banned_user (revoked, expires, expired);\n+\n+CREATE TABLE IF NOT EXISTS banned_ip (\n+    id SERIAL CONSTRAINT banned_ip_pkey PRIMARY KEY,\n+    time TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,\n+    expires TIMESTAMP WITH TIME ZONE NULL DEFAULT NULL,\n+    expired TIMESTAMP WITH TIME ZONE NULL DEFAULT NULL,\n+    revoked BOOLEAN NOT NULL DEFAULT FALSE,\n+    ip VARCHAR(39) NOT NULL,\n+    source VARCHAR(10) NOT NULL,\n+    reason VARCHAR(100) NULL DEFAULT NULL\n+);\n+\n+CREATE INDEX banned_ip_ip_idx ON banned_ip (ip);\n+CREATE INDEX banned_ip_lookup_idx ON banned_ip (ip, revoked, expires, expired);\n+CREATE INDEX banned_ip_list_idx ON banned_ip (revoked, expires, expired);\ndiff --git a/internal/storage/migrations/sqlite/V0020.Regulation.down.sql b/internal/storage/migrations/sqlite/V0020.Regulation.down.sql\nnew file mode 100644\nindex 0000000000000..86db3f933b020\n--- /dev/null\n+++ b/internal/storage/migrations/sqlite/V0020.Regulation.down.sql\n@@ -0,0 +1,2 @@\n+DROP TABLE IF EXISTS banned_user;\n+DROP TABLE IF EXISTS banned_ip;\ndiff --git a/internal/storage/migrations/sqlite/V0020.Regulation.up.sql b/internal/storage/migrations/sqlite/V0020.Regulation.up.sql\nnew file mode 100644\nindex 0000000000000..a4ec9de0c72a3\n--- /dev/null\n+++ b/internal/storage/migrations/sqlite/V0020.Regulation.up.sql\n@@ -0,0 +1,29 @@\n+CREATE TABLE IF NOT EXISTS banned_user (\n+    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n+    time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n+    expires TIMESTAMP NULL DEFAULT NULL,\n+    expired TIMESTAMP NULL DEFAULT NULL,\n+    revoked BOOLEAN NOT NULL DEFAULT FALSE,\n+    username VARCHAR(100) NOT NULL,\n+    source VARCHAR(10) NOT NULL,\n+    reason VARCHAR(100) NULL DEFAULT NULL\n+);\n+\n+CREATE INDEX banned_user_username_idx ON banned_user (username);\n+CREATE INDEX banned_user_lookup_idx ON banned_user (username, revoked, expires, expired);\n+CREATE INDEX banned_user_list_idx ON banned_user (revoked, expires, expired);\n+\n+CREATE TABLE IF NOT EXISTS banned_ip (\n+    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n+    time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n+    expires TIMESTAMP NULL DEFAULT NULL,\n+    expired TIMESTAMP NULL DEFAULT NULL,\n+    revoked BOOLEAN NOT NULL DEFAULT FALSE,\n+    ip VARCHAR(39) NOT NULL,\n+    source VARCHAR(10) NOT NULL,\n+    reason VARCHAR(100) NULL DEFAULT NULL\n+);\n+\n+CREATE INDEX banned_ip_ip_idx ON banned_ip (ip);\n+CREATE INDEX banned_ip_lookup_idx ON banned_ip (ip, revoked, expires, expired);\n+CREATE INDEX banned_ip_list_idx ON banned_ip (revoked, expires, expired);\ndiff --git a/internal/storage/provider.go b/internal/storage/provider.go\nindex 294433a7e0b18..a0e778255c517 100644\n--- a/internal/storage/provider.go\n+++ b/internal/storage/provider.go\n@@ -343,6 +343,41 @@ type RegulatorProvider interface {\n \t// AppendAuthenticationLog saves an authentication attempt to the storage provider.\n \tAppendAuthenticationLog(ctx context.Context, attempt model.AuthenticationAttempt) (err error)\n \n-\t// LoadAuthenticationLogs loads authentication attempts from the storage provider (paginated).\n-\tLoadAuthenticationLogs(ctx context.Context, username string, fromDate time.Time, limit, page int) (attempts []model.AuthenticationAttempt, err error)\n+\t// LoadRegulationRecordsByUser loads authentication logs for a given username for the purpose of regulation. As such\n+\t// compared to standard authentication logs the amount of available data is very low.\n+\tLoadRegulationRecordsByUser(ctx context.Context, username string, since time.Time, limit int) (records []model.RegulationRecord, err error)\n+\n+\t// SaveBannedUser saves a banned user to the database.\n+\tSaveBannedUser(ctx context.Context, ban *model.BannedUser) (err error)\n+\n+\t// LoadBannedUser loads banned users from the database given a username.\n+\tLoadBannedUser(ctx context.Context, username string) (bans []model.BannedUser, err error)\n+\n+\t// LoadBannedUserByID loads a banned user record given an id.\n+\tLoadBannedUserByID(ctx context.Context, id int) (ban model.BannedUser, err error)\n+\n+\t// LoadBannedUsers loads pages of banned users from the database.\n+\tLoadBannedUsers(ctx context.Context, limit, page int) (bans []model.BannedUser, err error)\n+\n+\t// RevokeBannedUser revokes a user ban in the database.\n+\tRevokeBannedUser(ctx context.Context, id int, expired time.Time) (err error)\n+\n+\t// LoadRegulationRecordsByIP loads authentication logs for a given ip for the purpose of regulation. As such\n+\t// compared to standard authentication logs the amount of available data is very low.\n+\tLoadRegulationRecordsByIP(ctx context.Context, ip model.IP, since time.Time, limit int) (records []model.RegulationRecord, err error)\n+\n+\t// SaveBannedIP saves a banned ip to the database.\n+\tSaveBannedIP(ctx context.Context, ban *model.BannedIP) (err error)\n+\n+\t// LoadBannedIP loads banned ip's from the database given an ip.\n+\tLoadBannedIP(ctx context.Context, remoteIP model.IP) (bans []model.BannedIP, err error)\n+\n+\t// LoadBannedIPByID loads a banned ip record given an id.\n+\tLoadBannedIPByID(ctx context.Context, id int) (ban model.BannedIP, err error)\n+\n+\t// LoadBannedIPs loads pages of banned ip's from the database.\n+\tLoadBannedIPs(ctx context.Context, limit, page int) (bans []model.BannedIP, err error)\n+\n+\t// RevokeBannedIP revokes an ip ban in the database.\n+\tRevokeBannedIP(ctx context.Context, id int, expired time.Time) (err error)\n }\ndiff --git a/internal/storage/sql_provider.go b/internal/storage/sql_provider.go\nindex c3659f7f0e510..d738cd80c2b28 100644\n--- a/internal/storage/sql_provider.go\n+++ b/internal/storage/sql_provider.go\n@@ -36,8 +36,23 @@ func NewSQLProvider(config *schema.Configuration, name, driverName, dataSourceNa\n \n \t\tlog: logging.Logger(),\n \n-\t\tsqlInsertAuthenticationAttempt:            fmt.Sprintf(queryFmtInsertAuthenticationLogEntry, tableAuthenticationLogs),\n-\t\tsqlSelectAuthenticationAttemptsByUsername: fmt.Sprintf(queryFmtSelect1FAAuthenticationLogEntryByUsername, tableAuthenticationLogs),\n+\t\tsqlInsertAuthenticationAttempt:                         fmt.Sprintf(queryFmtInsertAuthenticationLogEntry, tableAuthenticationLogs),\n+\t\tsqlSelectAuthenticationLogsRegulationRecordsByUsername: fmt.Sprintf(queryFmtSelectAuthenticationLogsRegulationRecordsByUsername, tableAuthenticationLogs),\n+\t\tsqlSelectAuthenticationLogsRegulationRecordsByRemoteIP: fmt.Sprintf(queryFmtSelectAuthenticationLogsRegulationRecordsByRemoteIP, tableAuthenticationLogs),\n+\n+\t\tsqlInsertBannedUser:         fmt.Sprintf(queryFmtInsertBannedUser, tableBannedUser),\n+\t\tsqlSelectBannedUser:         fmt.Sprintf(queryFmtSelectBannedUser, tableBannedUser),\n+\t\tsqlSelectBannedUserByID:     fmt.Sprintf(queryFmtSelectBannedUserByID, tableBannedUser),\n+\t\tsqlSelectBannedUsers:        fmt.Sprintf(queryFmtSelectBannedUsers, tableBannedUser),\n+\t\tsqlSelectBannedUserLastTime: fmt.Sprintf(queryFmtSelectBannedUserLastExpires, tableBannedUser),\n+\t\tsqlRevokeBannedUser:         fmt.Sprintf(queryFmtRevokeBannedEntry, tableBannedUser),\n+\n+\t\tsqlInsertBannedIP:         fmt.Sprintf(queryFmtInsertBannedIP, tableBannedIP),\n+\t\tsqlSelectBannedIP:         fmt.Sprintf(queryFmtSelectBannedIP, tableBannedIP),\n+\t\tsqlSelectBannedIPByID:     fmt.Sprintf(queryFmtSelectBannedIPByID, tableBannedIP),\n+\t\tsqlSelectBannedIPs:        fmt.Sprintf(queryFmtSelectBannedIPs, tableBannedIP),\n+\t\tsqlSelectBannedIPLastTime: fmt.Sprintf(queryFmtSelectBannedIPLastExpires, tableBannedIP),\n+\t\tsqlRevokeBannedIP:         fmt.Sprintf(queryFmtRevokeBannedEntry, tableBannedIP),\n \n \t\tsqlUpsertCachedData: fmt.Sprintf(queryFmtUpsertCachedData, tableCachedData),\n \t\tsqlSelectCachedData: fmt.Sprintf(queryFmtSelectCachedData, tableCachedData),\n@@ -181,8 +196,25 @@ type SQLProvider struct {\n \tlog *logrus.Logger\n \n \t// Table: authentication_logs.\n-\tsqlInsertAuthenticationAttempt            string\n-\tsqlSelectAuthenticationAttemptsByUsername string\n+\tsqlInsertAuthenticationAttempt                         string\n+\tsqlSelectAuthenticationLogsRegulationRecordsByUsername string\n+\tsqlSelectAuthenticationLogsRegulationRecordsByRemoteIP string\n+\n+\t// Table: banned_user.\n+\tsqlInsertBannedUser         string\n+\tsqlSelectBannedUser         string\n+\tsqlSelectBannedUserByID     string\n+\tsqlSelectBannedUsers        string\n+\tsqlSelectBannedUserLastTime string\n+\tsqlRevokeBannedUser         string\n+\n+\t// Table: banned_ip.\n+\tsqlInsertBannedIP         string\n+\tsqlSelectBannedIP         string\n+\tsqlSelectBannedIPByID     string\n+\tsqlSelectBannedIPs        string\n+\tsqlSelectBannedIPLastTime string\n+\tsqlRevokeBannedIP         string\n \n \t// Table: cached_data.\n \tsqlUpsertCachedData string\n@@ -469,7 +501,7 @@ func (p *SQLProvider) LoadUserInfo(ctx context.Context, username string) (info m\n // SaveUserOpaqueIdentifier saves a new opaque user identifier to the storage provider.\n func (p *SQLProvider) SaveUserOpaqueIdentifier(ctx context.Context, subject model.UserOpaqueIdentifier) (err error) {\n \tif _, err = p.db.ExecContext(ctx, p.sqlInsertUserOpaqueIdentifier, subject.Service, subject.SectorID, subject.Username, subject.Identifier); err != nil {\n-\t\treturn fmt.Errorf(\"error inserting user opaque id for user '%s' with opaque id '%s': %w\", subject.Username, subject.Identifier.String(), err)\n+\t\treturn fmt.Errorf(\"error inserting user opaque id for user '%s' with opaque id '%s': %w\", subject.Username, subject.Identifier, err)\n \t}\n \n \treturn nil\n@@ -484,7 +516,7 @@ func (p *SQLProvider) LoadUserOpaqueIdentifier(ctx context.Context, identifier u\n \t\tcase errors.Is(err, sql.ErrNoRows):\n \t\t\treturn nil, nil\n \t\tdefault:\n-\t\t\treturn nil, fmt.Errorf(\"error selecting user opaque id with value '%s': %w\", identifier.String(), err)\n+\t\t\treturn nil, fmt.Errorf(\"error selecting user opaque id with value '%s': %w\", identifier, err)\n \t\t}\n \t}\n \n@@ -1104,7 +1136,7 @@ func (p *SQLProvider) LoadOAuth2ConsentPreConfigurations(ctx context.Context, cl\n \t\t\treturn &ConsentPreConfigRows{}, nil\n \t\t}\n \n-\t\treturn &ConsentPreConfigRows{}, fmt.Errorf(\"error selecting oauth2 consent pre-configurations by signature with client id '%s' and subject '%s': %w\", clientID, subject.String(), err)\n+\t\treturn &ConsentPreConfigRows{}, fmt.Errorf(\"error selecting oauth2 consent pre-configurations by signature with client id '%s' and subject '%s': %w\", clientID, subject, err)\n \t}\n \n \treturn &ConsentPreConfigRows{rows: r}, nil\n@@ -1155,7 +1187,7 @@ func (p *SQLProvider) LoadOAuth2ConsentSessionByChallengeID(ctx context.Context,\n \tconsent = &model.OAuth2ConsentSession{}\n \n \tif err = p.db.GetContext(ctx, consent, p.sqlSelectOAuth2ConsentSessionByChallengeID, challengeID); err != nil {\n-\t\treturn nil, fmt.Errorf(\"error selecting oauth2 consent session with challenge id '%s': %w\", challengeID.String(), err)\n+\t\treturn nil, fmt.Errorf(\"error selecting oauth2 consent session with challenge id '%s': %w\", challengeID, err)\n \t}\n \n \treturn consent, nil\n@@ -1213,11 +1245,11 @@ func (p *SQLProvider) RevokeOAuth2Session(ctx context.Context, sessionType OAuth\n \tcase OAuth2SessionTypeRefreshToken:\n \t\tquery = p.sqlRevokeOAuth2RefreshTokenSession\n \tdefault:\n-\t\treturn fmt.Errorf(\"error revoking oauth2 session with signature '%s': unknown oauth2 session type '%s'\", signature, sessionType.String())\n+\t\treturn fmt.Errorf(\"error revoking oauth2 session with signature '%s': unknown oauth2 session type '%s'\", signature, sessionType)\n \t}\n \n \tif _, err = p.db.ExecContext(ctx, query, signature); err != nil {\n-\t\treturn fmt.Errorf(\"error revoking oauth2 %s session with signature '%s': %w\", sessionType.String(), signature, err)\n+\t\treturn fmt.Errorf(\"error revoking oauth2 %s session with signature '%s': %w\", sessionType, signature, err)\n \t}\n \n \treturn nil\n@@ -1239,11 +1271,11 @@ func (p *SQLProvider) RevokeOAuth2SessionByRequestID(ctx context.Context, sessio\n \tcase OAuth2SessionTypeRefreshToken:\n \t\tquery = p.sqlRevokeOAuth2RefreshTokenSessionByRequestID\n \tdefault:\n-\t\treturn fmt.Errorf(\"error revoking oauth2 session with request id '%s': unknown oauth2 session type '%s'\", requestID, sessionType.String())\n+\t\treturn fmt.Errorf(\"error revoking oauth2 session with request id '%s': unknown oauth2 session type '%s'\", requestID, sessionType)\n \t}\n \n \tif _, err = p.db.ExecContext(ctx, query, requestID); err != nil {\n-\t\treturn fmt.Errorf(\"error revoking oauth2 %s session with request id '%s': %w\", sessionType.String(), requestID, err)\n+\t\treturn fmt.Errorf(\"error revoking oauth2 %s session with request id '%s': %w\", sessionType, requestID, err)\n \t}\n \n \treturn nil\n@@ -1265,11 +1297,11 @@ func (p *SQLProvider) DeactivateOAuth2Session(ctx context.Context, sessionType O\n \tcase OAuth2SessionTypeRefreshToken:\n \t\tquery = p.sqlDeactivateOAuth2RefreshTokenSession\n \tdefault:\n-\t\treturn fmt.Errorf(\"error deactivating oauth2 session with signature '%s': unknown oauth2 session type '%s'\", signature, sessionType.String())\n+\t\treturn fmt.Errorf(\"error deactivating oauth2 session with signature '%s': unknown oauth2 session type '%s'\", signature, sessionType)\n \t}\n \n \tif _, err = p.db.ExecContext(ctx, query, signature); err != nil {\n-\t\treturn fmt.Errorf(\"error deactivating oauth2 %s session with signature '%s': %w\", sessionType.String(), signature, err)\n+\t\treturn fmt.Errorf(\"error deactivating oauth2 %s session with signature '%s': %w\", sessionType, signature, err)\n \t}\n \n \treturn nil\n@@ -1291,7 +1323,7 @@ func (p *SQLProvider) DeactivateOAuth2SessionByRequestID(ctx context.Context, se\n \tcase OAuth2SessionTypeRefreshToken:\n \t\tquery = p.sqlDeactivateOAuth2RefreshTokenSessionByRequestID\n \tdefault:\n-\t\treturn fmt.Errorf(\"error deactivating oauth2 session with request id '%s': unknown oauth2 session type '%s'\", requestID, sessionType.String())\n+\t\treturn fmt.Errorf(\"error deactivating oauth2 session with request id '%s': unknown oauth2 session type '%s'\", requestID, sessionType)\n \t}\n \n \tif _, err = p.db.ExecContext(ctx, query, requestID); err != nil {\n@@ -1317,17 +1349,17 @@ func (p *SQLProvider) LoadOAuth2Session(ctx context.Context, sessionType OAuth2S\n \tcase OAuth2SessionTypeRefreshToken:\n \t\tquery = p.sqlSelectOAuth2RefreshTokenSession\n \tdefault:\n-\t\treturn nil, fmt.Errorf(\"error selecting oauth2 session: unknown oauth2 session type '%s'\", sessionType.String())\n+\t\treturn nil, fmt.Errorf(\"error selecting oauth2 session: unknown oauth2 session type '%s'\", sessionType)\n \t}\n \n \tsession = &model.OAuth2Session{}\n \n \tif err = p.db.GetContext(ctx, session, query, signature); err != nil {\n-\t\treturn nil, fmt.Errorf(\"error selecting oauth2 %s session with signature '%s': %w\", sessionType.String(), signature, err)\n+\t\treturn nil, fmt.Errorf(\"error selecting oauth2 %s session with signature '%s': %w\", sessionType, signature, err)\n \t}\n \n \tif session.Session, err = p.decrypt(session.Session); err != nil {\n-\t\treturn nil, fmt.Errorf(\"error decrypting the oauth2 %s session data with signature '%s' for subject '%s' and request id '%s': %w\", sessionType.String(), signature, session.Subject.String, session.RequestID, err)\n+\t\treturn nil, fmt.Errorf(\"error decrypting the oauth2 %s session data with signature '%s' for subject '%s' and request id '%s': %w\", sessionType, signature, session.Subject.String, session.RequestID, err)\n \t}\n \n \treturn session, nil\n@@ -1490,19 +1522,160 @@ func (p *SQLProvider) AppendAuthenticationLog(ctx context.Context, attempt model\n \treturn nil\n }\n \n-// LoadAuthenticationLogs loads authentication attempts from the storage provider (paginated).\n-func (p *SQLProvider) LoadAuthenticationLogs(ctx context.Context, username string, fromDate time.Time, limit, page int) (attempts []model.AuthenticationAttempt, err error) {\n-\tattempts = make([]model.AuthenticationAttempt, 0, limit)\n+func (p *SQLProvider) LoadRegulationRecordsByUser(ctx context.Context, username string, since time.Time, limit int) (records []model.RegulationRecord, err error) {\n+\texp := banExpiresExpired{}\n \n-\tif err = p.db.SelectContext(ctx, &attempts, p.sqlSelectAuthenticationAttemptsByUsername, fromDate, username, limit, limit*page); err != nil {\n+\tif err = p.db.GetContext(ctx, &exp, p.sqlSelectBannedUserLastTime, username); err != nil {\n+\t\tif !errors.Is(err, sql.ErrNoRows) {\n+\t\t\treturn nil, fmt.Errorf(\"error selecting last banned user time for username '%s': %w\", username, err)\n+\t\t}\n+\t}\n+\n+\tif expiration := exp.Expiration(); expiration.After(since) {\n+\t\tsince = expiration\n+\t}\n+\n+\trecords = make([]model.RegulationRecord, 0, limit)\n+\n+\tif err = p.db.SelectContext(ctx, &records, p.sqlSelectAuthenticationLogsRegulationRecordsByUsername, since, username, false, limit); err != nil {\n+\t\tif errors.Is(err, sql.ErrNoRows) {\n+\t\t\treturn nil, nil\n+\t\t}\n+\n+\t\treturn nil, fmt.Errorf(\"error selecting regulation records for username '%s': %w\", username, err)\n+\t}\n+\n+\treturn records, nil\n+}\n+\n+func (p *SQLProvider) SaveBannedUser(ctx context.Context, ban *model.BannedUser) (err error) {\n+\tif _, err = p.db.ExecContext(ctx, p.sqlInsertBannedUser, ban.Expires, ban.Username, ban.Source, ban.Reason); err != nil {\n+\t\treturn fmt.Errorf(\"error inserting banned user with username '%s' and source '%s' and reason '%s': %w\", ban.Username, ban.Source, ban.Reason.String, err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+func (p *SQLProvider) LoadBannedUser(ctx context.Context, username string) (bans []model.BannedUser, err error) {\n+\tbans = []model.BannedUser{}\n+\n+\tif err = p.db.SelectContext(ctx, &bans, p.sqlSelectBannedUser, username, time.Now().UTC()); err != nil {\n+\t\tif errors.Is(err, sql.ErrNoRows) {\n+\t\t\treturn nil, nil\n+\t\t}\n+\n+\t\treturn nil, fmt.Errorf(\"error selecting banned user records for username '%s': %w\", username, err)\n+\t}\n+\n+\treturn bans, nil\n+}\n+\n+func (p *SQLProvider) LoadBannedUserByID(ctx context.Context, id int) (ban model.BannedUser, err error) {\n+\tif err = p.db.GetContext(ctx, &ban, p.sqlSelectBannedUserByID, id); err != nil {\n+\t\treturn model.BannedUser{}, fmt.Errorf(\"error selecting banned user with id '%d': %w\", id, err)\n+\t}\n+\n+\treturn ban, nil\n+}\n+\n+func (p *SQLProvider) LoadBannedUsers(ctx context.Context, limit, page int) (bans []model.BannedUser, err error) {\n+\tbans = []model.BannedUser{}\n+\n+\tif err = p.db.SelectContext(ctx, &bans, p.sqlSelectBannedUsers, false, time.Now().UTC(), limit, limit*page); err != nil {\n+\t\tif errors.Is(err, sql.ErrNoRows) {\n+\t\t\treturn nil, nil\n+\t\t}\n+\n+\t\treturn nil, fmt.Errorf(\"error selecting banned user records: %w\", err)\n+\t}\n+\n+\treturn bans, nil\n+}\n+\n+func (p *SQLProvider) RevokeBannedUser(ctx context.Context, id int, expired time.Time) (err error) {\n+\tif _, err = p.db.ExecContext(ctx, p.sqlRevokeBannedUser, expired, id); err != nil {\n+\t\treturn fmt.Errorf(\"error revoking banned user with id '%d': %w\", id, err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+func (p *SQLProvider) LoadRegulationRecordsByIP(ctx context.Context, ip model.IP, since time.Time, limit int) (records []model.RegulationRecord, err error) {\n+\texp := banExpiresExpired{}\n+\n+\tif err = p.db.GetContext(ctx, &exp, p.sqlSelectBannedIPLastTime, ip); err != nil {\n+\t\tif !errors.Is(err, sql.ErrNoRows) {\n+\t\t\treturn nil, fmt.Errorf(\"error selecting last banned time for ip '%s': %w\", ip, err)\n+\t\t}\n+\t}\n+\n+\tif expiration := exp.Expiration(); expiration.After(since) {\n+\t\tsince = expiration\n+\t}\n+\n+\trecords = make([]model.RegulationRecord, 0, limit)\n+\n+\tif err = p.db.SelectContext(ctx, &records, p.sqlSelectAuthenticationLogsRegulationRecordsByRemoteIP, since, ip, false, limit); err != nil {\n \t\tif errors.Is(err, sql.ErrNoRows) {\n-\t\t\treturn nil, ErrNoAuthenticationLogs\n+\t\t\treturn nil, nil\n \t\t}\n \n-\t\treturn nil, fmt.Errorf(\"error selecting authentication logs for user '%s': %w\", username, err)\n+\t\treturn nil, fmt.Errorf(\"error selecting regulation records for ip '%s': %w\", ip, err)\n \t}\n \n-\treturn attempts, nil\n+\treturn records, nil\n+}\n+\n+func (p *SQLProvider) SaveBannedIP(ctx context.Context, ban *model.BannedIP) (err error) {\n+\tif _, err = p.db.ExecContext(ctx, p.sqlInsertBannedIP, ban.Expires, ban.IP, ban.Source, ban.Reason); err != nil {\n+\t\treturn fmt.Errorf(\"error inserting banned ip with ip '%s' and source '%s' and reason '%s': %w\", ban.IP, ban.Source, ban.Reason.String, err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+func (p *SQLProvider) LoadBannedIP(ctx context.Context, ip model.IP) (bans []model.BannedIP, err error) {\n+\tbans = []model.BannedIP{}\n+\n+\tif err = p.db.SelectContext(ctx, &bans, p.sqlSelectBannedIP, ip, false, time.Now().UTC()); err != nil {\n+\t\tif errors.Is(err, sql.ErrNoRows) {\n+\t\t\treturn nil, nil\n+\t\t}\n+\n+\t\treturn nil, fmt.Errorf(\"error selecting banned ip records for ip '%s': %w\", ip, err)\n+\t}\n+\n+\treturn bans, nil\n+}\n+\n+func (p *SQLProvider) LoadBannedIPByID(ctx context.Context, id int) (ban model.BannedIP, err error) {\n+\tif err = p.db.GetContext(ctx, &ban, p.sqlSelectBannedIPByID, id); err != nil {\n+\t\treturn model.BannedIP{}, fmt.Errorf(\"error selecting banned ip with id '%d': %w\", id, err)\n+\t}\n+\n+\treturn ban, nil\n+}\n+\n+func (p *SQLProvider) LoadBannedIPs(ctx context.Context, limit, page int) (bans []model.BannedIP, err error) {\n+\tbans = []model.BannedIP{}\n+\n+\tif err = p.db.SelectContext(ctx, &bans, p.sqlSelectBannedIPs, time.Now().UTC(), limit, limit*page); err != nil {\n+\t\tif errors.Is(err, sql.ErrNoRows) {\n+\t\t\treturn nil, nil\n+\t\t}\n+\n+\t\treturn nil, fmt.Errorf(\"error selecting banned ip records: %w\", err)\n+\t}\n+\n+\treturn bans, nil\n+}\n+\n+func (p *SQLProvider) RevokeBannedIP(ctx context.Context, id int, expired time.Time) (err error) {\n+\tif _, err = p.db.ExecContext(ctx, p.sqlRevokeBannedIP, expired, id); err != nil {\n+\t\treturn fmt.Errorf(\"error revoking banned ip with id '%d': %w\", id, err)\n+\t}\n+\n+\treturn nil\n }\n \n func (p *SQLProvider) SaveCachedData(ctx context.Context, data model.CachedData) (err error) {\ndiff --git a/internal/storage/sql_provider_backend_postgres.go b/internal/storage/sql_provider_backend_postgres.go\nindex daa7eef02237c..0d7f8eb407924 100644\n--- a/internal/storage/sql_provider_backend_postgres.go\n+++ b/internal/storage/sql_provider_backend_postgres.go\n@@ -93,7 +93,22 @@ func NewPostgreSQLProvider(config *schema.Configuration, caCertPool *x509.CertPo\n \tprovider.sqlDeleteDuoDevice = provider.db.Rebind(provider.sqlDeleteDuoDevice)\n \n \tprovider.sqlInsertAuthenticationAttempt = provider.db.Rebind(provider.sqlInsertAuthenticationAttempt)\n-\tprovider.sqlSelectAuthenticationAttemptsByUsername = provider.db.Rebind(provider.sqlSelectAuthenticationAttemptsByUsername)\n+\tprovider.sqlSelectAuthenticationLogsRegulationRecordsByUsername = provider.db.Rebind(provider.sqlSelectAuthenticationLogsRegulationRecordsByUsername)\n+\tprovider.sqlSelectAuthenticationLogsRegulationRecordsByRemoteIP = provider.db.Rebind(provider.sqlSelectAuthenticationLogsRegulationRecordsByRemoteIP)\n+\n+\tprovider.sqlInsertBannedUser = provider.db.Rebind(provider.sqlInsertBannedUser)\n+\tprovider.sqlSelectBannedUser = provider.db.Rebind(provider.sqlSelectBannedUser)\n+\tprovider.sqlSelectBannedUserByID = provider.db.Rebind(provider.sqlSelectBannedUserByID)\n+\tprovider.sqlSelectBannedUsers = provider.db.Rebind(provider.sqlSelectBannedUsers)\n+\tprovider.sqlSelectBannedUserLastTime = provider.db.Rebind(provider.sqlSelectBannedUserLastTime)\n+\tprovider.sqlRevokeBannedUser = provider.db.Rebind(provider.sqlRevokeBannedUser)\n+\n+\tprovider.sqlInsertBannedIP = provider.db.Rebind(provider.sqlInsertBannedIP)\n+\tprovider.sqlSelectBannedIP = provider.db.Rebind(provider.sqlSelectBannedIP)\n+\tprovider.sqlSelectBannedIPByID = provider.db.Rebind(provider.sqlSelectBannedIPByID)\n+\tprovider.sqlSelectBannedIPs = provider.db.Rebind(provider.sqlSelectBannedIPs)\n+\tprovider.sqlSelectBannedIPLastTime = provider.db.Rebind(provider.sqlSelectBannedIPLastTime)\n+\tprovider.sqlRevokeBannedIP = provider.db.Rebind(provider.sqlRevokeBannedIP)\n \n \tprovider.sqlSelectCachedData = provider.db.Rebind(provider.sqlSelectCachedData)\n \tprovider.sqlDeleteCachedData = provider.db.Rebind(provider.sqlDeleteCachedData)\ndiff --git a/internal/storage/sql_provider_queries.go b/internal/storage/sql_provider_queries.go\nindex be6e6c958bb35..96bc0fa7b1f89 100644\n--- a/internal/storage/sql_provider_queries.go\n+++ b/internal/storage/sql_provider_queries.go\n@@ -283,13 +283,88 @@ const (\n \t\tINSERT INTO %s (time, successful, banned, username, auth_type, remote_ip, request_uri, request_method)\n \t\tVALUES (?, ?, ?, ?, ?, ?, ?, ?);`\n \n-\tqueryFmtSelect1FAAuthenticationLogEntryByUsername = `\n-\t\tSELECT time, successful, username\n+\tqueryFmtSelectAuthenticationLogsRegulationRecordsByUsername = `\n+\t\tSELECT time, successful\n \t\tFROM %s\n-\t\tWHERE time > ? AND username = ? AND auth_type = '1FA' AND banned = FALSE\n+\t\tWHERE time > ? AND username = ? AND auth_type = '1FA' AND banned = ?\n \t\tORDER BY time DESC\n+\t\tLIMIT ?;`\n+\n+\tqueryFmtSelectAuthenticationLogsRegulationRecordsByRemoteIP = `\n+\t\tSELECT time, successful\n+\t\tFROM %s\n+\t\tWHERE time > ? AND remote_ip = ? AND auth_type = '1FA' AND banned = ?\n+\t\tORDER BY time DESC\n+\t\tLIMIT ?;`\n+)\n+\n+const (\n+\tqueryFmtInsertBannedUser = `\n+\t\tINSERT INTO %s (expires, username, source, reason)\n+\t\tVALUES (?, ?, ?, ?);`\n+\n+\tqueryFmtSelectBannedUser = `\n+\t\tSELECT id, time, expires, expired, revoked, username, source, reason\n+\t\tFROM %s\n+\t\tWHERE username = ? AND revoked = FALSE AND (expires IS NULL OR expires > ?) AND expired IS NULL\n+\t\tORDER BY time DESC;`\n+\n+\tqueryFmtSelectBannedUserByID = `\n+\t\tSELECT id, time, expires, expired, revoked, username, source, reason\n+\t\tFROM %s\n+\t\tWHERE id = ?;`\n+\n+\tqueryFmtSelectBannedUsers = `\n+\t\tSELECT id, time, expires, expired, revoked, username, source, reason\n+\t\tFROM %s\n+\t\tWHERE revoked = ? AND (expires IS NULL OR expires > ?) AND expired IS NULL\n \t\tLIMIT ?\n \t\tOFFSET ?;`\n+\n+\tqueryFmtSelectBannedUserLastExpires = `\n+\t\tSELECT expires, expired, revoked\n+\t\tFROM %s\n+\t\tWHERE username = ?\n+\t\tORDER BY time DESC\n+\t\tLIMIT 1;`\n+)\n+\n+const (\n+\tqueryFmtInsertBannedIP = `\n+\t\tINSERT INTO %s (expires, ip, source, reason)\n+\t\tVALUES (?, ?, ?, ?);`\n+\n+\tqueryFmtSelectBannedIP = `\n+\t\tSELECT id, time, expires, expired, revoked, ip, source, reason\n+\t\tFROM %s\n+\t\tWHERE ip = ? AND revoked = ? AND (expires IS NULL OR expires > ?) AND expired IS NULL\n+\t\tORDER BY time DESC;`\n+\n+\tqueryFmtSelectBannedIPByID = `\n+\t\tSELECT id, time, expires, expired, revoked, ip, source, reason\n+\t\tFROM %s\n+\t\tWHERE id = ?;`\n+\n+\tqueryFmtSelectBannedIPs = `\n+\t\tSELECT id, time, expires, expired, revoked, ip, source, reason\n+\t\tFROM %s\n+\t\tWHERE revoked = FALSE AND (expires IS NULL OR expires > ?)\n+\t\tLIMIT ?\n+\t\tOFFSET ?;`\n+\n+\tqueryFmtSelectBannedIPLastExpires = `\n+\t\tSELECT expires, expired, revoked\n+\t\tFROM %s\n+\t\tWHERE ip = ?\n+\t\tORDER BY time DESC\n+\t\tLIMIT 1;`\n+)\n+\n+const (\n+\tqueryFmtRevokeBannedEntry = `\n+\t\tUPDATE %s\n+\t\tSET expired = ?, revoked = TRUE\n+\t\tWHERE id = ?;`\n )\n \n const (\ndiff --git a/internal/storage/types.go b/internal/storage/types.go\nindex 19e74ad2dcbcb..4da9973c4187e 100644\n--- a/internal/storage/types.go\n+++ b/internal/storage/types.go\n@@ -2,6 +2,8 @@ package storage\n \n import (\n \t\"context\"\n+\t\"database/sql\"\n+\t\"time\"\n \n \t\"github.com/jmoiron/sqlx\"\n )\n@@ -58,6 +60,24 @@ type encEncryption struct {\n \tValue []byte `db:\"value\"`\n }\n \n+type banExpiresExpired struct {\n+\tExpires sql.NullTime `db:\"expires\"`\n+\tExpired sql.NullTime `db:\"expired\"`\n+\tRevoked bool         `db:\"revoked\"`\n+}\n+\n+func (b *banExpiresExpired) Expiration() time.Time {\n+\tif b.Revoked && b.Expired.Valid {\n+\t\treturn b.Expired.Time\n+\t}\n+\n+\tif b.Expires.Valid {\n+\t\treturn b.Expires.Time\n+\t}\n+\n+\treturn time.Unix(0, 0)\n+}\n+\n // EncryptionValidationResult contains information about the success of a schema encryption validation.\n type EncryptionValidationResult struct {\n \tInvalidCheckValue bool\n", "test_patch": "diff --git a/internal/handlers/const_test.go b/internal/handlers/const_test.go\nindex ee526d0649385..118cb2ec0a023 100644\n--- a/internal/handlers/const_test.go\n+++ b/internal/handlers/const_test.go\n@@ -40,6 +40,10 @@ const (\n \texampleDotCom            = \"example.com\"\n )\n \n+const (\n+\ttestValue = \"test\"\n+)\n+\n var (\n \ttestRedirectionURL = func() *url.URL {\n \t\tu, err := url.ParseRequestURI(testRedirectionURLString)\ndiff --git a/internal/handlers/handler_authz_test.go b/internal/handlers/handler_authz_test.go\nindex 2538930939834..e3161cb901f20 100644\n--- a/internal/handlers/handler_authz_test.go\n+++ b/internal/handlers/handler_authz_test.go\n@@ -16,6 +16,7 @@ import (\n \t\"github.com/authelia/authelia/v4/internal/middlewares\"\n \t\"github.com/authelia/authelia/v4/internal/mocks\"\n \t\"github.com/authelia/authelia/v4/internal/model\"\n+\t\"github.com/authelia/authelia/v4/internal/regulation\"\n \t\"github.com/authelia/authelia/v4/internal/session\"\n \t\"github.com/authelia/authelia/v4/internal/utils\"\n )\n@@ -141,6 +142,8 @@ func (s *AuthzSuite) TestShouldApplyDefaultPolicy() {\n \n \tdefer mock.Close()\n \n+\tsetUpMockClock(mock)\n+\n \ts.ConfigureMockSessionProviderWithAutomaticAutheliaURLs(mock)\n \n \ttargetURI := s.RequireParseRequestURI(\"https://test.example.com\")\n@@ -149,16 +152,41 @@ func (s *AuthzSuite) TestShouldApplyDefaultPolicy() {\n \n \tmock.Ctx.Request.Header.Set(fasthttp.HeaderProxyAuthorization, \"Basic am9objpwYXNzd29yZA==\")\n \n-\tmock.UserProviderMock.EXPECT().\n-\t\tCheckUserPassword(gomock.Eq(\"john\"), gomock.Eq(\"password\")).\n-\t\tReturn(true, nil)\n+\tswitch s.implementation {\n+\tcase AuthzImplLegacy:\n+\t\tbreak\n+\tdefault:\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(mock.Ctx), gomock.Eq(model.NewIP(mock.Ctx.RemoteIP()))).Return(nil, nil)\n+\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(mock.Ctx), gomock.Eq(\"john\")).Return(nil, nil)\n+\n+\t\tattempt := model.AuthenticationAttempt{\n+\t\t\tTime:          mock.Ctx.Clock.Now(),\n+\t\t\tSuccessful:    true,\n+\t\t\tBanned:        false,\n+\t\t\tUsername:      \"john\",\n+\t\t\tType:          regulation.AuthType1FA,\n+\t\t\tRemoteIP:      model.NewNullIP(mock.Ctx.RemoteIP()),\n+\t\t\tRequestURI:    \"https://test.example.com\",\n+\t\t\tRequestMethod: fasthttp.MethodGet,\n+\t\t}\n \n-\tmock.UserProviderMock.EXPECT().\n-\t\tGetDetails(gomock.Eq(\"john\")).\n-\t\tReturn(&authentication.UserDetails{\n-\t\t\tEmails: []string{\"john@example.com\"},\n-\t\t\tGroups: []string{\"dev\", \"admins\"},\n-\t\t}, nil)\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tAppendAuthenticationLog(gomock.Eq(mock.Ctx), gomock.Eq(attempt)).Return(nil)\n+\t}\n+\n+\tmock.UserProviderMock.\n+\t\tEXPECT().\n+\t\tCheckUserPassword(gomock.Eq(\"john\"), gomock.Eq(\"password\")).Return(true, nil)\n+\n+\tmock.UserProviderMock.\n+\t\tEXPECT().\n+\t\tGetDetails(gomock.Eq(\"john\")).Return(&authentication.UserDetails{Emails: []string{\"john@example.com\"}, Groups: []string{\"dev\", \"admins\"}}, nil)\n \n \tauthz.Handler(mock.Ctx)\n \n@@ -223,6 +251,8 @@ func (s *AuthzSuite) TestShouldApplyPolicyOfBypassDomain() {\n \n \tdefer mock.Close()\n \n+\tsetUpMockClock(mock)\n+\n \ts.ConfigureMockSessionProviderWithAutomaticAutheliaURLs(mock)\n \n \ttargetURI := s.RequireParseRequestURI(\"https://bypass.example.com\")\n@@ -231,6 +261,34 @@ func (s *AuthzSuite) TestShouldApplyPolicyOfBypassDomain() {\n \n \tmock.Ctx.Request.Header.Set(fasthttp.HeaderProxyAuthorization, \"Basic am9objpwYXNzd29yZA==\")\n \n+\tswitch s.implementation {\n+\tcase AuthzImplLegacy:\n+\t\tbreak\n+\tdefault:\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(mock.Ctx), gomock.Eq(model.NewIP(mock.Ctx.RemoteIP()))).Return(nil, nil)\n+\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(mock.Ctx), gomock.Eq(\"john\")).Return(nil, nil)\n+\n+\t\tattempt := model.AuthenticationAttempt{\n+\t\t\tTime:          mock.Ctx.Clock.Now(),\n+\t\t\tSuccessful:    true,\n+\t\t\tBanned:        false,\n+\t\t\tUsername:      \"john\",\n+\t\t\tType:          regulation.AuthType1FA,\n+\t\t\tRemoteIP:      model.NewNullIP(mock.Ctx.RemoteIP()),\n+\t\t\tRequestURI:    \"https://bypass.example.com\",\n+\t\t\tRequestMethod: fasthttp.MethodGet,\n+\t\t}\n+\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tAppendAuthenticationLog(gomock.Eq(mock.Ctx), gomock.Eq(attempt)).Return(nil)\n+\t}\n+\n \tmock.UserProviderMock.EXPECT().\n \t\tCheckUserPassword(gomock.Eq(\"john\"), gomock.Eq(\"password\")).\n \t\tReturn(true, nil)\n@@ -260,6 +318,8 @@ func (s *AuthzSuite) TestShouldVerifyFailureToGetDetailsUsingBasicScheme() {\n \n \tdefer mock.Close()\n \n+\tsetUpMockClock(mock)\n+\n \ts.ConfigureMockSessionProviderWithAutomaticAutheliaURLs(mock)\n \n \ttargetURI := s.RequireParseRequestURI(\"https://one-factor.example.com\")\n@@ -268,15 +328,41 @@ func (s *AuthzSuite) TestShouldVerifyFailureToGetDetailsUsingBasicScheme() {\n \n \tmock.Ctx.Request.Header.Set(fasthttp.HeaderProxyAuthorization, \"Basic am9objpwYXNzd29yZA==\")\n \n-\tgomock.InOrder(\n-\t\tmock.UserProviderMock.EXPECT().\n-\t\t\tCheckUserPassword(gomock.Eq(\"john\"), gomock.Eq(\"password\")).\n-\t\t\tReturn(true, nil),\n+\tswitch s.implementation {\n+\tcase AuthzImplLegacy:\n+\t\tbreak\n+\tdefault:\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(mock.Ctx), gomock.Eq(model.NewIP(mock.Ctx.RemoteIP()))).Return(nil, nil)\n+\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(mock.Ctx), gomock.Eq(\"john\")).Return(nil, nil)\n+\n+\t\tattempt := model.AuthenticationAttempt{\n+\t\t\tTime:          mock.Ctx.Clock.Now(),\n+\t\t\tSuccessful:    true,\n+\t\t\tBanned:        false,\n+\t\t\tUsername:      \"john\",\n+\t\t\tType:          regulation.AuthType1FA,\n+\t\t\tRemoteIP:      model.NewNullIP(mock.Ctx.RemoteIP()),\n+\t\t\tRequestURI:    \"https://one-factor.example.com\",\n+\t\t\tRequestMethod: fasthttp.MethodGet,\n+\t\t}\n \n-\t\tmock.UserProviderMock.EXPECT().\n-\t\t\tGetDetails(gomock.Eq(\"john\")).\n-\t\t\tReturn(nil, fmt.Errorf(\"generic failure\")),\n-\t)\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tAppendAuthenticationLog(gomock.Eq(mock.Ctx), gomock.Eq(attempt)).Return(nil)\n+\t}\n+\n+\tmock.UserProviderMock.EXPECT().\n+\t\tCheckUserPassword(gomock.Eq(\"john\"), gomock.Eq(\"password\")).\n+\t\tReturn(true, nil)\n+\n+\tmock.UserProviderMock.EXPECT().\n+\t\tGetDetails(gomock.Eq(\"john\")).\n+\t\tReturn(nil, fmt.Errorf(\"generic failure\"))\n \n \tauthz.Handler(mock.Ctx)\n \n@@ -303,6 +389,8 @@ func (s *AuthzSuite) TestShouldVerifyBypassWithErrorToGetDetailsUsingBasicScheme\n \n \tdefer mock.Close()\n \n+\tsetUpMockClock(mock)\n+\n \ts.ConfigureMockSessionProviderWithAutomaticAutheliaURLs(mock)\n \n \ttargetURI := s.RequireParseRequestURI(\"https://bypass.example.com\")\n@@ -311,6 +399,34 @@ func (s *AuthzSuite) TestShouldVerifyBypassWithErrorToGetDetailsUsingBasicScheme\n \n \tmock.Ctx.Request.Header.Set(fasthttp.HeaderProxyAuthorization, \"Basic am9objpwYXNzd29yZA==\")\n \n+\tswitch s.implementation {\n+\tcase AuthzImplLegacy:\n+\t\tbreak\n+\tdefault:\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(mock.Ctx), gomock.Eq(model.NewIP(mock.Ctx.RemoteIP()))).Return(nil, nil)\n+\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(mock.Ctx), gomock.Eq(\"john\")).Return(nil, nil)\n+\n+\t\tattempt := model.AuthenticationAttempt{\n+\t\t\tTime:          mock.Ctx.Clock.Now(),\n+\t\t\tSuccessful:    true,\n+\t\t\tBanned:        false,\n+\t\t\tUsername:      \"john\",\n+\t\t\tType:          regulation.AuthType1FA,\n+\t\t\tRemoteIP:      model.NewNullIP(mock.Ctx.RemoteIP()),\n+\t\t\tRequestURI:    \"https://bypass.example.com\",\n+\t\t\tRequestMethod: fasthttp.MethodGet,\n+\t\t}\n+\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tAppendAuthenticationLog(gomock.Eq(mock.Ctx), gomock.Eq(attempt)).Return(nil)\n+\t}\n+\n \tgomock.InOrder(\n \t\tmock.UserProviderMock.EXPECT().\n \t\t\tCheckUserPassword(gomock.Eq(\"john\"), gomock.Eq(\"password\")).\n@@ -441,9 +557,7 @@ func (s *AuthzSuite) TestShouldNotFailOnMissingEmail() {\n \n \tdefer mock.Close()\n \n-\tmock.Ctx.Clock = &mock.Clock\n-\n-\tmock.Clock.Set(time.Now())\n+\tsetUpMockClock(mock)\n \n \tauthz := s.Builder().WithConfig(&mock.Ctx.Configuration).Build()\n \n@@ -484,6 +598,8 @@ func (s *AuthzSuite) TestShouldApplyPolicyOfOneFactorDomain() {\n \n \tdefer mock.Close()\n \n+\tsetUpMockClock(mock)\n+\n \ts.ConfigureMockSessionProviderWithAutomaticAutheliaURLs(mock)\n \n \ttargetURI := s.RequireParseRequestURI(\"https://one-factor.example.com\")\n@@ -492,6 +608,34 @@ func (s *AuthzSuite) TestShouldApplyPolicyOfOneFactorDomain() {\n \n \tmock.Ctx.Request.Header.Set(fasthttp.HeaderProxyAuthorization, \"Basic am9objpwYXNzd29yZA==\")\n \n+\tswitch s.implementation {\n+\tcase AuthzImplLegacy:\n+\t\tbreak\n+\tdefault:\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(mock.Ctx), gomock.Eq(model.NewIP(mock.Ctx.RemoteIP()))).Return(nil, nil)\n+\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(mock.Ctx), gomock.Eq(\"john\")).Return(nil, nil)\n+\n+\t\tattempt := model.AuthenticationAttempt{\n+\t\t\tTime:          mock.Ctx.Clock.Now(),\n+\t\t\tSuccessful:    true,\n+\t\t\tBanned:        false,\n+\t\t\tUsername:      \"john\",\n+\t\t\tType:          regulation.AuthType1FA,\n+\t\t\tRemoteIP:      model.NewNullIP(mock.Ctx.RemoteIP()),\n+\t\t\tRequestURI:    \"https://one-factor.example.com\",\n+\t\t\tRequestMethod: fasthttp.MethodGet,\n+\t\t}\n+\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tAppendAuthenticationLog(gomock.Eq(mock.Ctx), gomock.Eq(attempt)).Return(nil)\n+\t}\n+\n \tmock.UserProviderMock.EXPECT().\n \t\tCheckUserPassword(gomock.Eq(\"john\"), gomock.Eq(\"password\")).\n \t\tReturn(true, nil)\n@@ -532,6 +676,10 @@ func (s *AuthzSuite) TestShouldHandleAnyCaseSchemeParameter() {\n \n \t\t\tdefer mock.Close()\n \n+\t\t\tmock.Ctx.Clock = &mock.Clock\n+\n+\t\t\tmock.Clock.Set(time.Now())\n+\n \t\t\ts.ConfigureMockSessionProviderWithAutomaticAutheliaURLs(mock)\n \n \t\t\ttargetURI := s.RequireParseRequestURI(\"https://one-factor.example.com\")\n@@ -540,6 +688,34 @@ func (s *AuthzSuite) TestShouldHandleAnyCaseSchemeParameter() {\n \n \t\t\tmock.Ctx.Request.Header.Set(fasthttp.HeaderProxyAuthorization, fmt.Sprintf(\"%s am9objpwYXNzd29yZA==\", tc.scheme))\n \n+\t\t\tswitch s.implementation {\n+\t\t\tcase AuthzImplLegacy:\n+\t\t\t\tbreak\n+\t\t\tdefault:\n+\t\t\t\tmock.StorageMock.\n+\t\t\t\t\tEXPECT().\n+\t\t\t\t\tLoadBannedIP(gomock.Eq(mock.Ctx), gomock.Eq(model.NewIP(mock.Ctx.RemoteIP()))).Return(nil, nil)\n+\n+\t\t\t\tmock.StorageMock.\n+\t\t\t\t\tEXPECT().\n+\t\t\t\t\tLoadBannedUser(gomock.Eq(mock.Ctx), gomock.Eq(\"john\")).Return(nil, nil)\n+\n+\t\t\t\tattempt := model.AuthenticationAttempt{\n+\t\t\t\t\tTime:          mock.Ctx.Clock.Now(),\n+\t\t\t\t\tSuccessful:    true,\n+\t\t\t\t\tBanned:        false,\n+\t\t\t\t\tUsername:      \"john\",\n+\t\t\t\t\tType:          regulation.AuthType1FA,\n+\t\t\t\t\tRemoteIP:      model.NewNullIP(mock.Ctx.RemoteIP()),\n+\t\t\t\t\tRequestURI:    \"https://one-factor.example.com\",\n+\t\t\t\t\tRequestMethod: fasthttp.MethodGet,\n+\t\t\t\t}\n+\n+\t\t\t\tmock.StorageMock.\n+\t\t\t\t\tEXPECT().\n+\t\t\t\t\tAppendAuthenticationLog(gomock.Eq(mock.Ctx), gomock.Eq(attempt)).Return(nil)\n+\t\t\t}\n+\n \t\t\tmock.UserProviderMock.EXPECT().\n \t\t\t\tCheckUserPassword(gomock.Eq(\"john\"), gomock.Eq(\"password\")).\n \t\t\t\tReturn(true, nil)\n@@ -571,6 +747,8 @@ func (s *AuthzSuite) TestShouldApplyPolicyOfTwoFactorDomain() {\n \n \tdefer mock.Close()\n \n+\tsetUpMockClock(mock)\n+\n \ts.ConfigureMockSessionProviderWithAutomaticAutheliaURLs(mock)\n \n \ttargetURI := s.RequireParseRequestURI(\"https://two-factor.example.com\")\n@@ -579,6 +757,34 @@ func (s *AuthzSuite) TestShouldApplyPolicyOfTwoFactorDomain() {\n \n \tmock.Ctx.Request.Header.Set(fasthttp.HeaderProxyAuthorization, \"Basic am9objpwYXNzd29yZA==\")\n \n+\tswitch s.implementation {\n+\tcase AuthzImplLegacy:\n+\t\tbreak\n+\tdefault:\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(mock.Ctx), gomock.Eq(model.NewIP(mock.Ctx.RemoteIP()))).Return(nil, nil)\n+\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(mock.Ctx), gomock.Eq(\"john\")).Return(nil, nil)\n+\n+\t\tattempt := model.AuthenticationAttempt{\n+\t\t\tTime:          mock.Ctx.Clock.Now(),\n+\t\t\tSuccessful:    true,\n+\t\t\tBanned:        false,\n+\t\t\tUsername:      \"john\",\n+\t\t\tType:          regulation.AuthType1FA,\n+\t\t\tRemoteIP:      model.NewNullIP(mock.Ctx.RemoteIP()),\n+\t\t\tRequestURI:    \"https://two-factor.example.com\",\n+\t\t\tRequestMethod: fasthttp.MethodGet,\n+\t\t}\n+\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tAppendAuthenticationLog(gomock.Eq(mock.Ctx), gomock.Eq(attempt)).Return(nil)\n+\t}\n+\n \tmock.UserProviderMock.EXPECT().\n \t\tCheckUserPassword(gomock.Eq(\"john\"), gomock.Eq(\"password\")).\n \t\tReturn(true, nil)\n@@ -615,6 +821,8 @@ func (s *AuthzSuite) TestShouldApplyPolicyOfDenyDomain() {\n \n \tdefer mock.Close()\n \n+\tsetUpMockClock(mock)\n+\n \ts.ConfigureMockSessionProviderWithAutomaticAutheliaURLs(mock)\n \n \ttargetURI := s.RequireParseRequestURI(\"https://deny.example.com\")\n@@ -623,6 +831,34 @@ func (s *AuthzSuite) TestShouldApplyPolicyOfDenyDomain() {\n \n \tmock.Ctx.Request.Header.Set(fasthttp.HeaderProxyAuthorization, \"Basic am9objpwYXNzd29yZA==\")\n \n+\tswitch s.implementation {\n+\tcase AuthzImplLegacy:\n+\t\tbreak\n+\tdefault:\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(mock.Ctx), gomock.Eq(model.NewIP(mock.Ctx.RemoteIP()))).Return(nil, nil)\n+\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(mock.Ctx), gomock.Eq(\"john\")).Return(nil, nil)\n+\n+\t\tattempt := model.AuthenticationAttempt{\n+\t\t\tTime:          mock.Ctx.Clock.Now(),\n+\t\t\tSuccessful:    true,\n+\t\t\tBanned:        false,\n+\t\t\tUsername:      \"john\",\n+\t\t\tType:          regulation.AuthType1FA,\n+\t\t\tRemoteIP:      model.NewNullIP(mock.Ctx.RemoteIP()),\n+\t\t\tRequestURI:    \"https://deny.example.com\",\n+\t\t\tRequestMethod: fasthttp.MethodGet,\n+\t\t}\n+\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tAppendAuthenticationLog(gomock.Eq(mock.Ctx), gomock.Eq(attempt)).Return(nil)\n+\t}\n+\n \tmock.UserProviderMock.EXPECT().\n \t\tCheckUserPassword(gomock.Eq(\"john\"), gomock.Eq(\"password\")).\n \t\tReturn(true, nil)\n@@ -642,12 +878,10 @@ func (s *AuthzSuite) TestShouldApplyPolicyOfDenyDomain() {\n }\n \n func (s *AuthzSuite) TestShouldApplyPolicyOfOneFactorDomainWithAuthorizationHeader() {\n-\tif s.setRequest == nil {\n+\tif s.setRequest == nil || s.implementation == AuthzImplLegacy {\n \t\ts.T().Skip()\n \t}\n \n-\t// Equivalent of TestShouldVerifyAuthBasicArgOk.\n-\n \tbuilder := NewAuthzBuilder().WithImplementationLegacy()\n \n \tbuilder = builder.WithStrategies(\n@@ -662,6 +896,8 @@ func (s *AuthzSuite) TestShouldApplyPolicyOfOneFactorDomainWithAuthorizationHead\n \n \tdefer mock.Close()\n \n+\tsetUpMockClock(mock)\n+\n \ts.ConfigureMockSessionProviderWithAutomaticAutheliaURLs(mock)\n \n \ttargetURI := s.RequireParseRequestURI(\"https://one-factor.example.com\")\n@@ -670,6 +906,39 @@ func (s *AuthzSuite) TestShouldApplyPolicyOfOneFactorDomainWithAuthorizationHead\n \n \tmock.Ctx.Request.Header.Set(fasthttp.HeaderAuthorization, \"Basic am9objpwYXNzd29yZA==\")\n \n+\tswitch s.implementation {\n+\tcase AuthzImplLegacy:\n+\t\tbreak\n+\tdefault:\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(mock.Ctx), gomock.Eq(model.NewIP(mock.Ctx.RemoteIP()))).Return(nil, nil)\n+\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(mock.Ctx), gomock.Eq(\"john\")).Return(nil, nil)\n+\n+\t\tattempt := model.AuthenticationAttempt{\n+\t\t\tTime:          mock.Ctx.Clock.Now(),\n+\t\t\tSuccessful:    true,\n+\t\t\tBanned:        false,\n+\t\t\tUsername:      \"john\",\n+\t\t\tType:          regulation.AuthType1FA,\n+\t\t\tRemoteIP:      model.NewNullIP(mock.Ctx.RemoteIP()),\n+\t\t\tRequestURI:    \"https://one-factor.example.com\",\n+\t\t\tRequestMethod: fasthttp.MethodGet,\n+\t\t}\n+\n+\t\tswitch s.implementation {\n+\t\tcase AuthzImplExtAuthz, AuthzImplForwardAuth:\n+\t\t\tattempt.RequestURI += \"/\"\n+\t\t}\n+\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tAppendAuthenticationLog(gomock.Eq(mock.Ctx), gomock.Eq(attempt)).Return(nil)\n+\t}\n+\n \tmock.UserProviderMock.EXPECT().\n \t\tCheckUserPassword(gomock.Eq(\"john\"), gomock.Eq(\"password\")).\n \t\tReturn(true, nil)\n@@ -757,12 +1026,10 @@ func (s *AuthzSuite) TestShouldHandleAuthzWithEmptyAuthorizationHeader() {\n }\n \n func (s *AuthzSuite) TestShouldHandleAuthzWithAuthorizationHeaderInvalidPassword() {\n-\tif s.setRequest == nil {\n+\tif s.setRequest == nil || s.implementation == AuthzImplLegacy {\n \t\ts.T().Skip()\n \t}\n \n-\t// Equivalent of TestShouldVerifyAuthBasicArgFailingWrongPassword.\n-\n \tbuilder := NewAuthzBuilder().WithImplementationLegacy()\n \n \tbuilder = builder.WithStrategies(\n@@ -776,6 +1043,8 @@ func (s *AuthzSuite) TestShouldHandleAuthzWithAuthorizationHeaderInvalidPassword\n \n \tdefer mock.Close()\n \n+\tsetUpMockClock(mock)\n+\n \ts.ConfigureMockSessionProviderWithAutomaticAutheliaURLs(mock)\n \n \ttargetURI := s.RequireParseRequestURI(\"https://one-factor.example.com\")\n@@ -784,6 +1053,39 @@ func (s *AuthzSuite) TestShouldHandleAuthzWithAuthorizationHeaderInvalidPassword\n \n \tmock.Ctx.Request.Header.Set(fasthttp.HeaderAuthorization, \"Basic am9objpwYXNzd29yZA==\")\n \n+\tswitch s.implementation {\n+\tcase AuthzImplLegacy:\n+\t\tbreak\n+\tdefault:\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(mock.Ctx), gomock.Eq(model.NewIP(mock.Ctx.RemoteIP()))).Return(nil, nil)\n+\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(mock.Ctx), gomock.Eq(\"john\")).Return(nil, nil)\n+\n+\t\tattempt := model.AuthenticationAttempt{\n+\t\t\tTime:          mock.Ctx.Clock.Now(),\n+\t\t\tSuccessful:    false,\n+\t\t\tBanned:        false,\n+\t\t\tUsername:      \"john\",\n+\t\t\tType:          regulation.AuthType1FA,\n+\t\t\tRemoteIP:      model.NewNullIP(mock.Ctx.RemoteIP()),\n+\t\t\tRequestURI:    \"https://one-factor.example.com\",\n+\t\t\tRequestMethod: fasthttp.MethodGet,\n+\t\t}\n+\n+\t\tswitch s.implementation {\n+\t\tcase AuthzImplExtAuthz, AuthzImplForwardAuth:\n+\t\t\tattempt.RequestURI += \"/\"\n+\t\t}\n+\n+\t\tmock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tAppendAuthenticationLog(gomock.Eq(mock.Ctx), gomock.Eq(attempt)).Return(nil)\n+\t}\n+\n \tmock.UserProviderMock.EXPECT().\n \t\tCheckUserPassword(gomock.Eq(\"john\"), gomock.Eq(\"password\")).\n \t\tReturn(false, nil)\n@@ -844,9 +1146,7 @@ func (s *AuthzSuite) TestShouldDestroySessionWhenInactiveForTooLong() {\n \n \tdefer mock.Close()\n \n-\tmock.Ctx.Clock = &mock.Clock\n-\n-\tmock.Clock.Set(time.Now())\n+\tsetUpMockClock(mock)\n \n \tpast := mock.Clock.Now().Add(-1 * time.Hour)\n \n@@ -895,9 +1195,7 @@ func (s *AuthzSuite) TestShouldNotDestroySessionWhenInactiveForTooLongRememberMe\n \n \tdefer mock.Close()\n \n-\tmock.Ctx.Clock = &mock.Clock\n-\n-\tmock.Clock.Set(time.Now())\n+\tsetUpMockClock(mock)\n \n \tmock.Ctx.Configuration.Session.Cookies[0].Inactivity = testInactivity\n \n@@ -946,9 +1244,7 @@ func (s *AuthzSuite) TestShouldNotDestroySessionWhenNotInactiveForTooLong() {\n \n \tdefer mock.Close()\n \n-\tmock.Ctx.Clock = &mock.Clock\n-\n-\tmock.Clock.Set(time.Now())\n+\tsetUpMockClock(mock)\n \n \tmock.Ctx.Configuration.Session.Cookies[0].Inactivity = testInactivity\n \n@@ -998,9 +1294,7 @@ func (s *AuthzSuite) TestShouldUpdateInactivityTimestampEvenWhenHittingForbidden\n \n \tdefer mock.Close()\n \n-\tmock.Ctx.Clock = &mock.Clock\n-\n-\tmock.Clock.Set(time.Now())\n+\tsetUpMockClock(mock)\n \n \tmock.Ctx.Configuration.Session.Cookies[0].Inactivity = testInactivity\n \n@@ -1144,9 +1438,7 @@ func (s *AuthzSuite) TestShouldDestroySessionWhenUserDoesNotExist() {\n \n \tdefer mock.Close()\n \n-\tmock.Ctx.Clock = &mock.Clock\n-\n-\tmock.Clock.Set(time.Now())\n+\tsetUpMockClock(mock)\n \n \tmock.Ctx.Configuration.Session.Cookies[0].Inactivity = testInactivity\n \n@@ -1233,9 +1525,7 @@ func (s *AuthzSuite) TestShouldUpdateRemovedUserGroupsFromBackendAndDeny() {\n \n \tdefer mock.Close()\n \n-\tmock.Ctx.Clock = &mock.Clock\n-\n-\tmock.Clock.Set(time.Now())\n+\tsetUpMockClock(mock)\n \n \tmock.Ctx.Configuration.Session.Cookies[0].Inactivity = testInactivity\n \n@@ -1320,9 +1610,7 @@ func (s *AuthzSuite) TestShouldUpdateAddedUserGroupsFromBackendAndDeny() {\n \n \tdefer mock.Close()\n \n-\tmock.Ctx.Clock = &mock.Clock\n-\n-\tmock.Clock.Set(time.Now())\n+\tsetUpMockClock(mock)\n \n \tmock.Ctx.Configuration.Session.Cookies[0].Inactivity = testInactivity\n \n@@ -1406,9 +1694,7 @@ func (s *AuthzSuite) TestShouldCheckValidSessionUsernameHeaderAndReturn200() {\n \n \tdefer mock.Close()\n \n-\tmock.Ctx.Clock = &mock.Clock\n-\n-\tmock.Clock.Set(time.Now())\n+\tsetUpMockClock(mock)\n \n \tmock.Ctx.Configuration.Session.Cookies[0].Inactivity = testInactivity\n \n@@ -1459,9 +1745,7 @@ func (s *AuthzSuite) TestShouldCheckInvalidSessionUsernameHeaderAndReturn401AndD\n \n \tdefer mock.Close()\n \n-\tmock.Ctx.Clock = &mock.Clock\n-\n-\tmock.Clock.Set(time.Now())\n+\tsetUpMockClock(mock)\n \n \tmock.Ctx.Configuration.Session.Cookies[0].Inactivity = testInactivity\n \n@@ -1530,9 +1814,7 @@ func (s *AuthzSuite) TestShouldNotRedirectRequestsForBypassACLWhenInactiveForToo\n \n \tdefer mock.Close()\n \n-\tmock.Ctx.Clock = &mock.Clock\n-\n-\tmock.Clock.Set(time.Now())\n+\tsetUpMockClock(mock)\n \n \tpast := mock.Clock.Now().Add(-24 * time.Hour)\n \n@@ -1652,3 +1934,8 @@ type urlpair struct {\n \tTargetURI   *url.URL\n \tAutheliaURI *url.URL\n }\n+\n+func setUpMockClock(mock *mocks.MockAutheliaCtx) {\n+\tmock.Ctx.Clock = &mock.Clock\n+\tmock.Clock.Set(time.Now())\n+}\ndiff --git a/internal/handlers/handler_firstfactor_passkey_test.go b/internal/handlers/handler_firstfactor_passkey_test.go\nindex 82723430411b0..16f3a377510c6 100644\n--- a/internal/handlers/handler_firstfactor_passkey_test.go\n+++ b/internal/handlers/handler_firstfactor_passkey_test.go\n@@ -20,6 +20,7 @@ import (\n \t\"github.com/authelia/authelia/v4/internal/configuration/schema\"\n \t\"github.com/authelia/authelia/v4/internal/mocks\"\n \t\"github.com/authelia/authelia/v4/internal/model\"\n+\t\"github.com/authelia/authelia/v4/internal/regulation\"\n \t\"github.com/authelia/authelia/v4/internal/session\"\n )\n \n@@ -369,7 +370,7 @@ func TestFirstFactorPasskeyPOST(t *testing.T) {\n \t\t\t\t\t\t\tSuccessful: true,\n \t\t\t\t\t\t\tBanned:     false,\n \t\t\t\t\t\t\tUsername:   testUsername,\n-\t\t\t\t\t\t\tType:       \"Passkey\",\n+\t\t\t\t\t\t\tType:       regulation.AuthTypePasskey,\n \t\t\t\t\t\t\tRemoteIP:   model.NullIP{IP: net.ParseIP(\"0.0.0.0\")},\n \t\t\t\t\t\t})).\n \t\t\t\t\t\tReturn(nil),\n@@ -580,7 +581,7 @@ func TestFirstFactorPasskeyPOST(t *testing.T) {\n \t\t\t\t)\n \t\t\t},\n \t\t\thave:           dataReqGood,\n-\t\t\texpectedStatus: fasthttp.StatusForbidden,\n+\t\t\texpectedStatus: fasthttp.StatusOK,\n \t\t\texpectedf: func(t *testing.T, mock *mocks.MockAutheliaCtx) {\n \t\t\t\tus, err := mock.Ctx.GetSession()\n \n@@ -588,7 +589,7 @@ func TestFirstFactorPasskeyPOST(t *testing.T) {\n \n \t\t\t\tassert.Nil(t, us.WebAuthn)\n \n-\t\t\t\tAssertLogEntryMessageAndError(t, mock.Hook.LastEntry(), \"Error occurred validating a WebAuthn passkey authentication challenge for user 'john': error occurred recording the authentication attempt\", \"error marking auth\")\n+\t\t\t\tAssertLogEntryMessageAndError(t, mock.Hook.LastEntry(), \"Failed to record Passkey authentication attempt\", \"error marking auth\")\n \t\t\t},\n \t\t},\n \t\t{\ndiff --git a/internal/handlers/handler_firstfactor_password_test.go b/internal/handlers/handler_firstfactor_password_test.go\nindex 742ac801ef6cc..2b6830af73893 100644\n--- a/internal/handlers/handler_firstfactor_password_test.go\n+++ b/internal/handlers/handler_firstfactor_password_test.go\n@@ -69,7 +69,7 @@ func (s *FirstFactorSuite) TestShouldFailIfUserProviderCheckPasswordFail() {\n \ts.mock.StorageMock.\n \t\tEXPECT().\n \t\tAppendAuthenticationLog(s.mock.Ctx, gomock.Eq(model.AuthenticationAttempt{\n-\t\t\tUsername:   testValue,\n+\t\t\tUsername:   \"test\",\n \t\t\tSuccessful: false,\n \t\t\tBanned:     false,\n \t\t\tTime:       s.mock.Clock.Now(),\n@@ -77,6 +77,16 @@ func (s *FirstFactorSuite) TestShouldFailIfUserProviderCheckPasswordFail() {\n \t\t\tRemoteIP:   model.NewNullIPFromString(\"0.0.0.0\"),\n \t\t}))\n \n+\tgomock.InOrder(\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil),\n+\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(\"test\")).Return(nil, nil),\n+\t)\n+\n \ts.mock.Ctx.Request.SetBodyString(`{\n \t\t\"username\": \"test\",\n \t\t\"password\": \"hello\",\n@@ -90,71 +100,32 @@ func (s *FirstFactorSuite) TestShouldFailIfUserProviderCheckPasswordFail() {\n }\n \n func (s *FirstFactorSuite) TestShouldCheckAuthenticationIsNotMarkedWhenProviderCheckPasswordError() {\n-\ts.mock.UserProviderMock.\n-\t\tEXPECT().\n-\t\tGetDetails(gomock.Eq(\"test\")).\n-\t\tReturn(&authentication.UserDetails{Username: \"test\"}, nil)\n-\n-\ts.mock.UserProviderMock.\n-\t\tEXPECT().\n-\t\tCheckUserPassword(gomock.Eq(testValue), gomock.Eq(\"hello\")).\n-\t\tReturn(false, fmt.Errorf(\"invalid credentials\"))\n-\n-\ts.mock.StorageMock.\n-\t\tEXPECT().\n-\t\tAppendAuthenticationLog(s.mock.Ctx, gomock.Eq(model.AuthenticationAttempt{\n-\t\t\tUsername:   testValue,\n-\t\t\tSuccessful: false,\n-\t\t\tBanned:     false,\n-\t\t\tTime:       s.mock.Clock.Now(),\n-\t\t\tType:       regulation.AuthType1FA,\n-\t\t\tRemoteIP:   model.NewNullIPFromString(\"0.0.0.0\"),\n-\t\t}))\n-\n-\ts.mock.Ctx.Request.SetBodyString(`{\n-\t\t\"username\": \"test\",\n-\t\t\"password\": \"hello\",\n-\t\t\"keepMeLoggedIn\": true\n-\t}`)\n-\n-\tFirstFactorPasswordPOST(nil)(s.mock.Ctx)\n-}\n-\n-func (s *FirstFactorSuite) TestShouldCheckUserNotBanned() {\n-\ts.mock.Ctx.Providers.Regulator = regulation.NewRegulator(schema.Regulation{MaxRetries: 2}, s.mock.StorageMock, &s.mock.Clock)\n-\n-\ts.mock.Ctx.Request.SetBodyString(`{\n-\t\t\"username\": \"test\",\n-\t\t\"password\": \"hello\",\n-\t\t\"keepMeLoggedIn\": true\n-\t}`)\n-\n \tgomock.InOrder(\n-\t\ts.mock.UserProviderMock.EXPECT().GetDetails(testValue).Return(&authentication.UserDetails{Username: testValue}, nil),\n-\t\ts.mock.StorageMock.EXPECT().\n-\t\t\tLoadAuthenticationLogs(gomock.Eq(s.mock.Ctx), testValue, gomock.Any(), gomock.Any(), gomock.Any()).\n-\t\t\tReturn(nil, nil),\n-\n+\t\ts.mock.UserProviderMock.\n+\t\t\tEXPECT().\n+\t\t\tGetDetails(gomock.Eq(\"test\")).\n+\t\t\tReturn(&authentication.UserDetails{Username: testValue}, nil),\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil),\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(testValue)).Return(nil, nil),\n \t\ts.mock.UserProviderMock.\n \t\t\tEXPECT().\n \t\t\tCheckUserPassword(gomock.Eq(testValue), gomock.Eq(\"hello\")).\n \t\t\tReturn(false, fmt.Errorf(\"invalid credentials\")),\n-\n \t\ts.mock.StorageMock.\n \t\t\tEXPECT().\n-\t\t\tAppendAuthenticationLog(gomock.Eq(s.mock.Ctx), gomock.Eq(model.AuthenticationAttempt{\n-\t\t\t\tUsername:   testValue,\n+\t\t\tAppendAuthenticationLog(s.mock.Ctx, gomock.Eq(model.AuthenticationAttempt{\n+\t\t\t\tUsername:   \"test\",\n \t\t\t\tSuccessful: false,\n \t\t\t\tBanned:     false,\n \t\t\t\tTime:       s.mock.Clock.Now(),\n \t\t\t\tType:       regulation.AuthType1FA,\n \t\t\t\tRemoteIP:   model.NewNullIPFromString(\"0.0.0.0\"),\n-\t\t\t})))\n-\tFirstFactorPasswordPOST(nil)(s.mock.Ctx)\n-}\n-\n-func (s *FirstFactorSuite) TestShouldCheckBannedUser() {\n-\ts.mock.Ctx.Providers.Regulator = regulation.NewRegulator(schema.Regulation{MaxRetries: 2, FindTime: time.Hour, BanTime: time.Hour}, s.mock.StorageMock, &s.mock.Clock)\n+\t\t\t})),\n+\t)\n \n \ts.mock.Ctx.Request.SetBodyString(`{\n \t\t\"username\": \"test\",\n@@ -162,39 +133,21 @@ func (s *FirstFactorSuite) TestShouldCheckBannedUser() {\n \t\t\"keepMeLoggedIn\": true\n \t}`)\n \n-\tgomock.InOrder(\n-\t\ts.mock.UserProviderMock.EXPECT().GetDetails(testValue).Return(&authentication.UserDetails{Username: testValue}, nil),\n-\t\ts.mock.StorageMock.EXPECT().\n-\t\t\tLoadAuthenticationLogs(gomock.Eq(s.mock.Ctx), testValue, gomock.Any(), gomock.Any(), gomock.Any()).\n-\t\t\tReturn([]model.AuthenticationAttempt{\n-\t\t\t\t{Successful: false, Time: s.mock.Clock.Now().Add(-time.Second)},\n-\t\t\t\t{Successful: false, Time: s.mock.Clock.Now().Add(-time.Second)},\n-\t\t\t\t{Successful: false, Time: s.mock.Clock.Now().Add(-time.Second)},\n-\t\t\t\t{Successful: false, Time: s.mock.Clock.Now().Add(-time.Second)},\n-\t\t\t}, nil),\n-\n-\t\ts.mock.StorageMock.\n-\t\t\tEXPECT().\n-\t\t\tAppendAuthenticationLog(gomock.Eq(s.mock.Ctx), gomock.Eq(model.AuthenticationAttempt{\n-\t\t\t\tUsername:   testValue,\n-\t\t\t\tSuccessful: false,\n-\t\t\t\tBanned:     true,\n-\t\t\t\tTime:       s.mock.Clock.Now(),\n-\t\t\t\tType:       regulation.AuthType1FA,\n-\t\t\t\tRemoteIP:   model.NewNullIPFromString(\"0.0.0.0\"),\n-\t\t\t})))\n-\n \tFirstFactorPasswordPOST(nil)(s.mock.Ctx)\n \n-\ts.mock.AssertLastLogMessage(s.T(), \"Unsuccessful 1FA authentication attempt by user 'test' and they are banned until 2013-02-03 00:59:59 +0000 UTC\", \"\")\n+\ts.mock.AssertLastLogMessage(s.T(), \"Unsuccessful 1FA authentication attempt by user 'test'\", \"invalid credentials\")\n \ts.mock.Assert401KO(s.T(), \"Authentication failed. Check your credentials.\")\n }\n \n func (s *FirstFactorSuite) TestShouldCheckAuthenticationIsMarkedWhenInvalidCredentials() {\n \ts.mock.UserProviderMock.\n \t\tEXPECT().\n-\t\tGetDetails(gomock.Eq(\"test\")).\n-\t\tReturn(&authentication.UserDetails{Username: \"test\"}, nil)\n+\t\tGetDetails(gomock.Eq(testValue)).\n+\t\tReturn(&authentication.UserDetails{\n+\t\t\tUsername: \"test\",\n+\t\t\tEmails:   []string{\"test@example.com\"},\n+\t\t\tGroups:   []string{\"dev\", \"admins\"},\n+\t\t}, nil)\n \n \ts.mock.UserProviderMock.\n \t\tEXPECT().\n@@ -212,6 +165,14 @@ func (s *FirstFactorSuite) TestShouldCheckAuthenticationIsMarkedWhenInvalidCrede\n \t\t\tRemoteIP:   model.NewNullIPFromString(\"0.0.0.0\"),\n \t\t}))\n \n+\ts.mock.StorageMock.\n+\t\tEXPECT().\n+\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil)\n+\n+\ts.mock.StorageMock.\n+\t\tEXPECT().\n+\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(\"test\")).Return(nil, nil)\n+\n \ts.mock.Ctx.Request.SetBodyString(`{\n \t\t\"username\": \"test\",\n \t\t\"password\": \"hello\",\n@@ -232,28 +193,37 @@ func (s *FirstFactorSuite) TestShouldFailIfUserProviderGetDetailsFail() {\n \t\t\"password\": \"hello\",\n \t\t\"keepMeLoggedIn\": true\n \t}`)\n-\n \tFirstFactorPasswordPOST(nil)(s.mock.Ctx)\n \n-\tAssertLogEntryMessageAndError(s.T(), s.mock.Hook.LastEntry(), \"Error occurred getting details for user with username input 'test' which usually indicates they do not exist\", \"failed\")\n+\ts.mock.AssertLastLogMessage(s.T(), \"Error occurred getting details for user with username input 'test' which usually indicates they do not exist\", \"failed\")\n \ts.mock.Assert401KO(s.T(), \"Authentication failed. Check your credentials.\")\n }\n \n-func (s *FirstFactorSuite) TestShouldFailIfAuthenticationMarkFail() {\n-\ts.mock.UserProviderMock.\n-\t\tEXPECT().\n-\t\tGetDetails(gomock.Eq(\"test\")).\n-\t\tReturn(&authentication.UserDetails{Username: \"test\"}, nil)\n-\n-\ts.mock.UserProviderMock.\n-\t\tEXPECT().\n-\t\tCheckUserPassword(gomock.Eq(testValue), gomock.Eq(\"hello\")).\n-\t\tReturn(true, nil)\n-\n-\ts.mock.StorageMock.\n-\t\tEXPECT().\n-\t\tAppendAuthenticationLog(s.mock.Ctx, gomock.Any()).\n-\t\tReturn(fmt.Errorf(\"failed\"))\n+func (s *FirstFactorSuite) TestShouldNotFailIfAuthenticationMarkFail() {\n+\tgomock.InOrder(\n+\t\ts.mock.UserProviderMock.\n+\t\t\tEXPECT().\n+\t\t\tGetDetails(gomock.Eq(\"test\")).\n+\t\t\tReturn(&authentication.UserDetails{\n+\t\t\t\tUsername: \"test\",\n+\t\t\t\tEmails:   []string{\"test@example.com\"},\n+\t\t\t\tGroups:   []string{\"dev\", \"admins\"},\n+\t\t\t}, nil),\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil),\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(testValue)).Return(nil, nil),\n+\t\ts.mock.UserProviderMock.\n+\t\t\tEXPECT().\n+\t\t\tCheckUserPassword(gomock.Eq(testValue), gomock.Eq(\"hello\")).\n+\t\t\tReturn(true, nil),\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tAppendAuthenticationLog(s.mock.Ctx, gomock.Any()).\n+\t\t\tReturn(fmt.Errorf(\"failed\")),\n+\t)\n \n \ts.mock.Ctx.Request.SetBodyString(`{\n \t\t\"username\": \"test\",\n@@ -262,8 +232,8 @@ func (s *FirstFactorSuite) TestShouldFailIfAuthenticationMarkFail() {\n \t}`)\n \tFirstFactorPasswordPOST(nil)(s.mock.Ctx)\n \n-\ts.mock.AssertLastLogMessage(s.T(), \"Unable to mark 1FA authentication attempt by user 'test'\", \"failed\")\n-\ts.mock.Assert401KO(s.T(), \"Authentication failed. Check your credentials.\")\n+\ts.mock.AssertLastLogMessage(s.T(), \"Failed to record 1FA authentication attempt\", \"failed\")\n+\ts.mock.Assert200OK(s.T(), nil)\n }\n \n func (s *FirstFactorSuite) TestShouldAuthenticateUserWithRememberMeChecked() {\n@@ -281,6 +251,14 @@ func (s *FirstFactorSuite) TestShouldAuthenticateUserWithRememberMeChecked() {\n \t\t\tGroups:   []string{\"dev\", \"admins\"},\n \t\t}, nil)\n \n+\ts.mock.StorageMock.\n+\t\tEXPECT().\n+\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil)\n+\n+\ts.mock.StorageMock.\n+\t\tEXPECT().\n+\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(\"test\")).Return(nil, nil)\n+\n \ts.mock.StorageMock.\n \t\tEXPECT().\n \t\tAppendAuthenticationLog(s.mock.Ctx, gomock.Any()).\n@@ -302,7 +280,7 @@ func (s *FirstFactorSuite) TestShouldAuthenticateUserWithRememberMeChecked() {\n \n \tassert.Equal(s.T(), testValue, userSession.Username)\n \tassert.Equal(s.T(), true, userSession.KeepMeLoggedIn)\n-\tassert.Equal(s.T(), authentication.OneFactor, userSession.AuthenticationLevel(false))\n+\tassert.Equal(s.T(), authentication.OneFactor, userSession.AuthenticationLevel(s.mock.Ctx.Configuration.WebAuthn.EnablePasskey2FA))\n \tassert.Equal(s.T(), []string{\"test@example.com\"}, userSession.Emails)\n \tassert.Equal(s.T(), []string{\"dev\", \"admins\"}, userSession.Groups)\n }\n@@ -322,6 +300,14 @@ func (s *FirstFactorSuite) TestShouldAuthenticateUserWithRememberMeUnchecked() {\n \t\t\tGroups:   []string{\"dev\", \"admins\"},\n \t\t}, nil)\n \n+\ts.mock.StorageMock.\n+\t\tEXPECT().\n+\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil)\n+\n+\ts.mock.StorageMock.\n+\t\tEXPECT().\n+\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(testValue)).Return(nil, nil)\n+\n \ts.mock.StorageMock.\n \t\tEXPECT().\n \t\tAppendAuthenticationLog(s.mock.Ctx, gomock.Any()).\n@@ -344,54 +330,12 @@ func (s *FirstFactorSuite) TestShouldAuthenticateUserWithRememberMeUnchecked() {\n \n \tassert.Equal(s.T(), testValue, userSession.Username)\n \tassert.Equal(s.T(), false, userSession.KeepMeLoggedIn)\n-\tassert.Equal(s.T(), authentication.OneFactor, userSession.AuthenticationLevel(false))\n+\tassert.Equal(s.T(), authentication.OneFactor, userSession.AuthenticationLevel(s.mock.Ctx.Configuration.WebAuthn.EnablePasskey2FA))\n \tassert.Equal(s.T(), []string{\"test@example.com\"}, userSession.Emails)\n \tassert.Equal(s.T(), []string{\"dev\", \"admins\"}, userSession.Groups)\n }\n \n-func (s *FirstFactorSuite) TestShouldAuthenticateUserWithEmailAsUsernameInput() {\n-\tgomock.InOrder(\n-\t\ts.mock.UserProviderMock.\n-\t\t\tEXPECT().\n-\t\t\tGetDetails(gomock.Eq(\"test@example.com\")).\n-\t\t\tReturn(&authentication.UserDetails{\n-\t\t\t\tUsername: \"test\",\n-\t\t\t\tEmails:   []string{\"test@example.com\"},\n-\t\t\t\tGroups:   []string{\"dev\", \"admins\"},\n-\t\t\t}, nil),\n-\t\ts.mock.UserProviderMock.\n-\t\t\tEXPECT().\n-\t\t\tCheckUserPassword(gomock.Eq(\"test\"), gomock.Eq(\"hello\")).\n-\t\t\tReturn(true, nil),\n-\t\ts.mock.StorageMock.\n-\t\t\tEXPECT().\n-\t\t\tAppendAuthenticationLog(s.mock.Ctx, gomock.Eq(model.AuthenticationAttempt{Time: s.mock.Clock.Now(), Successful: true, Username: \"test\", Type: regulation.AuthType1FA, RemoteIP: model.NewNullIP(s.mock.Ctx.RemoteIP())})).\n-\t\t\tReturn(nil),\n-\t)\n-\n-\ts.mock.Ctx.Request.SetBodyString(`{\"username\":\"test@example.com\",\"password\":\"hello\",\"requestMethod\":\"GET\",\"keepMeLoggedIn\":false}`)\n-\tFirstFactorPasswordPOST(nil)(s.mock.Ctx)\n-\n-\t// Respond with 200.\n-\ts.Equal(fasthttp.StatusOK, s.mock.Ctx.Response.StatusCode())\n-\ts.Equal([]byte(\"{\\\"status\\\":\\\"OK\\\"}\"), s.mock.Ctx.Response.Body())\n-\n-\tuserSession, err := s.mock.Ctx.GetSession()\n-\ts.Assert().NoError(err)\n-\n-\ts.Equal(testValue, userSession.Username)\n-\ts.Equal(false, userSession.KeepMeLoggedIn)\n-\ts.Equal(authentication.OneFactor, userSession.AuthenticationLevel(false))\n-\ts.Equal([]string{\"test@example.com\"}, userSession.Emails)\n-\ts.Equal([]string{\"dev\", \"admins\"}, userSession.Groups)\n-}\n-\n func (s *FirstFactorSuite) TestShouldSaveUsernameFromAuthenticationBackendInSession() {\n-\ts.mock.UserProviderMock.\n-\t\tEXPECT().\n-\t\tCheckUserPassword(gomock.Eq(\"Test\"), gomock.Eq(\"hello\")).\n-\t\tReturn(true, nil)\n-\n \ts.mock.UserProviderMock.\n \t\tEXPECT().\n \t\tGetDetails(gomock.Eq(testValue)).\n@@ -404,6 +348,19 @@ func (s *FirstFactorSuite) TestShouldSaveUsernameFromAuthenticationBackendInSess\n \t\t\tGroups:   []string{\"dev\", \"admins\"},\n \t\t}, nil)\n \n+\ts.mock.StorageMock.\n+\t\tEXPECT().\n+\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil)\n+\n+\ts.mock.StorageMock.\n+\t\tEXPECT().\n+\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(\"Test\")).Return(nil, nil)\n+\n+\ts.mock.UserProviderMock.\n+\t\tEXPECT().\n+\t\tCheckUserPassword(gomock.Eq(\"Test\"), gomock.Eq(\"hello\")).\n+\t\tReturn(true, nil)\n+\n \ts.mock.StorageMock.\n \t\tEXPECT().\n \t\tAppendAuthenticationLog(s.mock.Ctx, gomock.Any()).\n@@ -415,6 +372,7 @@ func (s *FirstFactorSuite) TestShouldSaveUsernameFromAuthenticationBackendInSess\n \t\t\"requestMethod\": \"GET\",\n \t\t\"keepMeLoggedIn\": true\n \t}`)\n+\n \tFirstFactorPasswordPOST(nil)(s.mock.Ctx)\n \n \t// Respond with 200.\n@@ -426,7 +384,7 @@ func (s *FirstFactorSuite) TestShouldSaveUsernameFromAuthenticationBackendInSess\n \n \tassert.Equal(s.T(), \"Test\", userSession.Username)\n \tassert.Equal(s.T(), true, userSession.KeepMeLoggedIn)\n-\tassert.Equal(s.T(), authentication.OneFactor, userSession.AuthenticationLevel(false))\n+\tassert.Equal(s.T(), authentication.OneFactor, userSession.AuthenticationLevel(s.mock.Ctx.Configuration.WebAuthn.EnablePasskey2FA))\n \tassert.Equal(s.T(), []string{\"test@example.com\"}, userSession.Emails)\n \tassert.Equal(s.T(), []string{\"dev\", \"admins\"}, userSession.Groups)\n }\n@@ -483,6 +441,14 @@ func (s *FirstFactorRedirectionSuite) TearDownTest() {\n //\n //\tthe user should be redirected to the default url.\n func (s *FirstFactorRedirectionSuite) TestShouldRedirectToDefaultURLWhenNoTargetURLProvidedAndTwoFactorDisabled() {\n+\ts.mock.StorageMock.\n+\t\tEXPECT().\n+\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil)\n+\n+\ts.mock.StorageMock.\n+\t\tEXPECT().\n+\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(testValue)).Return(nil, nil)\n+\n \ts.mock.Ctx.Request.SetBodyString(`{\n \t\t\"username\": \"test\",\n \t\t\"password\": \"hello\",\n@@ -505,6 +471,14 @@ func (s *FirstFactorRedirectionSuite) TestShouldRedirectToDefaultURLWhenNoTarget\n //\n //\tthe user should be redirected to the default url.\n func (s *FirstFactorRedirectionSuite) TestShouldRedirectToDefaultURLWhenURLIsUnsafeAndTwoFactorDisabled() {\n+\ts.mock.StorageMock.\n+\t\tEXPECT().\n+\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil)\n+\n+\ts.mock.StorageMock.\n+\t\tEXPECT().\n+\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(testValue)).Return(nil, nil)\n+\n \ts.mock.Ctx.Request.SetBodyString(`{\n \t\t\"username\": \"test\",\n \t\t\"password\": \"hello\",\n@@ -527,6 +501,14 @@ func (s *FirstFactorRedirectionSuite) TestShouldRedirectToDefaultURLWhenURLIsUns\n //\n //\tthe user should receive 200 without redirection URL.\n func (s *FirstFactorRedirectionSuite) TestShouldReply200WhenNoTargetURLProvidedAndTwoFactorEnabled() {\n+\ts.mock.StorageMock.\n+\t\tEXPECT().\n+\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil)\n+\n+\ts.mock.StorageMock.\n+\t\tEXPECT().\n+\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(testValue)).Return(nil, nil)\n+\n \ts.mock.Ctx.Providers.Authorizer = authorization.NewAuthorizer(&schema.Configuration{\n \t\tAccessControl: schema.AccessControl{\n \t\t\tDefaultPolicy: \"two_factor\",\n@@ -553,6 +535,14 @@ func (s *FirstFactorRedirectionSuite) TestShouldReply200WhenNoTargetURLProvidedA\n //\n //\tthe user should receive 200 without redirection URL.\n func (s *FirstFactorRedirectionSuite) TestShouldReply200WhenUnsafeTargetURLProvidedAndTwoFactorEnabled() {\n+\ts.mock.StorageMock.\n+\t\tEXPECT().\n+\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil)\n+\n+\ts.mock.StorageMock.\n+\t\tEXPECT().\n+\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(testValue)).Return(nil, nil)\n+\n \ts.mock.Ctx.Providers.Authorizer = authorization.NewAuthorizer(&schema.Configuration{\n \t\tAccessControl: schema.AccessControl{\n \t\t\tDefaultPolicy: \"one_factor\",\n@@ -603,6 +593,14 @@ func (s *FirstFactorRedirectionSuite) TestShouldReplyWhenBadTargetURL() {\n \t\t\"targetURL\": \"#https://23kjnm412jk3\"\n \t}`)\n \n+\ts.mock.StorageMock.\n+\t\tEXPECT().\n+\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil)\n+\n+\ts.mock.StorageMock.\n+\t\tEXPECT().\n+\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(testValue)).Return(nil, nil)\n+\n \tFirstFactorPasswordPOST(nil)(s.mock.Ctx)\n \n \t// Respond with 200.\n@@ -632,6 +630,16 @@ func (s *FirstFactorRedirectionSuite) TestShouldReplyTwoFactorOK() {\n \t\t\"targetURL\": \"https://two-factor.example.com\"\n \t}`)\n \n+\tgomock.InOrder(\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil),\n+\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(testValue)).Return(nil, nil),\n+\t)\n+\n \tFirstFactorPasswordPOST(nil)(s.mock.Ctx)\n \n \t// Respond with 200.\n@@ -661,6 +669,16 @@ func (s *FirstFactorRedirectionSuite) TestShouldReplyTwoTwoFactorUnsafe() {\n \t\t\"targetURL\": \"https://unsafe-domain.com\"\n \t}`)\n \n+\tgomock.InOrder(\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil),\n+\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(testValue)).Return(nil, nil),\n+\t)\n+\n \tFirstFactorPasswordPOST(nil)(s.mock.Ctx)\n \n \t// Respond with 200.\n@@ -690,6 +708,16 @@ func (s *FirstFactorRedirectionSuite) TestShouldReplyTwoTwoFactorSafe() {\n \t\t\"targetURL\": \"https://test.example.com\"\n \t}`)\n \n+\tgomock.InOrder(\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil),\n+\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(testValue)).Return(nil, nil),\n+\t)\n+\n \tFirstFactorPasswordPOST(nil)(s.mock.Ctx)\n \n \t// Respond with 200.\n@@ -721,6 +749,15 @@ func (s *FirstFactorRedirectionSuite) TestShouldReplyOpenIDConnectCantParseUUID(\n \t\t\"workflowID\": \"aaaaaaaaaaaaaaaaaaaaaaaaaaa-9107-4067-8d31-407ca59eb69c\"\n \t}`)\n \n+\tgomock.InOrder(\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil),\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(testValue)).Return(nil, nil),\n+\t)\n+\n \tFirstFactorPasswordPOST(nil)(s.mock.Ctx)\n \n \t// Respond with 200.\n@@ -753,6 +790,12 @@ func (s *FirstFactorRedirectionSuite) TestShouldReplyOpenIDConnectCantGetConsent\n \t}`)\n \n \tgomock.InOrder(\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil),\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(testValue)).Return(nil, nil),\n \t\ts.mock.StorageMock.EXPECT().\n \t\t\tLoadOAuth2ConsentSessionByChallengeID(gomock.Eq(s.mock.Ctx), gomock.Eq(uuid.Must(uuid.Parse(\"d1ba0ad8-9107-4067-8d31-407ca59eb69c\")))).\n \t\t\tReturn(nil, fmt.Errorf(\"failed to obtain\")),\n@@ -790,6 +833,12 @@ func (s *FirstFactorRedirectionSuite) TestShouldReplyOpenIDConnectConsentSession\n \t}`)\n \n \tgomock.InOrder(\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil),\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(testValue)).Return(nil, nil),\n \t\ts.mock.StorageMock.EXPECT().\n \t\t\tLoadOAuth2ConsentSessionByChallengeID(gomock.Eq(s.mock.Ctx), gomock.Eq(uuid.Must(uuid.Parse(\"d1ba0ad8-9107-4067-8d31-407ca59eb69c\")))).\n \t\t\tReturn(&model.OAuth2ConsentSession{RespondedAt: sql.NullTime{Valid: true, Time: time.Now().Add(-time.Minute)}}, nil),\n@@ -830,6 +879,12 @@ func (s *FirstFactorRedirectionSuite) TestShouldReplyOpenIDConnectCantGetClient(\n \t}`)\n \n \tgomock.InOrder(\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil),\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(testValue)).Return(nil, nil),\n \t\ts.mock.StorageMock.EXPECT().\n \t\t\tLoadOAuth2ConsentSessionByChallengeID(gomock.Eq(s.mock.Ctx), gomock.Eq(uuid.Must(uuid.Parse(\"d1ba0ad8-9107-4067-8d31-407ca59eb69c\")))).\n \t\t\tReturn(&model.OAuth2ConsentSession{ClientID: \"abc\"}, nil),\n@@ -882,6 +937,12 @@ func (s *FirstFactorRedirectionSuite) TestShouldReplyOpenIDConnectNoOpaqueID() {\n \t}`)\n \n \tgomock.InOrder(\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil),\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(testValue)).Return(nil, nil),\n \t\ts.mock.StorageMock.EXPECT().\n \t\t\tLoadOAuth2ConsentSessionByChallengeID(gomock.Eq(s.mock.Ctx), gomock.Eq(uuid.Must(uuid.Parse(\"d1ba0ad8-9107-4067-8d31-407ca59eb69c\")))).\n \t\t\tReturn(&model.OAuth2ConsentSession{ClientID: \"abc\"}, nil),\n@@ -937,6 +998,12 @@ func (s *FirstFactorRedirectionSuite) TestShouldReplyOpenIDConnectNoOpaqueIDCrea\n \t}`)\n \n \tgomock.InOrder(\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil),\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(testValue)).Return(nil, nil),\n \t\ts.mock.StorageMock.EXPECT().\n \t\t\tLoadOAuth2ConsentSessionByChallengeID(gomock.Eq(s.mock.Ctx), gomock.Eq(uuid.Must(uuid.Parse(\"d1ba0ad8-9107-4067-8d31-407ca59eb69c\")))).\n \t\t\tReturn(&model.OAuth2ConsentSession{ClientID: \"abc\"}, nil),\n@@ -995,6 +1062,12 @@ func (s *FirstFactorRedirectionSuite) TestShouldReplyOpenIDConnectNoOpaqueIDCrea\n \t}`)\n \n \tgomock.InOrder(\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil),\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(testValue)).Return(nil, nil),\n \t\ts.mock.StorageMock.EXPECT().\n \t\t\tLoadOAuth2ConsentSessionByChallengeID(gomock.Eq(s.mock.Ctx), gomock.Eq(uuid.Must(uuid.Parse(\"d1ba0ad8-9107-4067-8d31-407ca59eb69c\")))).\n \t\t\tReturn(&model.OAuth2ConsentSession{ClientID: \"abc\"}, nil),\n@@ -1060,6 +1133,12 @@ func (s *FirstFactorRedirectionSuite) TestShouldReplyOpenIDConnectFormRequiresLo\n \t}\n \n \tgomock.InOrder(\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil),\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(testValue)).Return(nil, nil),\n \t\ts.mock.StorageMock.EXPECT().\n \t\t\tLoadOAuth2ConsentSessionByChallengeID(gomock.Eq(s.mock.Ctx), gomock.Eq(uuid.Must(uuid.Parse(\"d1ba0ad8-9107-4067-8d31-407ca59eb69c\")))).\n \t\t\tReturn(&model.OAuth2ConsentSession{ClientID: \"abc\", Form: form.Encode()}, nil),\n@@ -1120,6 +1199,12 @@ func (s *FirstFactorRedirectionSuite) TestShouldReplyOpenIDConnectFormRequiresLo\n \t}`)\n \n \tgomock.InOrder(\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil),\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(testValue)).Return(nil, nil),\n \t\ts.mock.StorageMock.EXPECT().\n \t\t\tLoadOAuth2ConsentSessionByChallengeID(gomock.Eq(s.mock.Ctx), gomock.Eq(uuid.Must(uuid.Parse(\"d1ba0ad8-9107-4067-8d31-407ca59eb69c\")))).\n \t\t\tReturn(&model.OAuth2ConsentSession{ClientID: \"abc\", Form: \"1238y12978y189gb128g1287g12807g128702g38172%1\"}, nil),\n@@ -1182,6 +1267,12 @@ func (s *FirstFactorRedirectionSuite) TestShouldReplyOpenIDConnectNeeds2FA() {\n \t}`)\n \n \tgomock.InOrder(\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil),\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(testValue)).Return(nil, nil),\n \t\ts.mock.StorageMock.EXPECT().\n \t\t\tLoadOAuth2ConsentSessionByChallengeID(gomock.Eq(s.mock.Ctx), gomock.Eq(uuid.Must(uuid.Parse(\"d1ba0ad8-9107-4067-8d31-407ca59eb69c\")))).\n \t\t\tReturn(&model.OAuth2ConsentSession{ClientID: \"abc\", Form: \"\"}, nil),\n@@ -1244,6 +1335,12 @@ func (s *FirstFactorRedirectionSuite) TestShouldReplyOpenIDConnectNeeds1FA() {\n \t}`)\n \n \tgomock.InOrder(\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil),\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(testValue)).Return(nil, nil),\n \t\ts.mock.StorageMock.EXPECT().\n \t\t\tLoadOAuth2ConsentSessionByChallengeID(gomock.Eq(s.mock.Ctx), gomock.Eq(uuid.Must(uuid.Parse(\"d1ba0ad8-9107-4067-8d31-407ca59eb69c\")))).\n \t\t\tReturn(&model.OAuth2ConsentSession{ClientID: \"abc\", Form: \"grant_type=authorization_code\"}, nil),\n@@ -1277,7 +1374,7 @@ func (s *FirstFactorReauthenticateSuite) SetupTest() {\n \n \ts.Require().NoError(err)\n \n-\tsession.SetOneFactorPassword(s.mock.Ctx.Clock.Now(), &authentication.UserDetails{Username: testValue}, false)\n+\tsession.SetOneFactorPasskey(s.mock.Ctx.Clock.Now(), &authentication.UserDetails{Username: testValue}, false, false, false, false)\n \n \ts.Require().NoError(s.mock.Ctx.SaveSession(session))\n }\n@@ -1366,10 +1463,6 @@ func (s *FirstFactorReauthenticateSuite) TestShouldCheckUserNotBanned() {\n \t}`)\n \n \tgomock.InOrder(\n-\t\ts.mock.StorageMock.EXPECT().\n-\t\t\tLoadAuthenticationLogs(gomock.Eq(s.mock.Ctx), testValue, gomock.Any(), gomock.Any(), gomock.Any()).\n-\t\t\tReturn(nil, nil),\n-\n \t\ts.mock.UserProviderMock.\n \t\t\tEXPECT().\n \t\t\tCheckUserPassword(gomock.Eq(testValue), gomock.Eq(\"hello\")).\n@@ -1399,14 +1492,16 @@ func (s *FirstFactorReauthenticateSuite) TestShouldCheckBannedUser() {\n \t}`)\n \n \tgomock.InOrder(\n-\t\ts.mock.StorageMock.EXPECT().\n-\t\t\tLoadAuthenticationLogs(gomock.Eq(s.mock.Ctx), testValue, gomock.Any(), gomock.Any(), gomock.Any()).\n-\t\t\tReturn([]model.AuthenticationAttempt{\n-\t\t\t\t{Successful: false, Time: s.mock.Clock.Now().Add(-time.Second)},\n-\t\t\t\t{Successful: false, Time: s.mock.Clock.Now().Add(-time.Second)},\n-\t\t\t\t{Successful: false, Time: s.mock.Clock.Now().Add(-time.Second)},\n-\t\t\t\t{Successful: false, Time: s.mock.Clock.Now().Add(-time.Second)},\n-\t\t\t}, nil),\n+\t\t/*\n+\t\t\ts.mock.StorageMock.EXPECT().\n+\t\t\t\tLoadAuthenticationLogs(gomock.Eq(s.mock.Ctx), testValue, gomock.Any(), gomock.Any(), gomock.Any()).\n+\t\t\t\tReturn([]model.AuthenticationAttempt{\n+\t\t\t\t\t{Successful: false, Time: s.mock.Clock.Now().Add(-time.Second)},\n+\t\t\t\t\t{Successful: false, Time: s.mock.Clock.Now().Add(-time.Second)},\n+\t\t\t\t\t{Successful: false, Time: s.mock.Clock.Now().Add(-time.Second)},\n+\t\t\t\t\t{Successful: false, Time: s.mock.Clock.Now().Add(-time.Second)},\n+\t\t\t\t}, nil),\n+\t\t*/\n \n \t\ts.mock.StorageMock.\n \t\t\tEXPECT().\n@@ -1520,7 +1615,6 @@ func (s *FirstFactorReauthenticateSuite) TestShouldSaveUsernameFromAuthenticatio\n \ts.mock.Ctx.Request.SetBodyString(`{\n \t\t\"password\": \"hello\"\n \t}`)\n-\n \tFirstFactorReauthenticatePOST(nil)(s.mock.Ctx)\n \n \t// Respond with 200.\n@@ -1530,9 +1624,9 @@ func (s *FirstFactorReauthenticateSuite) TestShouldSaveUsernameFromAuthenticatio\n \tuserSession, err := s.mock.Ctx.GetSession()\n \ts.Assert().NoError(err)\n \n-\tassert.Equal(s.T(), testValue, userSession.Username)\n+\tassert.Equal(s.T(), \"test\", userSession.Username)\n \tassert.Equal(s.T(), false, userSession.KeepMeLoggedIn)\n-\tassert.Equal(s.T(), authentication.OneFactor, userSession.AuthenticationLevel(false))\n+\tassert.Equal(s.T(), authentication.OneFactor, userSession.AuthenticationLevel(s.mock.Ctx.Configuration.WebAuthn.EnablePasskey2FA))\n \tassert.Equal(s.T(), []string{\"test@example.com\"}, userSession.Emails)\n \tassert.Equal(s.T(), []string{\"dev\", \"admins\"}, userSession.Groups)\n }\n@@ -1550,7 +1644,7 @@ func (s *FirstFactorReauthenticateRedirectionSuite) SetupTest() {\n \n \ts.Require().NoError(err)\n \n-\tsession.SetOneFactorPassword(s.mock.Ctx.Clock.Now(), &authentication.UserDetails{Username: testValue}, false)\n+\tsession.SetOneFactorPasskey(s.mock.Ctx.Clock.Now(), &authentication.UserDetails{Username: testValue}, false, false, false, false)\n \n \ts.Require().NoError(s.mock.Ctx.SaveSession(session))\n \n@@ -1687,12 +1781,3 @@ func TestFirstFactorSuite(t *testing.T) {\n \tsuite.Run(t, new(FirstFactorSuite))\n \tsuite.Run(t, new(FirstFactorRedirectionSuite))\n }\n-\n-func TestFirstFactorReauthenticateSuite(t *testing.T) {\n-\tsuite.Run(t, new(FirstFactorReauthenticateSuite))\n-\tsuite.Run(t, new(FirstFactorReauthenticateRedirectionSuite))\n-}\n-\n-const (\n-\ttestValue = \"test\"\n-)\ndiff --git a/internal/handlers/handler_sign_password_test.go b/internal/handlers/handler_sign_password_test.go\nindex f16d493fb5424..de7eaf4a8dce2 100644\n--- a/internal/handlers/handler_sign_password_test.go\n+++ b/internal/handlers/handler_sign_password_test.go\n@@ -182,8 +182,8 @@ func (s *HandlerSignPasswordSuite) TestShouldErrorMarkAttempt() {\n \n \tSecondFactorPasswordPOST(nil)(s.mock.Ctx)\n \n-\ts.mock.Assert401KO(s.T(), \"Authentication failed. Check your credentials.\")\n-\ts.AssertLastLogMessage(\"Unable to mark Password authentication attempt by user 'john'\", \"bad socket\")\n+\ts.mock.Assert200OK(s.T(), &redirectResponse{Redirect: \"https://www.example.com\"})\n+\ts.AssertLastLogMessage(\"Failed to record Password authentication attempt\", \"bad socket\")\n }\n \n func (s *HandlerSignPasswordSuite) TestShouldHandleBadPassword() {\n@@ -249,7 +249,7 @@ func (s *HandlerSignPasswordSuite) TestShouldHandleBadPasswordMarkAttemptError()\n \tSecondFactorPasswordPOST(nil)(s.mock.Ctx)\n \n \ts.mock.Assert401KO(s.T(), \"Authentication failed. Check your credentials.\")\n-\ts.AssertLastLogMessage(\"Unable to mark Password authentication attempt by user 'john'\", \"bad sockets\")\n+\ts.AssertLastLogMessage(\"Unsuccessful Password authentication attempt by user 'john'\", \"\")\n }\n \n func (s *HandlerSignPasswordSuite) TestShouldHandleBadPasswordWithError() {\ndiff --git a/internal/handlers/handler_sign_totp_test.go b/internal/handlers/handler_sign_totp_test.go\nindex 265d3f15850ee..818c82c4d0b86 100644\n--- a/internal/handlers/handler_sign_totp_test.go\n+++ b/internal/handlers/handler_sign_totp_test.go\n@@ -686,7 +686,7 @@ func (s *HandlerSignTOTPSuite) TestShouldReturnErrorOnInvalidBooleanMarkErr() {\n \t\tres[0][1],\n \t\tstring(s.mock.Ctx.Request.Header.Cookie(\"authelia_session\")))\n \n-\tAssertLogEntryMessageAndError(s.T(), s.mock.Hook.LastEntry(), \"Unable to mark TOTP authentication attempt by user 'john'\", \"failed to insert\")\n+\tAssertLogEntryMessageAndError(s.T(), s.mock.Hook.LastEntry(), \"Unsuccessful TOTP authentication attempt by user 'john'\", \"\")\n }\n \n func (s *HandlerSignTOTPSuite) TestShouldReturnErrorOnInvalidJSON() {\n@@ -705,7 +705,7 @@ func (s *HandlerSignTOTPSuite) TestShouldReturnErrorOnInvalidJSON() {\n \tAssertLogEntryMessageAndError(s.T(), s.mock.Hook.LastEntry(), \"Error occurred validating a TOTP authentication for user 'john': error parsing the request body\", \"unable to parse body: invalid character '1' after object key\")\n }\n \n-func (s *HandlerSignTOTPSuite) TestShouldReturnErrorOnInvalidBooleanMarkErrSuccess() {\n+func (s *HandlerSignTOTPSuite) TestShouldNotReturnErrorOnInvalidBooleanMarkErrSuccess() {\n \tconfig := model.TOTPConfiguration{ID: 1, Username: testUsername, Digits: 6, Secret: []byte(\"secret\"), Period: 30, Algorithm: \"SHA1\"}\n \n \tgomock.InOrder(\n@@ -734,6 +734,10 @@ func (s *HandlerSignTOTPSuite) TestShouldReturnErrorOnInvalidBooleanMarkErrSucce\n \t\t\t\tRemoteIP:   model.NewNullIPFromString(\"0.0.0.0\"),\n \t\t\t}).\n \t\t\tReturn(fmt.Errorf(\"failed to insert\")),\n+\t\ts.mock.StorageMock.\n+\t\t\tEXPECT().\n+\t\t\tUpdateTOTPConfigurationSignIn(s.mock.Ctx, gomock.Any(), gomock.Any()).\n+\t\t\tReturn(nil),\n \t)\n \n \tbodyBytes, err := json.Marshal(bodySignTOTPRequest{\n@@ -746,13 +750,15 @@ func (s *HandlerSignTOTPSuite) TestShouldReturnErrorOnInvalidBooleanMarkErrSucce\n \tres := r.FindAllStringSubmatch(string(s.mock.Ctx.Response.Header.PeekCookie(\"authelia_session\")), -1)\n \n \tTimeBasedOneTimePasswordPOST(s.mock.Ctx)\n-\ts.mock.Assert403KO(s.T(), \"Authentication failed, please retry later.\")\n+\ts.mock.Assert200OK(s.T(), redirectResponse{\n+\t\tRedirect: testRedirectionURLString,\n+\t})\n \n \ts.NotEqual(\n \t\tres[0][1],\n \t\tstring(s.mock.Ctx.Request.Header.Cookie(\"authelia_session\")))\n \n-\tAssertLogEntryMessageAndError(s.T(), s.mock.Hook.LastEntry(), \"Unable to mark TOTP authentication attempt by user 'john'\", \"failed to insert\")\n+\tAssertLogEntryMessageAndError(s.T(), s.mock.Hook.LastEntry(), \"Failed to record TOTP authentication attempt\", \"failed to insert\")\n }\n \n func (s *HandlerSignTOTPSuite) TestShouldReturnErrorOnInvalidConfig() {\ndiff --git a/internal/handlers/handler_sign_webauthn_test.go b/internal/handlers/handler_sign_webauthn_test.go\nindex 970010972fa6c..d5ee6ce8d7540 100644\n--- a/internal/handlers/handler_sign_webauthn_test.go\n+++ b/internal/handlers/handler_sign_webauthn_test.go\n@@ -524,9 +524,9 @@ func TestWebAuthnAssertionPOST(t *testing.T) {\n \t\t\t},\n \t\t\tdataReqGood,\n \t\t\t\"\",\n-\t\t\tfasthttp.StatusForbidden,\n+\t\t\tfasthttp.StatusOK,\n \t\t\tfunc(t *testing.T, mock *mocks.MockAutheliaCtx) {\n-\t\t\t\tAssertLogEntryMessageAndError(t, mock.Hook.LastEntry(), \"Unable to mark WebAuthn authentication attempt by user 'john'\", \"bad record\")\n+\t\t\t\tAssertLogEntryMessageAndError(t, mock.Hook.LastEntry(), \"Failed to record WebAuthn authentication attempt\", \"bad record\")\n \t\t\t},\n \t\t},\n \t\t{\ndiff --git a/internal/regulation/regulator_test.go b/internal/regulation/regulator_test.go\nindex 55b783889a2c1..235c90319746f 100644\n--- a/internal/regulation/regulator_test.go\n+++ b/internal/regulation/regulator_test.go\n@@ -1,12 +1,12 @@\n package regulation_test\n \n import (\n+\t\"database/sql\"\n \t\"fmt\"\n \t\"net\"\n \t\"testing\"\n \t\"time\"\n \n-\t\"github.com/stretchr/testify/assert\"\n \t\"github.com/stretchr/testify/suite\"\n \t\"github.com/valyala/fasthttp\"\n \t\"go.uber.org/mock/gomock\"\n@@ -25,7 +25,10 @@ type RegulatorSuite struct {\n \n func (s *RegulatorSuite) SetupTest() {\n \ts.mock = mocks.NewMockAutheliaCtx(s.T())\n+\ts.mock.Ctx.Clock = &s.mock.Clock\n+\n \ts.mock.Ctx.Configuration.Regulation = schema.Regulation{\n+\t\tModes:      []string{\"ip\", \"user\"},\n \t\tMaxRetries: 3,\n \t\tBanTime:    time.Second * 180,\n \t\tFindTime:   time.Second * 30,\n@@ -34,185 +37,777 @@ func (s *RegulatorSuite) SetupTest() {\n \ts.mock.Ctx.Request.Header.Set(fasthttp.HeaderXForwardedFor, \"127.0.0.1\")\n }\n \n+func (s *RegulatorSuite) Regulator() *regulation.Regulator {\n+\treturn regulation.NewRegulator(s.mock.Ctx.Configuration.Regulation, s.mock.StorageMock, &s.mock.Clock)\n+}\n+\n+func (s *RegulatorSuite) AssertLogEntryMessageAndError(message, err string) {\n+\tentry := s.mock.Hook.LastEntry()\n+\n+\ts.Require().NotNil(entry)\n+\n+\ts.Equal(message, entry.Message)\n+\n+\tv, ok := entry.Data[\"error\"]\n+\n+\tif err == \"\" {\n+\t\ts.False(ok)\n+\t\ts.Nil(v)\n+\t} else {\n+\t\ts.True(ok)\n+\t\ts.Require().NotNil(v)\n+\n+\t\ttheErr, ok := v.(error)\n+\t\ts.True(ok)\n+\t\ts.Require().NotNil(theErr)\n+\n+\t\ts.EqualError(theErr, err)\n+\t}\n+}\n+\n func (s *RegulatorSuite) TearDownTest() {\n \ts.mock.Ctrl.Finish()\n }\n \n-func (s *RegulatorSuite) TestShouldMark() {\n-\tregulator := regulation.NewRegulator(s.mock.Ctx.Configuration.Regulation, s.mock.StorageMock, &s.mock.Clock)\n-\n-\ts.mock.StorageMock.EXPECT().AppendAuthenticationLog(s.mock.Ctx, model.AuthenticationAttempt{\n-\t\tTime:          s.mock.Clock.Now(),\n-\t\tSuccessful:    true,\n-\t\tBanned:        false,\n-\t\tUsername:      \"john\",\n-\t\tType:          \"1fa\",\n-\t\tRemoteIP:      model.NewNullIP(net.ParseIP(\"127.0.0.1\")),\n-\t\tRequestURI:    \"https://google.com\",\n-\t\tRequestMethod: fasthttp.MethodGet,\n-\t})\n-\n-\ts.NoError(regulator.Mark(s.mock.Ctx, true, false, \"john\", \"https://google.com\", fasthttp.MethodGet, \"1fa\"))\n+func (s *RegulatorSuite) TestShouldHandleBanCheckIPError() {\n+\tregulator := s.Regulator()\n+\n+\tgomock.InOrder(\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedIP(s.mock.Ctx, gomock.Eq(model.NewIP(net.ParseIP(\"127.0.0.1\")))).\n+\t\t\tReturn(nil, fmt.Errorf(\"failed to load ip bans\")),\n+\t)\n+\n+\tban, value, expires, err := regulator.BanCheck(s.mock.Ctx, \"john\")\n+\n+\ts.Equal(regulation.BanTypeNone, ban)\n+\ts.Equal(\"\", value)\n+\ts.Equal((*time.Time)(nil), expires)\n+\ts.EqualError(err, \"failed to load ip bans\")\n }\n \n-func (s *RegulatorSuite) TestShouldHandleRegulateError() {\n-\tregulator := regulation.NewRegulator(s.mock.Ctx.Configuration.Regulation, s.mock.StorageMock, &s.mock.Clock)\n+func (s *RegulatorSuite) TestShouldHandleBanCheckIPBanned() {\n+\tregulator := s.Regulator()\n \n-\ts.mock.StorageMock.EXPECT().LoadAuthenticationLogs(s.mock.Ctx, \"john\", s.mock.Clock.Now().Add(-s.mock.Ctx.Configuration.Regulation.BanTime), 10, 0).Return(nil, fmt.Errorf(\"failed\"))\n+\tip := net.ParseIP(\"127.0.0.1\")\n \n-\tuntil, err := regulator.Regulate(s.mock.Ctx, \"john\")\n+\tresult := []model.BannedIP{\n+\t\t{\n+\t\t\tID:      1,\n+\t\t\tTime:    s.mock.Clock.Now().Add(-5 * time.Minute),\n+\t\t\tExpires: sql.NullTime{Valid: true, Time: s.mock.Clock.Now().Add(1 * time.Minute)},\n+\t\t\tExpired: sql.NullTime{},\n+\t\t\tRevoked: false,\n+\t\t\tIP:      model.IP{IP: ip},\n+\t\t\tSource:  \"regulation\",\n+\t\t\tReason:  sql.NullString{Valid: true, String: \"Exceeding Maximum Retries\"},\n+\t\t},\n+\t}\n \n-\ts.NoError(err)\n-\ts.Equal(time.Time{}, until)\n+\tattempt := model.AuthenticationAttempt{\n+\t\tTime:       s.mock.Clock.Now(),\n+\t\tSuccessful: false,\n+\t\tBanned:     true,\n+\t\tUsername:   \"john\",\n+\t\tType:       regulation.AuthType1FA,\n+\t\tRemoteIP:   model.NewNullIP(ip),\n+\t}\n+\n+\tgomock.InOrder(\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedIP(s.mock.Ctx, gomock.Eq(model.NewIP(ip))).\n+\t\t\tReturn(result, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tAppendAuthenticationLog(s.mock.Ctx, gomock.Eq(attempt)).\n+\t\t\tReturn(nil),\n+\t)\n+\n+\tban, value, expires, err := regulator.BanCheck(s.mock.Ctx, \"john\")\n+\n+\ts.Equal(regulation.BanTypeIP, ban)\n+\ts.Equal(\"127.0.0.1\", value)\n+\ts.Equal(&result[0].Expires.Time, expires)\n+\ts.EqualError(err, \"user is banned\")\n+\n+\tb := regulation.NewBan(ban, value, expires)\n+\n+\ts.Regexp(`expires at \\d{2}:\\d{2}:\\d{2}(AM|PM) on \\w+ \\d{1,2} \\d{4} \\(\\+\\d{2}:\\d{2}\\)`, b.FormatExpires())\n+\ts.Equal(regulation.BanTypeIP, b.Type())\n+\ts.Equal(\"127.0.0.1\", b.Value())\n+\n+\tregulator.HandleAttempt(s.mock.Ctx, false, true, \"john\", \"\", \"\", regulation.AuthType1FA)\n+}\n+\n+func (s *RegulatorSuite) TestShouldHandleBanCheckIPBannedPermanent() {\n+\tregulator := s.Regulator()\n+\n+\tip := net.ParseIP(\"127.0.0.1\")\n+\n+\tresult := []model.BannedIP{\n+\t\t{\n+\t\t\tID:      1,\n+\t\t\tTime:    s.mock.Clock.Now().Add(-5 * time.Minute),\n+\t\t\tExpires: sql.NullTime{},\n+\t\t\tExpired: sql.NullTime{},\n+\t\t\tRevoked: false,\n+\t\t\tIP:      model.IP{IP: ip},\n+\t\t\tSource:  \"regulation\",\n+\t\t\tReason:  sql.NullString{Valid: true, String: \"Exceeding Maximum Retries\"},\n+\t\t},\n+\t}\n+\n+\tattempt := model.AuthenticationAttempt{\n+\t\tTime:       s.mock.Clock.Now(),\n+\t\tSuccessful: false,\n+\t\tBanned:     true,\n+\t\tUsername:   \"john\",\n+\t\tType:       regulation.AuthType1FA,\n+\t\tRemoteIP:   model.NewNullIP(ip),\n+\t}\n+\n+\tgomock.InOrder(\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedIP(s.mock.Ctx, gomock.Eq(model.NewIP(ip))).\n+\t\t\tReturn(result, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tAppendAuthenticationLog(s.mock.Ctx, gomock.Eq(attempt)).\n+\t\t\tReturn(nil),\n+\t)\n+\n+\tban, value, expires, err := regulator.BanCheck(s.mock.Ctx, \"john\")\n+\n+\ts.Equal(regulation.BanTypeIP, ban)\n+\ts.Equal(\"127.0.0.1\", value)\n+\ts.Equal((*time.Time)(nil), expires)\n+\ts.EqualError(err, \"user is banned\")\n+\n+\tb := regulation.NewBan(ban, value, expires)\n+\n+\ts.Equal(\"never expires\", b.FormatExpires())\n+\ts.Equal(regulation.BanTypeIP, b.Type())\n+\ts.Equal(\"127.0.0.1\", b.Value())\n+\n+\tregulator.HandleAttempt(s.mock.Ctx, false, true, \"john\", \"\", \"\", regulation.AuthType1FA)\n }\n \n-func (s *RegulatorSuite) TestShouldNotThrowWhenUserIsLegitimate() {\n-\tattemptsInDB := []model.AuthenticationAttempt{\n+func (s *RegulatorSuite) TestShouldHandleBanCheckIPBannedFailToAppend() {\n+\tregulator := s.Regulator()\n+\n+\tip := net.ParseIP(\"127.0.0.1\")\n+\n+\tresult := []model.BannedIP{\n \t\t{\n-\t\t\tUsername:   \"john\",\n-\t\t\tSuccessful: true,\n-\t\t\tTime:       s.mock.Clock.Now().Add(-4 * time.Minute),\n+\t\t\tID:      1,\n+\t\t\tTime:    s.mock.Clock.Now().Add(-5 * time.Minute),\n+\t\t\tExpires: sql.NullTime{Valid: true, Time: s.mock.Clock.Now().Add(1 * time.Minute)},\n+\t\t\tExpired: sql.NullTime{},\n+\t\t\tRevoked: false,\n+\t\t\tIP:      model.IP{IP: ip},\n+\t\t\tSource:  \"regulation\",\n+\t\t\tReason:  sql.NullString{Valid: true, String: \"Exceeding Maximum Retries\"},\n \t\t},\n \t}\n \n-\ts.mock.StorageMock.EXPECT().\n-\t\tLoadAuthenticationLogs(s.mock.Ctx, gomock.Eq(\"john\"), gomock.Any(), gomock.Eq(10), gomock.Eq(0)).\n-\t\tReturn(attemptsInDB, nil)\n+\tattempt := model.AuthenticationAttempt{\n+\t\tTime:       s.mock.Clock.Now(),\n+\t\tSuccessful: false,\n+\t\tBanned:     true,\n+\t\tUsername:   \"john\",\n+\t\tType:       regulation.AuthType1FA,\n+\t\tRemoteIP:   model.NewNullIP(ip),\n+\t}\n+\n+\tgomock.InOrder(\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedIP(s.mock.Ctx, gomock.Eq(model.NewIP(ip))).\n+\t\t\tReturn(result, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tAppendAuthenticationLog(s.mock.Ctx, gomock.Eq(attempt)).\n+\t\t\tReturn(fmt.Errorf(\"failed to log\")),\n+\t)\n \n-\tregulator := regulation.NewRegulator(s.mock.Ctx.Configuration.Regulation, s.mock.StorageMock, &s.mock.Clock)\n+\tban, value, expires, err := regulator.BanCheck(s.mock.Ctx, \"john\")\n \n-\t_, err := regulator.Regulate(s.mock.Ctx, \"john\")\n-\tassert.NoError(s.T(), err)\n+\ts.Equal(regulation.BanTypeIP, ban)\n+\ts.Equal(\"127.0.0.1\", value)\n+\ts.Equal(&result[0].Expires.Time, expires)\n+\ts.EqualError(err, \"user is banned\")\n+\n+\tregulator.HandleAttempt(s.mock.Ctx, false, true, \"john\", \"\", \"\", regulation.AuthType1FA)\n+\n+\ts.AssertLogEntryMessageAndError(\"Failed to record 1FA authentication attempt\", \"failed to log\")\n }\n \n-// This test checks the case in which a user failed to authenticate many times but always\n-// with a certain amount of time larger than FindTime. Meaning the user should not be banned.\n-func (s *RegulatorSuite) TestShouldNotThrowWhenFailedAuthenticationNotInFindTime() {\n-\tattemptsInDB := []model.AuthenticationAttempt{\n+func (s *RegulatorSuite) TestShouldHandleBanCheckIPNotBanned() {\n+\tregulator := s.Regulator()\n+\n+\tip := net.ParseIP(\"127.0.0.1\")\n+\n+\tattempt := model.AuthenticationAttempt{\n+\t\tTime:       s.mock.Clock.Now(),\n+\t\tSuccessful: false,\n+\t\tBanned:     false,\n+\t\tUsername:   \"john\",\n+\t\tType:       regulation.AuthType1FA,\n+\t\tRemoteIP:   model.NewNullIP(ip),\n+\t}\n+\n+\tsince := s.mock.Clock.Now().Add(-s.mock.Ctx.Configuration.Regulation.FindTime)\n+\n+\trecords := []model.RegulationRecord{\n \t\t{\n-\t\t\tUsername:   \"john\",\n+\t\t\tTime:       s.mock.Clock.Now().Add(-10 * time.Second),\n \t\t\tSuccessful: false,\n-\t\t\tTime:       s.mock.Clock.Now().Add(-1 * time.Second),\n \t\t},\n \t\t{\n-\t\t\tUsername:   \"john\",\n+\t\t\tTime:       s.mock.Clock.Now().Add(-12 * time.Second),\n \t\t\tSuccessful: false,\n-\t\t\tTime:       s.mock.Clock.Now().Add(-90 * time.Second),\n \t\t},\n+\t}\n+\n+\tgomock.InOrder(\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedIP(s.mock.Ctx, gomock.Eq(model.NewIP(ip))).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedUser(s.mock.Ctx, gomock.Eq(\"john\")).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tAppendAuthenticationLog(s.mock.Ctx, gomock.Eq(attempt)).\n+\t\t\tReturn(nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadRegulationRecordsByIP(s.mock.Ctx, model.NewIP(ip), since, s.mock.Ctx.Configuration.Regulation.MaxRetries).\n+\t\t\tReturn(records, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadRegulationRecordsByUser(s.mock.Ctx, \"john\", since, s.mock.Ctx.Configuration.Regulation.MaxRetries).\n+\t\t\tReturn(nil, nil),\n+\t)\n+\n+\tban, value, expires, err := regulator.BanCheck(s.mock.Ctx, \"john\")\n+\n+\ts.Equal(regulation.BanTypeNone, ban)\n+\ts.Equal(\"\", value)\n+\ts.Equal((*time.Time)(nil), expires)\n+\ts.NoError(err)\n+\n+\tregulator.HandleAttempt(s.mock.Ctx, false, false, \"john\", \"\", \"\", regulation.AuthType1FA)\n+}\n+\n+func (s *RegulatorSuite) TestShouldHandleBanCheckIPNotBannedButFailedAttempt() {\n+\tregulator := s.Regulator()\n+\n+\tip := net.ParseIP(\"127.0.0.1\")\n+\n+\tattempt := model.AuthenticationAttempt{\n+\t\tTime:       s.mock.Clock.Now(),\n+\t\tSuccessful: false,\n+\t\tBanned:     false,\n+\t\tUsername:   \"john\",\n+\t\tType:       regulation.AuthType1FA,\n+\t\tRemoteIP:   model.NewNullIP(ip),\n+\t}\n+\n+\tsince := s.mock.Clock.Now().Add(-s.mock.Ctx.Configuration.Regulation.FindTime)\n+\n+\trecords := []model.RegulationRecord{\n \t\t{\n-\t\t\tUsername:   \"john\",\n+\t\t\tTime:       s.mock.Clock.Now().Add(-10 * time.Second),\n+\t\t\tSuccessful: false,\n+\t\t},\n+\t\t{\n+\t\t\tTime:       s.mock.Clock.Now().Add(-12 * time.Second),\n \t\t\tSuccessful: false,\n-\t\t\tTime:       s.mock.Clock.Now().Add(-180 * time.Second),\n \t\t},\n+\t\t{\n+\t\t\tTime:       s.mock.Clock.Now().Add(-12 * time.Second),\n+\t\t\tSuccessful: false,\n+\t\t},\n+\t}\n+\n+\tsqlban := &model.BannedIP{\n+\t\tExpires: sql.NullTime{Valid: true, Time: records[0].Time.Add(s.mock.Ctx.Configuration.Regulation.BanTime)},\n+\t\tIP:      model.NewIP(ip),\n+\t\tSource:  \"regulation\",\n+\t\tReason:  sql.NullString{Valid: true, String: \"Exceeding Maximum Retries\"},\n \t}\n \n-\ts.mock.StorageMock.EXPECT().\n-\t\tLoadAuthenticationLogs(s.mock.Ctx, gomock.Eq(\"john\"), gomock.Any(), gomock.Eq(10), gomock.Eq(0)).\n-\t\tReturn(attemptsInDB, nil)\n+\tgomock.InOrder(\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedIP(s.mock.Ctx, gomock.Eq(model.NewIP(ip))).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedUser(s.mock.Ctx, gomock.Eq(\"john\")).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tAppendAuthenticationLog(s.mock.Ctx, gomock.Eq(attempt)).\n+\t\t\tReturn(nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadRegulationRecordsByIP(s.mock.Ctx, model.NewIP(ip), since, s.mock.Ctx.Configuration.Regulation.MaxRetries).\n+\t\t\tReturn(records, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tSaveBannedIP(s.mock.Ctx, gomock.Eq(sqlban)).\n+\t\t\tReturn(nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadRegulationRecordsByUser(s.mock.Ctx, \"john\", since, s.mock.Ctx.Configuration.Regulation.MaxRetries).\n+\t\t\tReturn(nil, nil),\n+\t)\n+\n+\tban, value, expires, err := regulator.BanCheck(s.mock.Ctx, \"john\")\n+\n+\ts.Equal(regulation.BanTypeNone, ban)\n+\ts.Equal(\"\", value)\n+\ts.Equal((*time.Time)(nil), expires)\n+\ts.NoError(err)\n+\n+\tregulator.HandleAttempt(s.mock.Ctx, false, false, \"john\", \"\", \"\", regulation.AuthType1FA)\n+}\n+\n+func (s *RegulatorSuite) TestShouldHandleBanCheckUserError() {\n+\tregulator := s.Regulator()\n \n-\tregulator := regulation.NewRegulator(s.mock.Ctx.Configuration.Regulation, s.mock.StorageMock, &s.mock.Clock)\n+\tgomock.InOrder(\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedIP(s.mock.Ctx, gomock.Eq(model.NewIP(net.ParseIP(\"127.0.0.1\")))).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedUser(s.mock.Ctx, gomock.Eq(\"john\")).\n+\t\t\tReturn(nil, fmt.Errorf(\"failed to load user bans\")),\n+\t)\n \n-\t_, err := regulator.Regulate(s.mock.Ctx, \"john\")\n-\tassert.NoError(s.T(), err)\n+\tban, value, expires, err := regulator.BanCheck(s.mock.Ctx, \"john\")\n+\n+\ts.Equal(regulation.BanTypeNone, ban)\n+\ts.Equal(\"\", value)\n+\ts.Equal((*time.Time)(nil), expires)\n+\ts.EqualError(err, \"failed to load user bans\")\n }\n \n-// This test checks the case in which a user failed to authenticate many times only a few\n-// seconds ago (meaning we are checking from now back to now-FindTime).\n-func (s *RegulatorSuite) TestShouldBanUserIfLatestAttemptsAreWithinFinTime() {\n-\tattemptsInDB := []model.AuthenticationAttempt{\n+func (s *RegulatorSuite) TestShouldHandleBanCheckUserBanned() {\n+\tregulator := s.Regulator()\n+\n+\tip := net.ParseIP(\"127.0.0.1\")\n+\n+\tresult := []model.BannedUser{\n+\t\t{\n+\t\t\tID:       1,\n+\t\t\tTime:     s.mock.Clock.Now().Add(-5 * time.Minute),\n+\t\t\tExpires:  sql.NullTime{Valid: true, Time: s.mock.Clock.Now().Add(1 * time.Minute)},\n+\t\t\tExpired:  sql.NullTime{},\n+\t\t\tRevoked:  false,\n+\t\t\tUsername: \"john\",\n+\t\t\tSource:   \"regulation\",\n+\t\t\tReason:   sql.NullString{Valid: true, String: \"Exceeding Maximum Retries\"},\n+\t\t},\n+\t}\n+\n+\tattempt := model.AuthenticationAttempt{\n+\t\tTime:       s.mock.Clock.Now(),\n+\t\tSuccessful: false,\n+\t\tBanned:     true,\n+\t\tUsername:   \"john\",\n+\t\tType:       regulation.AuthType1FA,\n+\t\tRemoteIP:   model.NewNullIP(ip),\n+\t}\n+\n+\tgomock.InOrder(\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedIP(s.mock.Ctx, gomock.Eq(model.NewIP(ip))).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedUser(s.mock.Ctx, gomock.Eq(\"john\")).\n+\t\t\tReturn(result, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tAppendAuthenticationLog(s.mock.Ctx, gomock.Eq(attempt)).\n+\t\t\tReturn(nil),\n+\t)\n+\n+\tban, value, expires, err := regulator.BanCheck(s.mock.Ctx, \"john\")\n+\n+\ts.Equal(regulation.BanTypeUser, ban)\n+\ts.Equal(\"john\", value)\n+\ts.Equal(&result[0].Expires.Time, expires)\n+\ts.EqualError(err, \"user is banned\")\n+\n+\tb := regulation.NewBan(ban, value, expires)\n+\n+\ts.Regexp(`expires at \\d{2}:\\d{2}:\\d{2}(AM|PM) on \\w+ \\d{1,2} \\d{4} \\(\\+\\d{2}:\\d{2}\\)`, b.FormatExpires())\n+\ts.Equal(regulation.BanTypeUser, b.Type())\n+\ts.Equal(\"john\", b.Value())\n+\n+\tregulator.HandleAttempt(s.mock.Ctx, false, true, \"john\", \"\", \"\", regulation.AuthType1FA)\n+}\n+\n+func (s *RegulatorSuite) TestShouldHandleBanCheckUserBannedPermanent() {\n+\tregulator := s.Regulator()\n+\n+\tip := net.ParseIP(\"127.0.0.1\")\n+\n+\tresult := []model.BannedUser{\n \t\t{\n-\t\t\tUsername:   \"john\",\n+\t\t\tID:       1,\n+\t\t\tTime:     s.mock.Clock.Now().Add(-5 * time.Minute),\n+\t\t\tExpires:  sql.NullTime{},\n+\t\t\tExpired:  sql.NullTime{},\n+\t\t\tRevoked:  false,\n+\t\t\tUsername: \"john\",\n+\t\t\tSource:   \"regulation\",\n+\t\t\tReason:   sql.NullString{Valid: true, String: \"Exceeding Maximum Retries\"},\n+\t\t},\n+\t}\n+\n+\tattempt := model.AuthenticationAttempt{\n+\t\tTime:       s.mock.Clock.Now(),\n+\t\tSuccessful: false,\n+\t\tBanned:     true,\n+\t\tUsername:   \"john\",\n+\t\tType:       regulation.AuthType1FA,\n+\t\tRemoteIP:   model.NewNullIP(ip),\n+\t}\n+\n+\tgomock.InOrder(\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedIP(s.mock.Ctx, gomock.Eq(model.NewIP(ip))).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedUser(s.mock.Ctx, gomock.Eq(\"john\")).\n+\t\t\tReturn(result, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tAppendAuthenticationLog(s.mock.Ctx, gomock.Eq(attempt)).\n+\t\t\tReturn(nil),\n+\t)\n+\n+\tban, value, expires, err := regulator.BanCheck(s.mock.Ctx, \"john\")\n+\n+\ts.Equal(regulation.BanTypeUser, ban)\n+\ts.Equal(\"john\", value)\n+\ts.Equal((*time.Time)(nil), expires)\n+\ts.EqualError(err, \"user is banned\")\n+\n+\tb := regulation.NewBan(ban, value, expires)\n+\n+\ts.Equal(\"never expires\", b.FormatExpires())\n+\ts.Equal(regulation.BanTypeUser, b.Type())\n+\ts.Equal(\"john\", b.Value())\n+\n+\tregulator.HandleAttempt(s.mock.Ctx, false, true, \"john\", \"\", \"\", regulation.AuthType1FA)\n+}\n+\n+func (s *RegulatorSuite) TestShouldHandleBanCheckUserBannedFailToAppend() {\n+\tregulator := s.Regulator()\n+\n+\tip := net.ParseIP(\"127.0.0.1\")\n+\n+\tresult := []model.BannedUser{\n+\t\t{\n+\t\t\tID:       1,\n+\t\t\tTime:     s.mock.Clock.Now().Add(-5 * time.Minute),\n+\t\t\tExpires:  sql.NullTime{Valid: true, Time: s.mock.Clock.Now().Add(1 * time.Minute)},\n+\t\t\tExpired:  sql.NullTime{},\n+\t\t\tRevoked:  false,\n+\t\t\tUsername: \"john\",\n+\t\t\tSource:   \"regulation\",\n+\t\t\tReason:   sql.NullString{Valid: true, String: \"Exceeding Maximum Retries\"},\n+\t\t},\n+\t}\n+\n+\tattempt := model.AuthenticationAttempt{\n+\t\tTime:       s.mock.Clock.Now(),\n+\t\tSuccessful: false,\n+\t\tBanned:     true,\n+\t\tUsername:   \"john\",\n+\t\tType:       regulation.AuthType1FA,\n+\t\tRemoteIP:   model.NewNullIP(ip),\n+\t}\n+\n+\tgomock.InOrder(\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedIP(s.mock.Ctx, gomock.Eq(model.NewIP(ip))).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedUser(s.mock.Ctx, gomock.Eq(\"john\")).\n+\t\t\tReturn(result, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tAppendAuthenticationLog(s.mock.Ctx, gomock.Eq(attempt)).\n+\t\t\tReturn(fmt.Errorf(\"failed to log\")),\n+\t)\n+\n+\tban, value, expires, err := regulator.BanCheck(s.mock.Ctx, \"john\")\n+\n+\ts.Equal(regulation.BanTypeUser, ban)\n+\ts.Equal(\"john\", value)\n+\ts.Equal(&result[0].Expires.Time, expires)\n+\ts.EqualError(err, \"user is banned\")\n+\n+\tregulator.HandleAttempt(s.mock.Ctx, false, true, \"john\", \"\", \"\", regulation.AuthType1FA)\n+\n+\ts.AssertLogEntryMessageAndError(\"Failed to record 1FA authentication attempt\", \"failed to log\")\n+}\n+\n+func (s *RegulatorSuite) TestShouldHandleBanCheckUserNotBanned() {\n+\tregulator := s.Regulator()\n+\n+\tip := net.ParseIP(\"127.0.0.1\")\n+\n+\tattempt := model.AuthenticationAttempt{\n+\t\tTime:       s.mock.Clock.Now(),\n+\t\tSuccessful: false,\n+\t\tBanned:     false,\n+\t\tUsername:   \"john\",\n+\t\tType:       regulation.AuthType1FA,\n+\t\tRemoteIP:   model.NewNullIP(ip),\n+\t}\n+\n+\tsince := s.mock.Clock.Now().Add(-s.mock.Ctx.Configuration.Regulation.FindTime)\n+\n+\trecords := []model.RegulationRecord{\n+\t\t{\n+\t\t\tTime:       s.mock.Clock.Now().Add(-10 * time.Second),\n \t\t\tSuccessful: false,\n-\t\t\tTime:       s.mock.Clock.Now().Add(-1 * time.Second),\n \t\t},\n \t\t{\n-\t\t\tUsername:   \"john\",\n+\t\t\tTime:       s.mock.Clock.Now().Add(-12 * time.Second),\n+\t\t\tSuccessful: false,\n+\t\t},\n+\t}\n+\n+\tgomock.InOrder(\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedIP(s.mock.Ctx, gomock.Eq(model.NewIP(ip))).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedUser(s.mock.Ctx, gomock.Eq(\"john\")).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tAppendAuthenticationLog(s.mock.Ctx, gomock.Eq(attempt)).\n+\t\t\tReturn(nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadRegulationRecordsByIP(s.mock.Ctx, model.NewIP(ip), since, s.mock.Ctx.Configuration.Regulation.MaxRetries).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadRegulationRecordsByUser(s.mock.Ctx, \"john\", since, s.mock.Ctx.Configuration.Regulation.MaxRetries).\n+\t\t\tReturn(records, nil),\n+\t)\n+\n+\tban, value, expires, err := regulator.BanCheck(s.mock.Ctx, \"john\")\n+\n+\ts.Equal(regulation.BanTypeNone, ban)\n+\ts.Equal(\"\", value)\n+\ts.Equal((*time.Time)(nil), expires)\n+\ts.NoError(err)\n+\n+\tregulator.HandleAttempt(s.mock.Ctx, false, false, \"john\", \"\", \"\", regulation.AuthType1FA)\n+}\n+\n+func (s *RegulatorSuite) TestShouldHandleBanCheckUserNotBannedButFailedAttempt() {\n+\tregulator := s.Regulator()\n+\n+\tip := net.ParseIP(\"127.0.0.1\")\n+\n+\tattempt := model.AuthenticationAttempt{\n+\t\tTime:       s.mock.Clock.Now(),\n+\t\tSuccessful: false,\n+\t\tBanned:     false,\n+\t\tUsername:   \"john\",\n+\t\tType:       regulation.AuthType1FA,\n+\t\tRemoteIP:   model.NewNullIP(ip),\n+\t}\n+\n+\tsince := s.mock.Clock.Now().Add(-s.mock.Ctx.Configuration.Regulation.FindTime)\n+\n+\trecords := []model.RegulationRecord{\n+\t\t{\n+\t\t\tTime:       s.mock.Clock.Now().Add(-10 * time.Second),\n \t\t\tSuccessful: false,\n-\t\t\tTime:       s.mock.Clock.Now().Add(-4 * time.Second),\n \t\t},\n \t\t{\n-\t\t\tUsername:   \"john\",\n+\t\t\tTime:       s.mock.Clock.Now().Add(-12 * time.Second),\n \t\t\tSuccessful: false,\n-\t\t\tTime:       s.mock.Clock.Now().Add(-6 * time.Second),\n \t\t},\n \t\t{\n-\t\t\tUsername:   \"john\",\n+\t\t\tTime:       s.mock.Clock.Now().Add(-12 * time.Second),\n \t\t\tSuccessful: false,\n-\t\t\tTime:       s.mock.Clock.Now().Add(-180 * time.Second),\n \t\t},\n \t}\n \n-\ts.mock.StorageMock.EXPECT().\n-\t\tLoadAuthenticationLogs(s.mock.Ctx, gomock.Eq(\"john\"), gomock.Any(), gomock.Eq(10), gomock.Eq(0)).\n-\t\tReturn(attemptsInDB, nil)\n+\tsqlban := &model.BannedUser{\n+\t\tExpires:  sql.NullTime{Valid: true, Time: records[0].Time.Add(s.mock.Ctx.Configuration.Regulation.BanTime)},\n+\t\tUsername: \"john\",\n+\t\tSource:   \"regulation\",\n+\t\tReason:   sql.NullString{Valid: true, String: \"Exceeding Maximum Retries\"},\n+\t}\n \n-\tregulator := regulation.NewRegulator(s.mock.Ctx.Configuration.Regulation, s.mock.StorageMock, &s.mock.Clock)\n+\tgomock.InOrder(\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedIP(s.mock.Ctx, gomock.Eq(model.NewIP(ip))).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedUser(s.mock.Ctx, gomock.Eq(\"john\")).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tAppendAuthenticationLog(s.mock.Ctx, gomock.Eq(attempt)).\n+\t\t\tReturn(nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadRegulationRecordsByIP(s.mock.Ctx, model.NewIP(ip), since, s.mock.Ctx.Configuration.Regulation.MaxRetries).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadRegulationRecordsByUser(s.mock.Ctx, \"john\", since, s.mock.Ctx.Configuration.Regulation.MaxRetries).\n+\t\t\tReturn(records, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tSaveBannedUser(s.mock.Ctx, gomock.Eq(sqlban)).\n+\t\t\tReturn(nil),\n+\t)\n+\n+\tban, value, expires, err := regulator.BanCheck(s.mock.Ctx, \"john\")\n+\n+\ts.Equal(regulation.BanTypeNone, ban)\n+\ts.Equal(\"\", value)\n+\ts.Equal((*time.Time)(nil), expires)\n+\ts.NoError(err)\n \n-\t_, err := regulator.Regulate(s.mock.Ctx, \"john\")\n-\tassert.Equal(s.T(), regulation.ErrUserIsBanned, err)\n+\tregulator.HandleAttempt(s.mock.Ctx, false, false, \"john\", \"\", \"\", regulation.AuthType1FA)\n }\n \n-// This test checks the case in which a user failed to authenticate many times only a few\n-// seconds ago (meaning we are checking from now-FindTime+X back to now-2FindTime+X knowing that\n-// we are within now and now-BanTime). It means the user has been banned some time ago and is still\n-// banned right now.\n-func (s *RegulatorSuite) TestShouldCheckUserIsStillBanned() {\n-\tattemptsInDB := []model.AuthenticationAttempt{\n+// This test checks the case in which a user failed to authenticate many times but always\n+// with a certain amount of time larger than FindTime. Meaning the user should not be banned.\n+func (s *RegulatorSuite) TestShouldNotBanWhenFailedAuthenticationNotInFindTime() {\n+\tattemptsInDB := []model.RegulationRecord{\n \t\t{\n-\t\t\tUsername:   \"john\",\n \t\t\tSuccessful: false,\n-\t\t\tTime:       s.mock.Clock.Now().Add(-31 * time.Second),\n+\t\t\tTime:       s.mock.Clock.Now().Add(-1 * time.Second),\n \t\t},\n \t\t{\n-\t\t\tUsername:   \"john\",\n \t\t\tSuccessful: false,\n-\t\t\tTime:       s.mock.Clock.Now().Add(-34 * time.Second),\n+\t\t\tTime:       s.mock.Clock.Now().Add(-90 * time.Second),\n \t\t},\n \t\t{\n-\t\t\tUsername:   \"john\",\n \t\t\tSuccessful: false,\n-\t\t\tTime:       s.mock.Clock.Now().Add(-36 * time.Second),\n+\t\t\tTime:       s.mock.Clock.Now().Add(-180 * time.Second),\n \t\t},\n \t}\n \n-\ts.mock.StorageMock.EXPECT().\n-\t\tLoadAuthenticationLogs(s.mock.Ctx, gomock.Eq(\"john\"), gomock.Any(), gomock.Eq(10), gomock.Eq(0)).\n-\t\tReturn(attemptsInDB, nil)\n+\tip := net.ParseIP(\"127.0.0.1\")\n+\n+\tattempt := model.AuthenticationAttempt{\n+\t\tTime:       s.mock.Clock.Now(),\n+\t\tSuccessful: false,\n+\t\tBanned:     false,\n+\t\tUsername:   \"john\",\n+\t\tType:       regulation.AuthType1FA,\n+\t\tRemoteIP:   model.NewNullIP(ip),\n+\t}\n \n-\tregulator := regulation.NewRegulator(s.mock.Ctx.Configuration.Regulation, s.mock.StorageMock, &s.mock.Clock)\n+\tgomock.InOrder(\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedIP(s.mock.Ctx, gomock.Eq(model.NewIP(ip))).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedUser(s.mock.Ctx, gomock.Eq(\"john\")).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tAppendAuthenticationLog(s.mock.Ctx, gomock.Eq(attempt)).\n+\t\t\tReturn(nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadRegulationRecordsByIP(s.mock.Ctx, gomock.Eq(model.NewIP(net.ParseIP(\"127.0.0.1\"))), gomock.Eq(s.mock.Clock.Now().Add(-s.mock.Ctx.Configuration.Regulation.FindTime)), gomock.Eq(3)).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadRegulationRecordsByUser(s.mock.Ctx, gomock.Eq(\"john\"), gomock.Eq(s.mock.Clock.Now().Add(-s.mock.Ctx.Configuration.Regulation.FindTime)), gomock.Eq(3)).\n+\t\t\tReturn(attemptsInDB, nil),\n+\t)\n+\n+\tregulator := s.Regulator()\n+\n+\tban, value, expires, err := regulator.BanCheck(s.mock.Ctx, \"john\")\n+\n+\ts.Equal(regulation.BanTypeNone, ban)\n+\ts.Equal(\"\", value)\n+\ts.Equal((*time.Time)(nil), expires)\n+\ts.NoError(err)\n \n-\t_, err := regulator.Regulate(s.mock.Ctx, \"john\")\n-\tassert.Equal(s.T(), regulation.ErrUserIsBanned, err)\n+\tregulator.HandleAttempt(s.mock.Ctx, false, false, \"john\", \"\", \"\", regulation.AuthType1FA)\n }\n \n-func (s *RegulatorSuite) TestShouldCheckUserIsNotYetBanned() {\n-\tattemptsInDB := []model.AuthenticationAttempt{\n+// This test checks the case in which a user failed to authenticate many times only a few\n+// seconds ago (meaning we are checking from now back to now-FindTime).\n+func (s *RegulatorSuite) TestShouldBanUserIfLatestAttemptsAreWithinFindTime() {\n+\tattemptsInDB := []model.RegulationRecord{\n \t\t{\n-\t\t\tUsername:   \"john\",\n \t\t\tSuccessful: false,\n-\t\t\tTime:       s.mock.Clock.Now().Add(-34 * time.Second),\n+\t\t\tTime:       s.mock.Clock.Now().Add(-1 * time.Second),\n \t\t},\n \t\t{\n-\t\t\tUsername:   \"john\",\n \t\t\tSuccessful: false,\n-\t\t\tTime:       s.mock.Clock.Now().Add(-36 * time.Second),\n+\t\t\tTime:       s.mock.Clock.Now().Add(-4 * time.Second),\n \t\t},\n+\t\t{\n+\t\t\tSuccessful: false,\n+\t\t\tTime:       s.mock.Clock.Now().Add(-6 * time.Second),\n+\t\t},\n+\t\t{\n+\t\t\tSuccessful: false,\n+\t\t\tTime:       s.mock.Clock.Now().Add(-180 * time.Second),\n+\t\t},\n+\t}\n+\n+\tbanexp := s.mock.Clock.Now().Add(-1 * time.Second).Add(s.mock.Ctx.Configuration.Regulation.BanTime)\n+\n+\tbanned := &model.BannedUser{\n+\t\tExpires:  sql.NullTime{Time: banexp, Valid: true},\n+\t\tUsername: \"john\",\n+\t\tSource:   \"regulation\",\n+\t\tReason:   sql.NullString{Valid: true, String: \"Exceeding Maximum Retries\"},\n \t}\n \n-\ts.mock.StorageMock.EXPECT().\n-\t\tLoadAuthenticationLogs(s.mock.Ctx, gomock.Eq(\"john\"), gomock.Any(), gomock.Eq(10), gomock.Eq(0)).\n-\t\tReturn(attemptsInDB, nil)\n+\tip := net.ParseIP(\"127.0.0.1\")\n \n-\tregulator := regulation.NewRegulator(s.mock.Ctx.Configuration.Regulation, s.mock.StorageMock, &s.mock.Clock)\n+\tattempt := model.AuthenticationAttempt{\n+\t\tTime:       s.mock.Clock.Now(),\n+\t\tSuccessful: false,\n+\t\tBanned:     false,\n+\t\tUsername:   \"john\",\n+\t\tType:       regulation.AuthType1FA,\n+\t\tRemoteIP:   model.NewNullIP(ip),\n+\t}\n \n-\t_, err := regulator.Regulate(s.mock.Ctx, \"john\")\n-\tassert.NoError(s.T(), err)\n+\tgomock.InOrder(\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedIP(s.mock.Ctx, gomock.Eq(model.NewIP(net.ParseIP(\"127.0.0.1\")))).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedUser(s.mock.Ctx, gomock.Eq(\"john\")).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tAppendAuthenticationLog(s.mock.Ctx, gomock.Eq(attempt)).\n+\t\t\tReturn(nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadRegulationRecordsByIP(s.mock.Ctx, gomock.Eq(model.NewIP(net.ParseIP(\"127.0.0.1\"))), gomock.Eq(s.mock.Clock.Now().Add(-s.mock.Ctx.Configuration.Regulation.FindTime)), gomock.Eq(3)).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadRegulationRecordsByUser(s.mock.Ctx, gomock.Eq(\"john\"), gomock.Eq(s.mock.Clock.Now().Add(-s.mock.Ctx.Configuration.Regulation.FindTime)), gomock.Eq(3)).\n+\t\t\tReturn(attemptsInDB, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tSaveBannedUser(s.mock.Ctx, gomock.Eq(banned)).\n+\t\t\tReturn(nil),\n+\t)\n+\n+\tregulator := s.Regulator()\n+\n+\tban, value, expires, err := regulator.BanCheck(s.mock.Ctx, \"john\")\n+\n+\ts.Equal(regulation.BanTypeNone, ban)\n+\ts.Equal(\"\", value)\n+\ts.Equal((*time.Time)(nil), expires)\n+\ts.NoError(err)\n+\n+\tregulator.HandleAttempt(s.mock.Ctx, false, false, \"john\", \"\", \"\", regulation.AuthType1FA)\n }\n \n func (s *RegulatorSuite) TestShouldCheckUserWasAboutToBeBanned() {\n-\tattemptsInDB := []model.AuthenticationAttempt{\n+\tattemptsInDB := []model.RegulationRecord{\n+\t\t{\n+\t\t\tSuccessful: false,\n+\t\t\tTime:       s.mock.Clock.Now(),\n+\t\t},\n \t\t{\n-\t\t\tUsername:   \"john\",\n \t\t\tSuccessful: false,\n \t\t\tTime:       s.mock.Clock.Now().Add(-14 * time.Second),\n \t\t},\n@@ -220,92 +815,125 @@ func (s *RegulatorSuite) TestShouldCheckUserWasAboutToBeBanned() {\n \t\t// In that case we don't need to regulate the user even though the number\n \t\t// of retrieved attempts is 3.\n \t\t{\n-\t\t\tUsername:   \"john\",\n \t\t\tSuccessful: false,\n \t\t\tTime:       s.mock.Clock.Now().Add(-94 * time.Second),\n \t\t},\n \t\t{\n-\t\t\tUsername:   \"john\",\n \t\t\tSuccessful: false,\n \t\t\tTime:       s.mock.Clock.Now().Add(-96 * time.Second),\n \t\t},\n \t}\n \n-\ts.mock.StorageMock.EXPECT().\n-\t\tLoadAuthenticationLogs(s.mock.Ctx, gomock.Eq(\"john\"), gomock.Any(), gomock.Eq(10), gomock.Eq(0)).\n-\t\tReturn(attemptsInDB, nil)\n+\tip := net.ParseIP(\"127.0.0.1\")\n+\n+\tattempt := model.AuthenticationAttempt{\n+\t\tTime:       s.mock.Clock.Now(),\n+\t\tSuccessful: false,\n+\t\tBanned:     false,\n+\t\tUsername:   \"john\",\n+\t\tType:       regulation.AuthType1FA,\n+\t\tRemoteIP:   model.NewNullIP(ip),\n+\t}\n \n-\tregulator := regulation.NewRegulator(s.mock.Ctx.Configuration.Regulation, s.mock.StorageMock, &s.mock.Clock)\n+\tgomock.InOrder(\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedIP(s.mock.Ctx, gomock.Eq(model.NewIP(ip))).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedUser(s.mock.Ctx, gomock.Eq(\"john\")).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tAppendAuthenticationLog(s.mock.Ctx, gomock.Eq(attempt)).\n+\t\t\tReturn(nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadRegulationRecordsByIP(s.mock.Ctx, gomock.Eq(model.NewIP(ip)), gomock.Eq(s.mock.Clock.Now().Add(-s.mock.Ctx.Configuration.Regulation.FindTime)), gomock.Eq(3)).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadRegulationRecordsByUser(s.mock.Ctx, gomock.Eq(\"john\"), gomock.Eq(s.mock.Clock.Now().Add(-s.mock.Ctx.Configuration.Regulation.FindTime)), gomock.Eq(3)).\n+\t\t\tReturn(attemptsInDB, nil),\n+\t)\n+\n+\tregulator := s.Regulator()\n+\n+\tban, value, expires, err := regulator.BanCheck(s.mock.Ctx, \"john\")\n+\n+\ts.Equal(regulation.BanTypeNone, ban)\n+\ts.Equal(\"\", value)\n+\ts.Equal((*time.Time)(nil), expires)\n+\ts.NoError(err)\n \n-\t_, err := regulator.Regulate(s.mock.Ctx, \"john\")\n-\tassert.NoError(s.T(), err)\n+\tregulator.HandleAttempt(s.mock.Ctx, false, false, \"john\", \"\", \"\", regulation.AuthType1FA)\n }\n \n func (s *RegulatorSuite) TestShouldCheckRegulationHasBeenResetOnSuccessfulAttempt() {\n-\tattemptsInDB := []model.AuthenticationAttempt{\n+\tattemptsInDB := []model.RegulationRecord{\n \t\t{\n-\t\t\tUsername:   \"john\",\n \t\t\tSuccessful: false,\n-\t\t\tTime:       s.mock.Clock.Now().Add(-90 * time.Second),\n+\t\t\tTime:       s.mock.Clock.Now(),\n \t\t},\n \t\t{\n-\t\t\tUsername:   \"john\",\n \t\t\tSuccessful: true,\n-\t\t\tTime:       s.mock.Clock.Now().Add(-93 * time.Second),\n+\t\t\tTime:       s.mock.Clock.Now().Add(-5 * time.Second),\n \t\t},\n \t\t// The user was almost banned but he did a successful attempt. Therefore, even if the next\n \t\t// failure happens within FindTime, he should not be banned.\n \t\t{\n-\t\t\tUsername:   \"john\",\n \t\t\tSuccessful: false,\n-\t\t\tTime:       s.mock.Clock.Now().Add(-94 * time.Second),\n+\t\t\tTime:       s.mock.Clock.Now().Add(-10 * time.Second),\n \t\t},\n \t\t{\n-\t\t\tUsername:   \"john\",\n \t\t\tSuccessful: false,\n-\t\t\tTime:       s.mock.Clock.Now().Add(-96 * time.Second),\n+\t\t\tTime:       s.mock.Clock.Now().Add(-15 * time.Second),\n+\t\t},\n+\t\t{\n+\t\t\tSuccessful: false,\n+\t\t\tTime:       s.mock.Clock.Now().Add(-20 * time.Second),\n \t\t},\n \t}\n \n-\ts.mock.StorageMock.EXPECT().\n-\t\tLoadAuthenticationLogs(s.mock.Ctx, gomock.Eq(\"john\"), gomock.Any(), gomock.Eq(10), gomock.Eq(0)).\n-\t\tReturn(attemptsInDB, nil)\n+\tip := net.ParseIP(\"127.0.0.1\")\n \n-\tregulator := regulation.NewRegulator(s.mock.Ctx.Configuration.Regulation, s.mock.StorageMock, &s.mock.Clock)\n+\tattempt := model.AuthenticationAttempt{\n+\t\tTime:       s.mock.Clock.Now(),\n+\t\tSuccessful: false,\n+\t\tBanned:     false,\n+\t\tUsername:   \"john\",\n+\t\tType:       regulation.AuthType1FA,\n+\t\tRemoteIP:   model.NewNullIP(ip),\n+\t}\n \n-\t_, err := regulator.Regulate(s.mock.Ctx, \"john\")\n-\tassert.NoError(s.T(), err)\n-}\n+\tgomock.InOrder(\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedIP(s.mock.Ctx, gomock.Eq(model.NewIP(ip))).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadBannedUser(s.mock.Ctx, gomock.Eq(\"john\")).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tAppendAuthenticationLog(s.mock.Ctx, gomock.Eq(attempt)).\n+\t\t\tReturn(nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadRegulationRecordsByIP(s.mock.Ctx, gomock.Eq(model.NewIP(ip)), gomock.Eq(s.mock.Clock.Now().Add(-s.mock.Ctx.Configuration.Regulation.FindTime)), gomock.Eq(3)).\n+\t\t\tReturn(nil, nil),\n+\t\ts.mock.StorageMock.EXPECT().\n+\t\t\tLoadRegulationRecordsByUser(s.mock.Ctx, gomock.Eq(\"john\"), gomock.Eq(s.mock.Clock.Now().Add(-s.mock.Ctx.Configuration.Regulation.FindTime)), gomock.Eq(3)).\n+\t\t\tReturn(attemptsInDB, nil),\n+\t)\n+\n+\tregulator := s.Regulator()\n+\n+\tban, value, expires, err := regulator.BanCheck(s.mock.Ctx, \"john\")\n+\n+\ts.Equal(regulation.BanTypeNone, ban)\n+\ts.Equal(\"\", value)\n+\ts.Equal((*time.Time)(nil), expires)\n+\ts.NoError(err)\n \n-func TestRunRegulatorSuite(t *testing.T) {\n-\ts := new(RegulatorSuite)\n-\tsuite.Run(t, s)\n+\tregulator.HandleAttempt(s.mock.Ctx, false, false, \"john\", \"\", \"\", regulation.AuthType1FA)\n }\n \n // This test checks that the regulator is disabled when configuration is set to 0.\n func (s *RegulatorSuite) TestShouldHaveRegulatorDisabled() {\n-\tattemptsInDB := []model.AuthenticationAttempt{\n-\t\t{\n-\t\t\tUsername:   \"john\",\n-\t\t\tSuccessful: false,\n-\t\t\tTime:       s.mock.Clock.Now().Add(-31 * time.Second),\n-\t\t},\n-\t\t{\n-\t\t\tUsername:   \"john\",\n-\t\t\tSuccessful: false,\n-\t\t\tTime:       s.mock.Clock.Now().Add(-34 * time.Second),\n-\t\t},\n-\t\t{\n-\t\t\tUsername:   \"john\",\n-\t\t\tSuccessful: false,\n-\t\t\tTime:       s.mock.Clock.Now().Add(-36 * time.Second),\n-\t\t},\n-\t}\n-\n-\ts.mock.StorageMock.EXPECT().\n-\t\tLoadAuthenticationLogs(s.mock.Ctx, gomock.Eq(\"john\"), gomock.Any(), gomock.Eq(10), gomock.Eq(0)).\n-\t\tReturn(attemptsInDB, nil)\n-\n \t// Check Disabled Functionality.\n \tconfig := schema.Regulation{\n \t\tMaxRetries: 0,\n@@ -314,8 +942,20 @@ func (s *RegulatorSuite) TestShouldHaveRegulatorDisabled() {\n \t}\n \n \tregulator := regulation.NewRegulator(config, s.mock.StorageMock, &s.mock.Clock)\n-\t_, err := regulator.Regulate(s.mock.Ctx, \"john\")\n-\tassert.NoError(s.T(), err)\n+\n+\ts.mock.StorageMock.\n+\t\tEXPECT().\n+\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil)\n+\ts.mock.StorageMock.\n+\t\tEXPECT().\n+\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(\"john\")).Return(nil, nil)\n+\n+\tban, value, expires, err := regulator.BanCheck(s.mock.Ctx, \"john\")\n+\n+\ts.Equal(regulation.BanTypeNone, ban)\n+\ts.Equal(\"\", value)\n+\ts.Equal((*time.Time)(nil), expires)\n+\ts.NoError(err)\n \n \t// Check Enabled Functionality.\n \tconfig = schema.Regulation{\n@@ -325,6 +965,23 @@ func (s *RegulatorSuite) TestShouldHaveRegulatorDisabled() {\n \t}\n \n \tregulator = regulation.NewRegulator(config, s.mock.StorageMock, &s.mock.Clock)\n-\t_, err = regulator.Regulate(s.mock.Ctx, \"john\")\n-\tassert.Equal(s.T(), regulation.ErrUserIsBanned, err)\n+\n+\ts.mock.StorageMock.\n+\t\tEXPECT().\n+\t\tLoadBannedIP(gomock.Eq(s.mock.Ctx), gomock.Eq(model.NewIP(s.mock.Ctx.RemoteIP()))).Return(nil, nil)\n+\ts.mock.StorageMock.\n+\t\tEXPECT().\n+\t\tLoadBannedUser(gomock.Eq(s.mock.Ctx), gomock.Eq(\"john\")).Return(nil, nil)\n+\n+\tban, value, expires, err = regulator.BanCheck(s.mock.Ctx, \"john\")\n+\n+\ts.Equal(regulation.BanTypeNone, ban)\n+\ts.Equal(\"\", value)\n+\ts.Equal((*time.Time)(nil), expires)\n+\ts.NoError(err)\n+}\n+\n+func TestRunRegulatorSuite(t *testing.T) {\n+\ts := new(RegulatorSuite)\n+\tsuite.Run(t, s)\n }\ndiff --git a/internal/storage/migrations_test.go b/internal/storage/migrations_test.go\nindex 657f0bc3c4fdc..3d08684547743 100644\n--- a/internal/storage/migrations_test.go\n+++ b/internal/storage/migrations_test.go\n@@ -11,7 +11,7 @@ import (\n \n const (\n \t// This is the latest schema version for the purpose of tests.\n-\tLatestVersion = 19\n+\tLatestVersion = 20\n )\n \n func TestShouldObtainCorrectMigrations(t *testing.T) {\n"}
{"org": "projectdiscovery", "repo": "nuclei", "number": 6410, "state": "closed", "title": "feat(js): adds RSYNC module", "body": "## Proposed changes\r\nClose #6409\r\n\r\n## Checklist\r\n- [ ] Pull request is created against the [dev](https://github.com/projectdiscovery/nuclei/tree/dev) branch\r\n- [ ] All checks passed (lint, unit/integration/regression tests etc.) with my changes\r\n- [ ] I have added tests that prove my fix is effective or that my feature works\r\n- [ ] I have added necessary documentation (if appropriate)\n\n<!-- This is an auto-generated comment: release notes by coderabbit.ai -->\n## Summary by CodeRabbit\n\n* **New Features**\n  * Added an RSYNC client API to browse servers: list available modules and list files within a module; responses include captured RSYNC driver output for inspection.\n\n* **Tests**\n  * Added RSYNC-based JavaScript integration test (disabled on Windows/macOS) that starts a temporary RSYNC server, runs the test, and cleans up.\n\n* **Chores**\n  * Updated project dependencies to support RSYNC functionality.\n\n<sub>âœï¸ Tip: You can customize this high-level summary in your review settings.</sub>\n<!-- end of auto-generated comment: release notes by coderabbit.ai -->", "url": "https://api.github.com/repos/projectdiscovery/nuclei/pulls/6410", "id": 2761404801, "node_id": "PR_kwDODxGgs86kl7GB", "html_url": "https://github.com/projectdiscovery/nuclei/pull/6410", "diff_url": "https://github.com/projectdiscovery/nuclei/pull/6410.diff", "patch_url": "https://github.com/projectdiscovery/nuclei/pull/6410.patch", "issue_url": "https://api.github.com/repos/projectdiscovery/nuclei/issues/6410", "created_at": "2025-08-21T01:05:48+00:00", "updated_at": "2025-12-31T19:02:50+00:00", "closed_at": "2025-12-31T19:02:48+00:00", "merged_at": "2025-12-31T19:02:48+00:00", "merge_commit_sha": "891dffb4a14cd9dd04908e2cf2f3bc248855d04d", "labels": [], "draft": false, "commits_url": "https://api.github.com/repos/projectdiscovery/nuclei/pulls/6410/commits", "review_comments_url": "https://api.github.com/repos/projectdiscovery/nuclei/pulls/6410/comments", "review_comment_url": "https://api.github.com/repos/projectdiscovery/nuclei/pulls/comments{/number}", "comments_url": "https://api.github.com/repos/projectdiscovery/nuclei/issues/6410/comments", "base": {"label": "projectdiscovery:dev", "ref": "dev", "sha": "63aed75474c9251fabb663561527a95bad46d72d", "user": {"login": "projectdiscovery", "id": 50994705, "node_id": "MDEyOk9yZ2FuaXphdGlvbjUwOTk0NzA1", "avatar_url": "https://avatars.githubusercontent.com/u/50994705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/projectdiscovery", "html_url": "https://github.com/projectdiscovery", "followers_url": "https://api.github.com/users/projectdiscovery/followers", "following_url": "https://api.github.com/users/projectdiscovery/following{/other_user}", "gists_url": "https://api.github.com/users/projectdiscovery/gists{/gist_id}", "starred_url": "https://api.github.com/users/projectdiscovery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/projectdiscovery/subscriptions", "organizations_url": "https://api.github.com/users/projectdiscovery/orgs", "repos_url": "https://api.github.com/users/projectdiscovery/repos", "events_url": "https://api.github.com/users/projectdiscovery/events{/privacy}", "received_events_url": "https://api.github.com/users/projectdiscovery/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "repo": {"id": 252813491, "node_id": "MDEwOlJlcG9zaXRvcnkyNTI4MTM0OTE=", "name": "nuclei", "full_name": "projectdiscovery/nuclei", "private": false, "owner": {"login": "projectdiscovery", "id": 50994705, "node_id": "MDEyOk9yZ2FuaXphdGlvbjUwOTk0NzA1", "avatar_url": "https://avatars.githubusercontent.com/u/50994705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/projectdiscovery", "html_url": "https://github.com/projectdiscovery", "followers_url": "https://api.github.com/users/projectdiscovery/followers", "following_url": "https://api.github.com/users/projectdiscovery/following{/other_user}", "gists_url": "https://api.github.com/users/projectdiscovery/gists{/gist_id}", "starred_url": "https://api.github.com/users/projectdiscovery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/projectdiscovery/subscriptions", "organizations_url": "https://api.github.com/users/projectdiscovery/orgs", "repos_url": "https://api.github.com/users/projectdiscovery/repos", "events_url": "https://api.github.com/users/projectdiscovery/events{/privacy}", "received_events_url": "https://api.github.com/users/projectdiscovery/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "html_url": "https://github.com/projectdiscovery/nuclei", "description": "Nuclei is a fast, customizable vulnerability scanner powered by the global security community and built on a simple YAML-based DSL, enabling collaboration to tackle trending vulnerabilities on the internet. It helps you find vulnerabilities in your applications, APIs, networks, DNS, and cloud configurations.", "fork": false, "url": "https://api.github.com/repos/projectdiscovery/nuclei", "forks_url": "https://api.github.com/repos/projectdiscovery/nuclei/forks", "keys_url": "https://api.github.com/repos/projectdiscovery/nuclei/keys{/key_id}", "collaborators_url": "https://api.github.com/repos/projectdiscovery/nuclei/collaborators{/collaborator}", "teams_url": "https://api.github.com/repos/projectdiscovery/nuclei/teams", "hooks_url": "https://api.github.com/repos/projectdiscovery/nuclei/hooks", "issue_events_url": "https://api.github.com/repos/projectdiscovery/nuclei/issues/events{/number}", "events_url": "https://api.github.com/repos/projectdiscovery/nuclei/events", "assignees_url": "https://api.github.com/repos/projectdiscovery/nuclei/assignees{/user}", "branches_url": "https://api.github.com/repos/projectdiscovery/nuclei/branches{/branch}", "tags_url": "https://api.github.com/repos/projectdiscovery/nuclei/tags", "blobs_url": "https://api.github.com/repos/projectdiscovery/nuclei/git/blobs{/sha}", "git_tags_url": "https://api.github.com/repos/projectdiscovery/nuclei/git/tags{/sha}", "git_refs_url": "https://api.github.com/repos/projectdiscovery/nuclei/git/refs{/sha}", "trees_url": "https://api.github.com/repos/projectdiscovery/nuclei/git/trees{/sha}", "statuses_url": "https://api.github.com/repos/projectdiscovery/nuclei/statuses/{sha}", "languages_url": "https://api.github.com/repos/projectdiscovery/nuclei/languages", "stargazers_url": "https://api.github.com/repos/projectdiscovery/nuclei/stargazers", "contributors_url": "https://api.github.com/repos/projectdiscovery/nuclei/contributors", "subscribers_url": "https://api.github.com/repos/projectdiscovery/nuclei/subscribers", "subscription_url": "https://api.github.com/repos/projectdiscovery/nuclei/subscription", "commits_url": "https://api.github.com/repos/projectdiscovery/nuclei/commits{/sha}", "git_commits_url": "https://api.github.com/repos/projectdiscovery/nuclei/git/commits{/sha}", "comments_url": "https://api.github.com/repos/projectdiscovery/nuclei/comments{/number}", "issue_comment_url": "https://api.github.com/repos/projectdiscovery/nuclei/issues/comments{/number}", "contents_url": "https://api.github.com/repos/projectdiscovery/nuclei/contents/{+path}", "compare_url": "https://api.github.com/repos/projectdiscovery/nuclei/compare/{base}...{head}", "merges_url": "https://api.github.com/repos/projectdiscovery/nuclei/merges", "archive_url": "https://api.github.com/repos/projectdiscovery/nuclei/{archive_format}{/ref}", "downloads_url": "https://api.github.com/repos/projectdiscovery/nuclei/downloads", "issues_url": "https://api.github.com/repos/projectdiscovery/nuclei/issues{/number}", "pulls_url": "https://api.github.com/repos/projectdiscovery/nuclei/pulls{/number}", "milestones_url": "https://api.github.com/repos/projectdiscovery/nuclei/milestones{/number}", "notifications_url": "https://api.github.com/repos/projectdiscovery/nuclei/notifications{?since,all,participating}", "labels_url": "https://api.github.com/repos/projectdiscovery/nuclei/labels{/name}", "releases_url": "https://api.github.com/repos/projectdiscovery/nuclei/releases{/id}", "deployments_url": "https://api.github.com/repos/projectdiscovery/nuclei/deployments", "created_at": "2020-04-03T18:47:11Z", "updated_at": "2026-01-07T06:25:38Z", "pushed_at": "2026-01-06T08:07:30Z", "git_url": "git://github.com/projectdiscovery/nuclei.git", "ssh_url": "git@github.com:projectdiscovery/nuclei.git", "clone_url": "https://github.com/projectdiscovery/nuclei.git", "svn_url": "https://github.com/projectdiscovery/nuclei", "homepage": "https://docs.projectdiscovery.io/tools/nuclei", "size": 42133, "stargazers_count": 26440, "watchers_count": 26440, "language": "Go", "has_issues": true, "has_projects": true, "has_downloads": true, "has_wiki": false, "has_pages": false, "has_discussions": true, "forks_count": 3038, "mirror_url": null, "archived": false, "disabled": false, "open_issues_count": 202, "license": {"key": "mit", "name": "MIT License", "spdx_id": "MIT", "url": "https://api.github.com/licenses/mit", "node_id": "MDc6TGljZW5zZTEz"}, "allow_forking": true, "is_template": false, "web_commit_signoff_required": false, "topics": ["attack-surface", "cve-scanner", "dast", "hacktoberfest", "nuclei-engine", "security", "security-scanner", "subdomain-takeover", "vulnerability-assessment", "vulnerability-detection", "vulnerability-scanner"], "visibility": "public", "forks": 3038, "open_issues": 202, "watchers": 26440, "default_branch": "dev"}}, "commits": [{"sha": "7f5a1419365c0d734487ea771104611ada9c2997", "parents": ["b4644af80a574b6bf4af093310dcb239c9164190"], "message": "adding min auth support"}, {"sha": "663a8e9d49d5668307eff3c37f70a6e1a5ef88a5", "parents": ["7f5a1419365c0d734487ea771104611ada9c2997"], "message": "adding unauth list modules + auth list files in module"}, {"sha": "68605c210b9c48f22985de4bb2cfb5d9c1bf12ab", "parents": ["663a8e9d49d5668307eff3c37f70a6e1a5ef88a5"], "message": "example"}, {"sha": "36e7701833af282c8db219fe114d46c0caf341c6", "parents": ["68605c210b9c48f22985de4bb2cfb5d9c1bf12ab", "0f7b33cebf4d9980199cf8f21b6aec8ce9ed5c89"], "message": "Merge branch 'dev' into feat-6409-rsync-auth"}, {"sha": "fd3c304136dfbf9040f1ea269d90b1f650d73d04", "parents": ["36e7701833af282c8db219fe114d46c0caf341c6"], "message": "adding rsync test"}, {"sha": "7b0d9af632b54b51853d7066885ade9aab97f26a", "parents": ["fd3c304136dfbf9040f1ea269d90b1f650d73d04", "8194fabcf8f71bf83b093e5a228c2409c114b4f2"], "message": "Merge branch 'dev' into feat-6409-rsync-auth"}, {"sha": "47f45d330144b70f272cd284d30cb1b456ff0ef2", "parents": ["7b0d9af632b54b51853d7066885ade9aab97f26a"], "message": "bump go.mod"}, {"sha": "ef0f6a2097ce9b9049b751184d2c6d8961dda115", "parents": ["47f45d330144b70f272cd284d30cb1b456ff0ef2", "78e90e300d573bfd65bfe73011003499d910add3"], "message": "Merge branch 'dev' into feat-6409-rsync-auth"}, {"sha": "f93f8d81baf3867f96bd9f4c77e37509b7d1af38", "parents": ["ef0f6a2097ce9b9049b751184d2c6d8961dda115", "73ad95068c4559f193778cb41462a26da9a8ddb4"], "message": "Merge branch 'dev' into feat-6409-rsync-auth"}, {"sha": "58693ef2f72d9b33d3623a73e1ed65bf870ade8e", "parents": ["f93f8d81baf3867f96bd9f4c77e37509b7d1af38", "63aed75474c9251fabb663561527a95bad46d72d"], "message": "Merge branch 'dev' into feat-6409-rsync-auth"}], "resolved_issues": [{"org": "projectdiscovery", "repo": "nuclei", "number": 6409, "state": "closed", "title": "[FEATURE] Authentication support in Javascript RSYNC Protocol", "body": "### Describe your feature request\n\nAuthenticated RSYNC in Javascript protocol\n- [ ] Authentication with username and password\n- [ ] List Shares\n- [ ] List Modules"}], "fix_patch": "diff --git a/go.mod b/go.mod\nindex c27befc3cf..3b6928f212 100644\n--- a/go.mod\n+++ b/go.mod\n@@ -53,6 +53,7 @@ require (\n \tgithub.com/DataDog/gostackparse v0.7.0\n \tgithub.com/Masterminds/semver/v3 v3.2.1\n \tgithub.com/Mzack9999/gcache v0.0.0-20230410081825-519e28eab057\n+\tgithub.com/Mzack9999/go-rsync v0.0.0-20250821180103-81ffa574ef4d\n \tgithub.com/Mzack9999/goja v0.0.0-20250507184235-e46100e9c697\n \tgithub.com/Mzack9999/goja_nodejs v0.0.0-20250507184139-66bcbf65c883\n \tgithub.com/alexsnet/go-vnc v0.1.0\n@@ -269,6 +270,7 @@ require (\n \tgithub.com/jinzhu/inflection v1.0.0 // indirect\n \tgithub.com/josharian/intern v1.0.0 // indirect\n \tgithub.com/k14s/starlark-go v0.0.0-20200720175618-3a5c849cc368 // indirect\n+\tgithub.com/kaiakz/ubuffer v0.0.0-20200803053910-dd1083087166 // indirect\n \tgithub.com/kataras/jwt v0.1.10 // indirect\n \tgithub.com/kevinburke/ssh_config v1.2.0 // indirect\n \tgithub.com/klauspost/compress v1.18.2 // indirect\ndiff --git a/go.sum b/go.sum\nindex 76e4463fee..7db9b0b943 100644\n--- a/go.sum\n+++ b/go.sum\n@@ -87,6 +87,8 @@ github.com/Mzack9999/gcache v0.0.0-20230410081825-519e28eab057 h1:KFac3SiGbId8ub\n github.com/Mzack9999/gcache v0.0.0-20230410081825-519e28eab057/go.mod h1:iLB2pivrPICvLOuROKmlqURtFIEsoJZaMidQfCG1+D4=\n github.com/Mzack9999/go-http-digest-auth-client v0.6.1-0.20220414142836-eb8883508809 h1:ZbFL+BDfBqegi+/Ssh7im5+aQfBRx6it+kHnC7jaDU8=\n github.com/Mzack9999/go-http-digest-auth-client v0.6.1-0.20220414142836-eb8883508809/go.mod h1:upgc3Zs45jBDnBT4tVRgRcgm26ABpaP7MoTSdgysca4=\n+github.com/Mzack9999/go-rsync v0.0.0-20250821180103-81ffa574ef4d h1:DofPB5AcjTnOU538A/YD86/dfqSNTvQsAXgwagxmpu4=\n+github.com/Mzack9999/go-rsync v0.0.0-20250821180103-81ffa574ef4d/go.mod h1:uzdh/m6XQJI7qRvufeBPDa+lj5SVCJO8B9eLxTbtI5U=\n github.com/Mzack9999/goja v0.0.0-20250507184235-e46100e9c697 h1:54I+OF5vS4a/rxnUrN5J3hi0VEYKcrTlpc8JosDyP+c=\n github.com/Mzack9999/goja v0.0.0-20250507184235-e46100e9c697/go.mod h1:yNqYRqxYkSROY1J+LX+A0tOSA/6soXQs5m8hZSqYBac=\n github.com/Mzack9999/goja_nodejs v0.0.0-20250507184139-66bcbf65c883 h1:+Is1AS20q3naP+qJophNpxuvx1daFOx9C0kLIuI0GVk=\n@@ -634,6 +636,8 @@ github.com/k14s/difflib v0.0.0-20201117154628-0c031775bf57 h1:CwBRArr+BWBopnUJhD\n github.com/k14s/difflib v0.0.0-20201117154628-0c031775bf57/go.mod h1:B0xN2MiNBGWOWi9CcfAo9LBI8IU4J1utlbOIJCsmKr4=\n github.com/k14s/starlark-go v0.0.0-20200720175618-3a5c849cc368 h1:4bcRTTSx+LKSxMWibIwzHnDNmaN1x52oEpvnjCy+8vk=\n github.com/k14s/starlark-go v0.0.0-20200720175618-3a5c849cc368/go.mod h1:lKGj1op99m4GtQISxoD2t+K+WO/q2NzEPKvfXFQfbCA=\n+github.com/kaiakz/ubuffer v0.0.0-20200803053910-dd1083087166 h1:IAukUBAVLUWBcexOYgkTD/EjMkfnNos7g7LFpyIdHJI=\n+github.com/kaiakz/ubuffer v0.0.0-20200803053910-dd1083087166/go.mod h1:T4xUEny5PVedYIbkMAKYEBjMyDsOvvP0qK4s324AKA8=\n github.com/kataras/jwt v0.1.10 h1:GBXOF9RVInDPhCFBiDumRG9Tt27l7ugLeLo8HL5SeKQ=\n github.com/kataras/jwt v0.1.10/go.mod h1:xkimAtDhU/aGlQqjwvgtg+VyuPwMiyZHaY8LJRh0mYo=\n github.com/kevinburke/ssh_config v1.2.0 h1:x584FjTGwHzMwvHx18PXxbBVzfnxogHaAReU4gf13a4=\ndiff --git a/pkg/js/generated/go/librsync/rsync.go b/pkg/js/generated/go/librsync/rsync.go\nindex 6c269fcb00..ffc6f0a616 100644\n--- a/pkg/js/generated/go/librsync/rsync.go\n+++ b/pkg/js/generated/go/librsync/rsync.go\n@@ -21,6 +21,7 @@ func init() {\n \n \t\t\t// Objects / Classes\n \t\t\t\"IsRsyncResponse\": gojs.GetClassConstructor[lib_rsync.IsRsyncResponse](&lib_rsync.IsRsyncResponse{}),\n+\t\t\t\"RsyncClient\":     gojs.GetClassConstructor[lib_rsync.RsyncClient](&lib_rsync.RsyncClient{}),\n \t\t},\n \t).Register()\n }\ndiff --git a/pkg/js/generated/ts/rsync.ts b/pkg/js/generated/ts/rsync.ts\nindex afe2146803..6cb675b0d6 100755\n--- a/pkg/js/generated/ts/rsync.ts\n+++ b/pkg/js/generated/ts/rsync.ts\n@@ -13,7 +13,61 @@ export function IsRsync(host: string, port: number): IsRsyncResponse | null {\n     return null;\n }\n \n-\n+/**\n+ * RsyncClient is a client for RSYNC servers.\n+ * Internally client uses https://github.com/gokrazy/rsync driver.\n+ * @example\n+ * ```javascript\n+ * const rsync = require('nuclei/rsync');\n+ * const client = new rsync.RsyncClient();\n+ * ```\n+ */\n+export class RsyncClient {\n+    \n+    // Constructor of RsyncClient\n+    constructor() {}\n+    \n+    /**\n+     * Connect establishes a connection to the rsync server with authentication.\n+     * @example\n+     * ```javascript\n+     * const rsync = require('nuclei/rsync');\n+     * const client = new rsync.RsyncClient();\n+     * const connected = client.Connect('acme.com', 873, 'username', 'password', 'backup');\n+     * ```\n+     */\n+    public Connect(host: string, port: number, username: string, password: string, module: string): boolean | null {\n+        return null;\n+    }\n+    \n+    /**\n+     * ListModules lists available modules on the rsync server.\n+     * @example\n+     * ```javascript\n+     * const rsync = require('nuclei/rsync');\n+     * const client = new rsync.RsyncClient();\n+     * const modules = client.ListModules('acme.com', 873, 'username', 'password');\n+     * log(toJSON(modules));\n+     * ```\n+     */\n+    public ListModules(host: string, port: number, username: string, password: string): string[] | null {\n+        return null;\n+    }\n+    \n+    /**\n+     * ListFilesInModule lists files in a specific module on the rsync server.\n+     * @example\n+     * ```javascript\n+     * const rsync = require('nuclei/rsync');\n+     * const client = new rsync.RsyncClient();\n+     * const files = client.ListFilesInModule('acme.com', 873, 'username', 'password', 'backup');\n+     * log(toJSON(files));\n+     * ```\n+     */\n+    public ListFilesInModule(host: string, port: number, username: string, password: string, module: string): string[] | null {\n+        return null;\n+    }\n+}\n \n /**\n  * IsRsyncResponse is the response from the IsRsync function.\ndiff --git a/pkg/js/libs/rsync/rsync.go b/pkg/js/libs/rsync/rsync.go\nindex a1b4073959..1dddd80333 100644\n--- a/pkg/js/libs/rsync/rsync.go\n+++ b/pkg/js/libs/rsync/rsync.go\n@@ -1,18 +1,31 @@\n package rsync\n \n import (\n+\t\"bytes\"\n \t\"context\"\n \t\"fmt\"\n+\t\"log/slog\"\n \t\"net\"\n \t\"strconv\"\n \t\"time\"\n \n+\trsynclib \"github.com/Mzack9999/go-rsync/rsync\"\n+\n \t\"github.com/praetorian-inc/fingerprintx/pkg/plugins\"\n \t\"github.com/praetorian-inc/fingerprintx/pkg/plugins/services/rsync\"\n \t\"github.com/projectdiscovery/nuclei/v3/pkg/protocols/common/protocolstate\"\n )\n \n type (\n+\t// RsyncClient is a client for RSYNC servers.\n+\t// Internally client uses https://github.com/gokrazy/rsync driver.\n+\t// @example\n+\t// ```javascript\n+\t// const rsync = require('nuclei/rsync');\n+\t// const client = new rsync.RsyncClient();\n+\t// ```\n+\tRsyncClient struct{}\n+\n \t// IsRsyncResponse is the response from the IsRsync function.\n \t// this is returned by IsRsync function.\n \t// @example\n@@ -25,8 +38,30 @@ type (\n \t\tIsRsync bool\n \t\tBanner  string\n \t}\n+\n+\t// ListSharesResponse is the response from the ListShares function.\n+\t// this is returned by ListShares function.\n+\t// @example\n+\t// ```javascript\n+\t// const rsync = require('nuclei/rsync');\n+\t// const client = new rsync.RsyncClient();\n+\t// const listShares = client.ListShares('acme.com', 873);\n+\t// log(toJSON(listShares));\n+\tRsyncListResponse struct {\n+\t\tModules []string\n+\t\tFiles   []string\n+\t\tOutput  string\n+\t}\n )\n \n+func connectWithFastDialer(executionId string, host string, port int) (net.Conn, error) {\n+\tdialer := protocolstate.GetDialersWithId(executionId)\n+\tif dialer == nil {\n+\t\treturn nil, fmt.Errorf(\"dialers not initialized for %s\", executionId)\n+\t}\n+\treturn dialer.Fastdialer.Dial(context.Background(), \"tcp\", net.JoinHostPort(host, strconv.Itoa(port)))\n+}\n+\n // IsRsync checks if a host is running a Rsync server.\n // @example\n // ```javascript\n@@ -44,11 +79,7 @@ func isRsync(executionId string, host string, port int) (IsRsyncResponse, error)\n \tresp := IsRsyncResponse{}\n \n \ttimeout := 5 * time.Second\n-\tdialer := protocolstate.GetDialersWithId(executionId)\n-\tif dialer == nil {\n-\t\treturn IsRsyncResponse{}, fmt.Errorf(\"dialers not initialized for %s\", executionId)\n-\t}\n-\tconn, err := dialer.Fastdialer.Dial(context.TODO(), \"tcp\", net.JoinHostPort(host, strconv.Itoa(port)))\n+\tconn, err := connectWithFastDialer(executionId, host, port)\n \tif err != nil {\n \t\treturn resp, err\n \t}\n@@ -59,7 +90,7 @@ func isRsync(executionId string, host string, port int) (IsRsyncResponse, error)\n \trsyncPlugin := rsync.RSYNCPlugin{}\n \tservice, err := rsyncPlugin.Run(conn, timeout, plugins.Target{Host: host})\n \tif err != nil {\n-\t\treturn resp, err\n+\t\treturn resp, nil\n \t}\n \tif service == nil {\n \t\treturn resp, nil\n@@ -68,3 +99,115 @@ func isRsync(executionId string, host string, port int) (IsRsyncResponse, error)\n \tresp.IsRsync = true\n \treturn resp, nil\n }\n+\n+// ListModules lists the modules of a Rsync server.\n+// @example\n+// ```javascript\n+// const rsync = require('nuclei/rsync');\n+// const client = new rsync.RsyncClient();\n+// const listModules = client.ListModules('acme.com', 873, 'username', 'password');\n+// log(toJSON(listModules));\n+// ```\n+func (c *RsyncClient) ListModules(ctx context.Context, host string, port int, username string, password string) (RsyncListResponse, error) {\n+\texecutionId := ctx.Value(\"executionId\").(string)\n+\treturn listModules(executionId, host, port, username, password)\n+}\n+\n+// ListShares lists the shares of a Rsync server.\n+// @example\n+// ```javascript\n+// const rsync = require('nuclei/rsync');\n+// const client = new rsync.RsyncClient();\n+// const listShares = client.ListFilesInModule('acme.com', 873, 'username', 'password', '/');\n+// log(toJSON(listShares));\n+// ```\n+func (c *RsyncClient) ListFilesInModule(ctx context.Context, host string, port int, username string, password string, module string) (RsyncListResponse, error) {\n+\texecutionId := ctx.Value(\"executionId\").(string)\n+\treturn listFilesInModule(executionId, host, port, username, password, module)\n+}\n+\n+func listModules(executionId string, host string, port int, username string, password string) (RsyncListResponse, error) {\n+\tfastDialer := protocolstate.GetDialersWithId(executionId)\n+\tif fastDialer == nil {\n+\t\treturn RsyncListResponse{}, fmt.Errorf(\"dialers not initialized for %s\", executionId)\n+\t}\n+\n+\taddress := net.JoinHostPort(host, strconv.Itoa(port))\n+\n+\t// Create a bytes buffer for logging\n+\tvar logBuffer bytes.Buffer\n+\n+\t// Create a custom slog handler that writes to the buffer\n+\tlogHandler := slog.NewTextHandler(&logBuffer, &slog.HandlerOptions{\n+\t\tLevel: slog.LevelDebug,\n+\t})\n+\n+\t// Create a logger that writes to our buffer\n+\tlogger := slog.New(logHandler)\n+\n+\tsr, err := rsynclib.ListModules(address,\n+\t\trsynclib.WithClientAuth(username, password),\n+\t\trsynclib.WithLogger(logger),\n+\t\trsynclib.WithFastDialer(fastDialer.Fastdialer),\n+\t)\n+\tif err != nil {\n+\t\treturn RsyncListResponse{}, fmt.Errorf(\"connect failed: %v\", err)\n+\t}\n+\n+\tresult := RsyncListResponse{\n+\t\tModules: make([]string, len(sr)),\n+\t\tOutput:  logBuffer.String(),\n+\t}\n+\n+\tfor i, item := range sr {\n+\t\tresult.Modules[i] = string(item.Name)\n+\t}\n+\n+\treturn result, nil\n+}\n+\n+func listFilesInModule(executionId string, host string, port int, username string, password string, module string) (RsyncListResponse, error) {\n+\tfastDialer := protocolstate.GetDialersWithId(executionId)\n+\tif fastDialer == nil {\n+\t\treturn RsyncListResponse{}, fmt.Errorf(\"dialers not initialized for %s\", executionId)\n+\t}\n+\n+\taddress := net.JoinHostPort(host, strconv.Itoa(port))\n+\n+\t// Create a bytes buffer for logging\n+\tvar logBuffer bytes.Buffer\n+\n+\t// Create a custom slog handler that writes to the buffer\n+\tlogHandler := slog.NewTextHandler(&logBuffer, &slog.HandlerOptions{\n+\t\tLevel: slog.LevelDebug,\n+\t})\n+\n+\t// Create a logger that writes to our buffer\n+\tlogger := slog.New(logHandler)\n+\n+\tsr, err := rsynclib.SocketClient(nil, address, module, \".\",\n+\t\trsynclib.WithClientAuth(username, password),\n+\t\trsynclib.WithLogger(logger),\n+\t\trsynclib.WithFastDialer(fastDialer.Fastdialer),\n+\t)\n+\tif err != nil {\n+\t\treturn RsyncListResponse{}, fmt.Errorf(\"connect failed: %v\", err)\n+\t}\n+\n+\t// Try to list files to test authentication\n+\tlist, err := sr.List()\n+\tif err != nil {\n+\t\treturn RsyncListResponse{}, fmt.Errorf(\"authentication failed: %v\", err)\n+\t}\n+\n+\tresult := RsyncListResponse{\n+\t\tFiles:  make([]string, len(list)),\n+\t\tOutput: logBuffer.String(),\n+\t}\n+\n+\tfor i, item := range list {\n+\t\tresult.Files[i] = string(item.Path)\n+\t}\n+\n+\treturn result, nil\n+}\n", "test_patch": "diff --git a/cmd/integration-test/javascript.go b/cmd/integration-test/javascript.go\nindex 63b2d59e85..c85a8758a2 100644\n--- a/cmd/integration-test/javascript.go\n+++ b/cmd/integration-test/javascript.go\n@@ -15,6 +15,7 @@ var jsTestcases = []TestCaseInfo{\n \t{Path: \"protocols/javascript/ssh-server-fingerprint.yaml\", TestCase: &javascriptSSHServerFingerprint{}, DisableOn: func() bool { return osutils.IsWindows() || osutils.IsOSX() }},\n \t{Path: \"protocols/javascript/net-multi-step.yaml\", TestCase: &networkMultiStep{}},\n \t{Path: \"protocols/javascript/net-https.yaml\", TestCase: &javascriptNetHttps{}},\n+\t{Path: \"protocols/javascript/rsync-test.yaml\", TestCase: &javascriptRsyncTest{}, DisableOn: func() bool { return osutils.IsWindows() || osutils.IsOSX() }},\n \t{Path: \"protocols/javascript/oracle-auth-test.yaml\", TestCase: &javascriptOracleAuthTest{}, DisableOn: func() bool { return osutils.IsWindows() || osutils.IsOSX() }},\n \t{Path: \"protocols/javascript/vnc-pass-brute.yaml\", TestCase: &javascriptVncPassBrute{}},\n \t{Path: \"protocols/javascript/postgres-pass-brute.yaml\", TestCase: &javascriptPostgresPassBrute{}, DisableOn: func() bool { return osutils.IsWindows() || osutils.IsOSX() }},\n@@ -30,6 +31,7 @@ var (\n \tvncResource      *dockertest.Resource\n \tpostgresResource *dockertest.Resource\n \tmysqlResource    *dockertest.Resource\n+\trsyncResource    *dockertest.Resource\n \tpool             *dockertest.Pool\n \tdefaultRetry     = 3\n )\n@@ -124,7 +126,7 @@ func (j *javascriptOracleAuthTest) Execute(filePath string) error {\n \t\tresults := []string{}\n \t\tvar err error\n \t\t_ = pool.Retry(func() error {\n-\t\t\t//let ssh server start\n+\t\t\t// let oracle server start\n \t\t\ttime.Sleep(3 * time.Second)\n \t\t\tresults, err = testutils.RunNucleiTemplateAndGetResults(filePath, finalURL, debug)\n \t\t\treturn nil\n@@ -258,6 +260,38 @@ func (j *javascriptNoPortArgs) Execute(filePath string) error {\n \treturn expectResultsCount(results, 1)\n }\n \n+type javascriptRsyncTest struct{}\n+\n+func (j *javascriptRsyncTest) Execute(filePath string) error {\n+\tif rsyncResource == nil || pool == nil {\n+\t\t// skip test as rsync is not running\n+\t\treturn nil\n+\t}\n+\ttempPort := rsyncResource.GetPort(\"873/tcp\")\n+\tfinalURL := \"localhost:\" + tempPort\n+\tdefer purge(rsyncResource)\n+\terrs := []error{}\n+\tfor i := 0; i < defaultRetry; i++ {\n+\t\tresults := []string{}\n+\t\tvar err error\n+\t\t_ = pool.Retry(func() error {\n+\t\t\t//let rsync server start\n+\t\t\ttime.Sleep(3 * time.Second)\n+\t\t\tresults, err = testutils.RunNucleiTemplateAndGetResults(filePath, finalURL, debug)\n+\t\t\treturn nil\n+\t\t})\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err := expectResultsCount(results, 1); err == nil {\n+\t\t\treturn nil\n+\t\t} else {\n+\t\t\terrs = append(errs, err)\n+\t\t}\n+\t}\n+\treturn multierr.Combine(errs...)\n+}\n+\n // purge any given resource if it is not nil\n func purge(resource *dockertest.Resource) {\n \tif resource != nil && pool != nil {\n@@ -397,4 +431,20 @@ func init() {\n \tif err := mysqlResource.Expire(30); err != nil {\n \t\tlog.Printf(\"Could not expire mysql resource: %s\", err)\n \t}\n+\n+\t// setup a temporary rsync server\n+\trsyncResource, err = pool.RunWithOptions(&dockertest.RunOptions{\n+\t\tRepository: \"alpine\",\n+\t\tTag:        \"latest\",\n+\t\tCmd:        []string{\"sh\", \"-c\", \"apk add --no-cache rsync shadow && useradd -m rsyncuser && echo 'rsyncuser:mysecret' | chpasswd && echo 'rsyncuser:MySecret123' > /etc/rsyncd.secrets && chmod 600 /etc/rsyncd.secrets && echo -e '[data]\\\\n  path = /data\\\\n  comment = Local Rsync Share\\\\n  read only = false\\\\n  auth users = rsyncuser\\\\n  secrets file = /etc/rsyncd.secrets' > /etc/rsyncd.conf && mkdir -p /data && exec rsync --daemon --no-detach --config=/etc/rsyncd.conf\"},\n+\t\tPlatform:   \"linux/amd64\",\n+\t})\n+\tif err != nil {\n+\t\tlog.Printf(\"Could not start Rsync resource: %s\", err)\n+\t\treturn\n+\t}\n+\t// by default expire after 30 sec\n+\tif err := rsyncResource.Expire(30); err != nil {\n+\t\tlog.Printf(\"Could not expire Rsync resource: %s\", err)\n+\t}\n }\ndiff --git a/integration_tests/protocols/javascript/rsync-test.yaml b/integration_tests/protocols/javascript/rsync-test.yaml\nnew file mode 100644\nindex 0000000000..ce4ae4895e\n--- /dev/null\n+++ b/integration_tests/protocols/javascript/rsync-test.yaml\n@@ -0,0 +1,21 @@\n+id: rsync-test\n+\n+info:\n+  name: Rsync Test\n+  author: pdteam\n+  severity: info\n+\n+javascript:\n+  - code: |\n+      const rsync = require('nuclei/rsync');\n+      rsync.IsRsync(Host, Port);\n+\n+    args:\n+      Host: \"{{Host}}\"\n+      Port: \"873\"\n+\n+    matchers:\n+      - type: dsl\n+        dsl:\n+          - \"success == true\"\n+          \n\\ No newline at end of file\n"}
{"org": "netbirdio", "repo": "netbird", "number": 4969, "state": "closed", "title": "[client, management] Feature/ssh fine grained access", "body": "## Describe your changes\r\n\r\nAdd fine-grained SSH access control with authorized users/groups\r\n\r\n## Issue ticket number and link\r\n\r\n## Stack\r\n\r\n<!-- branch-stack -->\r\n\r\n### Checklist\r\n- [ ] Is it a bug fix\r\n- [ ] Is a typo/documentation fix\r\n- [x] Is a feature enhancement\r\n- [ ] It is a refactor\r\n- [ ] Created tests that fail without the change (if possible)\r\n\r\n> By submitting this pull request, you confirm that you have read and agree to the terms of the [Contributor License Agreement](https://github.com/netbirdio/netbird/blob/main/CONTRIBUTOR_LICENSE_AGREEMENT.md).\r\n\r\n## Documentation\r\nSelect exactly one:\r\n\r\n- [x] I added/updated documentation for this change\r\n- [ ] Documentation is **not needed** for this change (explain why)\r\n\r\n### Docs PR URL (required if \"docs added\" is checked)\r\nPaste the PR link from https://github.com/netbirdio/docs here:\r\n\r\nhttps://github.com/netbirdio/docs/pull/530\r\n\r\n\r\n<!-- This is an auto-generated comment: release notes by coderabbit.ai -->\r\n## Summary by CodeRabbit\r\n\r\n* **New Features**\r\n  * Runtime-updatable SSH access control with per-user hashed IDs and per-OS-user mappings\r\n  * Policy support for a new \"netbird-ssh\" protocol and per-source-group authorized-users\r\n  * Network maps and login responses now include SSH enablement and per-user authorization\r\n  * Peer API and OpenAPI extended with peer-local flags schema\r\n\r\n* **Behavioral Changes**\r\n  * Active-group user mappings now factor into network maps and peer resource calculations\r\n  * Peer-update propagation now triggers more broadly for user changes\r\n\r\n* **Tests**\r\n  * Extensive unit tests added for SSH auth, user hashing, JWT/proxy flows, policies and group behaviors\r\n\r\n<sub>âœï¸ Tip: You can customize this high-level summary in your review settings.</sub>\r\n<!-- end of auto-generated comment: release notes by coderabbit.ai -->", "url": "https://api.github.com/repos/netbirdio/netbird/pulls/4969", "id": 3114038541, "node_id": "PR_kwDOFVUT7865nHUN", "html_url": "https://github.com/netbirdio/netbird/pull/4969", "diff_url": "https://github.com/netbirdio/netbird/pull/4969.diff", "patch_url": "https://github.com/netbirdio/netbird/pull/4969.patch", "issue_url": "https://api.github.com/repos/netbirdio/netbird/issues/4969", "created_at": "2025-12-18T14:41:01+00:00", "updated_at": "2025-12-29T11:50:44+00:00", "closed_at": "2025-12-29T11:50:41+00:00", "merged_at": "2025-12-29T11:50:41+00:00", "merge_commit_sha": "67f7b2404ede1f1ff5d5b4aab09546c074777733", "labels": [], "draft": false, "commits_url": "https://api.github.com/repos/netbirdio/netbird/pulls/4969/commits", "review_comments_url": "https://api.github.com/repos/netbirdio/netbird/pulls/4969/comments", "review_comment_url": "https://api.github.com/repos/netbirdio/netbird/pulls/comments{/number}", "comments_url": "https://api.github.com/repos/netbirdio/netbird/issues/4969/comments", "base": {"label": "netbirdio:main", "ref": "main", "sha": "b7e98acd1f5f329366864d4add4c8350750c4d96", "user": {"login": "netbirdio", "id": 100464677, "node_id": "O_kgDOBfz4JQ", "avatar_url": "https://avatars.githubusercontent.com/u/100464677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/netbirdio", "html_url": "https://github.com/netbirdio", "followers_url": "https://api.github.com/users/netbirdio/followers", "following_url": "https://api.github.com/users/netbirdio/following{/other_user}", "gists_url": "https://api.github.com/users/netbirdio/gists{/gist_id}", "starred_url": "https://api.github.com/users/netbirdio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/netbirdio/subscriptions", "organizations_url": "https://api.github.com/users/netbirdio/orgs", "repos_url": "https://api.github.com/users/netbirdio/repos", "events_url": "https://api.github.com/users/netbirdio/events{/privacy}", "received_events_url": "https://api.github.com/users/netbirdio/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "repo": {"id": 357897199, "node_id": "MDEwOlJlcG9zaXRvcnkzNTc4OTcxOTk=", "name": "netbird", "full_name": "netbirdio/netbird", "private": false, "owner": {"login": "netbirdio", "id": 100464677, "node_id": "O_kgDOBfz4JQ", "avatar_url": "https://avatars.githubusercontent.com/u/100464677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/netbirdio", "html_url": "https://github.com/netbirdio", "followers_url": "https://api.github.com/users/netbirdio/followers", "following_url": "https://api.github.com/users/netbirdio/following{/other_user}", "gists_url": "https://api.github.com/users/netbirdio/gists{/gist_id}", "starred_url": "https://api.github.com/users/netbirdio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/netbirdio/subscriptions", "organizations_url": "https://api.github.com/users/netbirdio/orgs", "repos_url": "https://api.github.com/users/netbirdio/repos", "events_url": "https://api.github.com/users/netbirdio/events{/privacy}", "received_events_url": "https://api.github.com/users/netbirdio/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "html_url": "https://github.com/netbirdio/netbird", "description": "Connect your devices into a secure WireGuardÂ®-based overlay network with SSO, MFA and granular access controls.", "fork": false, "url": "https://api.github.com/repos/netbirdio/netbird", "forks_url": "https://api.github.com/repos/netbirdio/netbird/forks", "keys_url": "https://api.github.com/repos/netbirdio/netbird/keys{/key_id}", "collaborators_url": "https://api.github.com/repos/netbirdio/netbird/collaborators{/collaborator}", "teams_url": "https://api.github.com/repos/netbirdio/netbird/teams", "hooks_url": "https://api.github.com/repos/netbirdio/netbird/hooks", "issue_events_url": "https://api.github.com/repos/netbirdio/netbird/issues/events{/number}", "events_url": "https://api.github.com/repos/netbirdio/netbird/events", "assignees_url": "https://api.github.com/repos/netbirdio/netbird/assignees{/user}", "branches_url": "https://api.github.com/repos/netbirdio/netbird/branches{/branch}", "tags_url": "https://api.github.com/repos/netbirdio/netbird/tags", "blobs_url": "https://api.github.com/repos/netbirdio/netbird/git/blobs{/sha}", "git_tags_url": "https://api.github.com/repos/netbirdio/netbird/git/tags{/sha}", "git_refs_url": "https://api.github.com/repos/netbirdio/netbird/git/refs{/sha}", "trees_url": "https://api.github.com/repos/netbirdio/netbird/git/trees{/sha}", "statuses_url": "https://api.github.com/repos/netbirdio/netbird/statuses/{sha}", "languages_url": "https://api.github.com/repos/netbirdio/netbird/languages", "stargazers_url": "https://api.github.com/repos/netbirdio/netbird/stargazers", "contributors_url": "https://api.github.com/repos/netbirdio/netbird/contributors", "subscribers_url": "https://api.github.com/repos/netbirdio/netbird/subscribers", "subscription_url": "https://api.github.com/repos/netbirdio/netbird/subscription", "commits_url": "https://api.github.com/repos/netbirdio/netbird/commits{/sha}", "git_commits_url": "https://api.github.com/repos/netbirdio/netbird/git/commits{/sha}", "comments_url": "https://api.github.com/repos/netbirdio/netbird/comments{/number}", "issue_comment_url": "https://api.github.com/repos/netbirdio/netbird/issues/comments{/number}", "contents_url": "https://api.github.com/repos/netbirdio/netbird/contents/{+path}", "compare_url": "https://api.github.com/repos/netbirdio/netbird/compare/{base}...{head}", "merges_url": "https://api.github.com/repos/netbirdio/netbird/merges", "archive_url": "https://api.github.com/repos/netbirdio/netbird/{archive_format}{/ref}", "downloads_url": "https://api.github.com/repos/netbirdio/netbird/downloads", "issues_url": "https://api.github.com/repos/netbirdio/netbird/issues{/number}", "pulls_url": "https://api.github.com/repos/netbirdio/netbird/pulls{/number}", "milestones_url": "https://api.github.com/repos/netbirdio/netbird/milestones{/number}", "notifications_url": "https://api.github.com/repos/netbirdio/netbird/notifications{?since,all,participating}", "labels_url": "https://api.github.com/repos/netbirdio/netbird/labels{/name}", "releases_url": "https://api.github.com/repos/netbirdio/netbird/releases{/id}", "deployments_url": "https://api.github.com/repos/netbirdio/netbird/deployments", "created_at": "2021-04-14T12:27:20Z", "updated_at": "2026-01-07T04:18:10Z", "pushed_at": "2026-01-07T05:22:46Z", "git_url": "git://github.com/netbirdio/netbird.git", "ssh_url": "git@github.com:netbirdio/netbird.git", "clone_url": "https://github.com/netbirdio/netbird.git", "svn_url": "https://github.com/netbirdio/netbird", "homepage": "https://netbird.io", "size": 47404, "stargazers_count": 20703, "watchers_count": 20703, "language": "Go", "has_issues": true, "has_projects": true, "has_downloads": true, "has_wiki": true, "has_pages": false, "has_discussions": false, "forks_count": 1009, "mirror_url": null, "archived": false, "disabled": false, "open_issues_count": 1188, "license": {"key": "other", "name": "Other", "spdx_id": "NOASSERTION", "url": null, "node_id": "MDc6TGljZW5zZTA="}, "allow_forking": true, "is_template": false, "web_commit_signoff_required": false, "topics": ["golang", "mesh", "mesh-networks", "nat-traversal", "netbird", "vpn", "wireguard", "wireguard-vpn", "wiretrustee", "zero-trust-network-access"], "visibility": "public", "forks": 1009, "open_issues": 1188, "watchers": 20703, "default_branch": "main"}}, "commits": [{"sha": "ee6d96eac5dbdaf84b21fe868cd457cf946062ba", "parents": ["537151e0f365bfd9c94e8fa5b9c88b7cb1b78a02"], "message": "[management] add authorized users proto (#4961)"}, {"sha": "d378aa6d87bcb0a1ff5491e6742cc273994914ee", "parents": ["ee6d96eac5dbdaf84b21fe868cd457cf946062ba"], "message": "[client] Feature/ssh fine grained access client (#4962)\n\n* add authorized users proto\n\n* Add user hash type\n\n- Update management.proto to use fixed64 for AuthorizedUsers\n- Add shared sshauth package with UserIDHash type and FNV-1a hashing\n\n* Add client implementation\n\n* Add allowed user for tests\n\n* Add tests for SSH authorizer validation and user authorization logic\n\n* Add mutex for thread-safe SSH authorizer operations\n\n---------\n\nCo-authored-by: pascal <pascal@netbird.io>"}, {"sha": "e898a5817dfb361ae14a8a8d9df214e18a062552", "parents": ["d378aa6d87bcb0a1ff5491e6742cc273994914ee"], "message": "Fix test"}, {"sha": "437a3a7941adc199727275778f1cb452f341ade7", "parents": ["e898a5817dfb361ae14a8a8d9df214e18a062552"], "message": "[management] SSH authorized groups api (#4964)"}, {"sha": "1a6fc6c91729213c514abf6bfcd12d53c16c4243", "parents": ["437a3a7941adc199727275778f1cb452f341ade7"], "message": "Fix proxy test"}, {"sha": "d14d2a4c543e4be9c4a591a0aa589d02301306ae", "parents": ["1a6fc6c91729213c514abf6bfcd12d53c16c4243"], "message": "Fix concurency in tests"}, {"sha": "76c1cd10c0648836e5c6fa273ee85bdc85c9f6d2", "parents": ["d14d2a4c543e4be9c4a591a0aa589d02301306ae", "011cc81678833f49c24cab8abff960ed7635c9b6"], "message": "Merge branch 'main' into feature/ssh-fine-grained-access"}, {"sha": "2cc05abb39dc291f368a768f9b4294fd42e50224", "parents": ["76c1cd10c0648836e5c6fa273ee85bdc85c9f6d2"], "message": "Use BLAKE2b-256\n\n# Conflicts:\n#\tshared/management/proto/management.pb.go"}, {"sha": "9019747e2face4fd4260949ebb84cc3a5a239def", "parents": ["2cc05abb39dc291f368a768f9b4294fd42e50224"], "message": "Use BLAKE2b-128"}, {"sha": "3b28834454fab6d26975d3dd828151c667e8505b", "parents": ["9019747e2face4fd4260949ebb84cc3a5a239def"], "message": "Add error handling"}, {"sha": "1bdaa4002cd8207e8f920dfcaea618dac4fff584", "parents": ["3b28834454fab6d26975d3dd828151c667e8505b"], "message": "Feature/ssh fine grained access nmap (#4987)"}, {"sha": "317d816e3005b604d9dd756e12446a00de30be4a", "parents": ["1bdaa4002cd8207e8f920dfcaea618dac4fff584"], "message": "[management] return client flags on peers API (#4989)"}, {"sha": "0c7bcf0e8d9c956bbb368a1e478831203207562b", "parents": ["317d816e3005b604d9dd756e12446a00de30be4a", "b7e98acd1f5f329366864d4add4c8350750c4d96"], "message": "Merge branch 'main' into feature/ssh-fine-grained-access"}, {"sha": "9c70d0f970b064c39efd4802b116ddc162dec70b", "parents": ["0c7bcf0e8d9c956bbb368a1e478831203207562b"], "message": "send ssh flags on single peer api"}, {"sha": "be3702aac84cc7194f909c9433208550262b0bf5", "parents": ["9c70d0f970b064c39efd4802b116ddc162dec70b"], "message": "send JWT config on new policy"}, {"sha": "eae269dbb96bf9739e83062b569cadcdec560c9c", "parents": ["0c7bcf0e8d9c956bbb368a1e478831203207562b"], "message": "Remove invalid comment"}, {"sha": "0b884ccc29c81b14237058f0cc2d78faded2ba45", "parents": ["eae269dbb96bf9739e83062b569cadcdec560c9c", "be3702aac84cc7194f909c9433208550262b0bf5"], "message": "Merge remote-tracking branch 'origin/feature/ssh-fine-grained-access' into feature/ssh-fine-grained-access"}, {"sha": "75165d4bdac069b8065d79c66eaac39c5d30bc52", "parents": ["0b884ccc29c81b14237058f0cc2d78faded2ba45"], "message": "[management] use single user for authorized users list for browser client (#4994)"}, {"sha": "fc754067e2f4c712b1d6dc7ab9179eac9f7f1b56", "parents": ["75165d4bdac069b8065d79c66eaac39c5d30bc52"], "message": "Refine wildcard user index handling in SSH authorizer and add new test for partial wildcard index scenarios"}, {"sha": "cb32209ef6acc8585ad2eecd4965d0cc401954b0", "parents": ["fc754067e2f4c712b1d6dc7ab9179eac9f7f1b56"], "message": "update account peers after peer delete"}], "resolved_issues": [{"org": "netbirdio", "repo": "netbird", "number": -1, "state": "unknown", "title": "[client, management] Feature/ssh fine grained access", "body": "## Describe your changes\r\n\r\nAdd fine-grained SSH access control with authorized users/groups\r\n\r\n## Issue ticket number and link\r\n\r\n## Stack\r\n\r\n<!-- branch-stack -->\r\n\r\n### Checklist\r\n- [ ] Is it a bug fix\r\n- [ ] Is a typo/documentation fix\r\n- [x] Is a feature enhancement\r\n- [ ] It is a refactor\r\n- [ ] Created tests that fail without the change (if possible)\r\n\r\n> By submitting this pull request, you confirm that you have read and agree to the terms of the [Contributor License Agreement](https://github.com/netbirdio/netbird/blob/main/CONTRIBUTOR_LICENSE_AGREEMENT.md).\r\n\r\n## Documentation\r\nSelect exactly one:\r\n\r\n- [x] I added/updated documentation for this change\r\n- [ ] Documentation is **not needed** for this change (explain why)\r\n\r\n### Docs PR URL (required if \"docs added\" is checked)\r\nPaste the PR link from https://github.com/netbirdio/docs here:\r\n\r\nhttps://github.com/netbirdio/docs/pull/530\r\n\r\n\r\n<!-- This is an auto-generated comment: release notes by coderabbit.ai -->\r\n## Summary by CodeRabbit\r\n\r\n* **New Features**\r\n  * Runtime-updatable SSH access control with per-user hashed IDs and per-OS-user mappings\r\n  * Policy support for a new \"netbird-ssh\" protocol and per-source-group authorized-users\r\n  * Network maps and login responses now include SSH enablement and per-user authorization\r\n  * Peer API and OpenAPI extended with peer-local flags schema\r\n\r\n* **Behavioral Changes**\r\n  * Active-group user mappings now factor into network maps and peer resource calculations\r\n  * Peer-update propagation now triggers more broadly for user changes\r\n\r\n* **Tests**\r\n  * Extensive unit tests added for SSH auth, user hashing, JWT/proxy flows, policies and group behaviors\r\n\r\n<sub>âœï¸ Tip: You can customize this high-level summary in your review settings.</sub>\r\n<!-- end of auto-generated comment: release notes by coderabbit.ai -->"}], "fix_patch": "diff --git a/client/internal/engine.go b/client/internal/engine.go\nindex 084bafdbdb3..55645b4943e 100644\n--- a/client/internal/engine.go\n+++ b/client/internal/engine.go\n@@ -1151,6 +1151,8 @@ func (e *Engine) updateNetworkMap(networkMap *mgmProto.NetworkMap) error {\n \t\tif err := e.updateSSHClientConfig(networkMap.GetRemotePeers()); err != nil {\n \t\t\tlog.Warnf(\"failed to update SSH client config: %v\", err)\n \t\t}\n+\n+\t\te.updateSSHServerAuth(networkMap.GetSshAuth())\n \t}\n \n \t// must set the exclude list after the peers are added. Without it the manager can not figure out the peers parameters from the store\ndiff --git a/client/internal/engine_ssh.go b/client/internal/engine_ssh.go\nindex 861b3d6d215..e683d8ceea2 100644\n--- a/client/internal/engine_ssh.go\n+++ b/client/internal/engine_ssh.go\n@@ -11,15 +11,18 @@ import (\n \n \tfirewallManager \"github.com/netbirdio/netbird/client/firewall/manager\"\n \tnftypes \"github.com/netbirdio/netbird/client/internal/netflow/types\"\n+\tsshauth \"github.com/netbirdio/netbird/client/ssh/auth\"\n \tsshconfig \"github.com/netbirdio/netbird/client/ssh/config\"\n \tsshserver \"github.com/netbirdio/netbird/client/ssh/server\"\n \tmgmProto \"github.com/netbirdio/netbird/shared/management/proto\"\n+\tsshuserhash \"github.com/netbirdio/netbird/shared/sshauth\"\n )\n \n type sshServer interface {\n \tStart(ctx context.Context, addr netip.AddrPort) error\n \tStop() error\n \tGetStatus() (bool, []sshserver.SessionInfo)\n+\tUpdateSSHAuth(config *sshauth.Config)\n }\n \n func (e *Engine) setupSSHPortRedirection() error {\n@@ -353,3 +356,38 @@ func (e *Engine) GetSSHServerStatus() (enabled bool, sessions []sshserver.Sessio\n \n \treturn sshServer.GetStatus()\n }\n+\n+// updateSSHServerAuth updates SSH fine-grained access control configuration on a running SSH server\n+func (e *Engine) updateSSHServerAuth(sshAuth *mgmProto.SSHAuth) {\n+\tif sshAuth == nil {\n+\t\treturn\n+\t}\n+\n+\tif e.sshServer == nil {\n+\t\treturn\n+\t}\n+\n+\tprotoUsers := sshAuth.GetAuthorizedUsers()\n+\tauthorizedUsers := make([]sshuserhash.UserIDHash, len(protoUsers))\n+\tfor i, hash := range protoUsers {\n+\t\tif len(hash) != 16 {\n+\t\t\tlog.Warnf(\"invalid hash length %d, expected 16 - skipping SSH server auth update\", len(hash))\n+\t\t\treturn\n+\t\t}\n+\t\tauthorizedUsers[i] = sshuserhash.UserIDHash(hash)\n+\t}\n+\n+\tmachineUsers := make(map[string][]uint32)\n+\tfor osUser, indexes := range sshAuth.GetMachineUsers() {\n+\t\tmachineUsers[osUser] = indexes.GetIndexes()\n+\t}\n+\n+\t// Update SSH server with new authorization configuration\n+\tauthConfig := &sshauth.Config{\n+\t\tUserIDClaim:     sshAuth.GetUserIDClaim(),\n+\t\tAuthorizedUsers: authorizedUsers,\n+\t\tMachineUsers:    machineUsers,\n+\t}\n+\n+\te.sshServer.UpdateSSHAuth(authConfig)\n+}\ndiff --git a/client/ssh/auth/auth.go b/client/ssh/auth/auth.go\nnew file mode 100644\nindex 00000000000..488b6e12ef7\n--- /dev/null\n+++ b/client/ssh/auth/auth.go\n@@ -0,0 +1,184 @@\n+package auth\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"sync\"\n+\n+\tlog \"github.com/sirupsen/logrus\"\n+\n+\tsshuserhash \"github.com/netbirdio/netbird/shared/sshauth\"\n+)\n+\n+const (\n+\t// DefaultUserIDClaim is the default JWT claim used to extract user IDs\n+\tDefaultUserIDClaim = \"sub\"\n+\t// Wildcard is a special user ID that matches all users\n+\tWildcard = \"*\"\n+)\n+\n+var (\n+\tErrEmptyUserID           = errors.New(\"JWT user ID is empty\")\n+\tErrUserNotAuthorized     = errors.New(\"user is not authorized to access this peer\")\n+\tErrNoMachineUserMapping  = errors.New(\"no authorization mapping for OS user\")\n+\tErrUserNotMappedToOSUser = errors.New(\"user is not authorized to login as OS user\")\n+)\n+\n+// Authorizer handles SSH fine-grained access control authorization\n+type Authorizer struct {\n+\t// UserIDClaim is the JWT claim to extract the user ID from\n+\tuserIDClaim string\n+\n+\t// authorizedUsers is a list of hashed user IDs authorized to access this peer\n+\tauthorizedUsers []sshuserhash.UserIDHash\n+\n+\t// machineUsers maps OS login usernames to lists of authorized user indexes\n+\tmachineUsers map[string][]uint32\n+\n+\t// mu protects the list of users\n+\tmu sync.RWMutex\n+}\n+\n+// Config contains configuration for the SSH authorizer\n+type Config struct {\n+\t// UserIDClaim is the JWT claim to extract the user ID from (e.g., \"sub\", \"email\")\n+\tUserIDClaim string\n+\n+\t// AuthorizedUsers is a list of hashed user IDs (FNV-1a 64-bit) authorized to access this peer\n+\tAuthorizedUsers []sshuserhash.UserIDHash\n+\n+\t// MachineUsers maps OS login usernames to indexes in AuthorizedUsers\n+\t// If a user wants to login as a specific OS user, their index must be in the corresponding list\n+\tMachineUsers map[string][]uint32\n+}\n+\n+// NewAuthorizer creates a new SSH authorizer with empty configuration\n+func NewAuthorizer() *Authorizer {\n+\ta := &Authorizer{\n+\t\tuserIDClaim:  DefaultUserIDClaim,\n+\t\tmachineUsers: make(map[string][]uint32),\n+\t}\n+\n+\treturn a\n+}\n+\n+// Update updates the authorizer configuration with new values\n+func (a *Authorizer) Update(config *Config) {\n+\ta.mu.Lock()\n+\tdefer a.mu.Unlock()\n+\n+\tif config == nil {\n+\t\t// Clear authorization\n+\t\ta.userIDClaim = DefaultUserIDClaim\n+\t\ta.authorizedUsers = []sshuserhash.UserIDHash{}\n+\t\ta.machineUsers = make(map[string][]uint32)\n+\t\tlog.Info(\"SSH authorization cleared\")\n+\t\treturn\n+\t}\n+\n+\tuserIDClaim := config.UserIDClaim\n+\tif userIDClaim == \"\" {\n+\t\tuserIDClaim = DefaultUserIDClaim\n+\t}\n+\ta.userIDClaim = userIDClaim\n+\n+\t// Store authorized users list\n+\ta.authorizedUsers = config.AuthorizedUsers\n+\n+\t// Store machine users mapping\n+\tmachineUsers := make(map[string][]uint32)\n+\tfor osUser, indexes := range config.MachineUsers {\n+\t\tif len(indexes) > 0 {\n+\t\t\tmachineUsers[osUser] = indexes\n+\t\t}\n+\t}\n+\ta.machineUsers = machineUsers\n+\n+\tlog.Debugf(\"SSH auth: updated with %d authorized users, %d machine user mappings\",\n+\t\tlen(config.AuthorizedUsers), len(machineUsers))\n+}\n+\n+// Authorize validates if a user is authorized to login as the specified OS user\n+// Returns nil if authorized, or an error describing why authorization failed\n+func (a *Authorizer) Authorize(jwtUserID, osUsername string) error {\n+\tif jwtUserID == \"\" {\n+\t\tlog.Warnf(\"SSH auth denied: JWT user ID is empty for OS user '%s'\", osUsername)\n+\t\treturn ErrEmptyUserID\n+\t}\n+\n+\t// Hash the JWT user ID for comparison\n+\thashedUserID, err := sshuserhash.HashUserID(jwtUserID)\n+\tif err != nil {\n+\t\tlog.Errorf(\"SSH auth denied: failed to hash user ID '%s' for OS user '%s': %v\", jwtUserID, osUsername, err)\n+\t\treturn fmt.Errorf(\"failed to hash user ID: %w\", err)\n+\t}\n+\n+\ta.mu.RLock()\n+\tdefer a.mu.RUnlock()\n+\n+\t// Find the index of this user in the authorized list\n+\tuserIndex, found := a.findUserIndex(hashedUserID)\n+\tif !found {\n+\t\tlog.Warnf(\"SSH auth denied: user '%s' (hash: %s) not in authorized list for OS user '%s'\", jwtUserID, hashedUserID, osUsername)\n+\t\treturn ErrUserNotAuthorized\n+\t}\n+\n+\treturn a.checkMachineUserMapping(jwtUserID, osUsername, userIndex)\n+}\n+\n+// checkMachineUserMapping validates if a user's index is authorized for the specified OS user\n+// Checks wildcard mapping first, then specific OS user mappings\n+func (a *Authorizer) checkMachineUserMapping(jwtUserID, osUsername string, userIndex int) error {\n+\t// If wildcard exists and user's index is in the wildcard list, allow access to any OS user\n+\tif wildcardIndexes, hasWildcard := a.machineUsers[Wildcard]; hasWildcard {\n+\t\tif a.isIndexInList(uint32(userIndex), wildcardIndexes) {\n+\t\t\tlog.Infof(\"SSH auth granted: user '%s' authorized for OS user '%s' via wildcard (index: %d)\", jwtUserID, osUsername, userIndex)\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\n+\t// Check for specific OS username mapping\n+\tallowedIndexes, hasMachineUserMapping := a.machineUsers[osUsername]\n+\tif !hasMachineUserMapping {\n+\t\t// No mapping for this OS user - deny by default (fail closed)\n+\t\tlog.Warnf(\"SSH auth denied: no machine user mapping for OS user '%s' (JWT user: %s)\", osUsername, jwtUserID)\n+\t\treturn ErrNoMachineUserMapping\n+\t}\n+\n+\t// Check if user's index is in the allowed indexes for this specific OS user\n+\tif !a.isIndexInList(uint32(userIndex), allowedIndexes) {\n+\t\tlog.Warnf(\"SSH auth denied: user '%s' not mapped to OS user '%s' (user index: %d)\", jwtUserID, osUsername, userIndex)\n+\t\treturn ErrUserNotMappedToOSUser\n+\t}\n+\n+\tlog.Infof(\"SSH auth granted: user '%s' authorized for OS user '%s' (index: %d)\", jwtUserID, osUsername, userIndex)\n+\treturn nil\n+}\n+\n+// GetUserIDClaim returns the JWT claim name used to extract user IDs\n+func (a *Authorizer) GetUserIDClaim() string {\n+\ta.mu.RLock()\n+\tdefer a.mu.RUnlock()\n+\treturn a.userIDClaim\n+}\n+\n+// findUserIndex finds the index of a hashed user ID in the authorized users list\n+// Returns the index and true if found, 0 and false if not found\n+func (a *Authorizer) findUserIndex(hashedUserID sshuserhash.UserIDHash) (int, bool) {\n+\tfor i, id := range a.authorizedUsers {\n+\t\tif id == hashedUserID {\n+\t\t\treturn i, true\n+\t\t}\n+\t}\n+\treturn 0, false\n+}\n+\n+// isIndexInList checks if an index exists in a list of indexes\n+func (a *Authorizer) isIndexInList(index uint32, indexes []uint32) bool {\n+\tfor _, idx := range indexes {\n+\t\tif idx == index {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\ndiff --git a/client/ssh/server/server.go b/client/ssh/server/server.go\nindex 37763ee0e98..82718d00280 100644\n--- a/client/ssh/server/server.go\n+++ b/client/ssh/server/server.go\n@@ -21,6 +21,7 @@ import (\n \t\"golang.zx2c4.com/wireguard/tun/netstack\"\n \n \t\"github.com/netbirdio/netbird/client/iface/wgaddr\"\n+\tsshauth \"github.com/netbirdio/netbird/client/ssh/auth\"\n \t\"github.com/netbirdio/netbird/client/ssh/detection\"\n \t\"github.com/netbirdio/netbird/shared/auth\"\n \t\"github.com/netbirdio/netbird/shared/auth/jwt\"\n@@ -138,6 +139,8 @@ type Server struct {\n \tjwtExtractor *jwt.ClaimsExtractor\n \tjwtConfig    *JWTConfig\n \n+\tauthorizer *sshauth.Authorizer\n+\n \tsuSupportsPty    bool\n \tloginIsUtilLinux bool\n }\n@@ -179,6 +182,7 @@ func New(config *Config) *Server {\n \t\tsshConnections:         make(map[*cryptossh.ServerConn]*sshConnectionState),\n \t\tjwtEnabled:             config.JWT != nil,\n \t\tjwtConfig:              config.JWT,\n+\t\tauthorizer:             sshauth.NewAuthorizer(), // Initialize with empty config\n \t}\n \n \treturn s\n@@ -320,6 +324,19 @@ func (s *Server) SetNetworkValidation(addr wgaddr.Address) {\n \ts.wgAddress = addr\n }\n \n+// UpdateSSHAuth updates the SSH fine-grained access control configuration\n+// This should be called when network map updates include new SSH auth configuration\n+func (s *Server) UpdateSSHAuth(config *sshauth.Config) {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n+\t// Reset JWT validator/extractor to pick up new userIDClaim\n+\ts.jwtValidator = nil\n+\ts.jwtExtractor = nil\n+\n+\ts.authorizer.Update(config)\n+}\n+\n // ensureJWTValidator initializes the JWT validator and extractor if not already initialized\n func (s *Server) ensureJWTValidator() error {\n \ts.mu.RLock()\n@@ -328,6 +345,7 @@ func (s *Server) ensureJWTValidator() error {\n \t\treturn nil\n \t}\n \tconfig := s.jwtConfig\n+\tauthorizer := s.authorizer\n \ts.mu.RUnlock()\n \n \tif config == nil {\n@@ -343,9 +361,16 @@ func (s *Server) ensureJWTValidator() error {\n \t\ttrue,\n \t)\n \n-\textractor := jwt.NewClaimsExtractor(\n+\t// Use custom userIDClaim from authorizer if available\n+\textractorOptions := []jwt.ClaimsExtractorOption{\n \t\tjwt.WithAudience(config.Audience),\n-\t)\n+\t}\n+\tif authorizer.GetUserIDClaim() != \"\" {\n+\t\textractorOptions = append(extractorOptions, jwt.WithUserIDClaim(authorizer.GetUserIDClaim()))\n+\t\tlog.Debugf(\"Using custom user ID claim: %s\", authorizer.GetUserIDClaim())\n+\t}\n+\n+\textractor := jwt.NewClaimsExtractor(extractorOptions...)\n \n \ts.mu.Lock()\n \tdefer s.mu.Unlock()\n@@ -493,29 +518,41 @@ func (s *Server) parseTokenWithoutValidation(tokenString string) (map[string]int\n }\n \n func (s *Server) passwordHandler(ctx ssh.Context, password string) bool {\n+\tosUsername := ctx.User()\n+\tremoteAddr := ctx.RemoteAddr()\n+\n \tif err := s.ensureJWTValidator(); err != nil {\n-\t\tlog.Errorf(\"JWT validator initialization failed for user %s from %s: %v\", ctx.User(), ctx.RemoteAddr(), err)\n+\t\tlog.Errorf(\"JWT validator initialization failed for user %s from %s: %v\", osUsername, remoteAddr, err)\n \t\treturn false\n \t}\n \n \ttoken, err := s.validateJWTToken(password)\n \tif err != nil {\n-\t\tlog.Warnf(\"JWT authentication failed for user %s from %s: %v\", ctx.User(), ctx.RemoteAddr(), err)\n+\t\tlog.Warnf(\"JWT authentication failed for user %s from %s: %v\", osUsername, remoteAddr, err)\n \t\treturn false\n \t}\n \n \tuserAuth, err := s.extractAndValidateUser(token)\n \tif err != nil {\n-\t\tlog.Warnf(\"User validation failed for user %s from %s: %v\", ctx.User(), ctx.RemoteAddr(), err)\n+\t\tlog.Warnf(\"User validation failed for user %s from %s: %v\", osUsername, remoteAddr, err)\n+\t\treturn false\n+\t}\n+\n+\ts.mu.RLock()\n+\tauthorizer := s.authorizer\n+\ts.mu.RUnlock()\n+\n+\tif err := authorizer.Authorize(userAuth.UserId, osUsername); err != nil {\n+\t\tlog.Warnf(\"SSH authorization denied for user %s (JWT user ID: %s) from %s: %v\", osUsername, userAuth.UserId, remoteAddr, err)\n \t\treturn false\n \t}\n \n-\tkey := newAuthKey(ctx.User(), ctx.RemoteAddr())\n+\tkey := newAuthKey(osUsername, remoteAddr)\n \ts.mu.Lock()\n \ts.pendingAuthJWT[key] = userAuth.UserId\n \ts.mu.Unlock()\n \n-\tlog.Infof(\"JWT authentication successful for user %s (JWT user ID: %s) from %s\", ctx.User(), userAuth.UserId, ctx.RemoteAddr())\n+\tlog.Infof(\"JWT authentication successful for user %s (JWT user ID: %s) from %s\", osUsername, userAuth.UserId, remoteAddr)\n \treturn true\n }\n \ndiff --git a/management/internals/controllers/network_map/controller/controller.go b/management/internals/controllers/network_map/controller/controller.go\nindex 022ea774ce3..df16e192264 100644\n--- a/management/internals/controllers/network_map/controller/controller.go\n+++ b/management/internals/controllers/network_map/controller/controller.go\n@@ -178,6 +178,7 @@ func (c *Controller) sendUpdateAccountPeers(ctx context.Context, accountID strin\n \tcustomZone := account.GetPeersCustomZone(ctx, dnsDomain)\n \tresourcePolicies := account.GetResourcePoliciesMap()\n \trouters := account.GetResourceRoutersMap()\n+\tgroupIDToUserIDs := account.GetActiveGroupUsers()\n \n \tif c.experimentalNetworkMap(accountID) {\n \t\tc.initNetworkMapBuilderIfNeeded(account, approvedPeersMap)\n@@ -224,7 +225,7 @@ func (c *Controller) sendUpdateAccountPeers(ctx context.Context, accountID strin\n \t\t\tif c.experimentalNetworkMap(accountID) {\n \t\t\t\tremotePeerNetworkMap = c.getPeerNetworkMapExp(ctx, p.AccountID, p.ID, approvedPeersMap, customZone, c.accountManagerMetrics)\n \t\t\t} else {\n-\t\t\t\tremotePeerNetworkMap = account.GetPeerNetworkMap(ctx, p.ID, customZone, approvedPeersMap, resourcePolicies, routers, c.accountManagerMetrics)\n+\t\t\t\tremotePeerNetworkMap = account.GetPeerNetworkMap(ctx, p.ID, customZone, approvedPeersMap, resourcePolicies, routers, c.accountManagerMetrics, groupIDToUserIDs)\n \t\t\t}\n \n \t\t\tc.metrics.CountCalcPeerNetworkMapDuration(time.Since(start))\n@@ -320,6 +321,7 @@ func (c *Controller) UpdateAccountPeer(ctx context.Context, accountId string, pe\n \tcustomZone := account.GetPeersCustomZone(ctx, dnsDomain)\n \tresourcePolicies := account.GetResourcePoliciesMap()\n \trouters := account.GetResourceRoutersMap()\n+\tgroupIDToUserIDs := account.GetActiveGroupUsers()\n \n \tpostureChecks, err := c.getPeerPostureChecks(account, peerId)\n \tif err != nil {\n@@ -338,7 +340,7 @@ func (c *Controller) UpdateAccountPeer(ctx context.Context, accountId string, pe\n \tif c.experimentalNetworkMap(accountId) {\n \t\tremotePeerNetworkMap = c.getPeerNetworkMapExp(ctx, peer.AccountID, peer.ID, approvedPeersMap, customZone, c.accountManagerMetrics)\n \t} else {\n-\t\tremotePeerNetworkMap = account.GetPeerNetworkMap(ctx, peerId, customZone, approvedPeersMap, resourcePolicies, routers, c.accountManagerMetrics)\n+\t\tremotePeerNetworkMap = account.GetPeerNetworkMap(ctx, peerId, customZone, approvedPeersMap, resourcePolicies, routers, c.accountManagerMetrics, groupIDToUserIDs)\n \t}\n \n \tproxyNetworkMap, ok := proxyNetworkMaps[peer.ID]\n@@ -445,7 +447,7 @@ func (c *Controller) GetValidatedPeerWithMap(ctx context.Context, isRequiresAppr\n \tif c.experimentalNetworkMap(accountID) {\n \t\tnetworkMap = c.getPeerNetworkMapExp(ctx, peer.AccountID, peer.ID, approvedPeersMap, customZone, c.accountManagerMetrics)\n \t} else {\n-\t\tnetworkMap = account.GetPeerNetworkMap(ctx, peer.ID, customZone, approvedPeersMap, account.GetResourcePoliciesMap(), account.GetResourceRoutersMap(), c.accountManagerMetrics)\n+\t\tnetworkMap = account.GetPeerNetworkMap(ctx, peer.ID, customZone, approvedPeersMap, account.GetResourcePoliciesMap(), account.GetResourceRoutersMap(), c.accountManagerMetrics, account.GetActiveGroupUsers())\n \t}\n \n \tproxyNetworkMap, ok := proxyNetworkMaps[peer.ID]\n@@ -811,7 +813,7 @@ func (c *Controller) GetNetworkMap(ctx context.Context, peerID string) (*types.N\n \tif c.experimentalNetworkMap(peer.AccountID) {\n \t\tnetworkMap = c.getPeerNetworkMapExp(ctx, peer.AccountID, peerID, validatedPeers, customZone, nil)\n \t} else {\n-\t\tnetworkMap = account.GetPeerNetworkMap(ctx, peer.ID, customZone, validatedPeers, account.GetResourcePoliciesMap(), account.GetResourceRoutersMap(), nil)\n+\t\tnetworkMap = account.GetPeerNetworkMap(ctx, peer.ID, customZone, validatedPeers, account.GetResourcePoliciesMap(), account.GetResourceRoutersMap(), nil, account.GetActiveGroupUsers())\n \t}\n \n \tproxyNetworkMap, ok := proxyNetworkMaps[peer.ID]\ndiff --git a/management/internals/modules/peers/manager.go b/management/internals/modules/peers/manager.go\nindex e82f19e632d..b200b96638b 100644\n--- a/management/internals/modules/peers/manager.go\n+++ b/management/internals/modules/peers/manager.go\n@@ -158,5 +158,7 @@ func (m *managerImpl) DeletePeers(ctx context.Context, accountID string, peerIDs\n \t\t}\n \t}\n \n+\tm.accountManager.UpdateAccountPeers(ctx, accountID)\n+\n \treturn nil\n }\ndiff --git a/management/internals/shared/grpc/conversion.go b/management/internals/shared/grpc/conversion.go\nindex 1a0dc009b05..f984c73df3f 100644\n--- a/management/internals/shared/grpc/conversion.go\n+++ b/management/internals/shared/grpc/conversion.go\n@@ -6,7 +6,10 @@ import (\n \t\"net/url\"\n \t\"strings\"\n \n+\tlog \"github.com/sirupsen/logrus\"\n+\n \tintegrationsConfig \"github.com/netbirdio/management-integrations/integrations/config\"\n+\t\"github.com/netbirdio/netbird/client/ssh/auth\"\n \n \tnbdns \"github.com/netbirdio/netbird/dns\"\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map/controller/cache\"\n@@ -16,6 +19,7 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/types\"\n \t\"github.com/netbirdio/netbird/route\"\n \t\"github.com/netbirdio/netbird/shared/management/proto\"\n+\t\"github.com/netbirdio/netbird/shared/sshauth\"\n )\n \n func toNetbirdConfig(config *nbconfig.Config, turnCredentials *Token, relayToken *Token, extraSettings *types.ExtraSettings) *proto.NetbirdConfig {\n@@ -84,15 +88,15 @@ func toNetbirdConfig(config *nbconfig.Config, turnCredentials *Token, relayToken\n \treturn nbConfig\n }\n \n-func toPeerConfig(peer *nbpeer.Peer, network *types.Network, dnsName string, settings *types.Settings, httpConfig *nbconfig.HttpServerConfig, deviceFlowConfig *nbconfig.DeviceAuthorizationFlow) *proto.PeerConfig {\n+func toPeerConfig(peer *nbpeer.Peer, network *types.Network, dnsName string, settings *types.Settings, httpConfig *nbconfig.HttpServerConfig, deviceFlowConfig *nbconfig.DeviceAuthorizationFlow, enableSSH bool) *proto.PeerConfig {\n \tnetmask, _ := network.Net.Mask.Size()\n \tfqdn := peer.FQDN(dnsName)\n \n \tsshConfig := &proto.SSHConfig{\n-\t\tSshEnabled: peer.SSHEnabled,\n+\t\tSshEnabled: peer.SSHEnabled || enableSSH,\n \t}\n \n-\tif peer.SSHEnabled {\n+\tif sshConfig.SshEnabled {\n \t\tsshConfig.JwtConfig = buildJWTConfig(httpConfig, deviceFlowConfig)\n \t}\n \n@@ -110,12 +114,12 @@ func toPeerConfig(peer *nbpeer.Peer, network *types.Network, dnsName string, set\n \n func ToSyncResponse(ctx context.Context, config *nbconfig.Config, httpConfig *nbconfig.HttpServerConfig, deviceFlowConfig *nbconfig.DeviceAuthorizationFlow, peer *nbpeer.Peer, turnCredentials *Token, relayCredentials *Token, networkMap *types.NetworkMap, dnsName string, checks []*posture.Checks, dnsCache *cache.DNSConfigCache, settings *types.Settings, extraSettings *types.ExtraSettings, peerGroups []string, dnsFwdPort int64) *proto.SyncResponse {\n \tresponse := &proto.SyncResponse{\n-\t\tPeerConfig: toPeerConfig(peer, networkMap.Network, dnsName, settings, httpConfig, deviceFlowConfig),\n+\t\tPeerConfig: toPeerConfig(peer, networkMap.Network, dnsName, settings, httpConfig, deviceFlowConfig, networkMap.EnableSSH),\n \t\tNetworkMap: &proto.NetworkMap{\n \t\t\tSerial:     networkMap.Network.CurrentSerial(),\n \t\t\tRoutes:     toProtocolRoutes(networkMap.Routes),\n \t\t\tDNSConfig:  toProtocolDNSConfig(networkMap.DNSConfig, dnsCache, dnsFwdPort),\n-\t\t\tPeerConfig: toPeerConfig(peer, networkMap.Network, dnsName, settings, httpConfig, deviceFlowConfig),\n+\t\t\tPeerConfig: toPeerConfig(peer, networkMap.Network, dnsName, settings, httpConfig, deviceFlowConfig, networkMap.EnableSSH),\n \t\t},\n \t\tChecks: toProtocolChecks(ctx, checks),\n \t}\n@@ -151,9 +155,45 @@ func ToSyncResponse(ctx context.Context, config *nbconfig.Config, httpConfig *nb\n \t\tresponse.NetworkMap.ForwardingRules = forwardingRules\n \t}\n \n+\tif networkMap.AuthorizedUsers != nil {\n+\t\thashedUsers, machineUsers := buildAuthorizedUsersProto(ctx, networkMap.AuthorizedUsers)\n+\t\tuserIDClaim := auth.DefaultUserIDClaim\n+\t\tif httpConfig != nil && httpConfig.AuthUserIDClaim != \"\" {\n+\t\t\tuserIDClaim = httpConfig.AuthUserIDClaim\n+\t\t}\n+\t\tresponse.NetworkMap.SshAuth = &proto.SSHAuth{AuthorizedUsers: hashedUsers, MachineUsers: machineUsers, UserIDClaim: userIDClaim}\n+\t}\n+\n \treturn response\n }\n \n+func buildAuthorizedUsersProto(ctx context.Context, authorizedUsers map[string]map[string]struct{}) ([][]byte, map[string]*proto.MachineUserIndexes) {\n+\tuserIDToIndex := make(map[string]uint32)\n+\tvar hashedUsers [][]byte\n+\tmachineUsers := make(map[string]*proto.MachineUserIndexes, len(authorizedUsers))\n+\n+\tfor machineUser, users := range authorizedUsers {\n+\t\tindexes := make([]uint32, 0, len(users))\n+\t\tfor userID := range users {\n+\t\t\tidx, exists := userIDToIndex[userID]\n+\t\t\tif !exists {\n+\t\t\t\thash, err := sshauth.HashUserID(userID)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tlog.WithContext(ctx).Errorf(\"failed to hash user id %s: %v\", userID, err)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tidx = uint32(len(hashedUsers))\n+\t\t\t\tuserIDToIndex[userID] = idx\n+\t\t\t\thashedUsers = append(hashedUsers, hash[:])\n+\t\t\t}\n+\t\t\tindexes = append(indexes, idx)\n+\t\t}\n+\t\tmachineUsers[machineUser] = &proto.MachineUserIndexes{Indexes: indexes}\n+\t}\n+\n+\treturn hashedUsers, machineUsers\n+}\n+\n func appendRemotePeerConfig(dst []*proto.RemotePeerConfig, peers []*nbpeer.Peer, dnsName string) []*proto.RemotePeerConfig {\n \tfor _, rPeer := range peers {\n \t\tdst = append(dst, &proto.RemotePeerConfig{\ndiff --git a/management/internals/shared/grpc/server.go b/management/internals/shared/grpc/server.go\nindex 462e2e6ebf3..ad6b34c5ff4 100644\n--- a/management/internals/shared/grpc/server.go\n+++ b/management/internals/shared/grpc/server.go\n@@ -635,7 +635,7 @@ func (s *Server) prepareLoginResponse(ctx context.Context, peer *nbpeer.Peer, ne\n \t// if peer has reached this point then it has logged in\n \tloginResp := &proto.LoginResponse{\n \t\tNetbirdConfig: toNetbirdConfig(s.config, nil, relayToken, nil),\n-\t\tPeerConfig:    toPeerConfig(peer, netMap.Network, s.networkMapController.GetDNSDomain(settings), settings, s.config.HttpConfig, s.config.DeviceAuthorizationFlow),\n+\t\tPeerConfig:    toPeerConfig(peer, netMap.Network, s.networkMapController.GetDNSDomain(settings), settings, s.config.HttpConfig, s.config.DeviceAuthorizationFlow, netMap.EnableSSH),\n \t\tChecks:        toProtocolChecks(ctx, postureChecks),\n \t}\n \ndiff --git a/management/server/account.go b/management/server/account.go\nindex 04f83842e75..405a3c0f635 100644\n--- a/management/server/account.go\n+++ b/management/server/account.go\n@@ -1456,21 +1456,19 @@ func (am *DefaultAccountManager) SyncUserJWTGroups(ctx context.Context, userAuth\n \t\t}\n \t}\n \n-\tif settings.GroupsPropagationEnabled {\n-\t\tremovedGroupAffectsPeers, err := areGroupChangesAffectPeers(ctx, am.Store, userAuth.AccountId, removeOldGroups)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n+\tremovedGroupAffectsPeers, err := areGroupChangesAffectPeers(ctx, am.Store, userAuth.AccountId, removeOldGroups)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \n-\t\tnewGroupsAffectsPeers, err := areGroupChangesAffectPeers(ctx, am.Store, userAuth.AccountId, addNewGroups)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n+\tnewGroupsAffectsPeers, err := areGroupChangesAffectPeers(ctx, am.Store, userAuth.AccountId, addNewGroups)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \n-\t\tif removedGroupAffectsPeers || newGroupsAffectsPeers {\n-\t\t\tlog.WithContext(ctx).Tracef(\"user %s: JWT group membership changed, updating account peers\", userAuth.UserId)\n-\t\t\tam.BufferUpdateAccountPeers(ctx, userAuth.AccountId)\n-\t\t}\n+\tif removedGroupAffectsPeers || newGroupsAffectsPeers {\n+\t\tlog.WithContext(ctx).Tracef(\"user %s: JWT group membership changed, updating account peers\", userAuth.UserId)\n+\t\tam.BufferUpdateAccountPeers(ctx, userAuth.AccountId)\n \t}\n \n \treturn nil\ndiff --git a/management/server/http/handlers/peers/peers_handler.go b/management/server/http/handlers/peers/peers_handler.go\nindex f531f0cdb24..a5c9ab0ac47 100644\n--- a/management/server/http/handlers/peers/peers_handler.go\n+++ b/management/server/http/handlers/peers/peers_handler.go\n@@ -299,7 +299,7 @@ func (h *Handler) GetAccessiblePeers(w http.ResponseWriter, r *http.Request) {\n \tdnsDomain := h.networkMapController.GetDNSDomain(account.Settings)\n \n \tcustomZone := account.GetPeersCustomZone(r.Context(), dnsDomain)\n-\tnetMap := account.GetPeerNetworkMap(r.Context(), peerID, customZone, validPeers, account.GetResourcePoliciesMap(), account.GetResourceRoutersMap(), nil)\n+\tnetMap := account.GetPeerNetworkMap(r.Context(), peerID, customZone, validPeers, account.GetResourcePoliciesMap(), account.GetResourceRoutersMap(), nil, account.GetActiveGroupUsers())\n \n \tutil.WriteJSONObject(r.Context(), w, toAccessiblePeers(netMap, dnsDomain))\n }\n@@ -369,6 +369,9 @@ func (h *Handler) CreateTemporaryAccess(w http.ResponseWriter, r *http.Request)\n \t\t\t\tPortRanges:    []types.RulePortRange{portRange},\n \t\t\t}},\n \t\t}\n+\t\tif protocol == types.PolicyRuleProtocolNetbirdSSH {\n+\t\t\tpolicy.Rules[0].AuthorizedUser = userAuth.UserId\n+\t\t}\n \n \t\t_, err = h.accountManager.SavePolicy(r.Context(), userAuth.AccountId, userAuth.UserId, policy, true)\n \t\tif err != nil {\n@@ -449,6 +452,18 @@ func toSinglePeerResponse(peer *nbpeer.Peer, groupsInfo []api.GroupMinimum, dnsD\n \t\tSerialNumber:                peer.Meta.SystemSerialNumber,\n \t\tInactivityExpirationEnabled: peer.InactivityExpirationEnabled,\n \t\tEphemeral:                   peer.Ephemeral,\n+\t\tLocalFlags: &api.PeerLocalFlags{\n+\t\t\tBlockInbound:          &peer.Meta.Flags.BlockInbound,\n+\t\t\tBlockLanAccess:        &peer.Meta.Flags.BlockLANAccess,\n+\t\t\tDisableClientRoutes:   &peer.Meta.Flags.DisableClientRoutes,\n+\t\t\tDisableDns:            &peer.Meta.Flags.DisableDNS,\n+\t\t\tDisableFirewall:       &peer.Meta.Flags.DisableFirewall,\n+\t\t\tDisableServerRoutes:   &peer.Meta.Flags.DisableServerRoutes,\n+\t\t\tLazyConnectionEnabled: &peer.Meta.Flags.LazyConnectionEnabled,\n+\t\t\tRosenpassEnabled:      &peer.Meta.Flags.RosenpassEnabled,\n+\t\t\tRosenpassPermissive:   &peer.Meta.Flags.RosenpassPermissive,\n+\t\t\tServerSshAllowed:      &peer.Meta.Flags.ServerSSHAllowed,\n+\t\t},\n \t}\n \n \tif !approved {\n@@ -463,7 +478,6 @@ func toPeerListItemResponse(peer *nbpeer.Peer, groupsInfo []api.GroupMinimum, dn\n \tif osVersion == \"\" {\n \t\tosVersion = peer.Meta.Core\n \t}\n-\n \treturn &api.PeerBatch{\n \t\tCreatedAt:                   peer.CreatedAt,\n \t\tId:                          peer.ID,\n@@ -492,6 +506,18 @@ func toPeerListItemResponse(peer *nbpeer.Peer, groupsInfo []api.GroupMinimum, dn\n \t\tSerialNumber:                peer.Meta.SystemSerialNumber,\n \t\tInactivityExpirationEnabled: peer.InactivityExpirationEnabled,\n \t\tEphemeral:                   peer.Ephemeral,\n+\t\tLocalFlags: &api.PeerLocalFlags{\n+\t\t\tBlockInbound:          &peer.Meta.Flags.BlockInbound,\n+\t\t\tBlockLanAccess:        &peer.Meta.Flags.BlockLANAccess,\n+\t\t\tDisableClientRoutes:   &peer.Meta.Flags.DisableClientRoutes,\n+\t\t\tDisableDns:            &peer.Meta.Flags.DisableDNS,\n+\t\t\tDisableFirewall:       &peer.Meta.Flags.DisableFirewall,\n+\t\t\tDisableServerRoutes:   &peer.Meta.Flags.DisableServerRoutes,\n+\t\t\tLazyConnectionEnabled: &peer.Meta.Flags.LazyConnectionEnabled,\n+\t\t\tRosenpassEnabled:      &peer.Meta.Flags.RosenpassEnabled,\n+\t\t\tRosenpassPermissive:   &peer.Meta.Flags.RosenpassPermissive,\n+\t\t\tServerSshAllowed:      &peer.Meta.Flags.ServerSSHAllowed,\n+\t\t},\n \t}\n }\n \ndiff --git a/management/server/http/handlers/policies/policies_handler.go b/management/server/http/handlers/policies/policies_handler.go\nindex ab1639ab146..e4d1d73dfd8 100644\n--- a/management/server/http/handlers/policies/policies_handler.go\n+++ b/management/server/http/handlers/policies/policies_handler.go\n@@ -221,6 +221,8 @@ func (h *handler) savePolicy(w http.ResponseWriter, r *http.Request, accountID s\n \t\t\tpr.Protocol = types.PolicyRuleProtocolUDP\n \t\tcase api.PolicyRuleUpdateProtocolIcmp:\n \t\t\tpr.Protocol = types.PolicyRuleProtocolICMP\n+\t\tcase api.PolicyRuleUpdateProtocolNetbirdSsh:\n+\t\t\tpr.Protocol = types.PolicyRuleProtocolNetbirdSSH\n \t\tdefault:\n \t\t\tutil.WriteError(r.Context(), status.Errorf(status.InvalidArgument, \"unknown protocol type: %v\", rule.Protocol), w)\n \t\t\treturn\n@@ -254,6 +256,17 @@ func (h *handler) savePolicy(w http.ResponseWriter, r *http.Request, accountID s\n \t\t\t}\n \t\t}\n \n+\t\tif pr.Protocol == types.PolicyRuleProtocolNetbirdSSH && rule.AuthorizedGroups != nil && len(*rule.AuthorizedGroups) != 0 {\n+\t\t\tfor _, sourceGroupID := range pr.Sources {\n+\t\t\t\t_, ok := (*rule.AuthorizedGroups)[sourceGroupID]\n+\t\t\t\tif !ok {\n+\t\t\t\t\tutil.WriteError(r.Context(), status.Errorf(status.InvalidArgument, \"authorized group for netbird-ssh protocol should be specified for each source group\"), w)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tpr.AuthorizedGroups = *rule.AuthorizedGroups\n+\t\t}\n+\n \t\t// validate policy object\n \t\tif pr.Protocol == types.PolicyRuleProtocolALL || pr.Protocol == types.PolicyRuleProtocolICMP {\n \t\t\tif len(pr.Ports) != 0 || len(pr.PortRanges) != 0 {\n@@ -380,6 +393,11 @@ func toPolicyResponse(groups []*types.Group, policy *types.Policy) *api.Policy {\n \t\t\tDestinationResource: r.DestinationResource.ToAPIResponse(),\n \t\t}\n \n+\t\tif len(r.AuthorizedGroups) != 0 {\n+\t\t\tauthorizedGroupsCopy := r.AuthorizedGroups\n+\t\t\trule.AuthorizedGroups = &authorizedGroupsCopy\n+\t\t}\n+\n \t\tif len(r.Ports) != 0 {\n \t\t\tportsCopy := r.Ports\n \t\t\trule.Ports = &portsCopy\ndiff --git a/management/server/peer.go b/management/server/peer.go\nindex 49f5bf2a500..7c48a805279 100644\n--- a/management/server/peer.go\n+++ b/management/server/peer.go\n@@ -91,7 +91,7 @@ func (am *DefaultAccountManager) getUserAccessiblePeers(ctx context.Context, acc\n \n \t// fetch all the peers that have access to the user's peers\n \tfor _, peer := range peers {\n-\t\taclPeers, _ := account.GetPeerConnectionResources(ctx, peer, approvedPeersMap)\n+\t\taclPeers, _, _, _ := account.GetPeerConnectionResources(ctx, peer, approvedPeersMap, account.GetActiveGroupUsers())\n \t\tfor _, p := range aclPeers {\n \t\t\tpeersMap[p.ID] = p\n \t\t}\n@@ -1057,7 +1057,7 @@ func (am *DefaultAccountManager) checkIfUserOwnsPeer(ctx context.Context, accoun\n \t}\n \n \tfor _, p := range userPeers {\n-\t\taclPeers, _ := account.GetPeerConnectionResources(ctx, p, approvedPeersMap)\n+\t\taclPeers, _, _, _ := account.GetPeerConnectionResources(ctx, p, approvedPeersMap, account.GetActiveGroupUsers())\n \t\tfor _, aclPeer := range aclPeers {\n \t\t\tif aclPeer.ID == peer.ID {\n \t\t\t\treturn peer, nil\ndiff --git a/management/server/store/sql_store.go b/management/server/store/sql_store.go\nindex 2b8981b97c1..da05ba416f8 100644\n--- a/management/server/store/sql_store.go\n+++ b/management/server/store/sql_store.go\n@@ -1910,16 +1910,16 @@ func (s *SqlStore) getPolicyRules(ctx context.Context, policyIDs []string) ([]*t\n \tif len(policyIDs) == 0 {\n \t\treturn nil, nil\n \t}\n-\tconst query = `SELECT id, policy_id, name, description, enabled, action, destinations, destination_resource, sources, source_resource, bidirectional, protocol, ports, port_ranges FROM policy_rules WHERE policy_id = ANY($1)`\n+\tconst query = `SELECT id, policy_id, name, description, enabled, action, destinations, destination_resource, sources, source_resource, bidirectional, protocol, ports, port_ranges, authorized_groups, authorized_user FROM policy_rules WHERE policy_id = ANY($1)`\n \trows, err := s.pool.Query(ctx, query, policyIDs)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \trules, err := pgx.CollectRows(rows, func(row pgx.CollectableRow) (*types.PolicyRule, error) {\n \t\tvar r types.PolicyRule\n-\t\tvar dest, destRes, sources, sourceRes, ports, portRanges []byte\n+\t\tvar dest, destRes, sources, sourceRes, ports, portRanges, authorizedGroups []byte\n \t\tvar enabled, bidirectional sql.NullBool\n-\t\terr := row.Scan(&r.ID, &r.PolicyID, &r.Name, &r.Description, &enabled, &r.Action, &dest, &destRes, &sources, &sourceRes, &bidirectional, &r.Protocol, &ports, &portRanges)\n+\t\terr := row.Scan(&r.ID, &r.PolicyID, &r.Name, &r.Description, &enabled, &r.Action, &dest, &destRes, &sources, &sourceRes, &bidirectional, &r.Protocol, &ports, &portRanges, &authorizedGroups, &r.AuthorizedUser)\n \t\tif err == nil {\n \t\t\tif enabled.Valid {\n \t\t\t\tr.Enabled = enabled.Bool\n@@ -1945,6 +1945,9 @@ func (s *SqlStore) getPolicyRules(ctx context.Context, policyIDs []string) ([]*t\n \t\t\tif portRanges != nil {\n \t\t\t\t_ = json.Unmarshal(portRanges, &r.PortRanges)\n \t\t\t}\n+\t\t\tif authorizedGroups != nil {\n+\t\t\t\t_ = json.Unmarshal(authorizedGroups, &r.AuthorizedGroups)\n+\t\t\t}\n \t\t}\n \t\treturn &r, err\n \t})\ndiff --git a/management/server/types/account.go b/management/server/types/account.go\nindex 9e86d89366c..c43e0bb57b6 100644\n--- a/management/server/types/account.go\n+++ b/management/server/types/account.go\n@@ -16,6 +16,7 @@ import (\n \t\"github.com/rs/xid\"\n \tlog \"github.com/sirupsen/logrus\"\n \n+\t\"github.com/netbirdio/netbird/client/ssh/auth\"\n \tnbdns \"github.com/netbirdio/netbird/dns\"\n \tresourceTypes \"github.com/netbirdio/netbird/management/server/networks/resources/types\"\n \trouterTypes \"github.com/netbirdio/netbird/management/server/networks/routers/types\"\n@@ -45,8 +46,10 @@ const (\n \n \t// nativeSSHPortString defines the default port number as a string used for native SSH connections; this port is used by clients when hijacking ssh connections.\n \tnativeSSHPortString = \"22022\"\n+\tnativeSSHPortNumber = 22022\n \t// defaultSSHPortString defines the standard SSH port number as a string, commonly used for default SSH connections.\n \tdefaultSSHPortString = \"22\"\n+\tdefaultSSHPortNumber = 22\n )\n \n type supportedFeatures struct {\n@@ -275,6 +278,7 @@ func (a *Account) GetPeerNetworkMap(\n \tresourcePolicies map[string][]*Policy,\n \trouters map[string]map[string]*routerTypes.NetworkRouter,\n \tmetrics *telemetry.AccountManagerMetrics,\n+\tgroupIDToUserIDs map[string][]string,\n ) *NetworkMap {\n \tstart := time.Now()\n \tpeer := a.Peers[peerID]\n@@ -290,7 +294,7 @@ func (a *Account) GetPeerNetworkMap(\n \t\t}\n \t}\n \n-\taclPeers, firewallRules := a.GetPeerConnectionResources(ctx, peer, validatedPeersMap)\n+\taclPeers, firewallRules, authorizedUsers, enableSSH := a.GetPeerConnectionResources(ctx, peer, validatedPeersMap, groupIDToUserIDs)\n \t// exclude expired peers\n \tvar peersToConnect []*nbpeer.Peer\n \tvar expiredPeers []*nbpeer.Peer\n@@ -338,6 +342,8 @@ func (a *Account) GetPeerNetworkMap(\n \t\tOfflinePeers:        expiredPeers,\n \t\tFirewallRules:       firewallRules,\n \t\tRoutesFirewallRules: slices.Concat(networkResourcesFirewallRules, routesFirewallRules),\n+\t\tAuthorizedUsers:     authorizedUsers,\n+\t\tEnableSSH:           enableSSH,\n \t}\n \n \tif metrics != nil {\n@@ -1009,8 +1015,10 @@ func (a *Account) UserGroupsRemoveFromPeers(userID string, groups ...string) map\n // GetPeerConnectionResources for a given peer\n //\n // This function returns the list of peers and firewall rules that are applicable to a given peer.\n-func (a *Account) GetPeerConnectionResources(ctx context.Context, peer *nbpeer.Peer, validatedPeersMap map[string]struct{}) ([]*nbpeer.Peer, []*FirewallRule) {\n+func (a *Account) GetPeerConnectionResources(ctx context.Context, peer *nbpeer.Peer, validatedPeersMap map[string]struct{}, groupIDToUserIDs map[string][]string) ([]*nbpeer.Peer, []*FirewallRule, map[string]map[string]struct{}, bool) {\n \tgenerateResources, getAccumulatedResources := a.connResourcesGenerator(ctx, peer)\n+\tauthorizedUsers := make(map[string]map[string]struct{}) // machine user to list of userIDs\n+\tsshEnabled := false\n \n \tfor _, policy := range a.Policies {\n \t\tif !policy.Enabled {\n@@ -1053,10 +1061,58 @@ func (a *Account) GetPeerConnectionResources(ctx context.Context, peer *nbpeer.P\n \t\t\tif peerInDestinations {\n \t\t\t\tgenerateResources(rule, sourcePeers, FirewallRuleDirectionIN)\n \t\t\t}\n+\n+\t\t\tif peerInDestinations && rule.Protocol == PolicyRuleProtocolNetbirdSSH {\n+\t\t\t\tsshEnabled = true\n+\t\t\t\tswitch {\n+\t\t\t\tcase len(rule.AuthorizedGroups) > 0:\n+\t\t\t\t\tfor groupID, localUsers := range rule.AuthorizedGroups {\n+\t\t\t\t\t\tuserIDs, ok := groupIDToUserIDs[groupID]\n+\t\t\t\t\t\tif !ok {\n+\t\t\t\t\t\t\tlog.WithContext(ctx).Tracef(\"no user IDs found for group ID %s\", groupID)\n+\t\t\t\t\t\t\tcontinue\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif len(localUsers) == 0 {\n+\t\t\t\t\t\t\tlocalUsers = []string{auth.Wildcard}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tfor _, localUser := range localUsers {\n+\t\t\t\t\t\t\tif authorizedUsers[localUser] == nil {\n+\t\t\t\t\t\t\t\tauthorizedUsers[localUser] = make(map[string]struct{})\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tfor _, userID := range userIDs {\n+\t\t\t\t\t\t\t\tauthorizedUsers[localUser][userID] = struct{}{}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\tcase rule.AuthorizedUser != \"\":\n+\t\t\t\t\tif authorizedUsers[auth.Wildcard] == nil {\n+\t\t\t\t\t\tauthorizedUsers[auth.Wildcard] = make(map[string]struct{})\n+\t\t\t\t\t}\n+\t\t\t\t\tauthorizedUsers[auth.Wildcard][rule.AuthorizedUser] = struct{}{}\n+\t\t\t\tdefault:\n+\t\t\t\t\tauthorizedUsers[auth.Wildcard] = a.getAllowedUserIDs()\n+\t\t\t\t}\n+\t\t\t} else if peerInDestinations && policyRuleImpliesLegacySSH(rule) && peer.SSHEnabled {\n+\t\t\t\tsshEnabled = true\n+\t\t\t\tauthorizedUsers[auth.Wildcard] = a.getAllowedUserIDs()\n+\t\t\t}\n \t\t}\n \t}\n \n-\treturn getAccumulatedResources()\n+\tpeers, fwRules := getAccumulatedResources()\n+\treturn peers, fwRules, authorizedUsers, sshEnabled\n+}\n+\n+func (a *Account) getAllowedUserIDs() map[string]struct{} {\n+\tusers := make(map[string]struct{})\n+\tfor _, nbUser := range a.Users {\n+\t\tif !nbUser.IsBlocked() && !nbUser.IsServiceUser {\n+\t\t\tusers[nbUser.Id] = struct{}{}\n+\t\t}\n+\t}\n+\treturn users\n }\n \n // connResourcesGenerator returns generator and accumulator function which returns the result of generator calls\n@@ -1081,12 +1137,17 @@ func (a *Account) connResourcesGenerator(ctx context.Context, targetPeer *nbpeer\n \t\t\t\t\tpeersExists[peer.ID] = struct{}{}\n \t\t\t\t}\n \n+\t\t\t\tprotocol := rule.Protocol\n+\t\t\t\tif protocol == PolicyRuleProtocolNetbirdSSH {\n+\t\t\t\t\tprotocol = PolicyRuleProtocolTCP\n+\t\t\t\t}\n+\n \t\t\t\tfr := FirewallRule{\n \t\t\t\t\tPolicyID:  rule.ID,\n \t\t\t\t\tPeerIP:    peer.IP.String(),\n \t\t\t\t\tDirection: direction,\n \t\t\t\t\tAction:    string(rule.Action),\n-\t\t\t\t\tProtocol:  string(rule.Protocol),\n+\t\t\t\t\tProtocol:  string(protocol),\n \t\t\t\t}\n \n \t\t\t\truleID := rule.ID + fr.PeerIP + strconv.Itoa(direction) +\n@@ -1108,6 +1169,28 @@ func (a *Account) connResourcesGenerator(ctx context.Context, targetPeer *nbpeer\n \t\t}\n }\n \n+func policyRuleImpliesLegacySSH(rule *PolicyRule) bool {\n+\treturn rule.Protocol == PolicyRuleProtocolALL || (rule.Protocol == PolicyRuleProtocolTCP && (portsIncludesSSH(rule.Ports) || portRangeIncludesSSH(rule.PortRanges)))\n+}\n+\n+func portRangeIncludesSSH(portRanges []RulePortRange) bool {\n+\tfor _, pr := range portRanges {\n+\t\tif (pr.Start <= defaultSSHPortNumber && pr.End >= defaultSSHPortNumber) || (pr.Start <= nativeSSHPortNumber && pr.End >= nativeSSHPortNumber) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+func portsIncludesSSH(ports []string) bool {\n+\tfor _, port := range ports {\n+\t\tif port == defaultSSHPortString || port == nativeSSHPortString {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n // getAllPeersFromGroups for given peer ID and list of groups\n //\n // Returns a list of peers from specified groups that pass specified posture checks\n@@ -1660,6 +1743,26 @@ func (a *Account) AddAllGroup(disableDefaultPolicy bool) error {\n \treturn nil\n }\n \n+func (a *Account) GetActiveGroupUsers() map[string][]string {\n+\tallGroupID := \"\"\n+\tgroup, err := a.GetGroupAll()\n+\tif err != nil {\n+\t\tlog.Errorf(\"failed to get group all: %v\", err)\n+\t} else {\n+\t\tallGroupID = group.ID\n+\t}\n+\tgroups := make(map[string][]string, len(a.GroupsG))\n+\tfor _, user := range a.Users {\n+\t\tif !user.IsBlocked() && !user.IsServiceUser {\n+\t\t\tfor _, groupID := range user.AutoGroups {\n+\t\t\t\tgroups[groupID] = append(groups[groupID], user.Id)\n+\t\t\t}\n+\t\t\tgroups[allGroupID] = append(groups[allGroupID], user.Id)\n+\t\t}\n+\t}\n+\treturn groups\n+}\n+\n // expandPortsAndRanges expands Ports and PortRanges of a rule into individual firewall rules\n func expandPortsAndRanges(base FirewallRule, rule *PolicyRule, peer *nbpeer.Peer) []*FirewallRule {\n \tfeatures := peerSupportedFirewallFeatures(peer.Meta.WtVersion)\n@@ -1691,7 +1794,7 @@ func expandPortsAndRanges(base FirewallRule, rule *PolicyRule, peer *nbpeer.Peer\n \t\texpanded = append(expanded, &fr)\n \t}\n \n-\tif shouldCheckRulesForNativeSSH(features.nativeSSH, rule, peer) {\n+\tif shouldCheckRulesForNativeSSH(features.nativeSSH, rule, peer) || rule.Protocol == PolicyRuleProtocolNetbirdSSH {\n \t\texpanded = addNativeSSHRule(base, expanded)\n \t}\n \ndiff --git a/management/server/types/network.go b/management/server/types/network.go\nindex ffc01956517..d3708d80af5 100644\n--- a/management/server/types/network.go\n+++ b/management/server/types/network.go\n@@ -38,6 +38,8 @@ type NetworkMap struct {\n \tFirewallRules       []*FirewallRule\n \tRoutesFirewallRules []*RouteFirewallRule\n \tForwardingRules     []*ForwardingRule\n+\tAuthorizedUsers     map[string]map[string]struct{}\n+\tEnableSSH           bool\n }\n \n func (nm *NetworkMap) Merge(other *NetworkMap) {\ndiff --git a/management/server/types/policy.go b/management/server/types/policy.go\nindex 5e86a87c6c3..d4e1a8816b9 100644\n--- a/management/server/types/policy.go\n+++ b/management/server/types/policy.go\n@@ -23,6 +23,8 @@ const (\n \tPolicyRuleProtocolUDP = PolicyRuleProtocolType(\"udp\")\n \t// PolicyRuleProtocolICMP type of traffic\n \tPolicyRuleProtocolICMP = PolicyRuleProtocolType(\"icmp\")\n+\t// PolicyRuleProtocolNetbirdSSH type of traffic\n+\tPolicyRuleProtocolNetbirdSSH = PolicyRuleProtocolType(\"netbird-ssh\")\n )\n \n const (\n@@ -167,6 +169,8 @@ func ParseRuleString(rule string) (PolicyRuleProtocolType, RulePortRange, error)\n \t\tprotocol = PolicyRuleProtocolUDP\n \tcase \"icmp\":\n \t\treturn \"\", RulePortRange{}, errors.New(\"icmp does not accept ports; use 'icmp' without '/â€¦'\")\n+\tcase \"netbird-ssh\":\n+\t\treturn PolicyRuleProtocolNetbirdSSH, RulePortRange{Start: nativeSSHPortNumber, End: nativeSSHPortNumber}, nil\n \tdefault:\n \t\treturn \"\", RulePortRange{}, fmt.Errorf(\"invalid protocol: %q\", protoStr)\n \t}\ndiff --git a/management/server/types/policyrule.go b/management/server/types/policyrule.go\nindex 2643ae45c70..bb75dd55573 100644\n--- a/management/server/types/policyrule.go\n+++ b/management/server/types/policyrule.go\n@@ -80,6 +80,12 @@ type PolicyRule struct {\n \n \t// PortRanges a list of port ranges.\n \tPortRanges []RulePortRange `gorm:\"serializer:json\"`\n+\n+\t// AuthorizedGroups is a map of groupIDs and their respective access to local users via ssh\n+\tAuthorizedGroups map[string][]string `gorm:\"serializer:json\"`\n+\n+\t// AuthorizedUser is a list of userIDs that are authorized to access local resources via ssh\n+\tAuthorizedUser string\n }\n \n // Copy returns a copy of a policy rule\n@@ -99,10 +105,16 @@ func (pm *PolicyRule) Copy() *PolicyRule {\n \t\tProtocol:            pm.Protocol,\n \t\tPorts:               make([]string, len(pm.Ports)),\n \t\tPortRanges:          make([]RulePortRange, len(pm.PortRanges)),\n+\t\tAuthorizedGroups:    make(map[string][]string, len(pm.AuthorizedGroups)),\n+\t\tAuthorizedUser:      pm.AuthorizedUser,\n \t}\n \tcopy(rule.Destinations, pm.Destinations)\n \tcopy(rule.Sources, pm.Sources)\n \tcopy(rule.Ports, pm.Ports)\n \tcopy(rule.PortRanges, pm.PortRanges)\n+\tfor k, v := range pm.AuthorizedGroups {\n+\t\trule.AuthorizedGroups[k] = make([]string, len(v))\n+\t\tcopy(rule.AuthorizedGroups[k], v)\n+\t}\n \treturn rule\n }\ndiff --git a/management/server/user.go b/management/server/user.go\nindex ca02f91e67e..9d4620462cf 100644\n--- a/management/server/user.go\n+++ b/management/server/user.go\n@@ -523,16 +523,14 @@ func (am *DefaultAccountManager) SaveOrAddUsers(ctx context.Context, accountID,\n \t\t}\n \n \t\terr = am.Store.ExecuteInTransaction(ctx, func(transaction store.Store) error {\n-\t\t\tuserHadPeers, updatedUser, userPeersToExpire, userEvents, err := am.processUserUpdate(\n+\t\t\t_, updatedUser, userPeersToExpire, userEvents, err := am.processUserUpdate(\n \t\t\t\tctx, transaction, groupsMap, accountID, initiatorUserID, initiatorUser, update, addIfNotExists, settings,\n \t\t\t)\n \t\t\tif err != nil {\n \t\t\t\treturn fmt.Errorf(\"failed to process update for user %s: %w\", update.Id, err)\n \t\t\t}\n \n-\t\t\tif userHadPeers {\n-\t\t\t\tupdateAccountPeers = true\n-\t\t\t}\n+\t\t\tupdateAccountPeers = true\n \n \t\t\terr = transaction.SaveUser(ctx, updatedUser)\n \t\t\tif err != nil {\n@@ -581,7 +579,7 @@ func (am *DefaultAccountManager) SaveOrAddUsers(ctx context.Context, accountID,\n \t\t}\n \t}\n \n-\tif settings.GroupsPropagationEnabled && updateAccountPeers {\n+\tif updateAccountPeers {\n \t\tif err = am.Store.IncrementNetworkSerial(ctx, accountID); err != nil {\n \t\t\treturn nil, fmt.Errorf(\"failed to increment network serial: %w\", err)\n \t\t}\ndiff --git a/shared/management/http/api/openapi.yml b/shared/management/http/api/openapi.yml\nindex 42f2fd89ea3..c9edcdda659 100644\n--- a/shared/management/http/api/openapi.yml\n+++ b/shared/management/http/api/openapi.yml\n@@ -488,6 +488,8 @@ components:\n               description: Indicates whether the peer is ephemeral or not\n               type: boolean\n               example: false\n+            local_flags:\n+              $ref: '#/components/schemas/PeerLocalFlags'\n           required:\n             - city_name\n             - connected\n@@ -514,6 +516,49 @@ components:\n             - serial_number\n             - extra_dns_labels\n             - ephemeral\n+    PeerLocalFlags:\n+      type: object\n+      properties:\n+        rosenpass_enabled:\n+          description: Indicates whether Rosenpass is enabled on this peer\n+          type: boolean\n+          example: true\n+        rosenpass_permissive:\n+          description: Indicates whether Rosenpass is in permissive mode or not\n+          type: boolean\n+          example: false\n+        server_ssh_allowed:\n+          description: Indicates whether SSH access this peer is allowed or not\n+          type: boolean\n+          example: true\n+        disable_client_routes:\n+          description: Indicates whether client routes are disabled on this peer or not\n+          type: boolean\n+          example: false\n+        disable_server_routes:\n+          description: Indicates whether server routes are disabled on this peer or not\n+          type: boolean\n+          example: false\n+        disable_dns:\n+          description: Indicates whether DNS management is disabled on this peer or not\n+          type: boolean\n+          example: false\n+        disable_firewall:\n+          description: Indicates whether firewall management is disabled on this peer or not\n+          type: boolean\n+          example: false\n+        block_lan_access:\n+          description: Indicates whether LAN access is blocked on this peer when used as a routing peer\n+          type: boolean\n+          example: false\n+        block_inbound:\n+          description: Indicates whether inbound traffic is blocked on this peer\n+          type: boolean\n+          example: false\n+        lazy_connection_enabled:\n+          description: Indicates whether lazy connection is enabled on this peer\n+          type: boolean\n+          example: false\n     PeerTemporaryAccessRequest:\n       type: object\n       properties:\n@@ -936,7 +981,7 @@ components:\n         protocol:\n           description: Policy rule type of the traffic\n           type: string\n-          enum: [\"all\", \"tcp\", \"udp\", \"icmp\"]\n+          enum: [\"all\", \"tcp\", \"udp\", \"icmp\", \"netbird-ssh\"]\n           example: \"tcp\"\n         ports:\n           description: Policy rule affected ports\n@@ -949,6 +994,14 @@ components:\n           type: array\n           items:\n             $ref: '#/components/schemas/RulePortRange'\n+        authorized_groups:\n+          description: Map of user group ids to a list of local users\n+          type: object\n+          additionalProperties:\n+            type: array\n+            items:\n+              type: string\n+              example: \"group1\"\n       required:\n         - name\n         - enabled\ndiff --git a/shared/management/http/api/types.gen.go b/shared/management/http/api/types.gen.go\nindex 74d9ca92b7d..f242f5a1864 100644\n--- a/shared/management/http/api/types.gen.go\n+++ b/shared/management/http/api/types.gen.go\n@@ -130,10 +130,11 @@ const (\n \n // Defines values for PolicyRuleProtocol.\n const (\n-\tPolicyRuleProtocolAll  PolicyRuleProtocol = \"all\"\n-\tPolicyRuleProtocolIcmp PolicyRuleProtocol = \"icmp\"\n-\tPolicyRuleProtocolTcp  PolicyRuleProtocol = \"tcp\"\n-\tPolicyRuleProtocolUdp  PolicyRuleProtocol = \"udp\"\n+\tPolicyRuleProtocolAll        PolicyRuleProtocol = \"all\"\n+\tPolicyRuleProtocolIcmp       PolicyRuleProtocol = \"icmp\"\n+\tPolicyRuleProtocolNetbirdSsh PolicyRuleProtocol = \"netbird-ssh\"\n+\tPolicyRuleProtocolTcp        PolicyRuleProtocol = \"tcp\"\n+\tPolicyRuleProtocolUdp        PolicyRuleProtocol = \"udp\"\n )\n \n // Defines values for PolicyRuleMinimumAction.\n@@ -144,10 +145,11 @@ const (\n \n // Defines values for PolicyRuleMinimumProtocol.\n const (\n-\tPolicyRuleMinimumProtocolAll  PolicyRuleMinimumProtocol = \"all\"\n-\tPolicyRuleMinimumProtocolIcmp PolicyRuleMinimumProtocol = \"icmp\"\n-\tPolicyRuleMinimumProtocolTcp  PolicyRuleMinimumProtocol = \"tcp\"\n-\tPolicyRuleMinimumProtocolUdp  PolicyRuleMinimumProtocol = \"udp\"\n+\tPolicyRuleMinimumProtocolAll        PolicyRuleMinimumProtocol = \"all\"\n+\tPolicyRuleMinimumProtocolIcmp       PolicyRuleMinimumProtocol = \"icmp\"\n+\tPolicyRuleMinimumProtocolNetbirdSsh PolicyRuleMinimumProtocol = \"netbird-ssh\"\n+\tPolicyRuleMinimumProtocolTcp        PolicyRuleMinimumProtocol = \"tcp\"\n+\tPolicyRuleMinimumProtocolUdp        PolicyRuleMinimumProtocol = \"udp\"\n )\n \n // Defines values for PolicyRuleUpdateAction.\n@@ -158,10 +160,11 @@ const (\n \n // Defines values for PolicyRuleUpdateProtocol.\n const (\n-\tPolicyRuleUpdateProtocolAll  PolicyRuleUpdateProtocol = \"all\"\n-\tPolicyRuleUpdateProtocolIcmp PolicyRuleUpdateProtocol = \"icmp\"\n-\tPolicyRuleUpdateProtocolTcp  PolicyRuleUpdateProtocol = \"tcp\"\n-\tPolicyRuleUpdateProtocolUdp  PolicyRuleUpdateProtocol = \"udp\"\n+\tPolicyRuleUpdateProtocolAll        PolicyRuleUpdateProtocol = \"all\"\n+\tPolicyRuleUpdateProtocolIcmp       PolicyRuleUpdateProtocol = \"icmp\"\n+\tPolicyRuleUpdateProtocolNetbirdSsh PolicyRuleUpdateProtocol = \"netbird-ssh\"\n+\tPolicyRuleUpdateProtocolTcp        PolicyRuleUpdateProtocol = \"tcp\"\n+\tPolicyRuleUpdateProtocolUdp        PolicyRuleUpdateProtocol = \"udp\"\n )\n \n // Defines values for ResourceType.\n@@ -1077,7 +1080,8 @@ type Peer struct {\n \tLastLogin time.Time `json:\"last_login\"`\n \n \t// LastSeen Last time peer connected to Netbird's management service\n-\tLastSeen time.Time `json:\"last_seen\"`\n+\tLastSeen   time.Time       `json:\"last_seen\"`\n+\tLocalFlags *PeerLocalFlags `json:\"local_flags,omitempty\"`\n \n \t// LoginExpirationEnabled Indicates whether peer login expiration has been enabled or not\n \tLoginExpirationEnabled bool `json:\"login_expiration_enabled\"`\n@@ -1167,7 +1171,8 @@ type PeerBatch struct {\n \tLastLogin time.Time `json:\"last_login\"`\n \n \t// LastSeen Last time peer connected to Netbird's management service\n-\tLastSeen time.Time `json:\"last_seen\"`\n+\tLastSeen   time.Time       `json:\"last_seen\"`\n+\tLocalFlags *PeerLocalFlags `json:\"local_flags,omitempty\"`\n \n \t// LoginExpirationEnabled Indicates whether peer login expiration has been enabled or not\n \tLoginExpirationEnabled bool `json:\"login_expiration_enabled\"`\n@@ -1197,6 +1202,39 @@ type PeerBatch struct {\n \tVersion string `json:\"version\"`\n }\n \n+// PeerLocalFlags defines model for PeerLocalFlags.\n+type PeerLocalFlags struct {\n+\t// BlockInbound Indicates whether inbound traffic is blocked on this peer\n+\tBlockInbound *bool `json:\"block_inbound,omitempty\"`\n+\n+\t// BlockLanAccess Indicates whether LAN access is blocked on this peer when used as a routing peer\n+\tBlockLanAccess *bool `json:\"block_lan_access,omitempty\"`\n+\n+\t// DisableClientRoutes Indicates whether client routes are disabled on this peer or not\n+\tDisableClientRoutes *bool `json:\"disable_client_routes,omitempty\"`\n+\n+\t// DisableDns Indicates whether DNS management is disabled on this peer or not\n+\tDisableDns *bool `json:\"disable_dns,omitempty\"`\n+\n+\t// DisableFirewall Indicates whether firewall management is disabled on this peer or not\n+\tDisableFirewall *bool `json:\"disable_firewall,omitempty\"`\n+\n+\t// DisableServerRoutes Indicates whether server routes are disabled on this peer or not\n+\tDisableServerRoutes *bool `json:\"disable_server_routes,omitempty\"`\n+\n+\t// LazyConnectionEnabled Indicates whether lazy connection is enabled on this peer\n+\tLazyConnectionEnabled *bool `json:\"lazy_connection_enabled,omitempty\"`\n+\n+\t// RosenpassEnabled Indicates whether Rosenpass is enabled on this peer\n+\tRosenpassEnabled *bool `json:\"rosenpass_enabled,omitempty\"`\n+\n+\t// RosenpassPermissive Indicates whether Rosenpass is in permissive mode or not\n+\tRosenpassPermissive *bool `json:\"rosenpass_permissive,omitempty\"`\n+\n+\t// ServerSshAllowed Indicates whether SSH access this peer is allowed or not\n+\tServerSshAllowed *bool `json:\"server_ssh_allowed,omitempty\"`\n+}\n+\n // PeerMinimum defines model for PeerMinimum.\n type PeerMinimum struct {\n \t// Id Peer ID\n@@ -1349,6 +1387,9 @@ type PolicyRule struct {\n \t// Action Policy rule accept or drops packets\n \tAction PolicyRuleAction `json:\"action\"`\n \n+\t// AuthorizedGroups Map of user group ids to a list of local users\n+\tAuthorizedGroups *map[string][]string `json:\"authorized_groups,omitempty\"`\n+\n \t// Bidirectional Define if the rule is applicable in both directions, sources, and destinations.\n \tBidirectional bool `json:\"bidirectional\"`\n \n@@ -1393,6 +1434,9 @@ type PolicyRuleMinimum struct {\n \t// Action Policy rule accept or drops packets\n \tAction PolicyRuleMinimumAction `json:\"action\"`\n \n+\t// AuthorizedGroups Map of user group ids to a list of local users\n+\tAuthorizedGroups *map[string][]string `json:\"authorized_groups,omitempty\"`\n+\n \t// Bidirectional Define if the rule is applicable in both directions, sources, and destinations.\n \tBidirectional bool `json:\"bidirectional\"`\n \n@@ -1426,6 +1470,9 @@ type PolicyRuleUpdate struct {\n \t// Action Policy rule accept or drops packets\n \tAction PolicyRuleUpdateAction `json:\"action\"`\n \n+\t// AuthorizedGroups Map of user group ids to a list of local users\n+\tAuthorizedGroups *map[string][]string `json:\"authorized_groups,omitempty\"`\n+\n \t// Bidirectional Define if the rule is applicable in both directions, sources, and destinations.\n \tBidirectional bool `json:\"bidirectional\"`\n \ndiff --git a/shared/management/proto/management.pb.go b/shared/management/proto/management.pb.go\nindex 217b33db9a3..2047c51ea25 100644\n--- a/shared/management/proto/management.pb.go\n+++ b/shared/management/proto/management.pb.go\n@@ -1,7 +1,7 @@\n // Code generated by protoc-gen-go. DO NOT EDIT.\n // versions:\n // \tprotoc-gen-go v1.26.0\n-// \tprotoc        v3.21.12\n+// \tprotoc        v6.33.1\n // source: management.proto\n \n package proto\n@@ -267,7 +267,7 @@ func (x DeviceAuthorizationFlowProvider) Number() protoreflect.EnumNumber {\n \n // Deprecated: Use DeviceAuthorizationFlowProvider.Descriptor instead.\n func (DeviceAuthorizationFlowProvider) EnumDescriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{25, 0}\n+\treturn file_management_proto_rawDescGZIP(), []int{27, 0}\n }\n \n type EncryptedMessage struct {\n@@ -1942,6 +1942,8 @@ type NetworkMap struct {\n \t// RoutesFirewallRulesIsEmpty indicates whether RouteFirewallRule array is empty or not to bypass protobuf null and empty array equality.\n \tRoutesFirewallRulesIsEmpty bool              `protobuf:\"varint,11,opt,name=routesFirewallRulesIsEmpty,proto3\" json:\"routesFirewallRulesIsEmpty,omitempty\"`\n \tForwardingRules            []*ForwardingRule `protobuf:\"bytes,12,rep,name=forwardingRules,proto3\" json:\"forwardingRules,omitempty\"`\n+\t// SSHAuth represents SSH authorization configuration\n+\tSshAuth *SSHAuth `protobuf:\"bytes,13,opt,name=sshAuth,proto3\" json:\"sshAuth,omitempty\"`\n }\n \n func (x *NetworkMap) Reset() {\n@@ -2060,6 +2062,126 @@ func (x *NetworkMap) GetForwardingRules() []*ForwardingRule {\n \treturn nil\n }\n \n+func (x *NetworkMap) GetSshAuth() *SSHAuth {\n+\tif x != nil {\n+\t\treturn x.SshAuth\n+\t}\n+\treturn nil\n+}\n+\n+type SSHAuth struct {\n+\tstate         protoimpl.MessageState\n+\tsizeCache     protoimpl.SizeCache\n+\tunknownFields protoimpl.UnknownFields\n+\n+\t// UserIDClaim is the JWT claim to be used to get the users ID\n+\tUserIDClaim string `protobuf:\"bytes,1,opt,name=UserIDClaim,proto3\" json:\"UserIDClaim,omitempty\"`\n+\t// AuthorizedUsers is a list of hashed user IDs authorized to access this peer via SSH\n+\tAuthorizedUsers [][]byte `protobuf:\"bytes,2,rep,name=AuthorizedUsers,proto3\" json:\"AuthorizedUsers,omitempty\"`\n+\t// MachineUsers is a map of machine user names to their corresponding indexes in the AuthorizedUsers list\n+\tMachineUsers map[string]*MachineUserIndexes `protobuf:\"bytes,3,rep,name=machine_users,json=machineUsers,proto3\" json:\"machine_users,omitempty\" protobuf_key:\"bytes,1,opt,name=key,proto3\" protobuf_val:\"bytes,2,opt,name=value,proto3\"`\n+}\n+\n+func (x *SSHAuth) Reset() {\n+\t*x = SSHAuth{}\n+\tif protoimpl.UnsafeEnabled {\n+\t\tmi := &file_management_proto_msgTypes[22]\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tms.StoreMessageInfo(mi)\n+\t}\n+}\n+\n+func (x *SSHAuth) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*SSHAuth) ProtoMessage() {}\n+\n+func (x *SSHAuth) ProtoReflect() protoreflect.Message {\n+\tmi := &file_management_proto_msgTypes[22]\n+\tif protoimpl.UnsafeEnabled && x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use SSHAuth.ProtoReflect.Descriptor instead.\n+func (*SSHAuth) Descriptor() ([]byte, []int) {\n+\treturn file_management_proto_rawDescGZIP(), []int{22}\n+}\n+\n+func (x *SSHAuth) GetUserIDClaim() string {\n+\tif x != nil {\n+\t\treturn x.UserIDClaim\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *SSHAuth) GetAuthorizedUsers() [][]byte {\n+\tif x != nil {\n+\t\treturn x.AuthorizedUsers\n+\t}\n+\treturn nil\n+}\n+\n+func (x *SSHAuth) GetMachineUsers() map[string]*MachineUserIndexes {\n+\tif x != nil {\n+\t\treturn x.MachineUsers\n+\t}\n+\treturn nil\n+}\n+\n+type MachineUserIndexes struct {\n+\tstate         protoimpl.MessageState\n+\tsizeCache     protoimpl.SizeCache\n+\tunknownFields protoimpl.UnknownFields\n+\n+\tIndexes []uint32 `protobuf:\"varint,1,rep,packed,name=indexes,proto3\" json:\"indexes,omitempty\"`\n+}\n+\n+func (x *MachineUserIndexes) Reset() {\n+\t*x = MachineUserIndexes{}\n+\tif protoimpl.UnsafeEnabled {\n+\t\tmi := &file_management_proto_msgTypes[23]\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tms.StoreMessageInfo(mi)\n+\t}\n+}\n+\n+func (x *MachineUserIndexes) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*MachineUserIndexes) ProtoMessage() {}\n+\n+func (x *MachineUserIndexes) ProtoReflect() protoreflect.Message {\n+\tmi := &file_management_proto_msgTypes[23]\n+\tif protoimpl.UnsafeEnabled && x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use MachineUserIndexes.ProtoReflect.Descriptor instead.\n+func (*MachineUserIndexes) Descriptor() ([]byte, []int) {\n+\treturn file_management_proto_rawDescGZIP(), []int{23}\n+}\n+\n+func (x *MachineUserIndexes) GetIndexes() []uint32 {\n+\tif x != nil {\n+\t\treturn x.Indexes\n+\t}\n+\treturn nil\n+}\n+\n // RemotePeerConfig represents a configuration of a remote peer.\n // The properties are used to configure WireGuard Peers sections\n type RemotePeerConfig struct {\n@@ -2081,7 +2203,7 @@ type RemotePeerConfig struct {\n func (x *RemotePeerConfig) Reset() {\n \t*x = RemotePeerConfig{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[22]\n+\t\tmi := &file_management_proto_msgTypes[24]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2094,7 +2216,7 @@ func (x *RemotePeerConfig) String() string {\n func (*RemotePeerConfig) ProtoMessage() {}\n \n func (x *RemotePeerConfig) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[22]\n+\tmi := &file_management_proto_msgTypes[24]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2107,7 +2229,7 @@ func (x *RemotePeerConfig) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use RemotePeerConfig.ProtoReflect.Descriptor instead.\n func (*RemotePeerConfig) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{22}\n+\treturn file_management_proto_rawDescGZIP(), []int{24}\n }\n \n func (x *RemotePeerConfig) GetWgPubKey() string {\n@@ -2162,7 +2284,7 @@ type SSHConfig struct {\n func (x *SSHConfig) Reset() {\n \t*x = SSHConfig{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[23]\n+\t\tmi := &file_management_proto_msgTypes[25]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2175,7 +2297,7 @@ func (x *SSHConfig) String() string {\n func (*SSHConfig) ProtoMessage() {}\n \n func (x *SSHConfig) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[23]\n+\tmi := &file_management_proto_msgTypes[25]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2188,7 +2310,7 @@ func (x *SSHConfig) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SSHConfig.ProtoReflect.Descriptor instead.\n func (*SSHConfig) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{23}\n+\treturn file_management_proto_rawDescGZIP(), []int{25}\n }\n \n func (x *SSHConfig) GetSshEnabled() bool {\n@@ -2222,7 +2344,7 @@ type DeviceAuthorizationFlowRequest struct {\n func (x *DeviceAuthorizationFlowRequest) Reset() {\n \t*x = DeviceAuthorizationFlowRequest{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[24]\n+\t\tmi := &file_management_proto_msgTypes[26]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2235,7 +2357,7 @@ func (x *DeviceAuthorizationFlowRequest) String() string {\n func (*DeviceAuthorizationFlowRequest) ProtoMessage() {}\n \n func (x *DeviceAuthorizationFlowRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[24]\n+\tmi := &file_management_proto_msgTypes[26]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2248,7 +2370,7 @@ func (x *DeviceAuthorizationFlowRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use DeviceAuthorizationFlowRequest.ProtoReflect.Descriptor instead.\n func (*DeviceAuthorizationFlowRequest) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{24}\n+\treturn file_management_proto_rawDescGZIP(), []int{26}\n }\n \n // DeviceAuthorizationFlow represents Device Authorization Flow information\n@@ -2267,7 +2389,7 @@ type DeviceAuthorizationFlow struct {\n func (x *DeviceAuthorizationFlow) Reset() {\n \t*x = DeviceAuthorizationFlow{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[25]\n+\t\tmi := &file_management_proto_msgTypes[27]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2280,7 +2402,7 @@ func (x *DeviceAuthorizationFlow) String() string {\n func (*DeviceAuthorizationFlow) ProtoMessage() {}\n \n func (x *DeviceAuthorizationFlow) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[25]\n+\tmi := &file_management_proto_msgTypes[27]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2293,7 +2415,7 @@ func (x *DeviceAuthorizationFlow) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use DeviceAuthorizationFlow.ProtoReflect.Descriptor instead.\n func (*DeviceAuthorizationFlow) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{25}\n+\treturn file_management_proto_rawDescGZIP(), []int{27}\n }\n \n func (x *DeviceAuthorizationFlow) GetProvider() DeviceAuthorizationFlowProvider {\n@@ -2320,7 +2442,7 @@ type PKCEAuthorizationFlowRequest struct {\n func (x *PKCEAuthorizationFlowRequest) Reset() {\n \t*x = PKCEAuthorizationFlowRequest{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[26]\n+\t\tmi := &file_management_proto_msgTypes[28]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2333,7 +2455,7 @@ func (x *PKCEAuthorizationFlowRequest) String() string {\n func (*PKCEAuthorizationFlowRequest) ProtoMessage() {}\n \n func (x *PKCEAuthorizationFlowRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[26]\n+\tmi := &file_management_proto_msgTypes[28]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2346,7 +2468,7 @@ func (x *PKCEAuthorizationFlowRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use PKCEAuthorizationFlowRequest.ProtoReflect.Descriptor instead.\n func (*PKCEAuthorizationFlowRequest) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{26}\n+\treturn file_management_proto_rawDescGZIP(), []int{28}\n }\n \n // PKCEAuthorizationFlow represents Authorization Code Flow information\n@@ -2363,7 +2485,7 @@ type PKCEAuthorizationFlow struct {\n func (x *PKCEAuthorizationFlow) Reset() {\n \t*x = PKCEAuthorizationFlow{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[27]\n+\t\tmi := &file_management_proto_msgTypes[29]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2376,7 +2498,7 @@ func (x *PKCEAuthorizationFlow) String() string {\n func (*PKCEAuthorizationFlow) ProtoMessage() {}\n \n func (x *PKCEAuthorizationFlow) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[27]\n+\tmi := &file_management_proto_msgTypes[29]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2389,7 +2511,7 @@ func (x *PKCEAuthorizationFlow) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use PKCEAuthorizationFlow.ProtoReflect.Descriptor instead.\n func (*PKCEAuthorizationFlow) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{27}\n+\treturn file_management_proto_rawDescGZIP(), []int{29}\n }\n \n func (x *PKCEAuthorizationFlow) GetProviderConfig() *ProviderConfig {\n@@ -2435,7 +2557,7 @@ type ProviderConfig struct {\n func (x *ProviderConfig) Reset() {\n \t*x = ProviderConfig{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[28]\n+\t\tmi := &file_management_proto_msgTypes[30]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2448,7 +2570,7 @@ func (x *ProviderConfig) String() string {\n func (*ProviderConfig) ProtoMessage() {}\n \n func (x *ProviderConfig) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[28]\n+\tmi := &file_management_proto_msgTypes[30]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2461,7 +2583,7 @@ func (x *ProviderConfig) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use ProviderConfig.ProtoReflect.Descriptor instead.\n func (*ProviderConfig) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{28}\n+\treturn file_management_proto_rawDescGZIP(), []int{30}\n }\n \n func (x *ProviderConfig) GetClientID() string {\n@@ -2569,7 +2691,7 @@ type Route struct {\n func (x *Route) Reset() {\n \t*x = Route{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[29]\n+\t\tmi := &file_management_proto_msgTypes[31]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2582,7 +2704,7 @@ func (x *Route) String() string {\n func (*Route) ProtoMessage() {}\n \n func (x *Route) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[29]\n+\tmi := &file_management_proto_msgTypes[31]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2595,7 +2717,7 @@ func (x *Route) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use Route.ProtoReflect.Descriptor instead.\n func (*Route) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{29}\n+\treturn file_management_proto_rawDescGZIP(), []int{31}\n }\n \n func (x *Route) GetID() string {\n@@ -2684,7 +2806,7 @@ type DNSConfig struct {\n func (x *DNSConfig) Reset() {\n \t*x = DNSConfig{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[30]\n+\t\tmi := &file_management_proto_msgTypes[32]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2697,7 +2819,7 @@ func (x *DNSConfig) String() string {\n func (*DNSConfig) ProtoMessage() {}\n \n func (x *DNSConfig) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[30]\n+\tmi := &file_management_proto_msgTypes[32]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2710,7 +2832,7 @@ func (x *DNSConfig) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use DNSConfig.ProtoReflect.Descriptor instead.\n func (*DNSConfig) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{30}\n+\treturn file_management_proto_rawDescGZIP(), []int{32}\n }\n \n func (x *DNSConfig) GetServiceEnable() bool {\n@@ -2757,7 +2879,7 @@ type CustomZone struct {\n func (x *CustomZone) Reset() {\n \t*x = CustomZone{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[31]\n+\t\tmi := &file_management_proto_msgTypes[33]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2770,7 +2892,7 @@ func (x *CustomZone) String() string {\n func (*CustomZone) ProtoMessage() {}\n \n func (x *CustomZone) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[31]\n+\tmi := &file_management_proto_msgTypes[33]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2783,7 +2905,7 @@ func (x *CustomZone) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use CustomZone.ProtoReflect.Descriptor instead.\n func (*CustomZone) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{31}\n+\treturn file_management_proto_rawDescGZIP(), []int{33}\n }\n \n func (x *CustomZone) GetDomain() string {\n@@ -2830,7 +2952,7 @@ type SimpleRecord struct {\n func (x *SimpleRecord) Reset() {\n \t*x = SimpleRecord{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[32]\n+\t\tmi := &file_management_proto_msgTypes[34]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2843,7 +2965,7 @@ func (x *SimpleRecord) String() string {\n func (*SimpleRecord) ProtoMessage() {}\n \n func (x *SimpleRecord) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[32]\n+\tmi := &file_management_proto_msgTypes[34]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2856,7 +2978,7 @@ func (x *SimpleRecord) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SimpleRecord.ProtoReflect.Descriptor instead.\n func (*SimpleRecord) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{32}\n+\treturn file_management_proto_rawDescGZIP(), []int{34}\n }\n \n func (x *SimpleRecord) GetName() string {\n@@ -2909,7 +3031,7 @@ type NameServerGroup struct {\n func (x *NameServerGroup) Reset() {\n \t*x = NameServerGroup{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[33]\n+\t\tmi := &file_management_proto_msgTypes[35]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2922,7 +3044,7 @@ func (x *NameServerGroup) String() string {\n func (*NameServerGroup) ProtoMessage() {}\n \n func (x *NameServerGroup) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[33]\n+\tmi := &file_management_proto_msgTypes[35]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2935,7 +3057,7 @@ func (x *NameServerGroup) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use NameServerGroup.ProtoReflect.Descriptor instead.\n func (*NameServerGroup) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{33}\n+\treturn file_management_proto_rawDescGZIP(), []int{35}\n }\n \n func (x *NameServerGroup) GetNameServers() []*NameServer {\n@@ -2980,7 +3102,7 @@ type NameServer struct {\n func (x *NameServer) Reset() {\n \t*x = NameServer{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[34]\n+\t\tmi := &file_management_proto_msgTypes[36]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2993,7 +3115,7 @@ func (x *NameServer) String() string {\n func (*NameServer) ProtoMessage() {}\n \n func (x *NameServer) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[34]\n+\tmi := &file_management_proto_msgTypes[36]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3006,7 +3128,7 @@ func (x *NameServer) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use NameServer.ProtoReflect.Descriptor instead.\n func (*NameServer) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{34}\n+\treturn file_management_proto_rawDescGZIP(), []int{36}\n }\n \n func (x *NameServer) GetIP() string {\n@@ -3049,7 +3171,7 @@ type FirewallRule struct {\n func (x *FirewallRule) Reset() {\n \t*x = FirewallRule{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[35]\n+\t\tmi := &file_management_proto_msgTypes[37]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -3062,7 +3184,7 @@ func (x *FirewallRule) String() string {\n func (*FirewallRule) ProtoMessage() {}\n \n func (x *FirewallRule) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[35]\n+\tmi := &file_management_proto_msgTypes[37]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3075,7 +3197,7 @@ func (x *FirewallRule) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use FirewallRule.ProtoReflect.Descriptor instead.\n func (*FirewallRule) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{35}\n+\treturn file_management_proto_rawDescGZIP(), []int{37}\n }\n \n func (x *FirewallRule) GetPeerIP() string {\n@@ -3139,7 +3261,7 @@ type NetworkAddress struct {\n func (x *NetworkAddress) Reset() {\n \t*x = NetworkAddress{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[36]\n+\t\tmi := &file_management_proto_msgTypes[38]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -3152,7 +3274,7 @@ func (x *NetworkAddress) String() string {\n func (*NetworkAddress) ProtoMessage() {}\n \n func (x *NetworkAddress) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[36]\n+\tmi := &file_management_proto_msgTypes[38]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3165,7 +3287,7 @@ func (x *NetworkAddress) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use NetworkAddress.ProtoReflect.Descriptor instead.\n func (*NetworkAddress) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{36}\n+\treturn file_management_proto_rawDescGZIP(), []int{38}\n }\n \n func (x *NetworkAddress) GetNetIP() string {\n@@ -3193,7 +3315,7 @@ type Checks struct {\n func (x *Checks) Reset() {\n \t*x = Checks{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[37]\n+\t\tmi := &file_management_proto_msgTypes[39]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -3206,7 +3328,7 @@ func (x *Checks) String() string {\n func (*Checks) ProtoMessage() {}\n \n func (x *Checks) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[37]\n+\tmi := &file_management_proto_msgTypes[39]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3219,7 +3341,7 @@ func (x *Checks) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use Checks.ProtoReflect.Descriptor instead.\n func (*Checks) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{37}\n+\treturn file_management_proto_rawDescGZIP(), []int{39}\n }\n \n func (x *Checks) GetFiles() []string {\n@@ -3244,7 +3366,7 @@ type PortInfo struct {\n func (x *PortInfo) Reset() {\n \t*x = PortInfo{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[38]\n+\t\tmi := &file_management_proto_msgTypes[40]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -3257,7 +3379,7 @@ func (x *PortInfo) String() string {\n func (*PortInfo) ProtoMessage() {}\n \n func (x *PortInfo) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[38]\n+\tmi := &file_management_proto_msgTypes[40]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3270,7 +3392,7 @@ func (x *PortInfo) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use PortInfo.ProtoReflect.Descriptor instead.\n func (*PortInfo) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{38}\n+\treturn file_management_proto_rawDescGZIP(), []int{40}\n }\n \n func (m *PortInfo) GetPortSelection() isPortInfo_PortSelection {\n@@ -3341,7 +3463,7 @@ type RouteFirewallRule struct {\n func (x *RouteFirewallRule) Reset() {\n \t*x = RouteFirewallRule{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[39]\n+\t\tmi := &file_management_proto_msgTypes[41]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -3354,7 +3476,7 @@ func (x *RouteFirewallRule) String() string {\n func (*RouteFirewallRule) ProtoMessage() {}\n \n func (x *RouteFirewallRule) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[39]\n+\tmi := &file_management_proto_msgTypes[41]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3367,7 +3489,7 @@ func (x *RouteFirewallRule) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use RouteFirewallRule.ProtoReflect.Descriptor instead.\n func (*RouteFirewallRule) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{39}\n+\treturn file_management_proto_rawDescGZIP(), []int{41}\n }\n \n func (x *RouteFirewallRule) GetSourceRanges() []string {\n@@ -3458,7 +3580,7 @@ type ForwardingRule struct {\n func (x *ForwardingRule) Reset() {\n \t*x = ForwardingRule{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[40]\n+\t\tmi := &file_management_proto_msgTypes[42]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -3471,7 +3593,7 @@ func (x *ForwardingRule) String() string {\n func (*ForwardingRule) ProtoMessage() {}\n \n func (x *ForwardingRule) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[40]\n+\tmi := &file_management_proto_msgTypes[42]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3484,7 +3606,7 @@ func (x *ForwardingRule) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use ForwardingRule.ProtoReflect.Descriptor instead.\n func (*ForwardingRule) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{40}\n+\treturn file_management_proto_rawDescGZIP(), []int{42}\n }\n \n func (x *ForwardingRule) GetProtocol() RuleProtocol {\n@@ -3527,7 +3649,7 @@ type PortInfo_Range struct {\n func (x *PortInfo_Range) Reset() {\n \t*x = PortInfo_Range{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[41]\n+\t\tmi := &file_management_proto_msgTypes[44]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -3540,7 +3662,7 @@ func (x *PortInfo_Range) String() string {\n func (*PortInfo_Range) ProtoMessage() {}\n \n func (x *PortInfo_Range) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[41]\n+\tmi := &file_management_proto_msgTypes[44]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3553,7 +3675,7 @@ func (x *PortInfo_Range) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use PortInfo_Range.ProtoReflect.Descriptor instead.\n func (*PortInfo_Range) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{38, 0}\n+\treturn file_management_proto_rawDescGZIP(), []int{40, 0}\n }\n \n func (x *PortInfo_Range) GetStart() uint32 {\n@@ -3839,7 +3961,7 @@ var file_management_proto_rawDesc = []byte{\n \t0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x76,\n \t0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x22, 0x0a, 0x0c, 0x61, 0x6c, 0x77, 0x61, 0x79, 0x73,\n \t0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0c, 0x61, 0x6c,\n-\t0x77, 0x61, 0x79, 0x73, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x22, 0xb9, 0x05, 0x0a, 0x0a, 0x4e,\n+\t0x77, 0x61, 0x79, 0x73, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x22, 0xe8, 0x05, 0x0a, 0x0a, 0x4e,\n \t0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x4d, 0x61, 0x70, 0x12, 0x16, 0x0a, 0x06, 0x53, 0x65, 0x72,\n \t0x69, 0x61, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06, 0x53, 0x65, 0x72, 0x69, 0x61,\n \t0x6c, 0x12, 0x36, 0x0a, 0x0a, 0x70, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18,\n@@ -3883,264 +4005,286 @@ var file_management_proto_rawDesc = []byte{\n \t0x6c, 0x65, 0x73, 0x18, 0x0c, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x6d, 0x61, 0x6e, 0x61,\n \t0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x69, 0x6e,\n \t0x67, 0x52, 0x75, 0x6c, 0x65, 0x52, 0x0f, 0x66, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x69, 0x6e,\n-\t0x67, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x22, 0xbb, 0x01, 0x0a, 0x10, 0x52, 0x65, 0x6d, 0x6f, 0x74,\n-\t0x65, 0x50, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x1a, 0x0a, 0x08, 0x77,\n-\t0x67, 0x50, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x77,\n-\t0x67, 0x50, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x12, 0x1e, 0x0a, 0x0a, 0x61, 0x6c, 0x6c, 0x6f, 0x77,\n-\t0x65, 0x64, 0x49, 0x70, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0a, 0x61, 0x6c, 0x6c,\n-\t0x6f, 0x77, 0x65, 0x64, 0x49, 0x70, 0x73, 0x12, 0x33, 0x0a, 0x09, 0x73, 0x73, 0x68, 0x43, 0x6f,\n-\t0x6e, 0x66, 0x69, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x61, 0x6e,\n-\t0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x53, 0x48, 0x43, 0x6f, 0x6e, 0x66, 0x69,\n-\t0x67, 0x52, 0x09, 0x73, 0x73, 0x68, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x12, 0x0a, 0x04,\n-\t0x66, 0x71, 0x64, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x66, 0x71, 0x64, 0x6e,\n-\t0x12, 0x22, 0x0a, 0x0c, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,\n-\t0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x56, 0x65, 0x72,\n-\t0x73, 0x69, 0x6f, 0x6e, 0x22, 0x7e, 0x0a, 0x09, 0x53, 0x53, 0x48, 0x43, 0x6f, 0x6e, 0x66, 0x69,\n-\t0x67, 0x12, 0x1e, 0x0a, 0x0a, 0x73, 0x73, 0x68, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18,\n-\t0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x73, 0x73, 0x68, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65,\n-\t0x64, 0x12, 0x1c, 0x0a, 0x09, 0x73, 0x73, 0x68, 0x50, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x18, 0x02,\n-\t0x20, 0x01, 0x28, 0x0c, 0x52, 0x09, 0x73, 0x73, 0x68, 0x50, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x12,\n-\t0x33, 0x0a, 0x09, 0x6a, 0x77, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x03, 0x20, 0x01,\n-\t0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e,\n-\t0x4a, 0x57, 0x54, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x09, 0x6a, 0x77, 0x74, 0x43, 0x6f,\n-\t0x6e, 0x66, 0x69, 0x67, 0x22, 0x20, 0x0a, 0x1e, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x41, 0x75,\n-\t0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x6f, 0x77, 0x52,\n-\t0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0xbf, 0x01, 0x0a, 0x17, 0x44, 0x65, 0x76, 0x69, 0x63,\n-\t0x65, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c,\n-\t0x6f, 0x77, 0x12, 0x48, 0x0a, 0x08, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x18, 0x01,\n-\t0x20, 0x01, 0x28, 0x0e, 0x32, 0x2c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e,\n-\t0x74, 0x2e, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a,\n-\t0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x6f, 0x77, 0x2e, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64,\n-\t0x65, 0x72, 0x52, 0x08, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x12, 0x42, 0x0a, 0x0e,\n-\t0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x02,\n-\t0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e,\n-\t0x74, 0x2e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,\n-\t0x52, 0x0e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,\n-\t0x22, 0x16, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x12, 0x0a, 0x0a, 0x06,\n-\t0x48, 0x4f, 0x53, 0x54, 0x45, 0x44, 0x10, 0x00, 0x22, 0x1e, 0x0a, 0x1c, 0x50, 0x4b, 0x43, 0x45,\n-\t0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x6f,\n-\t0x77, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x5b, 0x0a, 0x15, 0x50, 0x4b, 0x43, 0x45,\n-\t0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x6f,\n-\t0x77, 0x12, 0x42, 0x0a, 0x0e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43, 0x6f, 0x6e,\n-\t0x66, 0x69, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x6d, 0x61, 0x6e, 0x61,\n-\t0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43,\n-\t0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43,\n-\t0x6f, 0x6e, 0x66, 0x69, 0x67, 0x22, 0xb8, 0x03, 0x0a, 0x0e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64,\n-\t0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x1a, 0x0a, 0x08, 0x43, 0x6c, 0x69, 0x65,\n-\t0x6e, 0x74, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x43, 0x6c, 0x69, 0x65,\n-\t0x6e, 0x74, 0x49, 0x44, 0x12, 0x22, 0x0a, 0x0c, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x53, 0x65,\n-\t0x63, 0x72, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x43, 0x6c, 0x69, 0x65,\n-\t0x6e, 0x74, 0x53, 0x65, 0x63, 0x72, 0x65, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x44, 0x6f, 0x6d, 0x61,\n-\t0x69, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e,\n-\t0x12, 0x1a, 0x0a, 0x08, 0x41, 0x75, 0x64, 0x69, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x04, 0x20, 0x01,\n-\t0x28, 0x09, 0x52, 0x08, 0x41, 0x75, 0x64, 0x69, 0x65, 0x6e, 0x63, 0x65, 0x12, 0x2e, 0x0a, 0x12,\n-\t0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x41, 0x75, 0x74, 0x68, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69,\n-\t0x6e, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x12, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65,\n-\t0x41, 0x75, 0x74, 0x68, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x12, 0x24, 0x0a, 0x0d,\n-\t0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x06, 0x20,\n-\t0x01, 0x28, 0x09, 0x52, 0x0d, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69,\n-\t0x6e, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x53, 0x63, 0x6f, 0x70, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28,\n-\t0x09, 0x52, 0x05, 0x53, 0x63, 0x6f, 0x70, 0x65, 0x12, 0x1e, 0x0a, 0x0a, 0x55, 0x73, 0x65, 0x49,\n-\t0x44, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x55, 0x73,\n-\t0x65, 0x49, 0x44, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x34, 0x0a, 0x15, 0x41, 0x75, 0x74, 0x68,\n-\t0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e,\n-\t0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x15, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69,\n-\t0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x12, 0x22,\n-\t0x0a, 0x0c, 0x52, 0x65, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x55, 0x52, 0x4c, 0x73, 0x18, 0x0a,\n-\t0x20, 0x03, 0x28, 0x09, 0x52, 0x0c, 0x52, 0x65, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x55, 0x52,\n-\t0x4c, 0x73, 0x12, 0x2e, 0x0a, 0x12, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f,\n-\t0x6d, 0x70, 0x74, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x08, 0x52, 0x12,\n-\t0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x6d, 0x70, 0x74, 0x4c, 0x6f, 0x67,\n-\t0x69, 0x6e, 0x12, 0x1c, 0x0a, 0x09, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x46, 0x6c, 0x61, 0x67, 0x18,\n-\t0x0c, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x46, 0x6c, 0x61, 0x67,\n-\t0x22, 0x93, 0x02, 0x0a, 0x05, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x49, 0x44,\n-\t0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x49, 0x44, 0x12, 0x18, 0x0a, 0x07, 0x4e, 0x65,\n-\t0x74, 0x77, 0x6f, 0x72, 0x6b, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x4e, 0x65, 0x74,\n-\t0x77, 0x6f, 0x72, 0x6b, 0x12, 0x20, 0x0a, 0x0b, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x54,\n-\t0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0b, 0x4e, 0x65, 0x74, 0x77, 0x6f,\n-\t0x72, 0x6b, 0x54, 0x79, 0x70, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x50, 0x65, 0x65, 0x72, 0x18, 0x04,\n-\t0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x50, 0x65, 0x65, 0x72, 0x12, 0x16, 0x0a, 0x06, 0x4d, 0x65,\n-\t0x74, 0x72, 0x69, 0x63, 0x18, 0x05, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x4d, 0x65, 0x74, 0x72,\n-\t0x69, 0x63, 0x12, 0x1e, 0x0a, 0x0a, 0x4d, 0x61, 0x73, 0x71, 0x75, 0x65, 0x72, 0x61, 0x64, 0x65,\n-\t0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x4d, 0x61, 0x73, 0x71, 0x75, 0x65, 0x72, 0x61,\n-\t0x64, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x4e, 0x65, 0x74, 0x49, 0x44, 0x18, 0x07, 0x20, 0x01, 0x28,\n-\t0x09, 0x52, 0x05, 0x4e, 0x65, 0x74, 0x49, 0x44, 0x12, 0x18, 0x0a, 0x07, 0x44, 0x6f, 0x6d, 0x61,\n-\t0x69, 0x6e, 0x73, 0x18, 0x08, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x44, 0x6f, 0x6d, 0x61, 0x69,\n-\t0x6e, 0x73, 0x12, 0x1c, 0x0a, 0x09, 0x6b, 0x65, 0x65, 0x70, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x18,\n-\t0x09, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x6b, 0x65, 0x65, 0x70, 0x52, 0x6f, 0x75, 0x74, 0x65,\n-\t0x12, 0x24, 0x0a, 0x0d, 0x73, 0x6b, 0x69, 0x70, 0x41, 0x75, 0x74, 0x6f, 0x41, 0x70, 0x70, 0x6c,\n-\t0x79, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x73, 0x6b, 0x69, 0x70, 0x41, 0x75, 0x74,\n-\t0x6f, 0x41, 0x70, 0x70, 0x6c, 0x79, 0x22, 0xde, 0x01, 0x0a, 0x09, 0x44, 0x4e, 0x53, 0x43, 0x6f,\n-\t0x6e, 0x66, 0x69, 0x67, 0x12, 0x24, 0x0a, 0x0d, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x45,\n-\t0x6e, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x53, 0x65, 0x72,\n-\t0x76, 0x69, 0x63, 0x65, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x47, 0x0a, 0x10, 0x4e, 0x61,\n-\t0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x73, 0x18, 0x02,\n-\t0x20, 0x03, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e,\n-\t0x74, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x47, 0x72, 0x6f, 0x75,\n-\t0x70, 0x52, 0x10, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x47, 0x72, 0x6f,\n-\t0x75, 0x70, 0x73, 0x12, 0x38, 0x0a, 0x0b, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5a, 0x6f, 0x6e,\n-\t0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67,\n-\t0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5a, 0x6f, 0x6e, 0x65,\n-\t0x52, 0x0b, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5a, 0x6f, 0x6e, 0x65, 0x73, 0x12, 0x28, 0x0a,\n-\t0x0d, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x65, 0x72, 0x50, 0x6f, 0x72, 0x74, 0x18, 0x04,\n-\t0x20, 0x01, 0x28, 0x03, 0x42, 0x02, 0x18, 0x01, 0x52, 0x0d, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72,\n-\t0x64, 0x65, 0x72, 0x50, 0x6f, 0x72, 0x74, 0x22, 0xb4, 0x01, 0x0a, 0x0a, 0x43, 0x75, 0x73, 0x74,\n-\t0x6f, 0x6d, 0x5a, 0x6f, 0x6e, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e,\n-\t0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x12, 0x32,\n-\t0x0a, 0x07, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32,\n-\t0x18, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x69, 0x6d,\n-\t0x70, 0x6c, 0x65, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x52, 0x07, 0x52, 0x65, 0x63, 0x6f, 0x72,\n-\t0x64, 0x73, 0x12, 0x32, 0x0a, 0x14, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x44, 0x6f, 0x6d, 0x61,\n-\t0x69, 0x6e, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08,\n-\t0x52, 0x14, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x44, 0x69,\n-\t0x73, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x26, 0x0a, 0x0e, 0x53, 0x6b, 0x69, 0x70, 0x50, 0x54,\n-\t0x52, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0e,\n-\t0x53, 0x6b, 0x69, 0x70, 0x50, 0x54, 0x52, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x22, 0x74,\n-\t0x0a, 0x0c, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x12, 0x12,\n-\t0x0a, 0x04, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x4e, 0x61,\n-\t0x6d, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x54, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03,\n-\t0x52, 0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x18,\n-\t0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x12, 0x10, 0x0a, 0x03,\n-\t0x54, 0x54, 0x4c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x03, 0x54, 0x54, 0x4c, 0x12, 0x14,\n-\t0x0a, 0x05, 0x52, 0x44, 0x61, 0x74, 0x61, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x52,\n-\t0x44, 0x61, 0x74, 0x61, 0x22, 0xb3, 0x01, 0x0a, 0x0f, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72,\n-\t0x76, 0x65, 0x72, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x12, 0x38, 0x0a, 0x0b, 0x4e, 0x61, 0x6d, 0x65,\n-\t0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e,\n-\t0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x53,\n-\t0x65, 0x72, 0x76, 0x65, 0x72, 0x52, 0x0b, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65,\n-\t0x72, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x50, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79, 0x18, 0x02, 0x20,\n-\t0x01, 0x28, 0x08, 0x52, 0x07, 0x50, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79, 0x12, 0x18, 0x0a, 0x07,\n-\t0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x44,\n-\t0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x12, 0x32, 0x0a, 0x14, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68,\n-\t0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x04,\n+\t0x67, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x2d, 0x0a, 0x07, 0x73, 0x73, 0x68, 0x41, 0x75, 0x74,\n+\t0x68, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65,\n+\t0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x53, 0x48, 0x41, 0x75, 0x74, 0x68, 0x52, 0x07, 0x73, 0x73,\n+\t0x68, 0x41, 0x75, 0x74, 0x68, 0x22, 0x82, 0x02, 0x0a, 0x07, 0x53, 0x53, 0x48, 0x41, 0x75, 0x74,\n+\t0x68, 0x12, 0x20, 0x0a, 0x0b, 0x55, 0x73, 0x65, 0x72, 0x49, 0x44, 0x43, 0x6c, 0x61, 0x69, 0x6d,\n+\t0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x55, 0x73, 0x65, 0x72, 0x49, 0x44, 0x43, 0x6c,\n+\t0x61, 0x69, 0x6d, 0x12, 0x28, 0x0a, 0x0f, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x65,\n+\t0x64, 0x55, 0x73, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0c, 0x52, 0x0f, 0x41, 0x75,\n+\t0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x65, 0x64, 0x55, 0x73, 0x65, 0x72, 0x73, 0x12, 0x4a, 0x0a,\n+\t0x0d, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x73, 0x18, 0x03,\n+\t0x20, 0x03, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e,\n+\t0x74, 0x2e, 0x53, 0x53, 0x48, 0x41, 0x75, 0x74, 0x68, 0x2e, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e,\n+\t0x65, 0x55, 0x73, 0x65, 0x72, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0c, 0x6d, 0x61, 0x63,\n+\t0x68, 0x69, 0x6e, 0x65, 0x55, 0x73, 0x65, 0x72, 0x73, 0x1a, 0x5f, 0x0a, 0x11, 0x4d, 0x61, 0x63,\n+\t0x68, 0x69, 0x6e, 0x65, 0x55, 0x73, 0x65, 0x72, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10,\n+\t0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79,\n+\t0x12, 0x34, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,\n+\t0x1e, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4d, 0x61, 0x63,\n+\t0x68, 0x69, 0x6e, 0x65, 0x55, 0x73, 0x65, 0x72, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x73, 0x52,\n+\t0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x2e, 0x0a, 0x12, 0x4d, 0x61,\n+\t0x63, 0x68, 0x69, 0x6e, 0x65, 0x55, 0x73, 0x65, 0x72, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x73,\n+\t0x12, 0x18, 0x0a, 0x07, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,\n+\t0x0d, 0x52, 0x07, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x73, 0x22, 0xbb, 0x01, 0x0a, 0x10, 0x52,\n+\t0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12,\n+\t0x1a, 0x0a, 0x08, 0x77, 0x67, 0x50, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28,\n+\t0x09, 0x52, 0x08, 0x77, 0x67, 0x50, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x12, 0x1e, 0x0a, 0x0a, 0x61,\n+\t0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x49, 0x70, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09, 0x52,\n+\t0x0a, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x49, 0x70, 0x73, 0x12, 0x33, 0x0a, 0x09, 0x73,\n+\t0x73, 0x68, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15,\n+\t0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x53, 0x48, 0x43,\n+\t0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x09, 0x73, 0x73, 0x68, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,\n+\t0x12, 0x12, 0x0a, 0x04, 0x66, 0x71, 0x64, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,\n+\t0x66, 0x71, 0x64, 0x6e, 0x12, 0x22, 0x0a, 0x0c, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x56, 0x65, 0x72,\n+\t0x73, 0x69, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x61, 0x67, 0x65, 0x6e,\n+\t0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0x7e, 0x0a, 0x09, 0x53, 0x53, 0x48, 0x43,\n+\t0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x1e, 0x0a, 0x0a, 0x73, 0x73, 0x68, 0x45, 0x6e, 0x61, 0x62,\n+\t0x6c, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x73, 0x73, 0x68, 0x45, 0x6e,\n+\t0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x1c, 0x0a, 0x09, 0x73, 0x73, 0x68, 0x50, 0x75, 0x62, 0x4b,\n+\t0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x09, 0x73, 0x73, 0x68, 0x50, 0x75, 0x62,\n+\t0x4b, 0x65, 0x79, 0x12, 0x33, 0x0a, 0x09, 0x6a, 0x77, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,\n+\t0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d,\n+\t0x65, 0x6e, 0x74, 0x2e, 0x4a, 0x57, 0x54, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x09, 0x6a,\n+\t0x77, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x22, 0x20, 0x0a, 0x1e, 0x44, 0x65, 0x76, 0x69,\n+\t0x63, 0x65, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46,\n+\t0x6c, 0x6f, 0x77, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0xbf, 0x01, 0x0a, 0x17, 0x44,\n+\t0x65, 0x76, 0x69, 0x63, 0x65, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69,\n+\t0x6f, 0x6e, 0x46, 0x6c, 0x6f, 0x77, 0x12, 0x48, 0x0a, 0x08, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64,\n+\t0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67,\n+\t0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x41, 0x75, 0x74, 0x68,\n+\t0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x6f, 0x77, 0x2e, 0x70, 0x72,\n+\t0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x52, 0x08, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72,\n+\t0x12, 0x42, 0x0a, 0x0e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66,\n+\t0x69, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67,\n+\t0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43, 0x6f,\n+\t0x6e, 0x66, 0x69, 0x67, 0x52, 0x0e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43, 0x6f,\n+\t0x6e, 0x66, 0x69, 0x67, 0x22, 0x16, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72,\n+\t0x12, 0x0a, 0x0a, 0x06, 0x48, 0x4f, 0x53, 0x54, 0x45, 0x44, 0x10, 0x00, 0x22, 0x1e, 0x0a, 0x1c,\n+\t0x50, 0x4b, 0x43, 0x45, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f,\n+\t0x6e, 0x46, 0x6c, 0x6f, 0x77, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x5b, 0x0a, 0x15,\n+\t0x50, 0x4b, 0x43, 0x45, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f,\n+\t0x6e, 0x46, 0x6c, 0x6f, 0x77, 0x12, 0x42, 0x0a, 0x0e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65,\n+\t0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e,\n+\t0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x72, 0x6f, 0x76, 0x69,\n+\t0x64, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0e, 0x50, 0x72, 0x6f, 0x76, 0x69,\n+\t0x64, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x22, 0xb8, 0x03, 0x0a, 0x0e, 0x50, 0x72,\n+\t0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x1a, 0x0a, 0x08,\n+\t0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08,\n+\t0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x44, 0x12, 0x22, 0x0a, 0x0c, 0x43, 0x6c, 0x69, 0x65,\n+\t0x6e, 0x74, 0x53, 0x65, 0x63, 0x72, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c,\n+\t0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x53, 0x65, 0x63, 0x72, 0x65, 0x74, 0x12, 0x16, 0x0a, 0x06,\n+\t0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x44, 0x6f,\n+\t0x6d, 0x61, 0x69, 0x6e, 0x12, 0x1a, 0x0a, 0x08, 0x41, 0x75, 0x64, 0x69, 0x65, 0x6e, 0x63, 0x65,\n+\t0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x41, 0x75, 0x64, 0x69, 0x65, 0x6e, 0x63, 0x65,\n+\t0x12, 0x2e, 0x0a, 0x12, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x41, 0x75, 0x74, 0x68, 0x45, 0x6e,\n+\t0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x12, 0x44, 0x65,\n+\t0x76, 0x69, 0x63, 0x65, 0x41, 0x75, 0x74, 0x68, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74,\n+\t0x12, 0x24, 0x0a, 0x0d, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e,\n+\t0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x45, 0x6e,\n+\t0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x53, 0x63, 0x6f, 0x70, 0x65, 0x18,\n+\t0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x53, 0x63, 0x6f, 0x70, 0x65, 0x12, 0x1e, 0x0a, 0x0a,\n+\t0x55, 0x73, 0x65, 0x49, 0x44, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08,\n+\t0x52, 0x0a, 0x55, 0x73, 0x65, 0x49, 0x44, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x34, 0x0a, 0x15,\n+\t0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x64,\n+\t0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x15, 0x41, 0x75, 0x74,\n+\t0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69,\n+\t0x6e, 0x74, 0x12, 0x22, 0x0a, 0x0c, 0x52, 0x65, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x55, 0x52,\n+\t0x4c, 0x73, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0c, 0x52, 0x65, 0x64, 0x69, 0x72, 0x65,\n+\t0x63, 0x74, 0x55, 0x52, 0x4c, 0x73, 0x12, 0x2e, 0x0a, 0x12, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c,\n+\t0x65, 0x50, 0x72, 0x6f, 0x6d, 0x70, 0x74, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x18, 0x0b, 0x20, 0x01,\n+\t0x28, 0x08, 0x52, 0x12, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x6d, 0x70,\n+\t0x74, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x12, 0x1c, 0x0a, 0x09, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x46,\n+\t0x6c, 0x61, 0x67, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x4c, 0x6f, 0x67, 0x69, 0x6e,\n+\t0x46, 0x6c, 0x61, 0x67, 0x22, 0x93, 0x02, 0x0a, 0x05, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x12, 0x0e,\n+\t0x0a, 0x02, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x49, 0x44, 0x12, 0x18,\n+\t0x0a, 0x07, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,\n+\t0x07, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x12, 0x20, 0x0a, 0x0b, 0x4e, 0x65, 0x74, 0x77,\n+\t0x6f, 0x72, 0x6b, 0x54, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0b, 0x4e,\n+\t0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x54, 0x79, 0x70, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x50, 0x65,\n+\t0x65, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x50, 0x65, 0x65, 0x72, 0x12, 0x16,\n+\t0x0a, 0x06, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x18, 0x05, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06,\n+\t0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x12, 0x1e, 0x0a, 0x0a, 0x4d, 0x61, 0x73, 0x71, 0x75, 0x65,\n+\t0x72, 0x61, 0x64, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x4d, 0x61, 0x73, 0x71,\n+\t0x75, 0x65, 0x72, 0x61, 0x64, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x4e, 0x65, 0x74, 0x49, 0x44, 0x18,\n+\t0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x4e, 0x65, 0x74, 0x49, 0x44, 0x12, 0x18, 0x0a, 0x07,\n+\t0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x18, 0x08, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x44,\n+\t0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x12, 0x1c, 0x0a, 0x09, 0x6b, 0x65, 0x65, 0x70, 0x52, 0x6f,\n+\t0x75, 0x74, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x6b, 0x65, 0x65, 0x70, 0x52,\n+\t0x6f, 0x75, 0x74, 0x65, 0x12, 0x24, 0x0a, 0x0d, 0x73, 0x6b, 0x69, 0x70, 0x41, 0x75, 0x74, 0x6f,\n+\t0x41, 0x70, 0x70, 0x6c, 0x79, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x73, 0x6b, 0x69,\n+\t0x70, 0x41, 0x75, 0x74, 0x6f, 0x41, 0x70, 0x70, 0x6c, 0x79, 0x22, 0xde, 0x01, 0x0a, 0x09, 0x44,\n+\t0x4e, 0x53, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x24, 0x0a, 0x0d, 0x53, 0x65, 0x72, 0x76,\n+\t0x69, 0x63, 0x65, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52,\n+\t0x0d, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x47,\n+\t0x0a, 0x10, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x47, 0x72, 0x6f, 0x75,\n+\t0x70, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67,\n+\t0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72,\n+\t0x47, 0x72, 0x6f, 0x75, 0x70, 0x52, 0x10, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65,\n+\t0x72, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x73, 0x12, 0x38, 0x0a, 0x0b, 0x43, 0x75, 0x73, 0x74, 0x6f,\n+\t0x6d, 0x5a, 0x6f, 0x6e, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d,\n+\t0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d,\n+\t0x5a, 0x6f, 0x6e, 0x65, 0x52, 0x0b, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5a, 0x6f, 0x6e, 0x65,\n+\t0x73, 0x12, 0x28, 0x0a, 0x0d, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x65, 0x72, 0x50, 0x6f,\n+\t0x72, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x42, 0x02, 0x18, 0x01, 0x52, 0x0d, 0x46, 0x6f,\n+\t0x72, 0x77, 0x61, 0x72, 0x64, 0x65, 0x72, 0x50, 0x6f, 0x72, 0x74, 0x22, 0xb4, 0x01, 0x0a, 0x0a,\n+\t0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5a, 0x6f, 0x6e, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x44, 0x6f,\n+\t0x6d, 0x61, 0x69, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x44, 0x6f, 0x6d, 0x61,\n+\t0x69, 0x6e, 0x12, 0x32, 0x0a, 0x07, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x18, 0x02, 0x20,\n+\t0x03, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74,\n+\t0x2e, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x52, 0x07, 0x52,\n+\t0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x12, 0x32, 0x0a, 0x14, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68,\n+\t0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x03,\n \t0x20, 0x01, 0x28, 0x08, 0x52, 0x14, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x44, 0x6f, 0x6d, 0x61,\n-\t0x69, 0x6e, 0x73, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x22, 0x48, 0x0a, 0x0a, 0x4e, 0x61,\n-\t0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x12, 0x0e, 0x0a, 0x02, 0x49, 0x50, 0x18, 0x01,\n-\t0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x49, 0x50, 0x12, 0x16, 0x0a, 0x06, 0x4e, 0x53, 0x54, 0x79,\n-\t0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x4e, 0x53, 0x54, 0x79, 0x70, 0x65,\n-\t0x12, 0x12, 0x0a, 0x04, 0x50, 0x6f, 0x72, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x04,\n-\t0x50, 0x6f, 0x72, 0x74, 0x22, 0xa7, 0x02, 0x0a, 0x0c, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c,\n-\t0x6c, 0x52, 0x75, 0x6c, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x50, 0x65, 0x65, 0x72, 0x49, 0x50, 0x18,\n-\t0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x50, 0x65, 0x65, 0x72, 0x49, 0x50, 0x12, 0x37, 0x0a,\n-\t0x09, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e,\n-\t0x32, 0x19, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75,\n-\t0x6c, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x09, 0x44, 0x69, 0x72,\n-\t0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x2e, 0x0a, 0x06, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e,\n-\t0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d,\n-\t0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x06,\n-\t0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x34, 0x0a, 0x08, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63,\n-\t0x6f, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x18, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67,\n-\t0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63,\n-\t0x6f, 0x6c, 0x52, 0x08, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x12, 0x0a, 0x04,\n-\t0x50, 0x6f, 0x72, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x50, 0x6f, 0x72, 0x74,\n-\t0x12, 0x30, 0x0a, 0x08, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x18, 0x06, 0x20, 0x01,\n-\t0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e,\n-\t0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x08, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e,\n-\t0x66, 0x6f, 0x12, 0x1a, 0x0a, 0x08, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49, 0x44, 0x18, 0x07,\n-\t0x20, 0x01, 0x28, 0x0c, 0x52, 0x08, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49, 0x44, 0x22, 0x38,\n-\t0x0a, 0x0e, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,\n-\t0x12, 0x14, 0x0a, 0x05, 0x6e, 0x65, 0x74, 0x49, 0x50, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,\n-\t0x05, 0x6e, 0x65, 0x74, 0x49, 0x50, 0x12, 0x10, 0x0a, 0x03, 0x6d, 0x61, 0x63, 0x18, 0x02, 0x20,\n-\t0x01, 0x28, 0x09, 0x52, 0x03, 0x6d, 0x61, 0x63, 0x22, 0x1e, 0x0a, 0x06, 0x43, 0x68, 0x65, 0x63,\n-\t0x6b, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,\n-\t0x09, 0x52, 0x05, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x22, 0x96, 0x01, 0x0a, 0x08, 0x50, 0x6f, 0x72,\n-\t0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x14, 0x0a, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x01, 0x20,\n-\t0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x12, 0x32, 0x0a, 0x05, 0x72,\n-\t0x61, 0x6e, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x6d, 0x61, 0x6e,\n-\t0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f,\n-\t0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x48, 0x00, 0x52, 0x05, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x1a,\n-\t0x2f, 0x0a, 0x05, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x72,\n-\t0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x12, 0x10,\n-\t0x0a, 0x03, 0x65, 0x6e, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x03, 0x65, 0x6e, 0x64,\n-\t0x42, 0x0f, 0x0a, 0x0d, 0x70, 0x6f, 0x72, 0x74, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f,\n-\t0x6e, 0x22, 0x87, 0x03, 0x0a, 0x11, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x46, 0x69, 0x72, 0x65, 0x77,\n-\t0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x12, 0x22, 0x0a, 0x0c, 0x73, 0x6f, 0x75, 0x72, 0x63,\n-\t0x65, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0c, 0x73,\n-\t0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x12, 0x2e, 0x0a, 0x06, 0x61,\n-\t0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x16, 0x2e, 0x6d, 0x61,\n-\t0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x41, 0x63, 0x74,\n-\t0x69, 0x6f, 0x6e, 0x52, 0x06, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x20, 0x0a, 0x0b, 0x64,\n-\t0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,\n-\t0x52, 0x0b, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x34, 0x0a,\n-\t0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32,\n-\t0x18, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75, 0x6c,\n-\t0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x52, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f,\n-\t0x63, 0x6f, 0x6c, 0x12, 0x30, 0x0a, 0x08, 0x70, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x18,\n-\t0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65,\n-\t0x6e, 0x74, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x08, 0x70, 0x6f, 0x72,\n-\t0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x1c, 0x0a, 0x09, 0x69, 0x73, 0x44, 0x79, 0x6e, 0x61, 0x6d,\n-\t0x69, 0x63, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x69, 0x73, 0x44, 0x79, 0x6e, 0x61,\n-\t0x6d, 0x69, 0x63, 0x12, 0x18, 0x0a, 0x07, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x18, 0x07,\n-\t0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x12, 0x26, 0x0a,\n-\t0x0e, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18,\n-\t0x08, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0e, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x50, 0x72, 0x6f,\n-\t0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x1a, 0x0a, 0x08, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49,\n-\t0x44, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x08, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49,\n-\t0x44, 0x12, 0x18, 0x0a, 0x07, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x49, 0x44, 0x18, 0x0a, 0x20, 0x01,\n-\t0x28, 0x09, 0x52, 0x07, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x49, 0x44, 0x22, 0xf2, 0x01, 0x0a, 0x0e,\n-\t0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x75, 0x6c, 0x65, 0x12, 0x34,\n-\t0x0a, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e,\n-\t0x32, 0x18, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75,\n-\t0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x52, 0x08, 0x70, 0x72, 0x6f, 0x74,\n-\t0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x3e, 0x0a, 0x0f, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74,\n-\t0x69, 0x6f, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e,\n-\t0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x49,\n-\t0x6e, 0x66, 0x6f, 0x52, 0x0f, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e,\n-\t0x50, 0x6f, 0x72, 0x74, 0x12, 0x2c, 0x0a, 0x11, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74,\n-\t0x65, 0x64, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52,\n-\t0x11, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74, 0x65, 0x64, 0x41, 0x64, 0x64, 0x72, 0x65,\n-\t0x73, 0x73, 0x12, 0x3c, 0x0a, 0x0e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74, 0x65, 0x64,\n-\t0x50, 0x6f, 0x72, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x61, 0x6e,\n-\t0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f,\n-\t0x52, 0x0e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74, 0x65, 0x64, 0x50, 0x6f, 0x72, 0x74,\n-\t0x2a, 0x4c, 0x0a, 0x0c, 0x52, 0x75, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c,\n-\t0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x00, 0x12, 0x07, 0x0a,\n-\t0x03, 0x41, 0x4c, 0x4c, 0x10, 0x01, 0x12, 0x07, 0x0a, 0x03, 0x54, 0x43, 0x50, 0x10, 0x02, 0x12,\n-\t0x07, 0x0a, 0x03, 0x55, 0x44, 0x50, 0x10, 0x03, 0x12, 0x08, 0x0a, 0x04, 0x49, 0x43, 0x4d, 0x50,\n-\t0x10, 0x04, 0x12, 0x0a, 0x0a, 0x06, 0x43, 0x55, 0x53, 0x54, 0x4f, 0x4d, 0x10, 0x05, 0x2a, 0x20,\n-\t0x0a, 0x0d, 0x52, 0x75, 0x6c, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12,\n-\t0x06, 0x0a, 0x02, 0x49, 0x4e, 0x10, 0x00, 0x12, 0x07, 0x0a, 0x03, 0x4f, 0x55, 0x54, 0x10, 0x01,\n-\t0x2a, 0x22, 0x0a, 0x0a, 0x52, 0x75, 0x6c, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x0a,\n-\t0x0a, 0x06, 0x41, 0x43, 0x43, 0x45, 0x50, 0x54, 0x10, 0x00, 0x12, 0x08, 0x0a, 0x04, 0x44, 0x52,\n-\t0x4f, 0x50, 0x10, 0x01, 0x32, 0xcd, 0x04, 0x0a, 0x11, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d,\n-\t0x65, 0x6e, 0x74, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x45, 0x0a, 0x05, 0x4c, 0x6f,\n-\t0x67, 0x69, 0x6e, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74,\n-\t0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67,\n-\t0x65, 0x1a, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45,\n-\t0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22,\n-\t0x00, 0x12, 0x46, 0x0a, 0x04, 0x53, 0x79, 0x6e, 0x63, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61,\n-\t0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64,\n-\t0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65,\n+\t0x69, 0x6e, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x26, 0x0a, 0x0e, 0x53, 0x6b,\n+\t0x69, 0x70, 0x50, 0x54, 0x52, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x18, 0x04, 0x20, 0x01,\n+\t0x28, 0x08, 0x52, 0x0e, 0x53, 0x6b, 0x69, 0x70, 0x50, 0x54, 0x52, 0x50, 0x72, 0x6f, 0x63, 0x65,\n+\t0x73, 0x73, 0x22, 0x74, 0x0a, 0x0c, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x52, 0x65, 0x63, 0x6f,\n+\t0x72, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,\n+\t0x52, 0x04, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x54, 0x79, 0x70, 0x65, 0x18, 0x02,\n+\t0x20, 0x01, 0x28, 0x03, 0x52, 0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x43, 0x6c,\n+\t0x61, 0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x43, 0x6c, 0x61, 0x73, 0x73,\n+\t0x12, 0x10, 0x0a, 0x03, 0x54, 0x54, 0x4c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x03, 0x54,\n+\t0x54, 0x4c, 0x12, 0x14, 0x0a, 0x05, 0x52, 0x44, 0x61, 0x74, 0x61, 0x18, 0x05, 0x20, 0x01, 0x28,\n+\t0x09, 0x52, 0x05, 0x52, 0x44, 0x61, 0x74, 0x61, 0x22, 0xb3, 0x01, 0x0a, 0x0f, 0x4e, 0x61, 0x6d,\n+\t0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x12, 0x38, 0x0a, 0x0b,\n+\t0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,\n+\t0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4e,\n+\t0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x52, 0x0b, 0x4e, 0x61, 0x6d, 0x65, 0x53,\n+\t0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x50, 0x72, 0x69, 0x6d, 0x61, 0x72,\n+\t0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x50, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79,\n+\t0x12, 0x18, 0x0a, 0x07, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28,\n+\t0x09, 0x52, 0x07, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x12, 0x32, 0x0a, 0x14, 0x53, 0x65,\n+\t0x61, 0x72, 0x63, 0x68, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x45, 0x6e, 0x61, 0x62, 0x6c,\n+\t0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x14, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68,\n+\t0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x22, 0x48,\n+\t0x0a, 0x0a, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x12, 0x0e, 0x0a, 0x02,\n+\t0x49, 0x50, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x49, 0x50, 0x12, 0x16, 0x0a, 0x06,\n+\t0x4e, 0x53, 0x54, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x4e, 0x53,\n+\t0x54, 0x79, 0x70, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x50, 0x6f, 0x72, 0x74, 0x18, 0x03, 0x20, 0x01,\n+\t0x28, 0x03, 0x52, 0x04, 0x50, 0x6f, 0x72, 0x74, 0x22, 0xa7, 0x02, 0x0a, 0x0c, 0x46, 0x69, 0x72,\n+\t0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x50, 0x65, 0x65,\n+\t0x72, 0x49, 0x50, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x50, 0x65, 0x65, 0x72, 0x49,\n+\t0x50, 0x12, 0x37, 0x0a, 0x09, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02,\n+\t0x20, 0x01, 0x28, 0x0e, 0x32, 0x19, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e,\n+\t0x74, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52,\n+\t0x09, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x2e, 0x0a, 0x06, 0x41, 0x63,\n+\t0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e,\n+\t0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x41, 0x63, 0x74, 0x69,\n+\t0x6f, 0x6e, 0x52, 0x06, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x34, 0x0a, 0x08, 0x50, 0x72,\n+\t0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x18, 0x2e, 0x6d,\n+\t0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x50, 0x72,\n+\t0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x52, 0x08, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c,\n+\t0x12, 0x12, 0x0a, 0x04, 0x50, 0x6f, 0x72, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,\n+\t0x50, 0x6f, 0x72, 0x74, 0x12, 0x30, 0x0a, 0x08, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f,\n+\t0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d,\n+\t0x65, 0x6e, 0x74, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x08, 0x50, 0x6f,\n+\t0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x1a, 0x0a, 0x08, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79,\n+\t0x49, 0x44, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x08, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79,\n+\t0x49, 0x44, 0x22, 0x38, 0x0a, 0x0e, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x41, 0x64, 0x64,\n+\t0x72, 0x65, 0x73, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x6e, 0x65, 0x74, 0x49, 0x50, 0x18, 0x01, 0x20,\n+\t0x01, 0x28, 0x09, 0x52, 0x05, 0x6e, 0x65, 0x74, 0x49, 0x50, 0x12, 0x10, 0x0a, 0x03, 0x6d, 0x61,\n+\t0x63, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6d, 0x61, 0x63, 0x22, 0x1e, 0x0a, 0x06,\n+\t0x43, 0x68, 0x65, 0x63, 0x6b, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x18,\n+\t0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x05, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x22, 0x96, 0x01, 0x0a,\n+\t0x08, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x14, 0x0a, 0x04, 0x70, 0x6f, 0x72,\n+\t0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x12,\n+\t0x32, 0x0a, 0x05, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a,\n+\t0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x6f, 0x72, 0x74,\n+\t0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x48, 0x00, 0x52, 0x05, 0x72, 0x61,\n+\t0x6e, 0x67, 0x65, 0x1a, 0x2f, 0x0a, 0x05, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x14, 0x0a, 0x05,\n+\t0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x05, 0x73, 0x74, 0x61,\n+\t0x72, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x65, 0x6e, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52,\n+\t0x03, 0x65, 0x6e, 0x64, 0x42, 0x0f, 0x0a, 0x0d, 0x70, 0x6f, 0x72, 0x74, 0x53, 0x65, 0x6c, 0x65,\n+\t0x63, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x87, 0x03, 0x0a, 0x11, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x46,\n+\t0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x12, 0x22, 0x0a, 0x0c, 0x73,\n+\t0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,\n+\t0x09, 0x52, 0x0c, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x12,\n+\t0x2e, 0x0a, 0x06, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32,\n+\t0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75, 0x6c,\n+\t0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x06, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12,\n+\t0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03,\n+\t0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f,\n+\t0x6e, 0x12, 0x34, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x04, 0x20,\n+\t0x01, 0x28, 0x0e, 0x32, 0x18, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74,\n+\t0x2e, 0x52, 0x75, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x52, 0x08, 0x70,\n+\t0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x30, 0x0a, 0x08, 0x70, 0x6f, 0x72, 0x74, 0x49,\n+\t0x6e, 0x66, 0x6f, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x61, 0x6e, 0x61,\n+\t0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52,\n+\t0x08, 0x70, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x1c, 0x0a, 0x09, 0x69, 0x73, 0x44,\n+\t0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x69, 0x73,\n+\t0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x12, 0x18, 0x0a, 0x07, 0x64, 0x6f, 0x6d, 0x61, 0x69,\n+\t0x6e, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e,\n+\t0x73, 0x12, 0x26, 0x0a, 0x0e, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x50, 0x72, 0x6f, 0x74, 0x6f,\n+\t0x63, 0x6f, 0x6c, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0e, 0x63, 0x75, 0x73, 0x74, 0x6f,\n+\t0x6d, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x1a, 0x0a, 0x08, 0x50, 0x6f, 0x6c,\n+\t0x69, 0x63, 0x79, 0x49, 0x44, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x08, 0x50, 0x6f, 0x6c,\n+\t0x69, 0x63, 0x79, 0x49, 0x44, 0x12, 0x18, 0x0a, 0x07, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x49, 0x44,\n+\t0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x49, 0x44, 0x22,\n+\t0xf2, 0x01, 0x0a, 0x0e, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x75,\n+\t0x6c, 0x65, 0x12, 0x34, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x01,\n+\t0x20, 0x01, 0x28, 0x0e, 0x32, 0x18, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e,\n+\t0x74, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x52, 0x08,\n+\t0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x3e, 0x0a, 0x0f, 0x64, 0x65, 0x73, 0x74,\n+\t0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28,\n+\t0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50,\n+\t0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x0f, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61,\n+\t0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x12, 0x2c, 0x0a, 0x11, 0x74, 0x72, 0x61, 0x6e,\n+\t0x73, 0x6c, 0x61, 0x74, 0x65, 0x64, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x03, 0x20,\n+\t0x01, 0x28, 0x0c, 0x52, 0x11, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74, 0x65, 0x64, 0x41,\n+\t0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x3c, 0x0a, 0x0e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6c,\n+\t0x61, 0x74, 0x65, 0x64, 0x50, 0x6f, 0x72, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14,\n+\t0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x6f, 0x72, 0x74,\n+\t0x49, 0x6e, 0x66, 0x6f, 0x52, 0x0e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74, 0x65, 0x64,\n+\t0x50, 0x6f, 0x72, 0x74, 0x2a, 0x4c, 0x0a, 0x0c, 0x52, 0x75, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74,\n+\t0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10,\n+\t0x00, 0x12, 0x07, 0x0a, 0x03, 0x41, 0x4c, 0x4c, 0x10, 0x01, 0x12, 0x07, 0x0a, 0x03, 0x54, 0x43,\n+\t0x50, 0x10, 0x02, 0x12, 0x07, 0x0a, 0x03, 0x55, 0x44, 0x50, 0x10, 0x03, 0x12, 0x08, 0x0a, 0x04,\n+\t0x49, 0x43, 0x4d, 0x50, 0x10, 0x04, 0x12, 0x0a, 0x0a, 0x06, 0x43, 0x55, 0x53, 0x54, 0x4f, 0x4d,\n+\t0x10, 0x05, 0x2a, 0x20, 0x0a, 0x0d, 0x52, 0x75, 0x6c, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74,\n+\t0x69, 0x6f, 0x6e, 0x12, 0x06, 0x0a, 0x02, 0x49, 0x4e, 0x10, 0x00, 0x12, 0x07, 0x0a, 0x03, 0x4f,\n+\t0x55, 0x54, 0x10, 0x01, 0x2a, 0x22, 0x0a, 0x0a, 0x52, 0x75, 0x6c, 0x65, 0x41, 0x63, 0x74, 0x69,\n+\t0x6f, 0x6e, 0x12, 0x0a, 0x0a, 0x06, 0x41, 0x43, 0x43, 0x45, 0x50, 0x54, 0x10, 0x00, 0x12, 0x08,\n+\t0x0a, 0x04, 0x44, 0x52, 0x4f, 0x50, 0x10, 0x01, 0x32, 0xcd, 0x04, 0x0a, 0x11, 0x4d, 0x61, 0x6e,\n+\t0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x45,\n+\t0x0a, 0x05, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65,\n \t0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65,\n-\t0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x00, 0x30, 0x01, 0x12, 0x42, 0x0a, 0x0c, 0x47, 0x65, 0x74,\n-\t0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x4b, 0x65, 0x79, 0x12, 0x11, 0x2e, 0x6d, 0x61, 0x6e, 0x61,\n-\t0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x1d, 0x2e, 0x6d,\n-\t0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72,\n-\t0x4b, 0x65, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x33, 0x0a,\n-\t0x09, 0x69, 0x73, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x79, 0x12, 0x11, 0x2e, 0x6d, 0x61, 0x6e,\n-\t0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x11, 0x2e,\n+\t0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65,\n+\t0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73,\n+\t0x61, 0x67, 0x65, 0x22, 0x00, 0x12, 0x46, 0x0a, 0x04, 0x53, 0x79, 0x6e, 0x63, 0x12, 0x1c, 0x2e,\n+\t0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79,\n+\t0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x1c, 0x2e, 0x6d, 0x61,\n+\t0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74,\n+\t0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x00, 0x30, 0x01, 0x12, 0x42, 0x0a,\n+\t0x0c, 0x47, 0x65, 0x74, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x4b, 0x65, 0x79, 0x12, 0x11, 0x2e,\n \t0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79,\n-\t0x22, 0x00, 0x12, 0x5a, 0x0a, 0x1a, 0x47, 0x65, 0x74, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x41,\n-\t0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x6f, 0x77,\n-\t0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e,\n-\t0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x1c,\n+\t0x1a, 0x1d, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x65,\n+\t0x72, 0x76, 0x65, 0x72, 0x4b, 0x65, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,\n+\t0x00, 0x12, 0x33, 0x0a, 0x09, 0x69, 0x73, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x79, 0x12, 0x11,\n+\t0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6d, 0x70, 0x74,\n+\t0x79, 0x1a, 0x11, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45,\n+\t0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x12, 0x5a, 0x0a, 0x1a, 0x47, 0x65, 0x74, 0x44, 0x65, 0x76,\n+\t0x69, 0x63, 0x65, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e,\n+\t0x46, 0x6c, 0x6f, 0x77, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e,\n+\t0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61,\n+\t0x67, 0x65, 0x1a, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e,\n+\t0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,\n+\t0x22, 0x00, 0x12, 0x58, 0x0a, 0x18, 0x47, 0x65, 0x74, 0x50, 0x4b, 0x43, 0x45, 0x41, 0x75, 0x74,\n+\t0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x6f, 0x77, 0x12, 0x1c,\n \t0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72,\n-\t0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x00, 0x12, 0x58,\n-\t0x0a, 0x18, 0x47, 0x65, 0x74, 0x50, 0x4b, 0x43, 0x45, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69,\n-\t0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x6f, 0x77, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e,\n-\t0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65,\n-\t0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67,\n+\t0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x1c, 0x2e, 0x6d,\n+\t0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70,\n+\t0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x00, 0x12, 0x3d, 0x0a, 0x08,\n+\t0x53, 0x79, 0x6e, 0x63, 0x4d, 0x65, 0x74, 0x61, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67,\n \t0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d,\n-\t0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x00, 0x12, 0x3d, 0x0a, 0x08, 0x53, 0x79, 0x6e, 0x63,\n-\t0x4d, 0x65, 0x74, 0x61, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e,\n-\t0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61,\n-\t0x67, 0x65, 0x1a, 0x11, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e,\n-\t0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x12, 0x3b, 0x0a, 0x06, 0x4c, 0x6f, 0x67, 0x6f, 0x75,\n-\t0x74, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45,\n-\t0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a,\n-\t0x11, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6d, 0x70,\n-\t0x74, 0x79, 0x22, 0x00, 0x42, 0x08, 0x5a, 0x06, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x06,\n-\t0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,\n+\t0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x11, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d,\n+\t0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x12, 0x3b, 0x0a, 0x06, 0x4c,\n+\t0x6f, 0x67, 0x6f, 0x75, 0x74, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65,\n+\t0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73,\n+\t0x61, 0x67, 0x65, 0x1a, 0x11, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74,\n+\t0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x42, 0x08, 0x5a, 0x06, 0x2f, 0x70, 0x72, 0x6f,\n+\t0x74, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,\n }\n \n var (\n@@ -4156,7 +4300,7 @@ func file_management_proto_rawDescGZIP() []byte {\n }\n \n var file_management_proto_enumTypes = make([]protoimpl.EnumInfo, 5)\n-var file_management_proto_msgTypes = make([]protoimpl.MessageInfo, 42)\n+var file_management_proto_msgTypes = make([]protoimpl.MessageInfo, 45)\n var file_management_proto_goTypes = []interface{}{\n \t(RuleProtocol)(0),                      // 0: management.RuleProtocol\n \t(RuleDirection)(0),                     // 1: management.RuleDirection\n@@ -4185,106 +4329,112 @@ var file_management_proto_goTypes = []interface{}{\n \t(*PeerConfig)(nil),                     // 24: management.PeerConfig\n \t(*AutoUpdateSettings)(nil),             // 25: management.AutoUpdateSettings\n \t(*NetworkMap)(nil),                     // 26: management.NetworkMap\n-\t(*RemotePeerConfig)(nil),               // 27: management.RemotePeerConfig\n-\t(*SSHConfig)(nil),                      // 28: management.SSHConfig\n-\t(*DeviceAuthorizationFlowRequest)(nil), // 29: management.DeviceAuthorizationFlowRequest\n-\t(*DeviceAuthorizationFlow)(nil),        // 30: management.DeviceAuthorizationFlow\n-\t(*PKCEAuthorizationFlowRequest)(nil),   // 31: management.PKCEAuthorizationFlowRequest\n-\t(*PKCEAuthorizationFlow)(nil),          // 32: management.PKCEAuthorizationFlow\n-\t(*ProviderConfig)(nil),                 // 33: management.ProviderConfig\n-\t(*Route)(nil),                          // 34: management.Route\n-\t(*DNSConfig)(nil),                      // 35: management.DNSConfig\n-\t(*CustomZone)(nil),                     // 36: management.CustomZone\n-\t(*SimpleRecord)(nil),                   // 37: management.SimpleRecord\n-\t(*NameServerGroup)(nil),                // 38: management.NameServerGroup\n-\t(*NameServer)(nil),                     // 39: management.NameServer\n-\t(*FirewallRule)(nil),                   // 40: management.FirewallRule\n-\t(*NetworkAddress)(nil),                 // 41: management.NetworkAddress\n-\t(*Checks)(nil),                         // 42: management.Checks\n-\t(*PortInfo)(nil),                       // 43: management.PortInfo\n-\t(*RouteFirewallRule)(nil),              // 44: management.RouteFirewallRule\n-\t(*ForwardingRule)(nil),                 // 45: management.ForwardingRule\n-\t(*PortInfo_Range)(nil),                 // 46: management.PortInfo.Range\n-\t(*timestamppb.Timestamp)(nil),          // 47: google.protobuf.Timestamp\n-\t(*durationpb.Duration)(nil),            // 48: google.protobuf.Duration\n+\t(*SSHAuth)(nil),                        // 27: management.SSHAuth\n+\t(*MachineUserIndexes)(nil),             // 28: management.MachineUserIndexes\n+\t(*RemotePeerConfig)(nil),               // 29: management.RemotePeerConfig\n+\t(*SSHConfig)(nil),                      // 30: management.SSHConfig\n+\t(*DeviceAuthorizationFlowRequest)(nil), // 31: management.DeviceAuthorizationFlowRequest\n+\t(*DeviceAuthorizationFlow)(nil),        // 32: management.DeviceAuthorizationFlow\n+\t(*PKCEAuthorizationFlowRequest)(nil),   // 33: management.PKCEAuthorizationFlowRequest\n+\t(*PKCEAuthorizationFlow)(nil),          // 34: management.PKCEAuthorizationFlow\n+\t(*ProviderConfig)(nil),                 // 35: management.ProviderConfig\n+\t(*Route)(nil),                          // 36: management.Route\n+\t(*DNSConfig)(nil),                      // 37: management.DNSConfig\n+\t(*CustomZone)(nil),                     // 38: management.CustomZone\n+\t(*SimpleRecord)(nil),                   // 39: management.SimpleRecord\n+\t(*NameServerGroup)(nil),                // 40: management.NameServerGroup\n+\t(*NameServer)(nil),                     // 41: management.NameServer\n+\t(*FirewallRule)(nil),                   // 42: management.FirewallRule\n+\t(*NetworkAddress)(nil),                 // 43: management.NetworkAddress\n+\t(*Checks)(nil),                         // 44: management.Checks\n+\t(*PortInfo)(nil),                       // 45: management.PortInfo\n+\t(*RouteFirewallRule)(nil),              // 46: management.RouteFirewallRule\n+\t(*ForwardingRule)(nil),                 // 47: management.ForwardingRule\n+\tnil,                                    // 48: management.SSHAuth.MachineUsersEntry\n+\t(*PortInfo_Range)(nil),                 // 49: management.PortInfo.Range\n+\t(*timestamppb.Timestamp)(nil),          // 50: google.protobuf.Timestamp\n+\t(*durationpb.Duration)(nil),            // 51: google.protobuf.Duration\n }\n var file_management_proto_depIdxs = []int32{\n \t14, // 0: management.SyncRequest.meta:type_name -> management.PeerSystemMeta\n \t18, // 1: management.SyncResponse.netbirdConfig:type_name -> management.NetbirdConfig\n \t24, // 2: management.SyncResponse.peerConfig:type_name -> management.PeerConfig\n-\t27, // 3: management.SyncResponse.remotePeers:type_name -> management.RemotePeerConfig\n+\t29, // 3: management.SyncResponse.remotePeers:type_name -> management.RemotePeerConfig\n \t26, // 4: management.SyncResponse.NetworkMap:type_name -> management.NetworkMap\n-\t42, // 5: management.SyncResponse.Checks:type_name -> management.Checks\n+\t44, // 5: management.SyncResponse.Checks:type_name -> management.Checks\n \t14, // 6: management.SyncMetaRequest.meta:type_name -> management.PeerSystemMeta\n \t14, // 7: management.LoginRequest.meta:type_name -> management.PeerSystemMeta\n \t10, // 8: management.LoginRequest.peerKeys:type_name -> management.PeerKeys\n-\t41, // 9: management.PeerSystemMeta.networkAddresses:type_name -> management.NetworkAddress\n+\t43, // 9: management.PeerSystemMeta.networkAddresses:type_name -> management.NetworkAddress\n \t11, // 10: management.PeerSystemMeta.environment:type_name -> management.Environment\n \t12, // 11: management.PeerSystemMeta.files:type_name -> management.File\n \t13, // 12: management.PeerSystemMeta.flags:type_name -> management.Flags\n \t18, // 13: management.LoginResponse.netbirdConfig:type_name -> management.NetbirdConfig\n \t24, // 14: management.LoginResponse.peerConfig:type_name -> management.PeerConfig\n-\t42, // 15: management.LoginResponse.Checks:type_name -> management.Checks\n-\t47, // 16: management.ServerKeyResponse.expiresAt:type_name -> google.protobuf.Timestamp\n+\t44, // 15: management.LoginResponse.Checks:type_name -> management.Checks\n+\t50, // 16: management.ServerKeyResponse.expiresAt:type_name -> google.protobuf.Timestamp\n \t19, // 17: management.NetbirdConfig.stuns:type_name -> management.HostConfig\n \t23, // 18: management.NetbirdConfig.turns:type_name -> management.ProtectedHostConfig\n \t19, // 19: management.NetbirdConfig.signal:type_name -> management.HostConfig\n \t20, // 20: management.NetbirdConfig.relay:type_name -> management.RelayConfig\n \t21, // 21: management.NetbirdConfig.flow:type_name -> management.FlowConfig\n \t3,  // 22: management.HostConfig.protocol:type_name -> management.HostConfig.Protocol\n-\t48, // 23: management.FlowConfig.interval:type_name -> google.protobuf.Duration\n+\t51, // 23: management.FlowConfig.interval:type_name -> google.protobuf.Duration\n \t19, // 24: management.ProtectedHostConfig.hostConfig:type_name -> management.HostConfig\n-\t28, // 25: management.PeerConfig.sshConfig:type_name -> management.SSHConfig\n+\t30, // 25: management.PeerConfig.sshConfig:type_name -> management.SSHConfig\n \t25, // 26: management.PeerConfig.autoUpdate:type_name -> management.AutoUpdateSettings\n \t24, // 27: management.NetworkMap.peerConfig:type_name -> management.PeerConfig\n-\t27, // 28: management.NetworkMap.remotePeers:type_name -> management.RemotePeerConfig\n-\t34, // 29: management.NetworkMap.Routes:type_name -> management.Route\n-\t35, // 30: management.NetworkMap.DNSConfig:type_name -> management.DNSConfig\n-\t27, // 31: management.NetworkMap.offlinePeers:type_name -> management.RemotePeerConfig\n-\t40, // 32: management.NetworkMap.FirewallRules:type_name -> management.FirewallRule\n-\t44, // 33: management.NetworkMap.routesFirewallRules:type_name -> management.RouteFirewallRule\n-\t45, // 34: management.NetworkMap.forwardingRules:type_name -> management.ForwardingRule\n-\t28, // 35: management.RemotePeerConfig.sshConfig:type_name -> management.SSHConfig\n-\t22, // 36: management.SSHConfig.jwtConfig:type_name -> management.JWTConfig\n-\t4,  // 37: management.DeviceAuthorizationFlow.Provider:type_name -> management.DeviceAuthorizationFlow.provider\n-\t33, // 38: management.DeviceAuthorizationFlow.ProviderConfig:type_name -> management.ProviderConfig\n-\t33, // 39: management.PKCEAuthorizationFlow.ProviderConfig:type_name -> management.ProviderConfig\n-\t38, // 40: management.DNSConfig.NameServerGroups:type_name -> management.NameServerGroup\n-\t36, // 41: management.DNSConfig.CustomZones:type_name -> management.CustomZone\n-\t37, // 42: management.CustomZone.Records:type_name -> management.SimpleRecord\n-\t39, // 43: management.NameServerGroup.NameServers:type_name -> management.NameServer\n-\t1,  // 44: management.FirewallRule.Direction:type_name -> management.RuleDirection\n-\t2,  // 45: management.FirewallRule.Action:type_name -> management.RuleAction\n-\t0,  // 46: management.FirewallRule.Protocol:type_name -> management.RuleProtocol\n-\t43, // 47: management.FirewallRule.PortInfo:type_name -> management.PortInfo\n-\t46, // 48: management.PortInfo.range:type_name -> management.PortInfo.Range\n-\t2,  // 49: management.RouteFirewallRule.action:type_name -> management.RuleAction\n-\t0,  // 50: management.RouteFirewallRule.protocol:type_name -> management.RuleProtocol\n-\t43, // 51: management.RouteFirewallRule.portInfo:type_name -> management.PortInfo\n-\t0,  // 52: management.ForwardingRule.protocol:type_name -> management.RuleProtocol\n-\t43, // 53: management.ForwardingRule.destinationPort:type_name -> management.PortInfo\n-\t43, // 54: management.ForwardingRule.translatedPort:type_name -> management.PortInfo\n-\t5,  // 55: management.ManagementService.Login:input_type -> management.EncryptedMessage\n-\t5,  // 56: management.ManagementService.Sync:input_type -> management.EncryptedMessage\n-\t17, // 57: management.ManagementService.GetServerKey:input_type -> management.Empty\n-\t17, // 58: management.ManagementService.isHealthy:input_type -> management.Empty\n-\t5,  // 59: management.ManagementService.GetDeviceAuthorizationFlow:input_type -> management.EncryptedMessage\n-\t5,  // 60: management.ManagementService.GetPKCEAuthorizationFlow:input_type -> management.EncryptedMessage\n-\t5,  // 61: management.ManagementService.SyncMeta:input_type -> management.EncryptedMessage\n-\t5,  // 62: management.ManagementService.Logout:input_type -> management.EncryptedMessage\n-\t5,  // 63: management.ManagementService.Login:output_type -> management.EncryptedMessage\n-\t5,  // 64: management.ManagementService.Sync:output_type -> management.EncryptedMessage\n-\t16, // 65: management.ManagementService.GetServerKey:output_type -> management.ServerKeyResponse\n-\t17, // 66: management.ManagementService.isHealthy:output_type -> management.Empty\n-\t5,  // 67: management.ManagementService.GetDeviceAuthorizationFlow:output_type -> management.EncryptedMessage\n-\t5,  // 68: management.ManagementService.GetPKCEAuthorizationFlow:output_type -> management.EncryptedMessage\n-\t17, // 69: management.ManagementService.SyncMeta:output_type -> management.Empty\n-\t17, // 70: management.ManagementService.Logout:output_type -> management.Empty\n-\t63, // [63:71] is the sub-list for method output_type\n-\t55, // [55:63] is the sub-list for method input_type\n-\t55, // [55:55] is the sub-list for extension type_name\n-\t55, // [55:55] is the sub-list for extension extendee\n-\t0,  // [0:55] is the sub-list for field type_name\n+\t29, // 28: management.NetworkMap.remotePeers:type_name -> management.RemotePeerConfig\n+\t36, // 29: management.NetworkMap.Routes:type_name -> management.Route\n+\t37, // 30: management.NetworkMap.DNSConfig:type_name -> management.DNSConfig\n+\t29, // 31: management.NetworkMap.offlinePeers:type_name -> management.RemotePeerConfig\n+\t42, // 32: management.NetworkMap.FirewallRules:type_name -> management.FirewallRule\n+\t46, // 33: management.NetworkMap.routesFirewallRules:type_name -> management.RouteFirewallRule\n+\t47, // 34: management.NetworkMap.forwardingRules:type_name -> management.ForwardingRule\n+\t27, // 35: management.NetworkMap.sshAuth:type_name -> management.SSHAuth\n+\t48, // 36: management.SSHAuth.machine_users:type_name -> management.SSHAuth.MachineUsersEntry\n+\t30, // 37: management.RemotePeerConfig.sshConfig:type_name -> management.SSHConfig\n+\t22, // 38: management.SSHConfig.jwtConfig:type_name -> management.JWTConfig\n+\t4,  // 39: management.DeviceAuthorizationFlow.Provider:type_name -> management.DeviceAuthorizationFlow.provider\n+\t35, // 40: management.DeviceAuthorizationFlow.ProviderConfig:type_name -> management.ProviderConfig\n+\t35, // 41: management.PKCEAuthorizationFlow.ProviderConfig:type_name -> management.ProviderConfig\n+\t40, // 42: management.DNSConfig.NameServerGroups:type_name -> management.NameServerGroup\n+\t38, // 43: management.DNSConfig.CustomZones:type_name -> management.CustomZone\n+\t39, // 44: management.CustomZone.Records:type_name -> management.SimpleRecord\n+\t41, // 45: management.NameServerGroup.NameServers:type_name -> management.NameServer\n+\t1,  // 46: management.FirewallRule.Direction:type_name -> management.RuleDirection\n+\t2,  // 47: management.FirewallRule.Action:type_name -> management.RuleAction\n+\t0,  // 48: management.FirewallRule.Protocol:type_name -> management.RuleProtocol\n+\t45, // 49: management.FirewallRule.PortInfo:type_name -> management.PortInfo\n+\t49, // 50: management.PortInfo.range:type_name -> management.PortInfo.Range\n+\t2,  // 51: management.RouteFirewallRule.action:type_name -> management.RuleAction\n+\t0,  // 52: management.RouteFirewallRule.protocol:type_name -> management.RuleProtocol\n+\t45, // 53: management.RouteFirewallRule.portInfo:type_name -> management.PortInfo\n+\t0,  // 54: management.ForwardingRule.protocol:type_name -> management.RuleProtocol\n+\t45, // 55: management.ForwardingRule.destinationPort:type_name -> management.PortInfo\n+\t45, // 56: management.ForwardingRule.translatedPort:type_name -> management.PortInfo\n+\t28, // 57: management.SSHAuth.MachineUsersEntry.value:type_name -> management.MachineUserIndexes\n+\t5,  // 58: management.ManagementService.Login:input_type -> management.EncryptedMessage\n+\t5,  // 59: management.ManagementService.Sync:input_type -> management.EncryptedMessage\n+\t17, // 60: management.ManagementService.GetServerKey:input_type -> management.Empty\n+\t17, // 61: management.ManagementService.isHealthy:input_type -> management.Empty\n+\t5,  // 62: management.ManagementService.GetDeviceAuthorizationFlow:input_type -> management.EncryptedMessage\n+\t5,  // 63: management.ManagementService.GetPKCEAuthorizationFlow:input_type -> management.EncryptedMessage\n+\t5,  // 64: management.ManagementService.SyncMeta:input_type -> management.EncryptedMessage\n+\t5,  // 65: management.ManagementService.Logout:input_type -> management.EncryptedMessage\n+\t5,  // 66: management.ManagementService.Login:output_type -> management.EncryptedMessage\n+\t5,  // 67: management.ManagementService.Sync:output_type -> management.EncryptedMessage\n+\t16, // 68: management.ManagementService.GetServerKey:output_type -> management.ServerKeyResponse\n+\t17, // 69: management.ManagementService.isHealthy:output_type -> management.Empty\n+\t5,  // 70: management.ManagementService.GetDeviceAuthorizationFlow:output_type -> management.EncryptedMessage\n+\t5,  // 71: management.ManagementService.GetPKCEAuthorizationFlow:output_type -> management.EncryptedMessage\n+\t17, // 72: management.ManagementService.SyncMeta:output_type -> management.Empty\n+\t17, // 73: management.ManagementService.Logout:output_type -> management.Empty\n+\t66, // [66:74] is the sub-list for method output_type\n+\t58, // [58:66] is the sub-list for method input_type\n+\t58, // [58:58] is the sub-list for extension type_name\n+\t58, // [58:58] is the sub-list for extension extendee\n+\t0,  // [0:58] is the sub-list for field type_name\n }\n \n func init() { file_management_proto_init() }\n@@ -4558,7 +4708,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*RemotePeerConfig); i {\n+\t\t\tswitch v := v.(*SSHAuth); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4570,7 +4720,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*SSHConfig); i {\n+\t\t\tswitch v := v.(*MachineUserIndexes); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4582,7 +4732,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*DeviceAuthorizationFlowRequest); i {\n+\t\t\tswitch v := v.(*RemotePeerConfig); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4594,7 +4744,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*DeviceAuthorizationFlow); i {\n+\t\t\tswitch v := v.(*SSHConfig); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4606,7 +4756,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[26].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*PKCEAuthorizationFlowRequest); i {\n+\t\t\tswitch v := v.(*DeviceAuthorizationFlowRequest); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4618,7 +4768,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[27].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*PKCEAuthorizationFlow); i {\n+\t\t\tswitch v := v.(*DeviceAuthorizationFlow); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4630,7 +4780,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[28].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*ProviderConfig); i {\n+\t\t\tswitch v := v.(*PKCEAuthorizationFlowRequest); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4642,7 +4792,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[29].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*Route); i {\n+\t\t\tswitch v := v.(*PKCEAuthorizationFlow); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4654,7 +4804,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[30].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*DNSConfig); i {\n+\t\t\tswitch v := v.(*ProviderConfig); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4666,7 +4816,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[31].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*CustomZone); i {\n+\t\t\tswitch v := v.(*Route); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4678,7 +4828,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[32].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*SimpleRecord); i {\n+\t\t\tswitch v := v.(*DNSConfig); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4690,7 +4840,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[33].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*NameServerGroup); i {\n+\t\t\tswitch v := v.(*CustomZone); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4702,7 +4852,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[34].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*NameServer); i {\n+\t\t\tswitch v := v.(*SimpleRecord); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4714,7 +4864,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[35].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*FirewallRule); i {\n+\t\t\tswitch v := v.(*NameServerGroup); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4726,7 +4876,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[36].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*NetworkAddress); i {\n+\t\t\tswitch v := v.(*NameServer); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4738,7 +4888,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[37].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*Checks); i {\n+\t\t\tswitch v := v.(*FirewallRule); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4750,7 +4900,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[38].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*PortInfo); i {\n+\t\t\tswitch v := v.(*NetworkAddress); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4762,7 +4912,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[39].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*RouteFirewallRule); i {\n+\t\t\tswitch v := v.(*Checks); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4774,7 +4924,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[40].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*ForwardingRule); i {\n+\t\t\tswitch v := v.(*PortInfo); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4786,6 +4936,30 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[41].Exporter = func(v interface{}, i int) interface{} {\n+\t\t\tswitch v := v.(*RouteFirewallRule); i {\n+\t\t\tcase 0:\n+\t\t\t\treturn &v.state\n+\t\t\tcase 1:\n+\t\t\t\treturn &v.sizeCache\n+\t\t\tcase 2:\n+\t\t\t\treturn &v.unknownFields\n+\t\t\tdefault:\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t}\n+\t\tfile_management_proto_msgTypes[42].Exporter = func(v interface{}, i int) interface{} {\n+\t\t\tswitch v := v.(*ForwardingRule); i {\n+\t\t\tcase 0:\n+\t\t\t\treturn &v.state\n+\t\t\tcase 1:\n+\t\t\t\treturn &v.sizeCache\n+\t\t\tcase 2:\n+\t\t\t\treturn &v.unknownFields\n+\t\t\tdefault:\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t}\n+\t\tfile_management_proto_msgTypes[44].Exporter = func(v interface{}, i int) interface{} {\n \t\t\tswitch v := v.(*PortInfo_Range); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n@@ -4798,7 +4972,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t}\n-\tfile_management_proto_msgTypes[38].OneofWrappers = []interface{}{\n+\tfile_management_proto_msgTypes[40].OneofWrappers = []interface{}{\n \t\t(*PortInfo_Port)(nil),\n \t\t(*PortInfo_Range_)(nil),\n \t}\n@@ -4808,7 +4982,7 @@ func file_management_proto_init() {\n \t\t\tGoPackagePath: reflect.TypeOf(x{}).PkgPath(),\n \t\t\tRawDescriptor: file_management_proto_rawDesc,\n \t\t\tNumEnums:      5,\n-\t\t\tNumMessages:   42,\n+\t\t\tNumMessages:   45,\n \t\t\tNumExtensions: 0,\n \t\t\tNumServices:   1,\n \t\t},\ndiff --git a/shared/management/proto/management.proto b/shared/management/proto/management.proto\nindex fec51ca91d3..f2e591e8828 100644\n--- a/shared/management/proto/management.proto\n+++ b/shared/management/proto/management.proto\n@@ -332,6 +332,24 @@ message NetworkMap {\n   bool routesFirewallRulesIsEmpty = 11;\n \n   repeated ForwardingRule forwardingRules = 12;\n+\n+  // SSHAuth represents SSH authorization configuration\n+  SSHAuth sshAuth = 13;\n+}\n+\n+message SSHAuth {\n+  // UserIDClaim is the JWT claim to be used to get the users ID\n+  string UserIDClaim = 1;\n+\n+  // AuthorizedUsers is a list of hashed user IDs authorized to access this peer via SSH\n+  repeated bytes AuthorizedUsers = 2;\n+\n+  // MachineUsers is a map of machine user names to their corresponding indexes in the AuthorizedUsers list\n+  map<string, MachineUserIndexes> machine_users = 3;\n+}\n+\n+message MachineUserIndexes {\n+  repeated uint32 indexes = 1;\n }\n \n // RemotePeerConfig represents a configuration of a remote peer.\ndiff --git a/shared/sshauth/userhash.go b/shared/sshauth/userhash.go\nnew file mode 100644\nindex 00000000000..276fc9ba201\n--- /dev/null\n+++ b/shared/sshauth/userhash.go\n@@ -0,0 +1,28 @@\n+package sshauth\n+\n+import (\n+\t\"encoding/hex\"\n+\n+\t\"golang.org/x/crypto/blake2b\"\n+)\n+\n+// UserIDHash represents a hashed user ID (BLAKE2b-128)\n+type UserIDHash [16]byte\n+\n+// HashUserID hashes a user ID using BLAKE2b-128 and returns the hash value\n+// This function must produce the same hash on both client and management server\n+func HashUserID(userID string) (UserIDHash, error) {\n+\thash, err := blake2b.New(16, nil)\n+\tif err != nil {\n+\t\treturn UserIDHash{}, err\n+\t}\n+\thash.Write([]byte(userID))\n+\tvar result UserIDHash\n+\tcopy(result[:], hash.Sum(nil))\n+\treturn result, nil\n+}\n+\n+// String returns the hexadecimal string representation of the hash\n+func (h UserIDHash) String() string {\n+\treturn hex.EncodeToString(h[:])\n+}\n", "test_patch": "diff --git a/client/ssh/auth/auth_test.go b/client/ssh/auth/auth_test.go\nnew file mode 100644\nindex 00000000000..2b3b5a41455\n--- /dev/null\n+++ b/client/ssh/auth/auth_test.go\n@@ -0,0 +1,612 @@\n+package auth\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\n+\t\"github.com/netbirdio/netbird/shared/sshauth\"\n+)\n+\n+func TestAuthorizer_Authorize_UserNotInList(t *testing.T) {\n+\tauthorizer := NewAuthorizer()\n+\n+\t// Set up authorized users list with one user\n+\tauthorizedUserHash, err := sshauth.HashUserID(\"authorized-user\")\n+\trequire.NoError(t, err)\n+\n+\tconfig := &Config{\n+\t\tUserIDClaim:     DefaultUserIDClaim,\n+\t\tAuthorizedUsers: []sshauth.UserIDHash{authorizedUserHash},\n+\t\tMachineUsers:    map[string][]uint32{},\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// Try to authorize a different user\n+\terr = authorizer.Authorize(\"unauthorized-user\", \"root\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrUserNotAuthorized)\n+}\n+\n+func TestAuthorizer_Authorize_UserInList_NoMachineUserRestrictions(t *testing.T) {\n+\tauthorizer := NewAuthorizer()\n+\n+\tuser1Hash, err := sshauth.HashUserID(\"user1\")\n+\trequire.NoError(t, err)\n+\tuser2Hash, err := sshauth.HashUserID(\"user2\")\n+\trequire.NoError(t, err)\n+\n+\tconfig := &Config{\n+\t\tUserIDClaim:     DefaultUserIDClaim,\n+\t\tAuthorizedUsers: []sshauth.UserIDHash{user1Hash, user2Hash},\n+\t\tMachineUsers:    map[string][]uint32{}, // Empty = deny all (fail closed)\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// All attempts should fail when no machine user mappings exist (fail closed)\n+\terr = authorizer.Authorize(\"user1\", \"root\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrNoMachineUserMapping)\n+\n+\terr = authorizer.Authorize(\"user2\", \"admin\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrNoMachineUserMapping)\n+\n+\terr = authorizer.Authorize(\"user1\", \"postgres\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrNoMachineUserMapping)\n+}\n+\n+func TestAuthorizer_Authorize_UserInList_WithMachineUserMapping_Allowed(t *testing.T) {\n+\tauthorizer := NewAuthorizer()\n+\n+\tuser1Hash, err := sshauth.HashUserID(\"user1\")\n+\trequire.NoError(t, err)\n+\tuser2Hash, err := sshauth.HashUserID(\"user2\")\n+\trequire.NoError(t, err)\n+\tuser3Hash, err := sshauth.HashUserID(\"user3\")\n+\trequire.NoError(t, err)\n+\n+\tconfig := &Config{\n+\t\tUserIDClaim:     DefaultUserIDClaim,\n+\t\tAuthorizedUsers: []sshauth.UserIDHash{user1Hash, user2Hash, user3Hash},\n+\t\tMachineUsers: map[string][]uint32{\n+\t\t\t\"root\":     {0, 1}, // user1 and user2 can access root\n+\t\t\t\"postgres\": {1, 2}, // user2 and user3 can access postgres\n+\t\t\t\"admin\":    {0},    // only user1 can access admin\n+\t\t},\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// user1 (index 0) should access root and admin\n+\terr = authorizer.Authorize(\"user1\", \"root\")\n+\tassert.NoError(t, err)\n+\n+\terr = authorizer.Authorize(\"user1\", \"admin\")\n+\tassert.NoError(t, err)\n+\n+\t// user2 (index 1) should access root and postgres\n+\terr = authorizer.Authorize(\"user2\", \"root\")\n+\tassert.NoError(t, err)\n+\n+\terr = authorizer.Authorize(\"user2\", \"postgres\")\n+\tassert.NoError(t, err)\n+\n+\t// user3 (index 2) should access postgres\n+\terr = authorizer.Authorize(\"user3\", \"postgres\")\n+\tassert.NoError(t, err)\n+}\n+\n+func TestAuthorizer_Authorize_UserInList_WithMachineUserMapping_Denied(t *testing.T) {\n+\tauthorizer := NewAuthorizer()\n+\n+\t// Set up authorized users list\n+\tuser1Hash, err := sshauth.HashUserID(\"user1\")\n+\trequire.NoError(t, err)\n+\tuser2Hash, err := sshauth.HashUserID(\"user2\")\n+\trequire.NoError(t, err)\n+\tuser3Hash, err := sshauth.HashUserID(\"user3\")\n+\trequire.NoError(t, err)\n+\n+\tconfig := &Config{\n+\t\tUserIDClaim:     DefaultUserIDClaim,\n+\t\tAuthorizedUsers: []sshauth.UserIDHash{user1Hash, user2Hash, user3Hash},\n+\t\tMachineUsers: map[string][]uint32{\n+\t\t\t\"root\":     {0, 1}, // user1 and user2 can access root\n+\t\t\t\"postgres\": {1, 2}, // user2 and user3 can access postgres\n+\t\t\t\"admin\":    {0},    // only user1 can access admin\n+\t\t},\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// user1 (index 0) should NOT access postgres\n+\terr = authorizer.Authorize(\"user1\", \"postgres\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrUserNotMappedToOSUser)\n+\n+\t// user2 (index 1) should NOT access admin\n+\terr = authorizer.Authorize(\"user2\", \"admin\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrUserNotMappedToOSUser)\n+\n+\t// user3 (index 2) should NOT access root\n+\terr = authorizer.Authorize(\"user3\", \"root\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrUserNotMappedToOSUser)\n+\n+\t// user3 (index 2) should NOT access admin\n+\terr = authorizer.Authorize(\"user3\", \"admin\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrUserNotMappedToOSUser)\n+}\n+\n+func TestAuthorizer_Authorize_UserInList_OSUserNotInMapping(t *testing.T) {\n+\tauthorizer := NewAuthorizer()\n+\n+\t// Set up authorized users list\n+\tuser1Hash, err := sshauth.HashUserID(\"user1\")\n+\trequire.NoError(t, err)\n+\n+\tconfig := &Config{\n+\t\tUserIDClaim:     DefaultUserIDClaim,\n+\t\tAuthorizedUsers: []sshauth.UserIDHash{user1Hash},\n+\t\tMachineUsers: map[string][]uint32{\n+\t\t\t\"root\": {0}, // only root is mapped\n+\t\t},\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// user1 should NOT access an unmapped OS user (fail closed)\n+\terr = authorizer.Authorize(\"user1\", \"postgres\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrNoMachineUserMapping)\n+}\n+\n+func TestAuthorizer_Authorize_EmptyJWTUserID(t *testing.T) {\n+\tauthorizer := NewAuthorizer()\n+\n+\t// Set up authorized users list\n+\tuser1Hash, err := sshauth.HashUserID(\"user1\")\n+\trequire.NoError(t, err)\n+\n+\tconfig := &Config{\n+\t\tUserIDClaim:     DefaultUserIDClaim,\n+\t\tAuthorizedUsers: []sshauth.UserIDHash{user1Hash},\n+\t\tMachineUsers:    map[string][]uint32{},\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// Empty user ID should fail\n+\terr = authorizer.Authorize(\"\", \"root\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrEmptyUserID)\n+}\n+\n+func TestAuthorizer_Authorize_MultipleUsersInList(t *testing.T) {\n+\tauthorizer := NewAuthorizer()\n+\n+\t// Set up multiple authorized users\n+\tuserHashes := make([]sshauth.UserIDHash, 10)\n+\tfor i := 0; i < 10; i++ {\n+\t\thash, err := sshauth.HashUserID(\"user\" + string(rune('0'+i)))\n+\t\trequire.NoError(t, err)\n+\t\tuserHashes[i] = hash\n+\t}\n+\n+\t// Create machine user mapping for all users\n+\trootIndexes := make([]uint32, 10)\n+\tfor i := 0; i < 10; i++ {\n+\t\trootIndexes[i] = uint32(i)\n+\t}\n+\n+\tconfig := &Config{\n+\t\tUserIDClaim:     DefaultUserIDClaim,\n+\t\tAuthorizedUsers: userHashes,\n+\t\tMachineUsers: map[string][]uint32{\n+\t\t\t\"root\": rootIndexes,\n+\t\t},\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// All users should be authorized for root\n+\tfor i := 0; i < 10; i++ {\n+\t\terr := authorizer.Authorize(\"user\"+string(rune('0'+i)), \"root\")\n+\t\tassert.NoError(t, err, \"user%d should be authorized\", i)\n+\t}\n+\n+\t// User not in list should fail\n+\terr := authorizer.Authorize(\"unknown-user\", \"root\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrUserNotAuthorized)\n+}\n+\n+func TestAuthorizer_Update_ClearsConfiguration(t *testing.T) {\n+\tauthorizer := NewAuthorizer()\n+\n+\t// Set up initial configuration\n+\tuser1Hash, err := sshauth.HashUserID(\"user1\")\n+\trequire.NoError(t, err)\n+\n+\tconfig := &Config{\n+\t\tUserIDClaim:     DefaultUserIDClaim,\n+\t\tAuthorizedUsers: []sshauth.UserIDHash{user1Hash},\n+\t\tMachineUsers:    map[string][]uint32{\"root\": {0}},\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// user1 should be authorized\n+\terr = authorizer.Authorize(\"user1\", \"root\")\n+\tassert.NoError(t, err)\n+\n+\t// Clear configuration\n+\tauthorizer.Update(nil)\n+\n+\t// user1 should no longer be authorized\n+\terr = authorizer.Authorize(\"user1\", \"root\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrUserNotAuthorized)\n+}\n+\n+func TestAuthorizer_Update_EmptyMachineUsersListEntries(t *testing.T) {\n+\tauthorizer := NewAuthorizer()\n+\n+\tuser1Hash, err := sshauth.HashUserID(\"user1\")\n+\trequire.NoError(t, err)\n+\n+\t// Machine users with empty index lists should be filtered out\n+\tconfig := &Config{\n+\t\tUserIDClaim:     DefaultUserIDClaim,\n+\t\tAuthorizedUsers: []sshauth.UserIDHash{user1Hash},\n+\t\tMachineUsers: map[string][]uint32{\n+\t\t\t\"root\":     {0},\n+\t\t\t\"postgres\": {},  // empty list - should be filtered out\n+\t\t\t\"admin\":    nil, // nil list - should be filtered out\n+\t\t},\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// root should work\n+\terr = authorizer.Authorize(\"user1\", \"root\")\n+\tassert.NoError(t, err)\n+\n+\t// postgres should fail (no mapping)\n+\terr = authorizer.Authorize(\"user1\", \"postgres\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrNoMachineUserMapping)\n+\n+\t// admin should fail (no mapping)\n+\terr = authorizer.Authorize(\"user1\", \"admin\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrNoMachineUserMapping)\n+}\n+\n+func TestAuthorizer_CustomUserIDClaim(t *testing.T) {\n+\tauthorizer := NewAuthorizer()\n+\n+\t// Set up with custom user ID claim\n+\tuser1Hash, err := sshauth.HashUserID(\"user@example.com\")\n+\trequire.NoError(t, err)\n+\n+\tconfig := &Config{\n+\t\tUserIDClaim:     \"email\",\n+\t\tAuthorizedUsers: []sshauth.UserIDHash{user1Hash},\n+\t\tMachineUsers: map[string][]uint32{\n+\t\t\t\"root\": {0},\n+\t\t},\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// Verify the custom claim is set\n+\tassert.Equal(t, \"email\", authorizer.GetUserIDClaim())\n+\n+\t// Authorize with email as user ID\n+\terr = authorizer.Authorize(\"user@example.com\", \"root\")\n+\tassert.NoError(t, err)\n+}\n+\n+func TestAuthorizer_DefaultUserIDClaim(t *testing.T) {\n+\tauthorizer := NewAuthorizer()\n+\n+\t// Verify default claim\n+\tassert.Equal(t, DefaultUserIDClaim, authorizer.GetUserIDClaim())\n+\tassert.Equal(t, \"sub\", authorizer.GetUserIDClaim())\n+\n+\t// Set up with empty user ID claim (should use default)\n+\tuser1Hash, err := sshauth.HashUserID(\"user1\")\n+\trequire.NoError(t, err)\n+\n+\tconfig := &Config{\n+\t\tUserIDClaim:     \"\", // empty - should use default\n+\t\tAuthorizedUsers: []sshauth.UserIDHash{user1Hash},\n+\t\tMachineUsers:    map[string][]uint32{},\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// Should fall back to default\n+\tassert.Equal(t, DefaultUserIDClaim, authorizer.GetUserIDClaim())\n+}\n+\n+func TestAuthorizer_MachineUserMapping_LargeIndexes(t *testing.T) {\n+\tauthorizer := NewAuthorizer()\n+\n+\t// Create a large authorized users list\n+\tconst numUsers = 1000\n+\tuserHashes := make([]sshauth.UserIDHash, numUsers)\n+\tfor i := 0; i < numUsers; i++ {\n+\t\thash, err := sshauth.HashUserID(\"user\" + string(rune(i)))\n+\t\trequire.NoError(t, err)\n+\t\tuserHashes[i] = hash\n+\t}\n+\n+\tconfig := &Config{\n+\t\tUserIDClaim:     DefaultUserIDClaim,\n+\t\tAuthorizedUsers: userHashes,\n+\t\tMachineUsers: map[string][]uint32{\n+\t\t\t\"root\": {0, 500, 999}, // first, middle, and last user\n+\t\t},\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// First user should have access\n+\terr := authorizer.Authorize(\"user\"+string(rune(0)), \"root\")\n+\tassert.NoError(t, err)\n+\n+\t// Middle user should have access\n+\terr = authorizer.Authorize(\"user\"+string(rune(500)), \"root\")\n+\tassert.NoError(t, err)\n+\n+\t// Last user should have access\n+\terr = authorizer.Authorize(\"user\"+string(rune(999)), \"root\")\n+\tassert.NoError(t, err)\n+\n+\t// User not in mapping should NOT have access\n+\terr = authorizer.Authorize(\"user\"+string(rune(100)), \"root\")\n+\tassert.Error(t, err)\n+}\n+\n+func TestAuthorizer_ConcurrentAuthorization(t *testing.T) {\n+\tauthorizer := NewAuthorizer()\n+\n+\t// Set up authorized users\n+\tuser1Hash, err := sshauth.HashUserID(\"user1\")\n+\trequire.NoError(t, err)\n+\tuser2Hash, err := sshauth.HashUserID(\"user2\")\n+\trequire.NoError(t, err)\n+\n+\tconfig := &Config{\n+\t\tUserIDClaim:     DefaultUserIDClaim,\n+\t\tAuthorizedUsers: []sshauth.UserIDHash{user1Hash, user2Hash},\n+\t\tMachineUsers: map[string][]uint32{\n+\t\t\t\"root\": {0, 1},\n+\t\t},\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// Test concurrent authorization calls (should be safe to read concurrently)\n+\tconst numGoroutines = 100\n+\terrChan := make(chan error, numGoroutines)\n+\n+\tfor i := 0; i < numGoroutines; i++ {\n+\t\tgo func(idx int) {\n+\t\t\tuser := \"user1\"\n+\t\t\tif idx%2 == 0 {\n+\t\t\t\tuser = \"user2\"\n+\t\t\t}\n+\t\t\terr := authorizer.Authorize(user, \"root\")\n+\t\t\terrChan <- err\n+\t\t}(i)\n+\t}\n+\n+\t// Wait for all goroutines to complete and collect errors\n+\tfor i := 0; i < numGoroutines; i++ {\n+\t\terr := <-errChan\n+\t\tassert.NoError(t, err)\n+\t}\n+}\n+\n+func TestAuthorizer_Wildcard_AllowsAllAuthorizedUsers(t *testing.T) {\n+\tauthorizer := NewAuthorizer()\n+\n+\tuser1Hash, err := sshauth.HashUserID(\"user1\")\n+\trequire.NoError(t, err)\n+\tuser2Hash, err := sshauth.HashUserID(\"user2\")\n+\trequire.NoError(t, err)\n+\tuser3Hash, err := sshauth.HashUserID(\"user3\")\n+\trequire.NoError(t, err)\n+\n+\t// Configure with wildcard - all authorized users can access any OS user\n+\tconfig := &Config{\n+\t\tUserIDClaim:     DefaultUserIDClaim,\n+\t\tAuthorizedUsers: []sshauth.UserIDHash{user1Hash, user2Hash, user3Hash},\n+\t\tMachineUsers: map[string][]uint32{\n+\t\t\t\"*\": {0, 1, 2}, // wildcard with all user indexes\n+\t\t},\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// All authorized users should be able to access any OS user\n+\terr = authorizer.Authorize(\"user1\", \"root\")\n+\tassert.NoError(t, err)\n+\n+\terr = authorizer.Authorize(\"user2\", \"postgres\")\n+\tassert.NoError(t, err)\n+\n+\terr = authorizer.Authorize(\"user3\", \"admin\")\n+\tassert.NoError(t, err)\n+\n+\terr = authorizer.Authorize(\"user1\", \"ubuntu\")\n+\tassert.NoError(t, err)\n+\n+\terr = authorizer.Authorize(\"user2\", \"nginx\")\n+\tassert.NoError(t, err)\n+\n+\terr = authorizer.Authorize(\"user3\", \"docker\")\n+\tassert.NoError(t, err)\n+}\n+\n+func TestAuthorizer_Wildcard_UnauthorizedUserStillDenied(t *testing.T) {\n+\tauthorizer := NewAuthorizer()\n+\n+\tuser1Hash, err := sshauth.HashUserID(\"user1\")\n+\trequire.NoError(t, err)\n+\n+\t// Configure with wildcard\n+\tconfig := &Config{\n+\t\tUserIDClaim:     DefaultUserIDClaim,\n+\t\tAuthorizedUsers: []sshauth.UserIDHash{user1Hash},\n+\t\tMachineUsers: map[string][]uint32{\n+\t\t\t\"*\": {0},\n+\t\t},\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// user1 should have access\n+\terr = authorizer.Authorize(\"user1\", \"root\")\n+\tassert.NoError(t, err)\n+\n+\t// Unauthorized user should still be denied even with wildcard\n+\terr = authorizer.Authorize(\"unauthorized-user\", \"root\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrUserNotAuthorized)\n+}\n+\n+func TestAuthorizer_Wildcard_TakesPrecedenceOverSpecificMappings(t *testing.T) {\n+\tauthorizer := NewAuthorizer()\n+\n+\tuser1Hash, err := sshauth.HashUserID(\"user1\")\n+\trequire.NoError(t, err)\n+\tuser2Hash, err := sshauth.HashUserID(\"user2\")\n+\trequire.NoError(t, err)\n+\n+\t// Configure with both wildcard and specific mappings\n+\t// Wildcard takes precedence for users in the wildcard index list\n+\tconfig := &Config{\n+\t\tUserIDClaim:     DefaultUserIDClaim,\n+\t\tAuthorizedUsers: []sshauth.UserIDHash{user1Hash, user2Hash},\n+\t\tMachineUsers: map[string][]uint32{\n+\t\t\t\"*\":    {0, 1}, // wildcard for both users\n+\t\t\t\"root\": {0},    // specific mapping that would normally restrict to user1 only\n+\t\t},\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// Both users should be able to access root via wildcard (takes precedence over specific mapping)\n+\terr = authorizer.Authorize(\"user1\", \"root\")\n+\tassert.NoError(t, err)\n+\n+\terr = authorizer.Authorize(\"user2\", \"root\")\n+\tassert.NoError(t, err)\n+\n+\t// Both users should be able to access any other OS user via wildcard\n+\terr = authorizer.Authorize(\"user1\", \"postgres\")\n+\tassert.NoError(t, err)\n+\n+\terr = authorizer.Authorize(\"user2\", \"admin\")\n+\tassert.NoError(t, err)\n+}\n+\n+func TestAuthorizer_NoWildcard_SpecificMappingsOnly(t *testing.T) {\n+\tauthorizer := NewAuthorizer()\n+\n+\tuser1Hash, err := sshauth.HashUserID(\"user1\")\n+\trequire.NoError(t, err)\n+\tuser2Hash, err := sshauth.HashUserID(\"user2\")\n+\trequire.NoError(t, err)\n+\n+\t// Configure WITHOUT wildcard - only specific mappings\n+\tconfig := &Config{\n+\t\tUserIDClaim:     DefaultUserIDClaim,\n+\t\tAuthorizedUsers: []sshauth.UserIDHash{user1Hash, user2Hash},\n+\t\tMachineUsers: map[string][]uint32{\n+\t\t\t\"root\":     {0}, // only user1\n+\t\t\t\"postgres\": {1}, // only user2\n+\t\t},\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// user1 can access root\n+\terr = authorizer.Authorize(\"user1\", \"root\")\n+\tassert.NoError(t, err)\n+\n+\t// user2 can access postgres\n+\terr = authorizer.Authorize(\"user2\", \"postgres\")\n+\tassert.NoError(t, err)\n+\n+\t// user1 cannot access postgres\n+\terr = authorizer.Authorize(\"user1\", \"postgres\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrUserNotMappedToOSUser)\n+\n+\t// user2 cannot access root\n+\terr = authorizer.Authorize(\"user2\", \"root\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrUserNotMappedToOSUser)\n+\n+\t// Neither can access unmapped OS users\n+\terr = authorizer.Authorize(\"user1\", \"admin\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrNoMachineUserMapping)\n+\n+\terr = authorizer.Authorize(\"user2\", \"admin\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrNoMachineUserMapping)\n+}\n+\n+func TestAuthorizer_Wildcard_WithPartialIndexes_AllowsAllUsers(t *testing.T) {\n+\t// This test covers the scenario where wildcard exists with limited indexes.\n+\t// Only users whose indexes are in the wildcard list can access any OS user via wildcard.\n+\t// Other users can only access OS users they are explicitly mapped to.\n+\tauthorizer := NewAuthorizer()\n+\n+\t// Create two authorized user hashes (simulating the base64-encoded hashes in the config)\n+\twasmHash, err := sshauth.HashUserID(\"wasm\")\n+\trequire.NoError(t, err)\n+\tuser2Hash, err := sshauth.HashUserID(\"user2\")\n+\trequire.NoError(t, err)\n+\n+\t// Configure with wildcard having only index 0, and specific mappings for other OS users\n+\tconfig := &Config{\n+\t\tUserIDClaim:     \"sub\",\n+\t\tAuthorizedUsers: []sshauth.UserIDHash{wasmHash, user2Hash},\n+\t\tMachineUsers: map[string][]uint32{\n+\t\t\t\"*\":     {0}, // wildcard with only index 0 - only wasm has wildcard access\n+\t\t\t\"alice\": {1}, // specific mapping for user2\n+\t\t\t\"bob\":   {1}, // specific mapping for user2\n+\t\t},\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// wasm (index 0) should access any OS user via wildcard\n+\terr = authorizer.Authorize(\"wasm\", \"root\")\n+\tassert.NoError(t, err, \"wasm should access root via wildcard\")\n+\n+\terr = authorizer.Authorize(\"wasm\", \"alice\")\n+\tassert.NoError(t, err, \"wasm should access alice via wildcard\")\n+\n+\terr = authorizer.Authorize(\"wasm\", \"bob\")\n+\tassert.NoError(t, err, \"wasm should access bob via wildcard\")\n+\n+\terr = authorizer.Authorize(\"wasm\", \"postgres\")\n+\tassert.NoError(t, err, \"wasm should access postgres via wildcard\")\n+\n+\t// user2 (index 1) should only access alice and bob (explicitly mapped), NOT root or postgres\n+\terr = authorizer.Authorize(\"user2\", \"alice\")\n+\tassert.NoError(t, err, \"user2 should access alice via explicit mapping\")\n+\n+\terr = authorizer.Authorize(\"user2\", \"bob\")\n+\tassert.NoError(t, err, \"user2 should access bob via explicit mapping\")\n+\n+\terr = authorizer.Authorize(\"user2\", \"root\")\n+\tassert.Error(t, err, \"user2 should NOT access root (not in wildcard indexes)\")\n+\tassert.ErrorIs(t, err, ErrNoMachineUserMapping)\n+\n+\terr = authorizer.Authorize(\"user2\", \"postgres\")\n+\tassert.Error(t, err, \"user2 should NOT access postgres (not explicitly mapped)\")\n+\tassert.ErrorIs(t, err, ErrNoMachineUserMapping)\n+\n+\t// Unauthorized user should still be denied\n+\terr = authorizer.Authorize(\"user3\", \"root\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrUserNotAuthorized, \"unauthorized user should be denied\")\n+}\ndiff --git a/client/ssh/proxy/proxy_test.go b/client/ssh/proxy/proxy_test.go\nindex 582f9c07bda..81d58880145 100644\n--- a/client/ssh/proxy/proxy_test.go\n+++ b/client/ssh/proxy/proxy_test.go\n@@ -27,9 +27,11 @@ import (\n \n \t\"github.com/netbirdio/netbird/client/proto\"\n \tnbssh \"github.com/netbirdio/netbird/client/ssh\"\n+\tsshauth \"github.com/netbirdio/netbird/client/ssh/auth\"\n \t\"github.com/netbirdio/netbird/client/ssh/server\"\n \t\"github.com/netbirdio/netbird/client/ssh/testutil\"\n \tnbjwt \"github.com/netbirdio/netbird/shared/auth/jwt\"\n+\tsshuserhash \"github.com/netbirdio/netbird/shared/sshauth\"\n )\n \n func TestMain(m *testing.M) {\n@@ -137,6 +139,21 @@ func TestSSHProxy_Connect(t *testing.T) {\n \tsshServer := server.New(serverConfig)\n \tsshServer.SetAllowRootLogin(true)\n \n+\t// Configure SSH authorization for the test user\n+\ttestUsername := testutil.GetTestUsername(t)\n+\ttestJWTUser := \"test-username\"\n+\ttestUserHash, err := sshuserhash.HashUserID(testJWTUser)\n+\trequire.NoError(t, err)\n+\n+\tauthConfig := &sshauth.Config{\n+\t\tUserIDClaim:     sshauth.DefaultUserIDClaim,\n+\t\tAuthorizedUsers: []sshuserhash.UserIDHash{testUserHash},\n+\t\tMachineUsers: map[string][]uint32{\n+\t\t\ttestUsername: {0}, // Index 0 in AuthorizedUsers\n+\t\t},\n+\t}\n+\tsshServer.UpdateSSHAuth(authConfig)\n+\n \tsshServerAddr := server.StartTestServer(t, sshServer)\n \tdefer func() { _ = sshServer.Stop() }()\n \n@@ -150,10 +167,10 @@ func TestSSHProxy_Connect(t *testing.T) {\n \n \tmockDaemon.setHostKey(host, hostPubKey)\n \n-\tvalidToken := generateValidJWT(t, privateKey, issuer, audience)\n+\tvalidToken := generateValidJWT(t, privateKey, issuer, audience, testJWTUser)\n \tmockDaemon.setJWTToken(validToken)\n \n-\tproxyInstance, err := New(mockDaemon.addr, host, port, nil, nil)\n+\tproxyInstance, err := New(mockDaemon.addr, host, port, io.Discard, nil)\n \trequire.NoError(t, err)\n \n \tclientConn, proxyConn := net.Pipe()\n@@ -347,12 +364,12 @@ func generateTestJWKS(t *testing.T) (*rsa.PrivateKey, []byte) {\n \treturn privateKey, jwksJSON\n }\n \n-func generateValidJWT(t *testing.T, privateKey *rsa.PrivateKey, issuer, audience string) string {\n+func generateValidJWT(t *testing.T, privateKey *rsa.PrivateKey, issuer, audience string, user string) string {\n \tt.Helper()\n \tclaims := jwt.MapClaims{\n \t\t\"iss\": issuer,\n \t\t\"aud\": audience,\n-\t\t\"sub\": \"test-user\",\n+\t\t\"sub\": user,\n \t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n \t\t\"iat\": time.Now().Unix(),\n \t}\ndiff --git a/client/ssh/server/jwt_test.go b/client/ssh/server/jwt_test.go\nindex 1f3bac76d54..d36d7cbbfb8 100644\n--- a/client/ssh/server/jwt_test.go\n+++ b/client/ssh/server/jwt_test.go\n@@ -23,10 +23,12 @@ import (\n \t\"github.com/stretchr/testify/require\"\n \n \tnbssh \"github.com/netbirdio/netbird/client/ssh\"\n+\tsshauth \"github.com/netbirdio/netbird/client/ssh/auth\"\n \t\"github.com/netbirdio/netbird/client/ssh/client\"\n \t\"github.com/netbirdio/netbird/client/ssh/detection\"\n \t\"github.com/netbirdio/netbird/client/ssh/testutil\"\n \tnbjwt \"github.com/netbirdio/netbird/shared/auth/jwt\"\n+\tsshuserhash \"github.com/netbirdio/netbird/shared/sshauth\"\n )\n \n func TestJWTEnforcement(t *testing.T) {\n@@ -577,6 +579,22 @@ func TestJWTAuthentication(t *testing.T) {\n \t\t\t\ttc.setupServer(server)\n \t\t\t}\n \n+\t\t\t// Always set up authorization for test-user to ensure tests fail at JWT validation stage\n+\t\t\ttestUserHash, err := sshuserhash.HashUserID(\"test-user\")\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\t// Get current OS username for machine user mapping\n+\t\t\tcurrentUser := testutil.GetTestUsername(t)\n+\n+\t\t\tauthConfig := &sshauth.Config{\n+\t\t\t\tUserIDClaim:     sshauth.DefaultUserIDClaim,\n+\t\t\t\tAuthorizedUsers: []sshuserhash.UserIDHash{testUserHash},\n+\t\t\t\tMachineUsers: map[string][]uint32{\n+\t\t\t\t\tcurrentUser: {0}, // Allow test-user (index 0) to access current OS user\n+\t\t\t\t},\n+\t\t\t}\n+\t\t\tserver.UpdateSSHAuth(authConfig)\n+\n \t\t\tserverAddr := StartTestServer(t, server)\n \t\t\tdefer require.NoError(t, server.Stop())\n \ndiff --git a/management/server/account_test.go b/management/server/account_test.go\nindex 7f125e3a0c8..25818ada29d 100644\n--- a/management/server/account_test.go\n+++ b/management/server/account_test.go\n@@ -397,7 +397,7 @@ func TestAccount_GetPeerNetworkMap(t *testing.T) {\n \t\t}\n \n \t\tcustomZone := account.GetPeersCustomZone(context.Background(), \"netbird.io\")\n-\t\tnetworkMap := account.GetPeerNetworkMap(context.Background(), testCase.peerID, customZone, validatedPeers, account.GetResourcePoliciesMap(), account.GetResourceRoutersMap(), nil)\n+\t\tnetworkMap := account.GetPeerNetworkMap(context.Background(), testCase.peerID, customZone, validatedPeers, account.GetResourcePoliciesMap(), account.GetResourceRoutersMap(), nil, account.GetActiveGroupUsers())\n \t\tassert.Len(t, networkMap.Peers, len(testCase.expectedPeers))\n \t\tassert.Len(t, networkMap.OfflinePeers, len(testCase.expectedOfflinePeers))\n \t}\ndiff --git a/management/server/policy_test.go b/management/server/policy_test.go\nindex 90fe8f0368c..a3f987732d0 100644\n--- a/management/server/policy_test.go\n+++ b/management/server/policy_test.go\n@@ -246,14 +246,14 @@ func TestAccount_getPeersByPolicy(t *testing.T) {\n \n \tt.Run(\"check that all peers get map\", func(t *testing.T) {\n \t\tfor _, p := range account.Peers {\n-\t\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), p, validatedPeers)\n+\t\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), p, validatedPeers, account.GetActiveGroupUsers())\n \t\t\tassert.GreaterOrEqual(t, len(peers), 1, \"minimum number peers should present\")\n \t\t\tassert.GreaterOrEqual(t, len(firewallRules), 1, \"minimum number of firewall rules should present\")\n \t\t}\n \t})\n \n \tt.Run(\"check first peer map details\", func(t *testing.T) {\n-\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], validatedPeers)\n+\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], validatedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 8)\n \t\tassert.Contains(t, peers, account.Peers[\"peerA\"])\n \t\tassert.Contains(t, peers, account.Peers[\"peerC\"])\n@@ -509,7 +509,7 @@ func TestAccount_getPeersByPolicy(t *testing.T) {\n \t})\n \n \tt.Run(\"check port ranges support for older peers\", func(t *testing.T) {\n-\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerK\"], validatedPeers)\n+\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerK\"], validatedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 1)\n \t\tassert.Contains(t, peers, account.Peers[\"peerI\"])\n \n@@ -635,7 +635,7 @@ func TestAccount_getPeersByPolicyDirect(t *testing.T) {\n \t}\n \n \tt.Run(\"check first peer map\", func(t *testing.T) {\n-\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Contains(t, peers, account.Peers[\"peerC\"])\n \n \t\texpectedFirewallRules := []*types.FirewallRule{\n@@ -665,7 +665,7 @@ func TestAccount_getPeersByPolicyDirect(t *testing.T) {\n \t})\n \n \tt.Run(\"check second peer map\", func(t *testing.T) {\n-\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerC\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerC\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Contains(t, peers, account.Peers[\"peerB\"])\n \n \t\texpectedFirewallRules := []*types.FirewallRule{\n@@ -697,7 +697,7 @@ func TestAccount_getPeersByPolicyDirect(t *testing.T) {\n \taccount.Policies[1].Rules[0].Bidirectional = false\n \n \tt.Run(\"check first peer map directional only\", func(t *testing.T) {\n-\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Contains(t, peers, account.Peers[\"peerC\"])\n \n \t\texpectedFirewallRules := []*types.FirewallRule{\n@@ -719,7 +719,7 @@ func TestAccount_getPeersByPolicyDirect(t *testing.T) {\n \t})\n \n \tt.Run(\"check second peer map directional only\", func(t *testing.T) {\n-\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerC\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerC\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Contains(t, peers, account.Peers[\"peerB\"])\n \n \t\texpectedFirewallRules := []*types.FirewallRule{\n@@ -917,7 +917,7 @@ func TestAccount_getPeersByPolicyPostureChecks(t *testing.T) {\n \tt.Run(\"verify peer's network map with default group peer list\", func(t *testing.T) {\n \t\t// peerB doesn't fulfill the NB posture check but is included in the destination group Swarm,\n \t\t// will establish a connection with all source peers satisfying the NB posture check.\n-\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 4)\n \t\tassert.Len(t, firewallRules, 4)\n \t\tassert.Contains(t, peers, account.Peers[\"peerA\"])\n@@ -927,7 +927,7 @@ func TestAccount_getPeersByPolicyPostureChecks(t *testing.T) {\n \n \t\t// peerC satisfy the NB posture check, should establish connection to all destination group peer's\n \t\t// We expect a single permissive firewall rule which all outgoing connections\n-\t\tpeers, firewallRules = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerC\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerC\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, len(account.Groups[\"GroupSwarm\"].Peers))\n \t\tassert.Len(t, firewallRules, 7)\n \t\texpectedFirewallRules := []*types.FirewallRule{\n@@ -992,7 +992,7 @@ func TestAccount_getPeersByPolicyPostureChecks(t *testing.T) {\n \n \t\t// peerE doesn't fulfill the NB posture check and exists in only destination group Swarm,\n \t\t// all source group peers satisfying the NB posture check should establish connection\n-\t\tpeers, firewallRules = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerE\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerE\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 4)\n \t\tassert.Len(t, firewallRules, 4)\n \t\tassert.Contains(t, peers, account.Peers[\"peerA\"])\n@@ -1002,7 +1002,7 @@ func TestAccount_getPeersByPolicyPostureChecks(t *testing.T) {\n \n \t\t// peerI doesn't fulfill the OS version posture check and exists in only destination group Swarm,\n \t\t// all source group peers satisfying the NB posture check should establish connection\n-\t\tpeers, firewallRules = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerI\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerI\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 4)\n \t\tassert.Len(t, firewallRules, 4)\n \t\tassert.Contains(t, peers, account.Peers[\"peerA\"])\n@@ -1017,19 +1017,19 @@ func TestAccount_getPeersByPolicyPostureChecks(t *testing.T) {\n \n \t\t// peerB doesn't satisfy the NB posture check, and doesn't exist in destination group peer's\n \t\t// no connection should be established to any peer of destination group\n-\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 0)\n \t\tassert.Len(t, firewallRules, 0)\n \n \t\t// peerI doesn't satisfy the OS version posture check, and doesn't exist in destination group peer's\n \t\t// no connection should be established to any peer of destination group\n-\t\tpeers, firewallRules = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerI\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerI\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 0)\n \t\tassert.Len(t, firewallRules, 0)\n \n \t\t// peerC satisfy the NB posture check, should establish connection to all destination group peer's\n \t\t// We expect a single permissive firewall rule which all outgoing connections\n-\t\tpeers, firewallRules = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerC\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerC\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, len(account.Groups[\"GroupSwarm\"].Peers))\n \t\tassert.Len(t, firewallRules, len(account.Groups[\"GroupSwarm\"].Peers))\n \n@@ -1044,14 +1044,14 @@ func TestAccount_getPeersByPolicyPostureChecks(t *testing.T) {\n \n \t\t// peerE doesn't fulfill the NB posture check and exists in only destination group Swarm,\n \t\t// all source group peers satisfying the NB posture check should establish connection\n-\t\tpeers, firewallRules = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerE\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerE\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 3)\n \t\tassert.Len(t, firewallRules, 3)\n \t\tassert.Contains(t, peers, account.Peers[\"peerA\"])\n \t\tassert.Contains(t, peers, account.Peers[\"peerC\"])\n \t\tassert.Contains(t, peers, account.Peers[\"peerD\"])\n \n-\t\tpeers, firewallRules = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerA\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerA\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 5)\n \t\t// assert peers from Group Swarm\n \t\tassert.Contains(t, peers, account.Peers[\"peerD\"])\ndiff --git a/management/server/types/account_test.go b/management/server/types/account_test.go\nindex f9aa6a1c22a..2c9f2428db7 100644\n--- a/management/server/types/account_test.go\n+++ b/management/server/types/account_test.go\n@@ -1105,6 +1105,193 @@ func Test_ExpandPortsAndRanges_SSHRuleExpansion(t *testing.T) {\n \t}\n }\n \n+func Test_GetActiveGroupUsers(t *testing.T) {\n+\ttests := []struct {\n+\t\tname     string\n+\t\taccount  *Account\n+\t\texpected map[string][]string\n+\t}{\n+\t\t{\n+\t\t\tname: \"all users are active\",\n+\t\t\taccount: &Account{\n+\t\t\t\tUsers: map[string]*User{\n+\t\t\t\t\t\"user1\": {\n+\t\t\t\t\t\tId:         \"user1\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\", \"group2\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user2\": {\n+\t\t\t\t\t\tId:         \"user2\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group2\", \"group3\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user3\": {\n+\t\t\t\t\t\tId:         \"user3\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: map[string][]string{\n+\t\t\t\t\"group1\": {\"user1\", \"user3\"},\n+\t\t\t\t\"group2\": {\"user1\", \"user2\"},\n+\t\t\t\t\"group3\": {\"user2\"},\n+\t\t\t\t\"\":       {\"user1\", \"user2\", \"user3\"},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"some users are blocked\",\n+\t\t\taccount: &Account{\n+\t\t\t\tUsers: map[string]*User{\n+\t\t\t\t\t\"user1\": {\n+\t\t\t\t\t\tId:         \"user1\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\", \"group2\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user2\": {\n+\t\t\t\t\t\tId:         \"user2\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group2\", \"group3\"},\n+\t\t\t\t\t\tBlocked:    true,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user3\": {\n+\t\t\t\t\t\tId:         \"user3\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\", \"group3\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: map[string][]string{\n+\t\t\t\t\"group1\": {\"user1\", \"user3\"},\n+\t\t\t\t\"group2\": {\"user1\"},\n+\t\t\t\t\"group3\": {\"user3\"},\n+\t\t\t\t\"\":       {\"user1\", \"user3\"},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"all users are blocked\",\n+\t\t\taccount: &Account{\n+\t\t\t\tUsers: map[string]*User{\n+\t\t\t\t\t\"user1\": {\n+\t\t\t\t\t\tId:         \"user1\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\"},\n+\t\t\t\t\t\tBlocked:    true,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user2\": {\n+\t\t\t\t\t\tId:         \"user2\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group2\"},\n+\t\t\t\t\t\tBlocked:    true,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: map[string][]string{},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"user with no auto groups\",\n+\t\t\taccount: &Account{\n+\t\t\t\tUsers: map[string]*User{\n+\t\t\t\t\t\"user1\": {\n+\t\t\t\t\t\tId:         \"user1\",\n+\t\t\t\t\t\tAutoGroups: []string{},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user2\": {\n+\t\t\t\t\t\tId:         \"user2\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: map[string][]string{\n+\t\t\t\t\"group1\": {\"user2\"},\n+\t\t\t\t\"\":       {\"user1\", \"user2\"},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"empty account\",\n+\t\t\taccount: &Account{\n+\t\t\t\tUsers: map[string]*User{},\n+\t\t\t},\n+\t\t\texpected: map[string][]string{},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"multiple users in same group\",\n+\t\t\taccount: &Account{\n+\t\t\t\tUsers: map[string]*User{\n+\t\t\t\t\t\"user1\": {\n+\t\t\t\t\t\tId:         \"user1\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user2\": {\n+\t\t\t\t\t\tId:         \"user2\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user3\": {\n+\t\t\t\t\t\tId:         \"user3\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: map[string][]string{\n+\t\t\t\t\"group1\": {\"user1\", \"user2\", \"user3\"},\n+\t\t\t\t\"\":       {\"user1\", \"user2\", \"user3\"},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"user in multiple groups with blocked users\",\n+\t\t\taccount: &Account{\n+\t\t\t\tUsers: map[string]*User{\n+\t\t\t\t\t\"user1\": {\n+\t\t\t\t\t\tId:         \"user1\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\", \"group2\", \"group3\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user2\": {\n+\t\t\t\t\t\tId:         \"user2\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\", \"group2\"},\n+\t\t\t\t\t\tBlocked:    true,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user3\": {\n+\t\t\t\t\t\tId:         \"user3\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group3\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: map[string][]string{\n+\t\t\t\t\"group1\": {\"user1\"},\n+\t\t\t\t\"group2\": {\"user1\"},\n+\t\t\t\t\"group3\": {\"user1\", \"user3\"},\n+\t\t\t\t\"\":       {\"user1\", \"user3\"},\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tresult := tt.account.GetActiveGroupUsers()\n+\n+\t\t\t// Check that the number of groups matches\n+\t\t\tassert.Equal(t, len(tt.expected), len(result), \"number of groups should match\")\n+\n+\t\t\t// Check each group's users\n+\t\t\tfor groupID, expectedUsers := range tt.expected {\n+\t\t\t\tactualUsers, exists := result[groupID]\n+\t\t\t\tassert.True(t, exists, \"group %s should exist in result\", groupID)\n+\t\t\t\tassert.ElementsMatch(t, expectedUsers, actualUsers, \"users in group %s should match\", groupID)\n+\t\t\t}\n+\n+\t\t\t// Ensure no extra groups in result\n+\t\t\tfor groupID := range result {\n+\t\t\t\t_, exists := tt.expected[groupID]\n+\t\t\t\tassert.True(t, exists, \"unexpected group %s in result\", groupID)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n func Test_FilterZoneRecordsForPeers(t *testing.T) {\n \ttests := []struct {\n \t\tname            string\ndiff --git a/management/server/types/networkmap_golden_test.go b/management/server/types/networkmap_golden_test.go\nindex d85aaabb212..913094e4c90 100644\n--- a/management/server/types/networkmap_golden_test.go\n+++ b/management/server/types/networkmap_golden_test.go\n@@ -69,7 +69,7 @@ func TestGetPeerNetworkMap_Golden(t *testing.T) {\n \tresourcePolicies := account.GetResourcePoliciesMap()\n \trouters := account.GetResourceRoutersMap()\n \n-\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil)\n+\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil, account.GetActiveGroupUsers())\n \n \tnormalizeAndSortNetworkMap(networkMap)\n \n@@ -141,7 +141,7 @@ func BenchmarkGetPeerNetworkMap(b *testing.B) {\n \tb.Run(\"old builder\", func(b *testing.B) {\n \t\tfor range b.N {\n \t\t\tfor _, peerID := range peerIDs {\n-\t\t\t\t_ = account.GetPeerNetworkMap(ctx, peerID, dns.CustomZone{}, validatedPeersMap, nil, nil, nil)\n+\t\t\t\t_ = account.GetPeerNetworkMap(ctx, peerID, dns.CustomZone{}, validatedPeersMap, nil, nil, nil, account.GetActiveGroupUsers())\n \t\t\t}\n \t\t}\n \t})\n@@ -201,7 +201,7 @@ func TestGetPeerNetworkMap_Golden_WithNewPeer(t *testing.T) {\n \tresourcePolicies := account.GetResourcePoliciesMap()\n \trouters := account.GetResourceRoutersMap()\n \n-\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil)\n+\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil, account.GetActiveGroupUsers())\n \n \tnormalizeAndSortNetworkMap(networkMap)\n \n@@ -320,7 +320,7 @@ func BenchmarkGetPeerNetworkMap_AfterPeerAdded(b *testing.B) {\n \tb.Run(\"old builder after add\", func(b *testing.B) {\n \t\tfor i := 0; i < b.N; i++ {\n \t\t\tfor _, testingPeerID := range peerIDs {\n-\t\t\t\t_ = account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, nil, nil, nil)\n+\t\t\t\t_ = account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, nil, nil, nil, account.GetActiveGroupUsers())\n \t\t\t}\n \t\t}\n \t})\n@@ -395,7 +395,7 @@ func TestGetPeerNetworkMap_Golden_WithNewRoutingPeer(t *testing.T) {\n \tresourcePolicies := account.GetResourcePoliciesMap()\n \trouters := account.GetResourceRoutersMap()\n \n-\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil)\n+\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil, account.GetActiveGroupUsers())\n \n \tnormalizeAndSortNetworkMap(networkMap)\n \n@@ -550,7 +550,7 @@ func BenchmarkGetPeerNetworkMap_AfterRouterPeerAdded(b *testing.B) {\n \tb.Run(\"old builder after add\", func(b *testing.B) {\n \t\tfor i := 0; i < b.N; i++ {\n \t\t\tfor _, testingPeerID := range peerIDs {\n-\t\t\t\t_ = account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, nil, nil, nil)\n+\t\t\t\t_ = account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, nil, nil, nil, account.GetActiveGroupUsers())\n \t\t\t}\n \t\t}\n \t})\n@@ -604,7 +604,7 @@ func TestGetPeerNetworkMap_Golden_WithDeletedPeer(t *testing.T) {\n \tresourcePolicies := account.GetResourcePoliciesMap()\n \trouters := account.GetResourceRoutersMap()\n \n-\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil)\n+\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil, account.GetActiveGroupUsers())\n \n \tnormalizeAndSortNetworkMap(networkMap)\n \n@@ -730,7 +730,7 @@ func TestGetPeerNetworkMap_Golden_WithDeletedRouterPeer(t *testing.T) {\n \tresourcePolicies := account.GetResourcePoliciesMap()\n \trouters := account.GetResourceRoutersMap()\n \n-\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil)\n+\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil, account.GetActiveGroupUsers())\n \n \tnormalizeAndSortNetworkMap(networkMap)\n \n@@ -847,7 +847,7 @@ func BenchmarkGetPeerNetworkMap_AfterPeerDeleted(b *testing.B) {\n \tb.Run(\"old builder after delete\", func(b *testing.B) {\n \t\tfor i := 0; i < b.N; i++ {\n \t\t\tfor _, testingPeerID := range peerIDs {\n-\t\t\t\t_ = account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, nil, nil, nil)\n+\t\t\t\t_ = account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, nil, nil, nil, account.GetActiveGroupUsers())\n \t\t\t}\n \t\t}\n \t})\ndiff --git a/management/server/user_test.go b/management/server/user_test.go\nindex 0d778cfa2b7..3032ee3e8ab 100644\n--- a/management/server/user_test.go\n+++ b/management/server/user_test.go\n@@ -1379,11 +1379,11 @@ func TestUserAccountPeersUpdate(t *testing.T) {\n \t\tupdateManager.CloseChannel(context.Background(), peer1.ID)\n \t})\n \n-\t// Creating a new regular user should not update account peers and not send peer update\n+\t// Creating a new regular user should send peer update (as users are not filtered yet)\n \tt.Run(\"creating new regular user with no groups\", func(t *testing.T) {\n \t\tdone := make(chan struct{})\n \t\tgo func() {\n-\t\t\tpeerShouldNotReceiveUpdate(t, updMsg)\n+\t\t\tpeerShouldReceiveUpdate(t, updMsg)\n \t\t\tclose(done)\n \t\t}()\n \n@@ -1402,11 +1402,11 @@ func TestUserAccountPeersUpdate(t *testing.T) {\n \t\t}\n \t})\n \n-\t// updating user with no linked peers should not update account peers and not send peer update\n+\t// updating user with no linked peers should update account peers and send peer update (as users are not filtered yet)\n \tt.Run(\"updating user with no linked peers\", func(t *testing.T) {\n \t\tdone := make(chan struct{})\n \t\tgo func() {\n-\t\t\tpeerShouldNotReceiveUpdate(t, updMsg)\n+\t\t\tpeerShouldReceiveUpdate(t, updMsg)\n \t\t\tclose(done)\n \t\t}()\n \ndiff --git a/shared/sshauth/userhash_test.go b/shared/sshauth/userhash_test.go\nnew file mode 100644\nindex 00000000000..5a3cb6986d3\n--- /dev/null\n+++ b/shared/sshauth/userhash_test.go\n@@ -0,0 +1,210 @@\n+package sshauth\n+\n+import (\n+\t\"testing\"\n+)\n+\n+func TestHashUserID(t *testing.T) {\n+\ttests := []struct {\n+\t\tname   string\n+\t\tuserID string\n+\t}{\n+\t\t{\n+\t\t\tname:   \"simple user ID\",\n+\t\t\tuserID: \"user@example.com\",\n+\t\t},\n+\t\t{\n+\t\t\tname:   \"UUID format\",\n+\t\t\tuserID: \"550e8400-e29b-41d4-a716-446655440000\",\n+\t\t},\n+\t\t{\n+\t\t\tname:   \"numeric ID\",\n+\t\t\tuserID: \"12345\",\n+\t\t},\n+\t\t{\n+\t\t\tname:   \"empty string\",\n+\t\t\tuserID: \"\",\n+\t\t},\n+\t\t{\n+\t\t\tname:   \"special characters\",\n+\t\t\tuserID: \"user+test@domain.com\",\n+\t\t},\n+\t\t{\n+\t\t\tname:   \"unicode characters\",\n+\t\t\tuserID: \"ç”¨æˆ·@example.com\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\thash, err := HashUserID(tt.userID)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"HashUserID() error = %v, want nil\", err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\t// Verify hash is non-zero for non-empty inputs\n+\t\t\tif tt.userID != \"\" && hash == [16]byte{} {\n+\t\t\t\tt.Errorf(\"HashUserID() returned zero hash for non-empty input\")\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestHashUserID_Consistency(t *testing.T) {\n+\tuserID := \"test@example.com\"\n+\n+\thash1, err1 := HashUserID(userID)\n+\tif err1 != nil {\n+\t\tt.Fatalf(\"First HashUserID() error = %v\", err1)\n+\t}\n+\n+\thash2, err2 := HashUserID(userID)\n+\tif err2 != nil {\n+\t\tt.Fatalf(\"Second HashUserID() error = %v\", err2)\n+\t}\n+\n+\tif hash1 != hash2 {\n+\t\tt.Errorf(\"HashUserID() is not consistent: got %v and %v for same input\", hash1, hash2)\n+\t}\n+}\n+\n+func TestHashUserID_Uniqueness(t *testing.T) {\n+\ttests := []struct {\n+\t\tuserID1 string\n+\t\tuserID2 string\n+\t}{\n+\t\t{\"user1@example.com\", \"user2@example.com\"},\n+\t\t{\"alice@domain.com\", \"bob@domain.com\"},\n+\t\t{\"test\", \"test1\"},\n+\t\t{\"\", \"a\"},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\thash1, err1 := HashUserID(tt.userID1)\n+\t\tif err1 != nil {\n+\t\t\tt.Fatalf(\"HashUserID(%s) error = %v\", tt.userID1, err1)\n+\t\t}\n+\n+\t\thash2, err2 := HashUserID(tt.userID2)\n+\t\tif err2 != nil {\n+\t\t\tt.Fatalf(\"HashUserID(%s) error = %v\", tt.userID2, err2)\n+\t\t}\n+\n+\t\tif hash1 == hash2 {\n+\t\t\tt.Errorf(\"HashUserID() collision: %s and %s produced same hash %v\", tt.userID1, tt.userID2, hash1)\n+\t\t}\n+\t}\n+}\n+\n+func TestUserIDHash_String(t *testing.T) {\n+\ttests := []struct {\n+\t\tname     string\n+\t\thash     UserIDHash\n+\t\texpected string\n+\t}{\n+\t\t{\n+\t\t\tname:     \"zero hash\",\n+\t\t\thash:     [16]byte{},\n+\t\t\texpected: \"00000000000000000000000000000000\",\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"small value\",\n+\t\t\thash:     [16]byte{15: 0xff},\n+\t\t\texpected: \"000000000000000000000000000000ff\",\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"large value\",\n+\t\t\thash:     [16]byte{8: 0xde, 9: 0xad, 10: 0xbe, 11: 0xef, 12: 0xca, 13: 0xfe, 14: 0xba, 15: 0xbe},\n+\t\t\texpected: \"0000000000000000deadbeefcafebabe\",\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"max value\",\n+\t\t\thash:     [16]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n+\t\t\texpected: \"ffffffffffffffffffffffffffffffff\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tresult := tt.hash.String()\n+\t\t\tif result != tt.expected {\n+\t\t\t\tt.Errorf(\"UserIDHash.String() = %v, want %v\", result, tt.expected)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestUserIDHash_String_Length(t *testing.T) {\n+\t// Test that String() always returns 32 hex characters (16 bytes * 2)\n+\tuserID := \"test@example.com\"\n+\thash, err := HashUserID(userID)\n+\tif err != nil {\n+\t\tt.Fatalf(\"HashUserID() error = %v\", err)\n+\t}\n+\n+\tresult := hash.String()\n+\tif len(result) != 32 {\n+\t\tt.Errorf(\"UserIDHash.String() length = %d, want 32\", len(result))\n+\t}\n+\n+\t// Verify it's valid hex\n+\tfor i, c := range result {\n+\t\tif !((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')) {\n+\t\t\tt.Errorf(\"UserIDHash.String() contains non-hex character at position %d: %c\", i, c)\n+\t\t}\n+\t}\n+}\n+\n+func TestHashUserID_KnownValues(t *testing.T) {\n+\t// Test with known BLAKE2b-128 values to ensure correct implementation\n+\ttests := []struct {\n+\t\tname     string\n+\t\tuserID   string\n+\t\texpected UserIDHash\n+\t}{\n+\t\t{\n+\t\t\tname:   \"empty string\",\n+\t\t\tuserID: \"\",\n+\t\t\t// BLAKE2b-128 of empty string\n+\t\t\texpected: [16]byte{0xca, 0xe6, 0x69, 0x41, 0xd9, 0xef, 0xbd, 0x40, 0x4e, 0x4d, 0x88, 0x75, 0x8e, 0xa6, 0x76, 0x70},\n+\t\t},\n+\t\t{\n+\t\t\tname:   \"single character 'a'\",\n+\t\t\tuserID: \"a\",\n+\t\t\t// BLAKE2b-128 of \"a\"\n+\t\t\texpected: [16]byte{0x27, 0xc3, 0x5e, 0x6e, 0x93, 0x73, 0x87, 0x7f, 0x29, 0xe5, 0x62, 0x46, 0x4e, 0x46, 0x49, 0x7e},\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\thash, err := HashUserID(tt.userID)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"HashUserID() error = %v\", err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif hash != tt.expected {\n+\t\t\t\tt.Errorf(\"HashUserID(%q) = %x, want %x\",\n+\t\t\t\t\ttt.userID, hash, tt.expected)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func BenchmarkHashUserID(b *testing.B) {\n+\tuserID := \"user@example.com\"\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\t_, _ = HashUserID(userID)\n+\t}\n+}\n+\n+func BenchmarkUserIDHash_String(b *testing.B) {\n+\thash := UserIDHash([16]byte{8: 0xde, 9: 0xad, 10: 0xbe, 11: 0xef, 12: 0xca, 13: 0xfe, 14: 0xba, 15: 0xbe})\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\t_ = hash.String()\n+\t}\n+}\n"}
{"org": "netbirdio", "repo": "netbird", "number": 4987, "state": "closed", "title": "Feature/ssh fine grained access nmap", "body": "## Describe your changes\r\n\r\n## Issue ticket number and link\r\n\r\n## Stack\r\n\r\n<!-- branch-stack -->\r\n\r\n### Checklist\r\n- [ ] Is it a bug fix\r\n- [ ] Is a typo/documentation fix\r\n- [ ] Is a feature enhancement\r\n- [ ] It is a refactor\r\n- [ ] Created tests that fail without the change (if possible)\r\n\r\n> By submitting this pull request, you confirm that you have read and agree to the terms of the [Contributor License Agreement](https://github.com/netbirdio/netbird/blob/main/CONTRIBUTOR_LICENSE_AGREEMENT.md).\r\n\r\n## Documentation\r\nSelect exactly one:\r\n\r\n- [ ] I added/updated documentation for this change\r\n- [x] Documentation is **not needed** for this change (explain why)\r\n\r\n### Docs PR URL (required if \"docs added\" is checked)\r\nPaste the PR link from https://github.com/netbirdio/docs here:\r\n\r\nhttps://github.com/netbirdio/docs/pull/__\r\n\n\n<!-- This is an auto-generated comment: release notes by coderabbit.ai -->\n\n## Summary by CodeRabbit\n\n* **New Features**\n  * Added SSH authorization system with wildcard support for flexible access management\n  * Introduced group-based SSH authentication capabilities enabling group-level access control\n\n* **Improvements**\n  * Enhanced peer network mapping to include SSH configuration and authorization data\n  * Improved consistency in peer network updates when user group memberships and policies change\n\n<sub>âœï¸ Tip: You can customize this high-level summary in your review settings.</sub>\n\n<!-- end of auto-generated comment: release notes by coderabbit.ai -->", "url": "https://api.github.com/repos/netbirdio/netbird/pulls/4987", "id": 3123901560, "node_id": "PR_kwDOFVUT7866MvR4", "html_url": "https://github.com/netbirdio/netbird/pull/4987", "diff_url": "https://github.com/netbirdio/netbird/pull/4987.diff", "patch_url": "https://github.com/netbirdio/netbird/pull/4987.patch", "issue_url": "https://api.github.com/repos/netbirdio/netbird/issues/4987", "created_at": "2025-12-22T18:58:01+00:00", "updated_at": "2025-12-23T11:34:44+00:00", "closed_at": "2025-12-23T11:34:42+00:00", "merged_at": "2025-12-23T11:34:42+00:00", "merge_commit_sha": "1bdaa4002cd8207e8f920dfcaea618dac4fff584", "labels": [], "draft": false, "commits_url": "https://api.github.com/repos/netbirdio/netbird/pulls/4987/commits", "review_comments_url": "https://api.github.com/repos/netbirdio/netbird/pulls/4987/comments", "review_comment_url": "https://api.github.com/repos/netbirdio/netbird/pulls/comments{/number}", "comments_url": "https://api.github.com/repos/netbirdio/netbird/issues/4987/comments", "base": {"label": "netbirdio:feature/ssh-fine-grained-access", "ref": "feature/ssh-fine-grained-access", "sha": "3b28834454fab6d26975d3dd828151c667e8505b", "user": {"login": "netbirdio", "id": 100464677, "node_id": "O_kgDOBfz4JQ", "avatar_url": "https://avatars.githubusercontent.com/u/100464677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/netbirdio", "html_url": "https://github.com/netbirdio", "followers_url": "https://api.github.com/users/netbirdio/followers", "following_url": "https://api.github.com/users/netbirdio/following{/other_user}", "gists_url": "https://api.github.com/users/netbirdio/gists{/gist_id}", "starred_url": "https://api.github.com/users/netbirdio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/netbirdio/subscriptions", "organizations_url": "https://api.github.com/users/netbirdio/orgs", "repos_url": "https://api.github.com/users/netbirdio/repos", "events_url": "https://api.github.com/users/netbirdio/events{/privacy}", "received_events_url": "https://api.github.com/users/netbirdio/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "repo": {"id": 357897199, "node_id": "MDEwOlJlcG9zaXRvcnkzNTc4OTcxOTk=", "name": "netbird", "full_name": "netbirdio/netbird", "private": false, "owner": {"login": "netbirdio", "id": 100464677, "node_id": "O_kgDOBfz4JQ", "avatar_url": "https://avatars.githubusercontent.com/u/100464677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/netbirdio", "html_url": "https://github.com/netbirdio", "followers_url": "https://api.github.com/users/netbirdio/followers", "following_url": "https://api.github.com/users/netbirdio/following{/other_user}", "gists_url": "https://api.github.com/users/netbirdio/gists{/gist_id}", "starred_url": "https://api.github.com/users/netbirdio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/netbirdio/subscriptions", "organizations_url": "https://api.github.com/users/netbirdio/orgs", "repos_url": "https://api.github.com/users/netbirdio/repos", "events_url": "https://api.github.com/users/netbirdio/events{/privacy}", "received_events_url": "https://api.github.com/users/netbirdio/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "html_url": "https://github.com/netbirdio/netbird", "description": "Connect your devices into a secure WireGuardÂ®-based overlay network with SSO, MFA and granular access controls.", "fork": false, "url": "https://api.github.com/repos/netbirdio/netbird", "forks_url": "https://api.github.com/repos/netbirdio/netbird/forks", "keys_url": "https://api.github.com/repos/netbirdio/netbird/keys{/key_id}", "collaborators_url": "https://api.github.com/repos/netbirdio/netbird/collaborators{/collaborator}", "teams_url": "https://api.github.com/repos/netbirdio/netbird/teams", "hooks_url": "https://api.github.com/repos/netbirdio/netbird/hooks", "issue_events_url": "https://api.github.com/repos/netbirdio/netbird/issues/events{/number}", "events_url": "https://api.github.com/repos/netbirdio/netbird/events", "assignees_url": "https://api.github.com/repos/netbirdio/netbird/assignees{/user}", "branches_url": "https://api.github.com/repos/netbirdio/netbird/branches{/branch}", "tags_url": "https://api.github.com/repos/netbirdio/netbird/tags", "blobs_url": "https://api.github.com/repos/netbirdio/netbird/git/blobs{/sha}", "git_tags_url": "https://api.github.com/repos/netbirdio/netbird/git/tags{/sha}", "git_refs_url": "https://api.github.com/repos/netbirdio/netbird/git/refs{/sha}", "trees_url": "https://api.github.com/repos/netbirdio/netbird/git/trees{/sha}", "statuses_url": "https://api.github.com/repos/netbirdio/netbird/statuses/{sha}", "languages_url": "https://api.github.com/repos/netbirdio/netbird/languages", "stargazers_url": "https://api.github.com/repos/netbirdio/netbird/stargazers", "contributors_url": "https://api.github.com/repos/netbirdio/netbird/contributors", "subscribers_url": "https://api.github.com/repos/netbirdio/netbird/subscribers", "subscription_url": "https://api.github.com/repos/netbirdio/netbird/subscription", "commits_url": "https://api.github.com/repos/netbirdio/netbird/commits{/sha}", "git_commits_url": "https://api.github.com/repos/netbirdio/netbird/git/commits{/sha}", "comments_url": "https://api.github.com/repos/netbirdio/netbird/comments{/number}", "issue_comment_url": "https://api.github.com/repos/netbirdio/netbird/issues/comments{/number}", "contents_url": "https://api.github.com/repos/netbirdio/netbird/contents/{+path}", "compare_url": "https://api.github.com/repos/netbirdio/netbird/compare/{base}...{head}", "merges_url": "https://api.github.com/repos/netbirdio/netbird/merges", "archive_url": "https://api.github.com/repos/netbirdio/netbird/{archive_format}{/ref}", "downloads_url": "https://api.github.com/repos/netbirdio/netbird/downloads", "issues_url": "https://api.github.com/repos/netbirdio/netbird/issues{/number}", "pulls_url": "https://api.github.com/repos/netbirdio/netbird/pulls{/number}", "milestones_url": "https://api.github.com/repos/netbirdio/netbird/milestones{/number}", "notifications_url": "https://api.github.com/repos/netbirdio/netbird/notifications{?since,all,participating}", "labels_url": "https://api.github.com/repos/netbirdio/netbird/labels{/name}", "releases_url": "https://api.github.com/repos/netbirdio/netbird/releases{/id}", "deployments_url": "https://api.github.com/repos/netbirdio/netbird/deployments", "created_at": "2021-04-14T12:27:20Z", "updated_at": "2026-01-07T04:18:10Z", "pushed_at": "2026-01-07T05:22:46Z", "git_url": "git://github.com/netbirdio/netbird.git", "ssh_url": "git@github.com:netbirdio/netbird.git", "clone_url": "https://github.com/netbirdio/netbird.git", "svn_url": "https://github.com/netbirdio/netbird", "homepage": "https://netbird.io", "size": 47404, "stargazers_count": 20703, "watchers_count": 20703, "language": "Go", "has_issues": true, "has_projects": true, "has_downloads": true, "has_wiki": true, "has_pages": false, "has_discussions": false, "forks_count": 1009, "mirror_url": null, "archived": false, "disabled": false, "open_issues_count": 1188, "license": {"key": "other", "name": "Other", "spdx_id": "NOASSERTION", "url": null, "node_id": "MDc6TGljZW5zZTA="}, "allow_forking": true, "is_template": false, "web_commit_signoff_required": false, "topics": ["golang", "mesh", "mesh-networks", "nat-traversal", "netbird", "vpn", "wireguard", "wireguard-vpn", "wiretrustee", "zero-trust-network-access"], "visibility": "public", "forks": 1009, "open_issues": 1188, "watchers": 20703, "default_branch": "main"}}, "commits": [{"sha": "3b19e177898bab3fac850438d35b129465ac9e1f", "parents": ["ee6d96eac5dbdaf84b21fe868cd457cf946062ba"], "message": "add api to store layer"}, {"sha": "bb7069d1f415faf49c1f8ad69e194d3c8f198452", "parents": ["3b19e177898bab3fac850438d35b129465ac9e1f"], "message": "fix api response on empty groups"}, {"sha": "5752bc6477c21f3d56776e1f64ce4cf33e2dd667", "parents": ["bb7069d1f415faf49c1f8ad69e194d3c8f198452"], "message": "add happy path for network map calc"}, {"sha": "cfcdae523bed3f370135f480542ae1f959abec9a", "parents": ["5752bc6477c21f3d56776e1f64ce4cf33e2dd667", "437a3a7941adc199727275778f1cb452f341ade7"], "message": "Merge branch 'feature/ssh-fine-grained-access' into feature/ssh-fine-grained-access-nmap\n\n# Conflicts:\n#\tmanagement/server/http/handlers/policies/policies_handler.go"}, {"sha": "f6c0e7777b26e00cf20e8b95ecd994457ea1e5b6", "parents": ["cfcdae523bed3f370135f480542ae1f959abec9a"], "message": "simplify"}, {"sha": "6b919d7cf7f46ce8fa1471522662a086a426e19c", "parents": ["f6c0e7777b26e00cf20e8b95ecd994457ea1e5b6"], "message": "filter for wildcard"}, {"sha": "9daabc0d882a03aa8a6fcf7ccf0d84741d14318d", "parents": ["6b919d7cf7f46ce8fa1471522662a086a426e19c"], "message": "handle legacy policies"}, {"sha": "3f01f90a0d391267dc7637086c8dcac8c19d2d4f", "parents": ["9daabc0d882a03aa8a6fcf7ccf0d84741d14318d"], "message": "extract wildcard and all user generation"}, {"sha": "a1870ee58acf2cd23263e3759ef08178afbc0161", "parents": ["3f01f90a0d391267dc7637086c8dcac8c19d2d4f"], "message": "handle legacy ssh configs"}, {"sha": "96ae60b1b34df4f0e2afc44608db965a77512c4f", "parents": ["a1870ee58acf2cd23263e3759ef08178afbc0161"], "message": "update account peers on user update"}, {"sha": "78b85e1ffdcf39574456caa591ea2683cfdfa872", "parents": ["96ae60b1b34df4f0e2afc44608db965a77512c4f", "9019747e2face4fd4260949ebb84cc3a5a239def"], "message": "Merge branch 'feature/ssh-fine-grained-access' into feature/ssh-fine-grained-access-nmap\n\n# Conflicts:\n#\tmanagement/internals/shared/grpc/conversion.go"}, {"sha": "fc46a5166520e5c54c64745d61525baacea3139c", "parents": ["78b85e1ffdcf39574456caa591ea2683cfdfa872"], "message": "fix hash conversion"}, {"sha": "87a39069e1570ffb7fcef4dca6f737cc05b3e026", "parents": ["fc46a5166520e5c54c64745d61525baacea3139c"], "message": "[client] Add wildcard support (#4985)\n\nAdd wildcard support"}, {"sha": "776b14cf963872137ce271e1037ce310c8b7d4fd", "parents": ["87a39069e1570ffb7fcef4dca6f737cc05b3e026"], "message": "add firewall rule proto to TCP for new netbird-ssh"}, {"sha": "e3f93fd42a8ccf0132f95f1b94f98aa9acd33245", "parents": ["776b14cf963872137ce271e1037ce310c8b7d4fd"], "message": "add firewall rule proto to TCP for new netbird-ssh"}, {"sha": "c358d8725d822d843d770c59f9d6563aefc9b351", "parents": ["e3f93fd42a8ccf0132f95f1b94f98aa9acd33245"], "message": "fix tests"}, {"sha": "690155c2e0d271ed34779f1693a8c4ad5071e670", "parents": ["c358d8725d822d843d770c59f9d6563aefc9b351"], "message": "fix test expectations"}, {"sha": "e2dfcdc37f56b63a1c2f0078b3db7c3d138858c1", "parents": ["690155c2e0d271ed34779f1693a8c4ad5071e670"], "message": "handle ALL group"}, {"sha": "27bfe6785cb5a17dece3c0c15ea2e22780f5407c", "parents": ["e2dfcdc37f56b63a1c2f0078b3db7c3d138858c1"], "message": "fix active group test"}], "resolved_issues": [{"org": "netbirdio", "repo": "netbird", "number": -1, "state": "unknown", "title": "Feature/ssh fine grained access nmap", "body": "## Describe your changes\r\n\r\n## Issue ticket number and link\r\n\r\n## Stack\r\n\r\n<!-- branch-stack -->\r\n\r\n### Checklist\r\n- [ ] Is it a bug fix\r\n- [ ] Is a typo/documentation fix\r\n- [ ] Is a feature enhancement\r\n- [ ] It is a refactor\r\n- [ ] Created tests that fail without the change (if possible)\r\n\r\n> By submitting this pull request, you confirm that you have read and agree to the terms of the [Contributor License Agreement](https://github.com/netbirdio/netbird/blob/main/CONTRIBUTOR_LICENSE_AGREEMENT.md).\r\n\r\n## Documentation\r\nSelect exactly one:\r\n\r\n- [ ] I added/updated documentation for this change\r\n- [x] Documentation is **not needed** for this change (explain why)\r\n\r\n### Docs PR URL (required if \"docs added\" is checked)\r\nPaste the PR link from https://github.com/netbirdio/docs here:\r\n\r\nhttps://github.com/netbirdio/docs/pull/__\r\n\n\n<!-- This is an auto-generated comment: release notes by coderabbit.ai -->\n\n## Summary by CodeRabbit\n\n* **New Features**\n  * Added SSH authorization system with wildcard support for flexible access management\n  * Introduced group-based SSH authentication capabilities enabling group-level access control\n\n* **Improvements**\n  * Enhanced peer network mapping to include SSH configuration and authorization data\n  * Improved consistency in peer network updates when user group memberships and policies change\n\n<sub>âœï¸ Tip: You can customize this high-level summary in your review settings.</sub>\n\n<!-- end of auto-generated comment: release notes by coderabbit.ai -->"}], "fix_patch": "diff --git a/client/ssh/auth/auth.go b/client/ssh/auth/auth.go\nindex cf7ccf01c46..c883849a59c 100644\n--- a/client/ssh/auth/auth.go\n+++ b/client/ssh/auth/auth.go\n@@ -13,6 +13,8 @@ import (\n const (\n \t// DefaultUserIDClaim is the default JWT claim used to extract user IDs\n \tDefaultUserIDClaim = \"sub\"\n+\t// Wildcard is a special user ID that matches all users\n+\tWildcard = \"*\"\n )\n \n var (\n@@ -121,7 +123,19 @@ func (a *Authorizer) Authorize(jwtUserID, osUsername string) error {\n \t\treturn ErrUserNotAuthorized\n \t}\n \n-\t// Check machine user mapping\n+\treturn a.checkMachineUserMapping(jwtUserID, osUsername, userIndex)\n+}\n+\n+// checkMachineUserMapping validates if a user's index is authorized for the specified OS user\n+// Checks wildcard mapping first, then specific OS user mappings\n+func (a *Authorizer) checkMachineUserMapping(jwtUserID, osUsername string, userIndex int) error {\n+\t// If wildcard exists, allow any authorized user to access any OS user\n+\tif _, hasWildcard := a.machineUsers[Wildcard]; hasWildcard {\n+\t\tlog.Infof(\"SSH auth granted: user '%s' authorized for OS user '%s' via wildcard (index: %d)\", jwtUserID, osUsername, userIndex)\n+\t\treturn nil\n+\t}\n+\n+\t// Check for specific OS username mapping\n \tallowedIndexes, hasMachineUserMapping := a.machineUsers[osUsername]\n \tif !hasMachineUserMapping {\n \t\t// No mapping for this OS user - deny by default (fail closed)\n@@ -129,7 +143,7 @@ func (a *Authorizer) Authorize(jwtUserID, osUsername string) error {\n \t\treturn ErrNoMachineUserMapping\n \t}\n \n-\t// Check if user's index is in the allowed indexes for this OS user\n+\t// Check if user's index is in the allowed indexes for this specific OS user\n \tif !a.isIndexInList(uint32(userIndex), allowedIndexes) {\n \t\tlog.Warnf(\"SSH auth denied: user '%s' not mapped to OS user '%s' (user index: %d)\", jwtUserID, osUsername, userIndex)\n \t\treturn ErrUserNotMappedToOSUser\ndiff --git a/management/internals/controllers/network_map/controller/controller.go b/management/internals/controllers/network_map/controller/controller.go\nindex 022ea774ce3..df16e192264 100644\n--- a/management/internals/controllers/network_map/controller/controller.go\n+++ b/management/internals/controllers/network_map/controller/controller.go\n@@ -178,6 +178,7 @@ func (c *Controller) sendUpdateAccountPeers(ctx context.Context, accountID strin\n \tcustomZone := account.GetPeersCustomZone(ctx, dnsDomain)\n \tresourcePolicies := account.GetResourcePoliciesMap()\n \trouters := account.GetResourceRoutersMap()\n+\tgroupIDToUserIDs := account.GetActiveGroupUsers()\n \n \tif c.experimentalNetworkMap(accountID) {\n \t\tc.initNetworkMapBuilderIfNeeded(account, approvedPeersMap)\n@@ -224,7 +225,7 @@ func (c *Controller) sendUpdateAccountPeers(ctx context.Context, accountID strin\n \t\t\tif c.experimentalNetworkMap(accountID) {\n \t\t\t\tremotePeerNetworkMap = c.getPeerNetworkMapExp(ctx, p.AccountID, p.ID, approvedPeersMap, customZone, c.accountManagerMetrics)\n \t\t\t} else {\n-\t\t\t\tremotePeerNetworkMap = account.GetPeerNetworkMap(ctx, p.ID, customZone, approvedPeersMap, resourcePolicies, routers, c.accountManagerMetrics)\n+\t\t\t\tremotePeerNetworkMap = account.GetPeerNetworkMap(ctx, p.ID, customZone, approvedPeersMap, resourcePolicies, routers, c.accountManagerMetrics, groupIDToUserIDs)\n \t\t\t}\n \n \t\t\tc.metrics.CountCalcPeerNetworkMapDuration(time.Since(start))\n@@ -320,6 +321,7 @@ func (c *Controller) UpdateAccountPeer(ctx context.Context, accountId string, pe\n \tcustomZone := account.GetPeersCustomZone(ctx, dnsDomain)\n \tresourcePolicies := account.GetResourcePoliciesMap()\n \trouters := account.GetResourceRoutersMap()\n+\tgroupIDToUserIDs := account.GetActiveGroupUsers()\n \n \tpostureChecks, err := c.getPeerPostureChecks(account, peerId)\n \tif err != nil {\n@@ -338,7 +340,7 @@ func (c *Controller) UpdateAccountPeer(ctx context.Context, accountId string, pe\n \tif c.experimentalNetworkMap(accountId) {\n \t\tremotePeerNetworkMap = c.getPeerNetworkMapExp(ctx, peer.AccountID, peer.ID, approvedPeersMap, customZone, c.accountManagerMetrics)\n \t} else {\n-\t\tremotePeerNetworkMap = account.GetPeerNetworkMap(ctx, peerId, customZone, approvedPeersMap, resourcePolicies, routers, c.accountManagerMetrics)\n+\t\tremotePeerNetworkMap = account.GetPeerNetworkMap(ctx, peerId, customZone, approvedPeersMap, resourcePolicies, routers, c.accountManagerMetrics, groupIDToUserIDs)\n \t}\n \n \tproxyNetworkMap, ok := proxyNetworkMaps[peer.ID]\n@@ -445,7 +447,7 @@ func (c *Controller) GetValidatedPeerWithMap(ctx context.Context, isRequiresAppr\n \tif c.experimentalNetworkMap(accountID) {\n \t\tnetworkMap = c.getPeerNetworkMapExp(ctx, peer.AccountID, peer.ID, approvedPeersMap, customZone, c.accountManagerMetrics)\n \t} else {\n-\t\tnetworkMap = account.GetPeerNetworkMap(ctx, peer.ID, customZone, approvedPeersMap, account.GetResourcePoliciesMap(), account.GetResourceRoutersMap(), c.accountManagerMetrics)\n+\t\tnetworkMap = account.GetPeerNetworkMap(ctx, peer.ID, customZone, approvedPeersMap, account.GetResourcePoliciesMap(), account.GetResourceRoutersMap(), c.accountManagerMetrics, account.GetActiveGroupUsers())\n \t}\n \n \tproxyNetworkMap, ok := proxyNetworkMaps[peer.ID]\n@@ -811,7 +813,7 @@ func (c *Controller) GetNetworkMap(ctx context.Context, peerID string) (*types.N\n \tif c.experimentalNetworkMap(peer.AccountID) {\n \t\tnetworkMap = c.getPeerNetworkMapExp(ctx, peer.AccountID, peerID, validatedPeers, customZone, nil)\n \t} else {\n-\t\tnetworkMap = account.GetPeerNetworkMap(ctx, peer.ID, customZone, validatedPeers, account.GetResourcePoliciesMap(), account.GetResourceRoutersMap(), nil)\n+\t\tnetworkMap = account.GetPeerNetworkMap(ctx, peer.ID, customZone, validatedPeers, account.GetResourcePoliciesMap(), account.GetResourceRoutersMap(), nil, account.GetActiveGroupUsers())\n \t}\n \n \tproxyNetworkMap, ok := proxyNetworkMaps[peer.ID]\ndiff --git a/management/internals/shared/grpc/conversion.go b/management/internals/shared/grpc/conversion.go\nindex 1a0dc009b05..3b89574d060 100644\n--- a/management/internals/shared/grpc/conversion.go\n+++ b/management/internals/shared/grpc/conversion.go\n@@ -6,7 +6,10 @@ import (\n \t\"net/url\"\n \t\"strings\"\n \n+\tlog \"github.com/sirupsen/logrus\"\n+\n \tintegrationsConfig \"github.com/netbirdio/management-integrations/integrations/config\"\n+\t\"github.com/netbirdio/netbird/client/ssh/auth\"\n \n \tnbdns \"github.com/netbirdio/netbird/dns\"\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map/controller/cache\"\n@@ -16,6 +19,7 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/types\"\n \t\"github.com/netbirdio/netbird/route\"\n \t\"github.com/netbirdio/netbird/shared/management/proto\"\n+\t\"github.com/netbirdio/netbird/shared/sshauth\"\n )\n \n func toNetbirdConfig(config *nbconfig.Config, turnCredentials *Token, relayToken *Token, extraSettings *types.ExtraSettings) *proto.NetbirdConfig {\n@@ -84,12 +88,12 @@ func toNetbirdConfig(config *nbconfig.Config, turnCredentials *Token, relayToken\n \treturn nbConfig\n }\n \n-func toPeerConfig(peer *nbpeer.Peer, network *types.Network, dnsName string, settings *types.Settings, httpConfig *nbconfig.HttpServerConfig, deviceFlowConfig *nbconfig.DeviceAuthorizationFlow) *proto.PeerConfig {\n+func toPeerConfig(peer *nbpeer.Peer, network *types.Network, dnsName string, settings *types.Settings, httpConfig *nbconfig.HttpServerConfig, deviceFlowConfig *nbconfig.DeviceAuthorizationFlow, enableSSH bool) *proto.PeerConfig {\n \tnetmask, _ := network.Net.Mask.Size()\n \tfqdn := peer.FQDN(dnsName)\n \n \tsshConfig := &proto.SSHConfig{\n-\t\tSshEnabled: peer.SSHEnabled,\n+\t\tSshEnabled: peer.SSHEnabled || enableSSH,\n \t}\n \n \tif peer.SSHEnabled {\n@@ -110,12 +114,12 @@ func toPeerConfig(peer *nbpeer.Peer, network *types.Network, dnsName string, set\n \n func ToSyncResponse(ctx context.Context, config *nbconfig.Config, httpConfig *nbconfig.HttpServerConfig, deviceFlowConfig *nbconfig.DeviceAuthorizationFlow, peer *nbpeer.Peer, turnCredentials *Token, relayCredentials *Token, networkMap *types.NetworkMap, dnsName string, checks []*posture.Checks, dnsCache *cache.DNSConfigCache, settings *types.Settings, extraSettings *types.ExtraSettings, peerGroups []string, dnsFwdPort int64) *proto.SyncResponse {\n \tresponse := &proto.SyncResponse{\n-\t\tPeerConfig: toPeerConfig(peer, networkMap.Network, dnsName, settings, httpConfig, deviceFlowConfig),\n+\t\tPeerConfig: toPeerConfig(peer, networkMap.Network, dnsName, settings, httpConfig, deviceFlowConfig, networkMap.EnableSSH),\n \t\tNetworkMap: &proto.NetworkMap{\n \t\t\tSerial:     networkMap.Network.CurrentSerial(),\n \t\t\tRoutes:     toProtocolRoutes(networkMap.Routes),\n \t\t\tDNSConfig:  toProtocolDNSConfig(networkMap.DNSConfig, dnsCache, dnsFwdPort),\n-\t\t\tPeerConfig: toPeerConfig(peer, networkMap.Network, dnsName, settings, httpConfig, deviceFlowConfig),\n+\t\t\tPeerConfig: toPeerConfig(peer, networkMap.Network, dnsName, settings, httpConfig, deviceFlowConfig, networkMap.EnableSSH),\n \t\t},\n \t\tChecks: toProtocolChecks(ctx, checks),\n \t}\n@@ -151,9 +155,52 @@ func ToSyncResponse(ctx context.Context, config *nbconfig.Config, httpConfig *nb\n \t\tresponse.NetworkMap.ForwardingRules = forwardingRules\n \t}\n \n+\tif networkMap.AuthorizedUsers != nil {\n+\t\thashedUsers, machineUsers := buildAuthorizedUsersProto(ctx, networkMap.AuthorizedUsers)\n+\t\tuserIDClaim := auth.DefaultUserIDClaim\n+\t\tif httpConfig != nil && httpConfig.AuthUserIDClaim != \"\" {\n+\t\t\tuserIDClaim = httpConfig.AuthUserIDClaim\n+\t\t}\n+\t\tresponse.NetworkMap.SshAuth = &proto.SSHAuth{AuthorizedUsers: hashedUsers, MachineUsers: machineUsers, UserIDClaim: userIDClaim}\n+\t}\n+\n \treturn response\n }\n \n+func buildAuthorizedUsersProto(ctx context.Context, authorizedUsers map[string]map[string]struct{}) ([][]byte, map[string]*proto.MachineUserIndexes) {\n+\tuserIDToIndex := make(map[string]uint32)\n+\tvar hashedUsers [][]byte\n+\tmachineUsers := make(map[string]*proto.MachineUserIndexes, len(authorizedUsers))\n+\n+\tusers, ok := authorizedUsers[auth.Wildcard]\n+\tif ok {\n+\t\twildcard := make(map[string]map[string]struct{})\n+\t\twildcard[auth.Wildcard] = users\n+\t\tauthorizedUsers = wildcard\n+\t}\n+\n+\tfor machineUser, users := range authorizedUsers {\n+\t\tindexes := make([]uint32, 0, len(users))\n+\t\tfor userID := range users {\n+\t\t\tidx, exists := userIDToIndex[userID]\n+\t\t\tif !exists {\n+\t\t\t\thash, err := sshauth.HashUserID(userID)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tlog.WithContext(ctx).Errorf(\"failed to hash user id %s: %v\", userID, err)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tidx = uint32(len(hashedUsers))\n+\t\t\t\tuserIDToIndex[userID] = idx\n+\t\t\t\thashedUsers = append(hashedUsers, hash[:])\n+\t\t\t}\n+\t\t\tindexes = append(indexes, idx)\n+\t\t}\n+\t\tmachineUsers[machineUser] = &proto.MachineUserIndexes{Indexes: indexes}\n+\t}\n+\n+\treturn hashedUsers, machineUsers\n+}\n+\n func appendRemotePeerConfig(dst []*proto.RemotePeerConfig, peers []*nbpeer.Peer, dnsName string) []*proto.RemotePeerConfig {\n \tfor _, rPeer := range peers {\n \t\tdst = append(dst, &proto.RemotePeerConfig{\ndiff --git a/management/internals/shared/grpc/server.go b/management/internals/shared/grpc/server.go\nindex 462e2e6ebf3..ad6b34c5ff4 100644\n--- a/management/internals/shared/grpc/server.go\n+++ b/management/internals/shared/grpc/server.go\n@@ -635,7 +635,7 @@ func (s *Server) prepareLoginResponse(ctx context.Context, peer *nbpeer.Peer, ne\n \t// if peer has reached this point then it has logged in\n \tloginResp := &proto.LoginResponse{\n \t\tNetbirdConfig: toNetbirdConfig(s.config, nil, relayToken, nil),\n-\t\tPeerConfig:    toPeerConfig(peer, netMap.Network, s.networkMapController.GetDNSDomain(settings), settings, s.config.HttpConfig, s.config.DeviceAuthorizationFlow),\n+\t\tPeerConfig:    toPeerConfig(peer, netMap.Network, s.networkMapController.GetDNSDomain(settings), settings, s.config.HttpConfig, s.config.DeviceAuthorizationFlow, netMap.EnableSSH),\n \t\tChecks:        toProtocolChecks(ctx, postureChecks),\n \t}\n \ndiff --git a/management/server/account.go b/management/server/account.go\nindex 04f83842e75..405a3c0f635 100644\n--- a/management/server/account.go\n+++ b/management/server/account.go\n@@ -1456,21 +1456,19 @@ func (am *DefaultAccountManager) SyncUserJWTGroups(ctx context.Context, userAuth\n \t\t}\n \t}\n \n-\tif settings.GroupsPropagationEnabled {\n-\t\tremovedGroupAffectsPeers, err := areGroupChangesAffectPeers(ctx, am.Store, userAuth.AccountId, removeOldGroups)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n+\tremovedGroupAffectsPeers, err := areGroupChangesAffectPeers(ctx, am.Store, userAuth.AccountId, removeOldGroups)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \n-\t\tnewGroupsAffectsPeers, err := areGroupChangesAffectPeers(ctx, am.Store, userAuth.AccountId, addNewGroups)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n+\tnewGroupsAffectsPeers, err := areGroupChangesAffectPeers(ctx, am.Store, userAuth.AccountId, addNewGroups)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \n-\t\tif removedGroupAffectsPeers || newGroupsAffectsPeers {\n-\t\t\tlog.WithContext(ctx).Tracef(\"user %s: JWT group membership changed, updating account peers\", userAuth.UserId)\n-\t\t\tam.BufferUpdateAccountPeers(ctx, userAuth.AccountId)\n-\t\t}\n+\tif removedGroupAffectsPeers || newGroupsAffectsPeers {\n+\t\tlog.WithContext(ctx).Tracef(\"user %s: JWT group membership changed, updating account peers\", userAuth.UserId)\n+\t\tam.BufferUpdateAccountPeers(ctx, userAuth.AccountId)\n \t}\n \n \treturn nil\ndiff --git a/management/server/http/handlers/peers/peers_handler.go b/management/server/http/handlers/peers/peers_handler.go\nindex f531f0cdb24..01913ca127f 100644\n--- a/management/server/http/handlers/peers/peers_handler.go\n+++ b/management/server/http/handlers/peers/peers_handler.go\n@@ -299,7 +299,7 @@ func (h *Handler) GetAccessiblePeers(w http.ResponseWriter, r *http.Request) {\n \tdnsDomain := h.networkMapController.GetDNSDomain(account.Settings)\n \n \tcustomZone := account.GetPeersCustomZone(r.Context(), dnsDomain)\n-\tnetMap := account.GetPeerNetworkMap(r.Context(), peerID, customZone, validPeers, account.GetResourcePoliciesMap(), account.GetResourceRoutersMap(), nil)\n+\tnetMap := account.GetPeerNetworkMap(r.Context(), peerID, customZone, validPeers, account.GetResourcePoliciesMap(), account.GetResourceRoutersMap(), nil, account.GetActiveGroupUsers())\n \n \tutil.WriteJSONObject(r.Context(), w, toAccessiblePeers(netMap, dnsDomain))\n }\ndiff --git a/management/server/peer.go b/management/server/peer.go\nindex 49f5bf2a500..7c48a805279 100644\n--- a/management/server/peer.go\n+++ b/management/server/peer.go\n@@ -91,7 +91,7 @@ func (am *DefaultAccountManager) getUserAccessiblePeers(ctx context.Context, acc\n \n \t// fetch all the peers that have access to the user's peers\n \tfor _, peer := range peers {\n-\t\taclPeers, _ := account.GetPeerConnectionResources(ctx, peer, approvedPeersMap)\n+\t\taclPeers, _, _, _ := account.GetPeerConnectionResources(ctx, peer, approvedPeersMap, account.GetActiveGroupUsers())\n \t\tfor _, p := range aclPeers {\n \t\t\tpeersMap[p.ID] = p\n \t\t}\n@@ -1057,7 +1057,7 @@ func (am *DefaultAccountManager) checkIfUserOwnsPeer(ctx context.Context, accoun\n \t}\n \n \tfor _, p := range userPeers {\n-\t\taclPeers, _ := account.GetPeerConnectionResources(ctx, p, approvedPeersMap)\n+\t\taclPeers, _, _, _ := account.GetPeerConnectionResources(ctx, p, approvedPeersMap, account.GetActiveGroupUsers())\n \t\tfor _, aclPeer := range aclPeers {\n \t\t\tif aclPeer.ID == peer.ID {\n \t\t\t\treturn peer, nil\ndiff --git a/management/server/store/sql_store.go b/management/server/store/sql_store.go\nindex 2b8981b97c1..60109849c41 100644\n--- a/management/server/store/sql_store.go\n+++ b/management/server/store/sql_store.go\n@@ -1910,16 +1910,16 @@ func (s *SqlStore) getPolicyRules(ctx context.Context, policyIDs []string) ([]*t\n \tif len(policyIDs) == 0 {\n \t\treturn nil, nil\n \t}\n-\tconst query = `SELECT id, policy_id, name, description, enabled, action, destinations, destination_resource, sources, source_resource, bidirectional, protocol, ports, port_ranges FROM policy_rules WHERE policy_id = ANY($1)`\n+\tconst query = `SELECT id, policy_id, name, description, enabled, action, destinations, destination_resource, sources, source_resource, bidirectional, protocol, ports, port_ranges, authorized_groups FROM policy_rules WHERE policy_id = ANY($1)`\n \trows, err := s.pool.Query(ctx, query, policyIDs)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \trules, err := pgx.CollectRows(rows, func(row pgx.CollectableRow) (*types.PolicyRule, error) {\n \t\tvar r types.PolicyRule\n-\t\tvar dest, destRes, sources, sourceRes, ports, portRanges []byte\n+\t\tvar dest, destRes, sources, sourceRes, ports, portRanges, authorizedGroups []byte\n \t\tvar enabled, bidirectional sql.NullBool\n-\t\terr := row.Scan(&r.ID, &r.PolicyID, &r.Name, &r.Description, &enabled, &r.Action, &dest, &destRes, &sources, &sourceRes, &bidirectional, &r.Protocol, &ports, &portRanges)\n+\t\terr := row.Scan(&r.ID, &r.PolicyID, &r.Name, &r.Description, &enabled, &r.Action, &dest, &destRes, &sources, &sourceRes, &bidirectional, &r.Protocol, &ports, &portRanges, &authorizedGroups)\n \t\tif err == nil {\n \t\t\tif enabled.Valid {\n \t\t\t\tr.Enabled = enabled.Bool\n@@ -1945,6 +1945,9 @@ func (s *SqlStore) getPolicyRules(ctx context.Context, policyIDs []string) ([]*t\n \t\t\tif portRanges != nil {\n \t\t\t\t_ = json.Unmarshal(portRanges, &r.PortRanges)\n \t\t\t}\n+\t\t\tif authorizedGroups != nil {\n+\t\t\t\t_ = json.Unmarshal(authorizedGroups, &r.AuthorizedGroups)\n+\t\t\t}\n \t\t}\n \t\treturn &r, err\n \t})\ndiff --git a/management/server/types/account.go b/management/server/types/account.go\nindex 9e86d89366c..195dbbaa937 100644\n--- a/management/server/types/account.go\n+++ b/management/server/types/account.go\n@@ -16,6 +16,7 @@ import (\n \t\"github.com/rs/xid\"\n \tlog \"github.com/sirupsen/logrus\"\n \n+\t\"github.com/netbirdio/netbird/client/ssh/auth\"\n \tnbdns \"github.com/netbirdio/netbird/dns\"\n \tresourceTypes \"github.com/netbirdio/netbird/management/server/networks/resources/types\"\n \trouterTypes \"github.com/netbirdio/netbird/management/server/networks/routers/types\"\n@@ -45,8 +46,10 @@ const (\n \n \t// nativeSSHPortString defines the default port number as a string used for native SSH connections; this port is used by clients when hijacking ssh connections.\n \tnativeSSHPortString = \"22022\"\n+\tnativeSSHPortNumber = 22022\n \t// defaultSSHPortString defines the standard SSH port number as a string, commonly used for default SSH connections.\n \tdefaultSSHPortString = \"22\"\n+\tdefaultSSHPortNumber = 22\n )\n \n type supportedFeatures struct {\n@@ -275,6 +278,7 @@ func (a *Account) GetPeerNetworkMap(\n \tresourcePolicies map[string][]*Policy,\n \trouters map[string]map[string]*routerTypes.NetworkRouter,\n \tmetrics *telemetry.AccountManagerMetrics,\n+\tgroupIDToUserIDs map[string][]string,\n ) *NetworkMap {\n \tstart := time.Now()\n \tpeer := a.Peers[peerID]\n@@ -290,7 +294,7 @@ func (a *Account) GetPeerNetworkMap(\n \t\t}\n \t}\n \n-\taclPeers, firewallRules := a.GetPeerConnectionResources(ctx, peer, validatedPeersMap)\n+\taclPeers, firewallRules, authorizedUsers, enableSSH := a.GetPeerConnectionResources(ctx, peer, validatedPeersMap, groupIDToUserIDs)\n \t// exclude expired peers\n \tvar peersToConnect []*nbpeer.Peer\n \tvar expiredPeers []*nbpeer.Peer\n@@ -338,6 +342,8 @@ func (a *Account) GetPeerNetworkMap(\n \t\tOfflinePeers:        expiredPeers,\n \t\tFirewallRules:       firewallRules,\n \t\tRoutesFirewallRules: slices.Concat(networkResourcesFirewallRules, routesFirewallRules),\n+\t\tAuthorizedUsers:     authorizedUsers,\n+\t\tEnableSSH:           enableSSH,\n \t}\n \n \tif metrics != nil {\n@@ -1009,8 +1015,10 @@ func (a *Account) UserGroupsRemoveFromPeers(userID string, groups ...string) map\n // GetPeerConnectionResources for a given peer\n //\n // This function returns the list of peers and firewall rules that are applicable to a given peer.\n-func (a *Account) GetPeerConnectionResources(ctx context.Context, peer *nbpeer.Peer, validatedPeersMap map[string]struct{}) ([]*nbpeer.Peer, []*FirewallRule) {\n+func (a *Account) GetPeerConnectionResources(ctx context.Context, peer *nbpeer.Peer, validatedPeersMap map[string]struct{}, groupIDToUserIDs map[string][]string) ([]*nbpeer.Peer, []*FirewallRule, map[string]map[string]struct{}, bool) {\n \tgenerateResources, getAccumulatedResources := a.connResourcesGenerator(ctx, peer)\n+\tauthorizedUsers := make(map[string]map[string]struct{}) // machine user to list of userIDs\n+\tsshEnabled := false\n \n \tfor _, policy := range a.Policies {\n \t\tif !policy.Enabled {\n@@ -1053,10 +1061,52 @@ func (a *Account) GetPeerConnectionResources(ctx context.Context, peer *nbpeer.P\n \t\t\tif peerInDestinations {\n \t\t\t\tgenerateResources(rule, sourcePeers, FirewallRuleDirectionIN)\n \t\t\t}\n+\n+\t\t\tif peerInDestinations && rule.Protocol == PolicyRuleProtocolNetbirdSSH {\n+\t\t\t\tsshEnabled = true\n+\t\t\t\tif len(rule.AuthorizedGroups) == 0 {\n+\t\t\t\t\tauthorizedUsers[auth.Wildcard] = a.getAllowedUserIDs()\n+\t\t\t\t} else {\n+\t\t\t\t\tfor groupID, localUsers := range rule.AuthorizedGroups {\n+\t\t\t\t\t\tuserIDs, ok := groupIDToUserIDs[groupID]\n+\t\t\t\t\t\tif !ok {\n+\t\t\t\t\t\t\tlog.WithContext(ctx).Tracef(\"no user IDs found for group ID %s\", groupID)\n+\t\t\t\t\t\t\tcontinue\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif len(localUsers) == 0 {\n+\t\t\t\t\t\t\tlocalUsers = []string{auth.Wildcard}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tfor _, localUser := range localUsers {\n+\t\t\t\t\t\t\tif authorizedUsers[localUser] == nil {\n+\t\t\t\t\t\t\t\tauthorizedUsers[localUser] = make(map[string]struct{})\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tfor _, userID := range userIDs {\n+\t\t\t\t\t\t\t\tauthorizedUsers[localUser][userID] = struct{}{}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else if peerInDestinations && policyRuleImpliesLegacySSH(rule) && peer.SSHEnabled {\n+\t\t\t\tsshEnabled = true\n+\t\t\t\tauthorizedUsers[auth.Wildcard] = a.getAllowedUserIDs()\n+\t\t\t}\n \t\t}\n \t}\n \n-\treturn getAccumulatedResources()\n+\tpeers, fwRules := getAccumulatedResources()\n+\treturn peers, fwRules, authorizedUsers, sshEnabled\n+}\n+\n+func (a *Account) getAllowedUserIDs() map[string]struct{} {\n+\tusers := make(map[string]struct{})\n+\tfor _, nbUser := range a.Users {\n+\t\tif !nbUser.IsBlocked() && !nbUser.IsServiceUser {\n+\t\t\tusers[nbUser.Id] = struct{}{}\n+\t\t}\n+\t}\n+\treturn users\n }\n \n // connResourcesGenerator returns generator and accumulator function which returns the result of generator calls\n@@ -1081,12 +1131,17 @@ func (a *Account) connResourcesGenerator(ctx context.Context, targetPeer *nbpeer\n \t\t\t\t\tpeersExists[peer.ID] = struct{}{}\n \t\t\t\t}\n \n+\t\t\t\tprotocol := rule.Protocol\n+\t\t\t\tif protocol == PolicyRuleProtocolNetbirdSSH {\n+\t\t\t\t\tprotocol = PolicyRuleProtocolTCP\n+\t\t\t\t}\n+\n \t\t\t\tfr := FirewallRule{\n \t\t\t\t\tPolicyID:  rule.ID,\n \t\t\t\t\tPeerIP:    peer.IP.String(),\n \t\t\t\t\tDirection: direction,\n \t\t\t\t\tAction:    string(rule.Action),\n-\t\t\t\t\tProtocol:  string(rule.Protocol),\n+\t\t\t\t\tProtocol:  string(protocol),\n \t\t\t\t}\n \n \t\t\t\truleID := rule.ID + fr.PeerIP + strconv.Itoa(direction) +\n@@ -1108,6 +1163,28 @@ func (a *Account) connResourcesGenerator(ctx context.Context, targetPeer *nbpeer\n \t\t}\n }\n \n+func policyRuleImpliesLegacySSH(rule *PolicyRule) bool {\n+\treturn rule.Protocol == PolicyRuleProtocolALL || (rule.Protocol == PolicyRuleProtocolTCP && (portsIncludesSSH(rule.Ports) || portRangeIncludesSSH(rule.PortRanges)))\n+}\n+\n+func portRangeIncludesSSH(portRanges []RulePortRange) bool {\n+\tfor _, pr := range portRanges {\n+\t\tif (pr.Start <= defaultSSHPortNumber && pr.End >= defaultSSHPortNumber) || (pr.Start <= nativeSSHPortNumber && pr.End >= nativeSSHPortNumber) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+func portsIncludesSSH(ports []string) bool {\n+\tfor _, port := range ports {\n+\t\tif port == defaultSSHPortString || port == nativeSSHPortString {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n // getAllPeersFromGroups for given peer ID and list of groups\n //\n // Returns a list of peers from specified groups that pass specified posture checks\n@@ -1660,6 +1737,26 @@ func (a *Account) AddAllGroup(disableDefaultPolicy bool) error {\n \treturn nil\n }\n \n+func (a *Account) GetActiveGroupUsers() map[string][]string {\n+\tallGroupID := \"\"\n+\tgroup, err := a.GetGroupAll()\n+\tif err != nil {\n+\t\tlog.Errorf(\"failed to get group all: %v\", err)\n+\t} else {\n+\t\tallGroupID = group.ID\n+\t}\n+\tgroups := make(map[string][]string, len(a.GroupsG))\n+\tfor _, user := range a.Users {\n+\t\tif !user.IsBlocked() && !user.IsServiceUser {\n+\t\t\tfor _, groupID := range user.AutoGroups {\n+\t\t\t\tgroups[groupID] = append(groups[groupID], user.Id)\n+\t\t\t}\n+\t\t\tgroups[allGroupID] = append(groups[allGroupID], user.Id)\n+\t\t}\n+\t}\n+\treturn groups\n+}\n+\n // expandPortsAndRanges expands Ports and PortRanges of a rule into individual firewall rules\n func expandPortsAndRanges(base FirewallRule, rule *PolicyRule, peer *nbpeer.Peer) []*FirewallRule {\n \tfeatures := peerSupportedFirewallFeatures(peer.Meta.WtVersion)\n@@ -1691,7 +1788,7 @@ func expandPortsAndRanges(base FirewallRule, rule *PolicyRule, peer *nbpeer.Peer\n \t\texpanded = append(expanded, &fr)\n \t}\n \n-\tif shouldCheckRulesForNativeSSH(features.nativeSSH, rule, peer) {\n+\tif shouldCheckRulesForNativeSSH(features.nativeSSH, rule, peer) || rule.Protocol == PolicyRuleProtocolNetbirdSSH {\n \t\texpanded = addNativeSSHRule(base, expanded)\n \t}\n \ndiff --git a/management/server/types/network.go b/management/server/types/network.go\nindex ffc01956517..d3708d80af5 100644\n--- a/management/server/types/network.go\n+++ b/management/server/types/network.go\n@@ -38,6 +38,8 @@ type NetworkMap struct {\n \tFirewallRules       []*FirewallRule\n \tRoutesFirewallRules []*RouteFirewallRule\n \tForwardingRules     []*ForwardingRule\n+\tAuthorizedUsers     map[string]map[string]struct{}\n+\tEnableSSH           bool\n }\n \n func (nm *NetworkMap) Merge(other *NetworkMap) {\ndiff --git a/management/server/types/policy.go b/management/server/types/policy.go\nindex c7ac7b6aeaa..d4e1a8816b9 100644\n--- a/management/server/types/policy.go\n+++ b/management/server/types/policy.go\n@@ -170,7 +170,7 @@ func ParseRuleString(rule string) (PolicyRuleProtocolType, RulePortRange, error)\n \tcase \"icmp\":\n \t\treturn \"\", RulePortRange{}, errors.New(\"icmp does not accept ports; use 'icmp' without '/â€¦'\")\n \tcase \"netbird-ssh\":\n-\t\treturn PolicyRuleProtocolNetbirdSSH, RulePortRange{Start: 22, End: 22}, nil\n+\t\treturn PolicyRuleProtocolNetbirdSSH, RulePortRange{Start: nativeSSHPortNumber, End: nativeSSHPortNumber}, nil\n \tdefault:\n \t\treturn \"\", RulePortRange{}, fmt.Errorf(\"invalid protocol: %q\", protoStr)\n \t}\ndiff --git a/management/server/user.go b/management/server/user.go\nindex ca02f91e67e..9d4620462cf 100644\n--- a/management/server/user.go\n+++ b/management/server/user.go\n@@ -523,16 +523,14 @@ func (am *DefaultAccountManager) SaveOrAddUsers(ctx context.Context, accountID,\n \t\t}\n \n \t\terr = am.Store.ExecuteInTransaction(ctx, func(transaction store.Store) error {\n-\t\t\tuserHadPeers, updatedUser, userPeersToExpire, userEvents, err := am.processUserUpdate(\n+\t\t\t_, updatedUser, userPeersToExpire, userEvents, err := am.processUserUpdate(\n \t\t\t\tctx, transaction, groupsMap, accountID, initiatorUserID, initiatorUser, update, addIfNotExists, settings,\n \t\t\t)\n \t\t\tif err != nil {\n \t\t\t\treturn fmt.Errorf(\"failed to process update for user %s: %w\", update.Id, err)\n \t\t\t}\n \n-\t\t\tif userHadPeers {\n-\t\t\t\tupdateAccountPeers = true\n-\t\t\t}\n+\t\t\tupdateAccountPeers = true\n \n \t\t\terr = transaction.SaveUser(ctx, updatedUser)\n \t\t\tif err != nil {\n@@ -581,7 +579,7 @@ func (am *DefaultAccountManager) SaveOrAddUsers(ctx context.Context, accountID,\n \t\t}\n \t}\n \n-\tif settings.GroupsPropagationEnabled && updateAccountPeers {\n+\tif updateAccountPeers {\n \t\tif err = am.Store.IncrementNetworkSerial(ctx, accountID); err != nil {\n \t\t\treturn nil, fmt.Errorf(\"failed to increment network serial: %w\", err)\n \t\t}\n", "test_patch": "diff --git a/client/ssh/auth/auth_test.go b/client/ssh/auth/auth_test.go\nindex e7c2e9a1315..b51ddcab9b4 100644\n--- a/client/ssh/auth/auth_test.go\n+++ b/client/ssh/auth/auth_test.go\n@@ -404,3 +404,150 @@ func TestAuthorizer_ConcurrentAuthorization(t *testing.T) {\n \t\tassert.NoError(t, err)\n \t}\n }\n+\n+func TestAuthorizer_Wildcard_AllowsAllAuthorizedUsers(t *testing.T) {\n+\tauthorizer := NewAuthorizer()\n+\n+\tuser1Hash, err := sshauth.HashUserID(\"user1\")\n+\trequire.NoError(t, err)\n+\tuser2Hash, err := sshauth.HashUserID(\"user2\")\n+\trequire.NoError(t, err)\n+\tuser3Hash, err := sshauth.HashUserID(\"user3\")\n+\trequire.NoError(t, err)\n+\n+\t// Configure with wildcard - all authorized users can access any OS user\n+\tconfig := &Config{\n+\t\tUserIDClaim:     DefaultUserIDClaim,\n+\t\tAuthorizedUsers: []sshauth.UserIDHash{user1Hash, user2Hash, user3Hash},\n+\t\tMachineUsers: map[string][]uint32{\n+\t\t\t\"*\": {0}, // wildcard with any indexes - indexes don't matter\n+\t\t},\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// All authorized users should be able to access any OS user\n+\terr = authorizer.Authorize(\"user1\", \"root\")\n+\tassert.NoError(t, err)\n+\n+\terr = authorizer.Authorize(\"user2\", \"postgres\")\n+\tassert.NoError(t, err)\n+\n+\terr = authorizer.Authorize(\"user3\", \"admin\")\n+\tassert.NoError(t, err)\n+\n+\terr = authorizer.Authorize(\"user1\", \"ubuntu\")\n+\tassert.NoError(t, err)\n+\n+\terr = authorizer.Authorize(\"user2\", \"nginx\")\n+\tassert.NoError(t, err)\n+\n+\terr = authorizer.Authorize(\"user3\", \"docker\")\n+\tassert.NoError(t, err)\n+}\n+\n+func TestAuthorizer_Wildcard_UnauthorizedUserStillDenied(t *testing.T) {\n+\tauthorizer := NewAuthorizer()\n+\n+\tuser1Hash, err := sshauth.HashUserID(\"user1\")\n+\trequire.NoError(t, err)\n+\n+\t// Configure with wildcard\n+\tconfig := &Config{\n+\t\tUserIDClaim:     DefaultUserIDClaim,\n+\t\tAuthorizedUsers: []sshauth.UserIDHash{user1Hash},\n+\t\tMachineUsers: map[string][]uint32{\n+\t\t\t\"*\": {0},\n+\t\t},\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// user1 should have access\n+\terr = authorizer.Authorize(\"user1\", \"root\")\n+\tassert.NoError(t, err)\n+\n+\t// Unauthorized user should still be denied even with wildcard\n+\terr = authorizer.Authorize(\"unauthorized-user\", \"root\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrUserNotAuthorized)\n+}\n+\n+func TestAuthorizer_Wildcard_TakesPrecedenceOverSpecificMappings(t *testing.T) {\n+\tauthorizer := NewAuthorizer()\n+\n+\tuser1Hash, err := sshauth.HashUserID(\"user1\")\n+\trequire.NoError(t, err)\n+\tuser2Hash, err := sshauth.HashUserID(\"user2\")\n+\trequire.NoError(t, err)\n+\n+\t// Configure with both wildcard and specific mappings - wildcard should take precedence\n+\tconfig := &Config{\n+\t\tUserIDClaim:     DefaultUserIDClaim,\n+\t\tAuthorizedUsers: []sshauth.UserIDHash{user1Hash, user2Hash},\n+\t\tMachineUsers: map[string][]uint32{\n+\t\t\t\"*\":    {0}, // wildcard exists\n+\t\t\t\"root\": {0}, // specific mapping that would normally restrict to user1 only\n+\t\t},\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// Both users should be able to access root because wildcard takes precedence\n+\terr = authorizer.Authorize(\"user1\", \"root\")\n+\tassert.NoError(t, err)\n+\n+\terr = authorizer.Authorize(\"user2\", \"root\")\n+\tassert.NoError(t, err)\n+\n+\t// Both users should be able to access any other OS user via wildcard\n+\terr = authorizer.Authorize(\"user1\", \"postgres\")\n+\tassert.NoError(t, err)\n+\n+\terr = authorizer.Authorize(\"user2\", \"admin\")\n+\tassert.NoError(t, err)\n+}\n+\n+func TestAuthorizer_NoWildcard_SpecificMappingsOnly(t *testing.T) {\n+\tauthorizer := NewAuthorizer()\n+\n+\tuser1Hash, err := sshauth.HashUserID(\"user1\")\n+\trequire.NoError(t, err)\n+\tuser2Hash, err := sshauth.HashUserID(\"user2\")\n+\trequire.NoError(t, err)\n+\n+\t// Configure WITHOUT wildcard - only specific mappings\n+\tconfig := &Config{\n+\t\tUserIDClaim:     DefaultUserIDClaim,\n+\t\tAuthorizedUsers: []sshauth.UserIDHash{user1Hash, user2Hash},\n+\t\tMachineUsers: map[string][]uint32{\n+\t\t\t\"root\":     {0}, // only user1\n+\t\t\t\"postgres\": {1}, // only user2\n+\t\t},\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// user1 can access root\n+\terr = authorizer.Authorize(\"user1\", \"root\")\n+\tassert.NoError(t, err)\n+\n+\t// user2 can access postgres\n+\terr = authorizer.Authorize(\"user2\", \"postgres\")\n+\tassert.NoError(t, err)\n+\n+\t// user1 cannot access postgres\n+\terr = authorizer.Authorize(\"user1\", \"postgres\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrUserNotMappedToOSUser)\n+\n+\t// user2 cannot access root\n+\terr = authorizer.Authorize(\"user2\", \"root\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrUserNotMappedToOSUser)\n+\n+\t// Neither can access unmapped OS users\n+\terr = authorizer.Authorize(\"user1\", \"admin\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrNoMachineUserMapping)\n+\n+\terr = authorizer.Authorize(\"user2\", \"admin\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrNoMachineUserMapping)\n+}\ndiff --git a/management/server/account_test.go b/management/server/account_test.go\nindex 7f125e3a0c8..25818ada29d 100644\n--- a/management/server/account_test.go\n+++ b/management/server/account_test.go\n@@ -397,7 +397,7 @@ func TestAccount_GetPeerNetworkMap(t *testing.T) {\n \t\t}\n \n \t\tcustomZone := account.GetPeersCustomZone(context.Background(), \"netbird.io\")\n-\t\tnetworkMap := account.GetPeerNetworkMap(context.Background(), testCase.peerID, customZone, validatedPeers, account.GetResourcePoliciesMap(), account.GetResourceRoutersMap(), nil)\n+\t\tnetworkMap := account.GetPeerNetworkMap(context.Background(), testCase.peerID, customZone, validatedPeers, account.GetResourcePoliciesMap(), account.GetResourceRoutersMap(), nil, account.GetActiveGroupUsers())\n \t\tassert.Len(t, networkMap.Peers, len(testCase.expectedPeers))\n \t\tassert.Len(t, networkMap.OfflinePeers, len(testCase.expectedOfflinePeers))\n \t}\ndiff --git a/management/server/policy_test.go b/management/server/policy_test.go\nindex 90fe8f0368c..a3f987732d0 100644\n--- a/management/server/policy_test.go\n+++ b/management/server/policy_test.go\n@@ -246,14 +246,14 @@ func TestAccount_getPeersByPolicy(t *testing.T) {\n \n \tt.Run(\"check that all peers get map\", func(t *testing.T) {\n \t\tfor _, p := range account.Peers {\n-\t\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), p, validatedPeers)\n+\t\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), p, validatedPeers, account.GetActiveGroupUsers())\n \t\t\tassert.GreaterOrEqual(t, len(peers), 1, \"minimum number peers should present\")\n \t\t\tassert.GreaterOrEqual(t, len(firewallRules), 1, \"minimum number of firewall rules should present\")\n \t\t}\n \t})\n \n \tt.Run(\"check first peer map details\", func(t *testing.T) {\n-\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], validatedPeers)\n+\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], validatedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 8)\n \t\tassert.Contains(t, peers, account.Peers[\"peerA\"])\n \t\tassert.Contains(t, peers, account.Peers[\"peerC\"])\n@@ -509,7 +509,7 @@ func TestAccount_getPeersByPolicy(t *testing.T) {\n \t})\n \n \tt.Run(\"check port ranges support for older peers\", func(t *testing.T) {\n-\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerK\"], validatedPeers)\n+\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerK\"], validatedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 1)\n \t\tassert.Contains(t, peers, account.Peers[\"peerI\"])\n \n@@ -635,7 +635,7 @@ func TestAccount_getPeersByPolicyDirect(t *testing.T) {\n \t}\n \n \tt.Run(\"check first peer map\", func(t *testing.T) {\n-\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Contains(t, peers, account.Peers[\"peerC\"])\n \n \t\texpectedFirewallRules := []*types.FirewallRule{\n@@ -665,7 +665,7 @@ func TestAccount_getPeersByPolicyDirect(t *testing.T) {\n \t})\n \n \tt.Run(\"check second peer map\", func(t *testing.T) {\n-\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerC\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerC\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Contains(t, peers, account.Peers[\"peerB\"])\n \n \t\texpectedFirewallRules := []*types.FirewallRule{\n@@ -697,7 +697,7 @@ func TestAccount_getPeersByPolicyDirect(t *testing.T) {\n \taccount.Policies[1].Rules[0].Bidirectional = false\n \n \tt.Run(\"check first peer map directional only\", func(t *testing.T) {\n-\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Contains(t, peers, account.Peers[\"peerC\"])\n \n \t\texpectedFirewallRules := []*types.FirewallRule{\n@@ -719,7 +719,7 @@ func TestAccount_getPeersByPolicyDirect(t *testing.T) {\n \t})\n \n \tt.Run(\"check second peer map directional only\", func(t *testing.T) {\n-\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerC\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerC\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Contains(t, peers, account.Peers[\"peerB\"])\n \n \t\texpectedFirewallRules := []*types.FirewallRule{\n@@ -917,7 +917,7 @@ func TestAccount_getPeersByPolicyPostureChecks(t *testing.T) {\n \tt.Run(\"verify peer's network map with default group peer list\", func(t *testing.T) {\n \t\t// peerB doesn't fulfill the NB posture check but is included in the destination group Swarm,\n \t\t// will establish a connection with all source peers satisfying the NB posture check.\n-\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 4)\n \t\tassert.Len(t, firewallRules, 4)\n \t\tassert.Contains(t, peers, account.Peers[\"peerA\"])\n@@ -927,7 +927,7 @@ func TestAccount_getPeersByPolicyPostureChecks(t *testing.T) {\n \n \t\t// peerC satisfy the NB posture check, should establish connection to all destination group peer's\n \t\t// We expect a single permissive firewall rule which all outgoing connections\n-\t\tpeers, firewallRules = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerC\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerC\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, len(account.Groups[\"GroupSwarm\"].Peers))\n \t\tassert.Len(t, firewallRules, 7)\n \t\texpectedFirewallRules := []*types.FirewallRule{\n@@ -992,7 +992,7 @@ func TestAccount_getPeersByPolicyPostureChecks(t *testing.T) {\n \n \t\t// peerE doesn't fulfill the NB posture check and exists in only destination group Swarm,\n \t\t// all source group peers satisfying the NB posture check should establish connection\n-\t\tpeers, firewallRules = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerE\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerE\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 4)\n \t\tassert.Len(t, firewallRules, 4)\n \t\tassert.Contains(t, peers, account.Peers[\"peerA\"])\n@@ -1002,7 +1002,7 @@ func TestAccount_getPeersByPolicyPostureChecks(t *testing.T) {\n \n \t\t// peerI doesn't fulfill the OS version posture check and exists in only destination group Swarm,\n \t\t// all source group peers satisfying the NB posture check should establish connection\n-\t\tpeers, firewallRules = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerI\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerI\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 4)\n \t\tassert.Len(t, firewallRules, 4)\n \t\tassert.Contains(t, peers, account.Peers[\"peerA\"])\n@@ -1017,19 +1017,19 @@ func TestAccount_getPeersByPolicyPostureChecks(t *testing.T) {\n \n \t\t// peerB doesn't satisfy the NB posture check, and doesn't exist in destination group peer's\n \t\t// no connection should be established to any peer of destination group\n-\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 0)\n \t\tassert.Len(t, firewallRules, 0)\n \n \t\t// peerI doesn't satisfy the OS version posture check, and doesn't exist in destination group peer's\n \t\t// no connection should be established to any peer of destination group\n-\t\tpeers, firewallRules = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerI\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerI\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 0)\n \t\tassert.Len(t, firewallRules, 0)\n \n \t\t// peerC satisfy the NB posture check, should establish connection to all destination group peer's\n \t\t// We expect a single permissive firewall rule which all outgoing connections\n-\t\tpeers, firewallRules = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerC\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerC\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, len(account.Groups[\"GroupSwarm\"].Peers))\n \t\tassert.Len(t, firewallRules, len(account.Groups[\"GroupSwarm\"].Peers))\n \n@@ -1044,14 +1044,14 @@ func TestAccount_getPeersByPolicyPostureChecks(t *testing.T) {\n \n \t\t// peerE doesn't fulfill the NB posture check and exists in only destination group Swarm,\n \t\t// all source group peers satisfying the NB posture check should establish connection\n-\t\tpeers, firewallRules = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerE\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerE\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 3)\n \t\tassert.Len(t, firewallRules, 3)\n \t\tassert.Contains(t, peers, account.Peers[\"peerA\"])\n \t\tassert.Contains(t, peers, account.Peers[\"peerC\"])\n \t\tassert.Contains(t, peers, account.Peers[\"peerD\"])\n \n-\t\tpeers, firewallRules = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerA\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerA\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 5)\n \t\t// assert peers from Group Swarm\n \t\tassert.Contains(t, peers, account.Peers[\"peerD\"])\ndiff --git a/management/server/types/account_test.go b/management/server/types/account_test.go\nindex f9aa6a1c22a..2c9f2428db7 100644\n--- a/management/server/types/account_test.go\n+++ b/management/server/types/account_test.go\n@@ -1105,6 +1105,193 @@ func Test_ExpandPortsAndRanges_SSHRuleExpansion(t *testing.T) {\n \t}\n }\n \n+func Test_GetActiveGroupUsers(t *testing.T) {\n+\ttests := []struct {\n+\t\tname     string\n+\t\taccount  *Account\n+\t\texpected map[string][]string\n+\t}{\n+\t\t{\n+\t\t\tname: \"all users are active\",\n+\t\t\taccount: &Account{\n+\t\t\t\tUsers: map[string]*User{\n+\t\t\t\t\t\"user1\": {\n+\t\t\t\t\t\tId:         \"user1\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\", \"group2\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user2\": {\n+\t\t\t\t\t\tId:         \"user2\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group2\", \"group3\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user3\": {\n+\t\t\t\t\t\tId:         \"user3\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: map[string][]string{\n+\t\t\t\t\"group1\": {\"user1\", \"user3\"},\n+\t\t\t\t\"group2\": {\"user1\", \"user2\"},\n+\t\t\t\t\"group3\": {\"user2\"},\n+\t\t\t\t\"\":       {\"user1\", \"user2\", \"user3\"},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"some users are blocked\",\n+\t\t\taccount: &Account{\n+\t\t\t\tUsers: map[string]*User{\n+\t\t\t\t\t\"user1\": {\n+\t\t\t\t\t\tId:         \"user1\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\", \"group2\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user2\": {\n+\t\t\t\t\t\tId:         \"user2\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group2\", \"group3\"},\n+\t\t\t\t\t\tBlocked:    true,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user3\": {\n+\t\t\t\t\t\tId:         \"user3\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\", \"group3\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: map[string][]string{\n+\t\t\t\t\"group1\": {\"user1\", \"user3\"},\n+\t\t\t\t\"group2\": {\"user1\"},\n+\t\t\t\t\"group3\": {\"user3\"},\n+\t\t\t\t\"\":       {\"user1\", \"user3\"},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"all users are blocked\",\n+\t\t\taccount: &Account{\n+\t\t\t\tUsers: map[string]*User{\n+\t\t\t\t\t\"user1\": {\n+\t\t\t\t\t\tId:         \"user1\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\"},\n+\t\t\t\t\t\tBlocked:    true,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user2\": {\n+\t\t\t\t\t\tId:         \"user2\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group2\"},\n+\t\t\t\t\t\tBlocked:    true,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: map[string][]string{},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"user with no auto groups\",\n+\t\t\taccount: &Account{\n+\t\t\t\tUsers: map[string]*User{\n+\t\t\t\t\t\"user1\": {\n+\t\t\t\t\t\tId:         \"user1\",\n+\t\t\t\t\t\tAutoGroups: []string{},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user2\": {\n+\t\t\t\t\t\tId:         \"user2\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: map[string][]string{\n+\t\t\t\t\"group1\": {\"user2\"},\n+\t\t\t\t\"\":       {\"user1\", \"user2\"},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"empty account\",\n+\t\t\taccount: &Account{\n+\t\t\t\tUsers: map[string]*User{},\n+\t\t\t},\n+\t\t\texpected: map[string][]string{},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"multiple users in same group\",\n+\t\t\taccount: &Account{\n+\t\t\t\tUsers: map[string]*User{\n+\t\t\t\t\t\"user1\": {\n+\t\t\t\t\t\tId:         \"user1\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user2\": {\n+\t\t\t\t\t\tId:         \"user2\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user3\": {\n+\t\t\t\t\t\tId:         \"user3\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: map[string][]string{\n+\t\t\t\t\"group1\": {\"user1\", \"user2\", \"user3\"},\n+\t\t\t\t\"\":       {\"user1\", \"user2\", \"user3\"},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"user in multiple groups with blocked users\",\n+\t\t\taccount: &Account{\n+\t\t\t\tUsers: map[string]*User{\n+\t\t\t\t\t\"user1\": {\n+\t\t\t\t\t\tId:         \"user1\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\", \"group2\", \"group3\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user2\": {\n+\t\t\t\t\t\tId:         \"user2\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\", \"group2\"},\n+\t\t\t\t\t\tBlocked:    true,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user3\": {\n+\t\t\t\t\t\tId:         \"user3\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group3\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: map[string][]string{\n+\t\t\t\t\"group1\": {\"user1\"},\n+\t\t\t\t\"group2\": {\"user1\"},\n+\t\t\t\t\"group3\": {\"user1\", \"user3\"},\n+\t\t\t\t\"\":       {\"user1\", \"user3\"},\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tresult := tt.account.GetActiveGroupUsers()\n+\n+\t\t\t// Check that the number of groups matches\n+\t\t\tassert.Equal(t, len(tt.expected), len(result), \"number of groups should match\")\n+\n+\t\t\t// Check each group's users\n+\t\t\tfor groupID, expectedUsers := range tt.expected {\n+\t\t\t\tactualUsers, exists := result[groupID]\n+\t\t\t\tassert.True(t, exists, \"group %s should exist in result\", groupID)\n+\t\t\t\tassert.ElementsMatch(t, expectedUsers, actualUsers, \"users in group %s should match\", groupID)\n+\t\t\t}\n+\n+\t\t\t// Ensure no extra groups in result\n+\t\t\tfor groupID := range result {\n+\t\t\t\t_, exists := tt.expected[groupID]\n+\t\t\t\tassert.True(t, exists, \"unexpected group %s in result\", groupID)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n func Test_FilterZoneRecordsForPeers(t *testing.T) {\n \ttests := []struct {\n \t\tname            string\ndiff --git a/management/server/types/networkmap_golden_test.go b/management/server/types/networkmap_golden_test.go\nindex d85aaabb212..913094e4c90 100644\n--- a/management/server/types/networkmap_golden_test.go\n+++ b/management/server/types/networkmap_golden_test.go\n@@ -69,7 +69,7 @@ func TestGetPeerNetworkMap_Golden(t *testing.T) {\n \tresourcePolicies := account.GetResourcePoliciesMap()\n \trouters := account.GetResourceRoutersMap()\n \n-\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil)\n+\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil, account.GetActiveGroupUsers())\n \n \tnormalizeAndSortNetworkMap(networkMap)\n \n@@ -141,7 +141,7 @@ func BenchmarkGetPeerNetworkMap(b *testing.B) {\n \tb.Run(\"old builder\", func(b *testing.B) {\n \t\tfor range b.N {\n \t\t\tfor _, peerID := range peerIDs {\n-\t\t\t\t_ = account.GetPeerNetworkMap(ctx, peerID, dns.CustomZone{}, validatedPeersMap, nil, nil, nil)\n+\t\t\t\t_ = account.GetPeerNetworkMap(ctx, peerID, dns.CustomZone{}, validatedPeersMap, nil, nil, nil, account.GetActiveGroupUsers())\n \t\t\t}\n \t\t}\n \t})\n@@ -201,7 +201,7 @@ func TestGetPeerNetworkMap_Golden_WithNewPeer(t *testing.T) {\n \tresourcePolicies := account.GetResourcePoliciesMap()\n \trouters := account.GetResourceRoutersMap()\n \n-\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil)\n+\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil, account.GetActiveGroupUsers())\n \n \tnormalizeAndSortNetworkMap(networkMap)\n \n@@ -320,7 +320,7 @@ func BenchmarkGetPeerNetworkMap_AfterPeerAdded(b *testing.B) {\n \tb.Run(\"old builder after add\", func(b *testing.B) {\n \t\tfor i := 0; i < b.N; i++ {\n \t\t\tfor _, testingPeerID := range peerIDs {\n-\t\t\t\t_ = account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, nil, nil, nil)\n+\t\t\t\t_ = account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, nil, nil, nil, account.GetActiveGroupUsers())\n \t\t\t}\n \t\t}\n \t})\n@@ -395,7 +395,7 @@ func TestGetPeerNetworkMap_Golden_WithNewRoutingPeer(t *testing.T) {\n \tresourcePolicies := account.GetResourcePoliciesMap()\n \trouters := account.GetResourceRoutersMap()\n \n-\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil)\n+\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil, account.GetActiveGroupUsers())\n \n \tnormalizeAndSortNetworkMap(networkMap)\n \n@@ -550,7 +550,7 @@ func BenchmarkGetPeerNetworkMap_AfterRouterPeerAdded(b *testing.B) {\n \tb.Run(\"old builder after add\", func(b *testing.B) {\n \t\tfor i := 0; i < b.N; i++ {\n \t\t\tfor _, testingPeerID := range peerIDs {\n-\t\t\t\t_ = account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, nil, nil, nil)\n+\t\t\t\t_ = account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, nil, nil, nil, account.GetActiveGroupUsers())\n \t\t\t}\n \t\t}\n \t})\n@@ -604,7 +604,7 @@ func TestGetPeerNetworkMap_Golden_WithDeletedPeer(t *testing.T) {\n \tresourcePolicies := account.GetResourcePoliciesMap()\n \trouters := account.GetResourceRoutersMap()\n \n-\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil)\n+\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil, account.GetActiveGroupUsers())\n \n \tnormalizeAndSortNetworkMap(networkMap)\n \n@@ -730,7 +730,7 @@ func TestGetPeerNetworkMap_Golden_WithDeletedRouterPeer(t *testing.T) {\n \tresourcePolicies := account.GetResourcePoliciesMap()\n \trouters := account.GetResourceRoutersMap()\n \n-\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil)\n+\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil, account.GetActiveGroupUsers())\n \n \tnormalizeAndSortNetworkMap(networkMap)\n \n@@ -847,7 +847,7 @@ func BenchmarkGetPeerNetworkMap_AfterPeerDeleted(b *testing.B) {\n \tb.Run(\"old builder after delete\", func(b *testing.B) {\n \t\tfor i := 0; i < b.N; i++ {\n \t\t\tfor _, testingPeerID := range peerIDs {\n-\t\t\t\t_ = account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, nil, nil, nil)\n+\t\t\t\t_ = account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, nil, nil, nil, account.GetActiveGroupUsers())\n \t\t\t}\n \t\t}\n \t})\ndiff --git a/management/server/user_test.go b/management/server/user_test.go\nindex 0d778cfa2b7..3032ee3e8ab 100644\n--- a/management/server/user_test.go\n+++ b/management/server/user_test.go\n@@ -1379,11 +1379,11 @@ func TestUserAccountPeersUpdate(t *testing.T) {\n \t\tupdateManager.CloseChannel(context.Background(), peer1.ID)\n \t})\n \n-\t// Creating a new regular user should not update account peers and not send peer update\n+\t// Creating a new regular user should send peer update (as users are not filtered yet)\n \tt.Run(\"creating new regular user with no groups\", func(t *testing.T) {\n \t\tdone := make(chan struct{})\n \t\tgo func() {\n-\t\t\tpeerShouldNotReceiveUpdate(t, updMsg)\n+\t\t\tpeerShouldReceiveUpdate(t, updMsg)\n \t\t\tclose(done)\n \t\t}()\n \n@@ -1402,11 +1402,11 @@ func TestUserAccountPeersUpdate(t *testing.T) {\n \t\t}\n \t})\n \n-\t// updating user with no linked peers should not update account peers and not send peer update\n+\t// updating user with no linked peers should update account peers and send peer update (as users are not filtered yet)\n \tt.Run(\"updating user with no linked peers\", func(t *testing.T) {\n \t\tdone := make(chan struct{})\n \t\tgo func() {\n-\t\t\tpeerShouldNotReceiveUpdate(t, updMsg)\n+\t\t\tpeerShouldReceiveUpdate(t, updMsg)\n \t\t\tclose(done)\n \t\t}()\n \n"}
{"org": "netbirdio", "repo": "netbird", "number": 4015, "state": "closed", "title": "[client,management] Rewrite the SSH feature", "body": "## Describe your changes\r\n\r\n\r\n### NetBird SSH Client\r\n- Port forwarding\r\n- Windows support\r\n- Non-interactive commands\r\n- Single command execution over SSH\r\n\r\n### SSH Server\r\n- SFTP\r\n- Port forwarding (without user switching)\r\n- PTY (interactive, non-interactive)\r\n- Non-PTY (commands)\r\n- Windows support\r\n- JWT auth (user identity instead of machine identity, can be turned off) \r\n\r\n### New Flags\r\n```\r\n# server\r\n--enable-ssh-local-port-forwarding\r\n--enable-ssh-remote-port-forwarding\r\n--enable-ssh-root\r\n--enable-ssh-sftp\r\n--disable-ssh-auth\r\n\r\n# client\r\n--ssh-jwt-cache-ttl\r\n```\r\n\r\n### UI\r\n\r\n- Better organization\r\n<img width=\"608\" height=\"432\" alt=\"image\" src=\"https://github.com/user-attachments/assets/7e8f7415-7f7f-47f4-b945-d1e6135e8bd7\" />\r\n\r\n<img width=\"608\" height=\"432\" alt=\"image\" src=\"https://github.com/user-attachments/assets/d463c3d3-0742-4700-91ca-29db0b47c1f4\" />\r\n \r\n<img width=\"608\" height=\"432\" alt=\"image\" src=\"https://github.com/user-attachments/assets/8023d3de-f6fd-4c5d-8985-a49a452a6491\" />\r\n\r\n\r\n### Changes\r\n- Default port changed to 22022\r\n- Redirect port 22 to 22022 when SSH server enabled\r\n- Remove implicit OpenSSH firewall port\r\n- Management now passes its `jwks` config to peers with enabled ssh server\r\n- SSH server peers verify incoming clients' `jwt` with max token age \r\n- SSH clients request `jwt`s from the IdP and send these for authentication with remote ssh peers\r\n- Add `netbird ssh detect` command to detect if the remote peer is running the NetBird server\r\n- Add `netbird ssh proxy` command for native ssh and sftp clients. The proxy requests `jwt`s just like `netbird ssh`, passes them for authentication and bridges the connection between the native client and the remote server.\r\n- Add jwt capability to the wasm ssh client\r\n\r\n\r\n### Auth Flows\r\n\r\n  1. NetBird SSH Flow (`netbird ssh <peer>`)\r\n\r\n  ```mermaid\r\n  flowchart TD\r\n      A[User: netbird ssh &lt;peer&gt;] --> B[Connect to peer:22]\r\n      B --> C[Detect Server Type]\r\n      C --> D[Send 'netbird-detect' request]\r\n\r\n      D --> E{Server Response}\r\n\r\n      E -->|No NetBird identifier| F[Regular SSH Server]\r\n      E -->|NetBird + JWT required| G[NetBird with JWT Auth]\r\n      E -->|NetBird + No JWT| H[NetBird without JWT]\r\n\r\n      F --> I[Standard SSH Connection]\r\n      H --> I\r\n\r\n      G --> J[Request JWT from NetBird daemon]\r\n\r\n      J --> J1{Check JWT cache}\r\n      J1 -->|Cache valid| J2[Use cached JWT token]\r\n      J1 -->|No cache/expired| J3[OIDC flow:<br/>User authorizes via IDP callback]\r\n      J3 --> J4[Receive & cache JWT token]\r\n      J4 --> K[Connect to peer SSH server]\r\n      J2 --> K\r\n\r\n      K --> M[Send JWT authentication request]\r\n      M --> N{JWT Valid?}\r\n\r\n      N -->|No| O[Connection Rejected]\r\n      N -->|Yes| P[SSH Session Established]\r\n      I --> P\r\n\r\n      P --> Q[Interactive Shell / Execute Command / Port Forwarding]\r\n\r\n      style G fill:#f57c00,color:#fff\r\n      style J fill:#1976d2,color:#fff\r\n      style J1 fill:#1976d2,color:#fff\r\n      style J3 fill:#e65100,color:#fff\r\n      style P fill:#388e3c,color:#fff\r\n  ```\r\n\r\n  2. Native SSH Flow (e.g. openssh client)\r\n\r\n  ```mermaid\r\n  flowchart TD\r\n      A[User: ssh &lt;peer&gt;] --> B[OpenSSH loads config:<br/>/etc/ssh/ssh_config.d/99-netbird.conf]\r\n      B --> D{Host matches NetBird pattern?}\r\n\r\n      D -->|No| E[Standard SSH connection]\r\n\r\n      D -->|Yes| F[Run detection check:<br/>netbird ssh detect &lt;peer&gt; 22]\r\n      F --> G{Is NetBird SSH server?}\r\n\r\n      G -->|No| E\r\n\r\n      G -->|Yes - JWT required| H[Activate ProxyCommand:<br/>netbird ssh proxy &lt;peer&gt; 22]\r\n\r\n      H --> I[Local SSH Proxy Started]\r\n      I --> J[OpenSSH connects to proxy via stdio]\r\n\r\n      J --> K[Proxy requests JWT from daemon]\r\n\r\n      K --> K1{Check JWT cache}\r\n      K1 -->|Cache valid| K2[Use cached JWT token]\r\n      K1 -->|No cache/expired| K3[OIDC flow:<br/>User authorizes via IDP callback]\r\n      K3 --> K4[Receive & cache JWT token]\r\n      K4 --> L[Proxy connects to peer SSH server]\r\n      K2 --> L\r\n\r\n      L --> M[Proxy sends JWT authentication]\r\n\r\n      M --> N{JWT Valid?}\r\n      N -->|No| O[Connection Rejected]\r\n      N -->|Yes| P[Proxy establishes session]\r\n\r\n      P --> Q[Bidirectional forwarding:<br/>OpenSSH â†” Proxy â†” Peer SSH Server]\r\n\r\n      Q --> R[User interacts with remote shell]\r\n\r\n      style H fill:#f57c00,color:#fff\r\n      style I fill:#1976d2,color:#fff\r\n      style K fill:#1976d2,color:#fff\r\n      style K1 fill:#1976d2,color:#fff\r\n      style K3 fill:#e65100,color:#fff\r\n      style Q fill:#388e3c,color:#fff\r\n\r\n      classDef proxyBox fill:#1565c0,stroke:#0d47a1,stroke-width:2px,color:#fff\r\n      class I,K,L,M,P,Q proxyBox\r\n  ```\r\n\r\n## Issue ticket number and link\r\n\r\nFixes https://github.com/netbirdio/netbird/issues/4759 https://github.com/netbirdio/netbird/issues/4672 https://github.com/netbirdio/netbird/issues/4456  https://github.com/netbirdio/netbird/issues/4039 https://github.com/netbirdio/netbird/issues/3985 https://github.com/netbirdio/netbird/issues/2498 https://github.com/netbirdio/netbird/issues/4457\r\n\r\n\r\n## Stack\r\n\r\n<!-- branch-stack -->\r\n\r\n### Checklist\r\n- [x] Is it a bug fix\r\n- [ ] Is a typo/documentation fix\r\n- [x] Is a feature enhancement\r\n- [x] It is a refactor\r\n- [x] Created tests that fail without the change (if possible)\r\n- [ ] Extended the README / documentation, if necessary\r\n\r\n## Documentation\r\nSelect exactly one:\r\n\r\n- [x] I added/updated documentation for this change [ netbirdio/docs/pull/475 ]\r\n- [ ] Documentation is **not needed** for this change \r\n---\r\n\r\n\r\n> By submitting this pull request, you confirm that you have read and agree to the terms of the [Contributor License Agreement](https://github.com/netbirdio/netbird/blob/main/CONTRIBUTOR_LICENSE_AGREEMENT.md).\r\n\r\n\r\n<!-- This is an auto-generated comment: release notes by coderabbit.ai -->\r\n## Summary by CodeRabbit\r\n\r\n* **New Features**\r\n  * Complete SSH support: embedded SSH server and client (JWT-backed auth), SFTP, local/remote port forwarding, SSH proxy, host-key retrieval, session listing, SSH client config generation, server detection, and UI/WASM controls including SSH JWT cache TTL.\r\n* **Bug Fixes**\r\n  * License check made quieter and more robust by suppressing noisy errors during scanning.\r\n<!-- end of auto-generated comment: release notes by coderabbit.ai -->", "url": "https://api.github.com/repos/netbirdio/netbird/pulls/4015", "id": 2605408068, "node_id": "PR_kwDOFVUT786bS19E", "html_url": "https://github.com/netbirdio/netbird/pull/4015", "diff_url": "https://github.com/netbirdio/netbird/pull/4015.diff", "patch_url": "https://github.com/netbirdio/netbird/pull/4015.patch", "issue_url": "https://api.github.com/repos/netbirdio/netbird/issues/4015", "created_at": "2025-06-19T17:33:36+00:00", "updated_at": "2025-11-17T16:10:44+00:00", "closed_at": "2025-11-17T16:10:42+00:00", "merged_at": "2025-11-17T16:10:41+00:00", "merge_commit_sha": "d71a82769c32238cf29bd1bb3bd3ec520c0c1ab9", "labels": [], "draft": false, "commits_url": "https://api.github.com/repos/netbirdio/netbird/pulls/4015/commits", "review_comments_url": "https://api.github.com/repos/netbirdio/netbird/pulls/4015/comments", "review_comment_url": "https://api.github.com/repos/netbirdio/netbird/pulls/comments{/number}", "comments_url": "https://api.github.com/repos/netbirdio/netbird/issues/4015/comments", "base": {"label": "netbirdio:main", "ref": "main", "sha": "e4b41d0ad70676b3f3f4a18f621b5467bd1c509c", "user": {"login": "netbirdio", "id": 100464677, "node_id": "O_kgDOBfz4JQ", "avatar_url": "https://avatars.githubusercontent.com/u/100464677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/netbirdio", "html_url": "https://github.com/netbirdio", "followers_url": "https://api.github.com/users/netbirdio/followers", "following_url": "https://api.github.com/users/netbirdio/following{/other_user}", "gists_url": "https://api.github.com/users/netbirdio/gists{/gist_id}", "starred_url": "https://api.github.com/users/netbirdio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/netbirdio/subscriptions", "organizations_url": "https://api.github.com/users/netbirdio/orgs", "repos_url": "https://api.github.com/users/netbirdio/repos", "events_url": "https://api.github.com/users/netbirdio/events{/privacy}", "received_events_url": "https://api.github.com/users/netbirdio/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "repo": {"id": 357897199, "node_id": "MDEwOlJlcG9zaXRvcnkzNTc4OTcxOTk=", "name": "netbird", "full_name": "netbirdio/netbird", "private": false, "owner": {"login": "netbirdio", "id": 100464677, "node_id": "O_kgDOBfz4JQ", "avatar_url": "https://avatars.githubusercontent.com/u/100464677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/netbirdio", "html_url": "https://github.com/netbirdio", "followers_url": "https://api.github.com/users/netbirdio/followers", "following_url": "https://api.github.com/users/netbirdio/following{/other_user}", "gists_url": "https://api.github.com/users/netbirdio/gists{/gist_id}", "starred_url": "https://api.github.com/users/netbirdio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/netbirdio/subscriptions", "organizations_url": "https://api.github.com/users/netbirdio/orgs", "repos_url": "https://api.github.com/users/netbirdio/repos", "events_url": "https://api.github.com/users/netbirdio/events{/privacy}", "received_events_url": "https://api.github.com/users/netbirdio/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "html_url": "https://github.com/netbirdio/netbird", "description": "Connect your devices into a secure WireGuardÂ®-based overlay network with SSO, MFA and granular access controls.", "fork": false, "url": "https://api.github.com/repos/netbirdio/netbird", "forks_url": "https://api.github.com/repos/netbirdio/netbird/forks", "keys_url": "https://api.github.com/repos/netbirdio/netbird/keys{/key_id}", "collaborators_url": "https://api.github.com/repos/netbirdio/netbird/collaborators{/collaborator}", "teams_url": "https://api.github.com/repos/netbirdio/netbird/teams", "hooks_url": "https://api.github.com/repos/netbirdio/netbird/hooks", "issue_events_url": "https://api.github.com/repos/netbirdio/netbird/issues/events{/number}", "events_url": "https://api.github.com/repos/netbirdio/netbird/events", "assignees_url": "https://api.github.com/repos/netbirdio/netbird/assignees{/user}", "branches_url": "https://api.github.com/repos/netbirdio/netbird/branches{/branch}", "tags_url": "https://api.github.com/repos/netbirdio/netbird/tags", "blobs_url": "https://api.github.com/repos/netbirdio/netbird/git/blobs{/sha}", "git_tags_url": "https://api.github.com/repos/netbirdio/netbird/git/tags{/sha}", "git_refs_url": "https://api.github.com/repos/netbirdio/netbird/git/refs{/sha}", "trees_url": "https://api.github.com/repos/netbirdio/netbird/git/trees{/sha}", "statuses_url": "https://api.github.com/repos/netbirdio/netbird/statuses/{sha}", "languages_url": "https://api.github.com/repos/netbirdio/netbird/languages", "stargazers_url": "https://api.github.com/repos/netbirdio/netbird/stargazers", "contributors_url": "https://api.github.com/repos/netbirdio/netbird/contributors", "subscribers_url": "https://api.github.com/repos/netbirdio/netbird/subscribers", "subscription_url": "https://api.github.com/repos/netbirdio/netbird/subscription", "commits_url": "https://api.github.com/repos/netbirdio/netbird/commits{/sha}", "git_commits_url": "https://api.github.com/repos/netbirdio/netbird/git/commits{/sha}", "comments_url": "https://api.github.com/repos/netbirdio/netbird/comments{/number}", "issue_comment_url": "https://api.github.com/repos/netbirdio/netbird/issues/comments{/number}", "contents_url": "https://api.github.com/repos/netbirdio/netbird/contents/{+path}", "compare_url": "https://api.github.com/repos/netbirdio/netbird/compare/{base}...{head}", "merges_url": "https://api.github.com/repos/netbirdio/netbird/merges", "archive_url": "https://api.github.com/repos/netbirdio/netbird/{archive_format}{/ref}", "downloads_url": "https://api.github.com/repos/netbirdio/netbird/downloads", "issues_url": "https://api.github.com/repos/netbirdio/netbird/issues{/number}", "pulls_url": "https://api.github.com/repos/netbirdio/netbird/pulls{/number}", "milestones_url": "https://api.github.com/repos/netbirdio/netbird/milestones{/number}", "notifications_url": "https://api.github.com/repos/netbirdio/netbird/notifications{?since,all,participating}", "labels_url": "https://api.github.com/repos/netbirdio/netbird/labels{/name}", "releases_url": "https://api.github.com/repos/netbirdio/netbird/releases{/id}", "deployments_url": "https://api.github.com/repos/netbirdio/netbird/deployments", "created_at": "2021-04-14T12:27:20Z", "updated_at": "2026-01-07T04:18:10Z", "pushed_at": "2026-01-07T05:22:46Z", "git_url": "git://github.com/netbirdio/netbird.git", "ssh_url": "git@github.com:netbirdio/netbird.git", "clone_url": "https://github.com/netbirdio/netbird.git", "svn_url": "https://github.com/netbirdio/netbird", "homepage": "https://netbird.io", "size": 47404, "stargazers_count": 20703, "watchers_count": 20703, "language": "Go", "has_issues": true, "has_projects": true, "has_downloads": true, "has_wiki": true, "has_pages": false, "has_discussions": false, "forks_count": 1009, "mirror_url": null, "archived": false, "disabled": false, "open_issues_count": 1188, "license": {"key": "other", "name": "Other", "spdx_id": "NOASSERTION", "url": null, "node_id": "MDc6TGljZW5zZTA="}, "allow_forking": true, "is_template": false, "web_commit_signoff_required": false, "topics": ["golang", "mesh", "mesh-networks", "nat-traversal", "netbird", "vpn", "wireguard", "wireguard-vpn", "wiretrustee", "zero-trust-network-access"], "visibility": "public", "forks": 1009, "open_issues": 1188, "watchers": 20703, "default_branch": "main"}}, "commits": [{"sha": "bb74e903cd04bc38b54a0c28bb00db393eeb7f2d", "parents": ["8df8c1012f647f1947a4a1d673051825240b8f2f"], "message": "Implement dns routes for Android"}, {"sha": "49bbd9055753a9af4c0f2217601bf73572c7e7fe", "parents": ["bb74e903cd04bc38b54a0c28bb00db393eeb7f2d"], "message": "Fix test"}, {"sha": "50ac3d437e774185c2ce912fc590473cd95f49a9", "parents": ["49bbd9055753a9af4c0f2217601bf73572c7e7fe"], "message": "Fix lint issues"}, {"sha": "631b77dc3c1a1123eacb20d655473cfc55ff63a0", "parents": ["50ac3d437e774185c2ce912fc590473cd95f49a9"], "message": "Remove some allocations"}, {"sha": "8e94d85d149079be63b65ec3f4aea5f9c630305b", "parents": ["631b77dc3c1a1123eacb20d655473cfc55ff63a0"], "message": "Rename test files"}, {"sha": "8684981b57b201673986195a4e467ef0b3ce15a5", "parents": ["8e94d85d149079be63b65ec3f4aea5f9c630305b"], "message": "Add tests"}, {"sha": "7cd44a9a3c6d1faef080ff4a12bb47e705ae25ad", "parents": ["8684981b57b201673986195a4e467ef0b3ce15a5"], "message": "Improve nat perf"}, {"sha": "2952669e97ffa84079c093180dcbe0c9c23520b6", "parents": ["7cd44a9a3c6d1faef080ff4a12bb47e705ae25ad"], "message": "Fix lint"}, {"sha": "51b9e93eb924f4ed6d61331c117d32802d3929b3", "parents": ["2952669e97ffa84079c093180dcbe0c9c23520b6", "f61ebdb3bc07b35d2b5335d383269dee53ac67d5"], "message": "Merge branch 'main' into android-dns-routes"}, {"sha": "1a3b04d2fe012220eae1bbf909f82aed20306dfd", "parents": ["51b9e93eb924f4ed6d61331c117d32802d3929b3"], "message": "Swap tracking and nat order"}, {"sha": "471f90e8dbcaa18d0889f07290d56f7afbfa086f", "parents": ["1a3b04d2fe012220eae1bbf909f82aed20306dfd"], "message": "Rename methods"}, {"sha": "d47c6b624eedb98f18791384e64a448ec7bffb46", "parents": ["471f90e8dbcaa18d0889f07290d56f7afbfa086f"], "message": "Fix spelling"}, {"sha": "f51ce7cee52a7818b005db9db49170e0bfb97c38", "parents": ["d47c6b624eedb98f18791384e64a448ec7bffb46"], "message": "Remove nil checks"}, {"sha": "9468e69c8c4642ebe7fbe574de89c16f466013cd", "parents": ["f51ce7cee52a7818b005db9db49170e0bfb97c38"], "message": "Extract static error"}, {"sha": "306d75fe1a5aa16487dc4542397ddb29935cf533", "parents": ["9468e69c8c4642ebe7fbe574de89c16f466013cd"], "message": "Set up fake ip route only if the dns feature flag is enabled"}, {"sha": "a79cb1c11b9bcea4aa9f79fb39892bbd9eb067b7", "parents": ["306d75fe1a5aa16487dc4542397ddb29935cf533", "0e5dc9d41229ef3f368aa5feb336934815b69a04"], "message": "Merge branch 'main' into android-dns-routes"}, {"sha": "26fc32f1be9f3b32ad29d123c656152eeb801f39", "parents": ["a79cb1c11b9bcea4aa9f79fb39892bbd9eb067b7"], "message": "Fix errorf"}, {"sha": "c7884039b885d0c17dbd7c8a26a64ae9ddbd25b3", "parents": ["26fc32f1be9f3b32ad29d123c656152eeb801f39"], "message": "Revert \"Fix errorf\"\n\nThis reverts commit 26fc32f1be9f3b32ad29d123c656152eeb801f39."}, {"sha": "5fc95d4a0cead6f46b71a7dabe9e97ca1dabfa04", "parents": ["c7884039b885d0c17dbd7c8a26a64ae9ddbd25b3"], "message": "Display domains properly"}, {"sha": "11bdf5b3a5ffd55b4b966896b32b145af86e4d7d", "parents": ["5fc95d4a0cead6f46b71a7dabe9e97ca1dabfa04"], "message": "Use r"}, {"sha": "5299e9fda3d53b74ebae0fdf3dc2c4f5f20c1713", "parents": ["11bdf5b3a5ffd55b4b966896b32b145af86e4d7d", "6c633497bc84c19f452bf8d230901f1f2dabcd6b"], "message": "Merge branch 'main' into android-dns-routes"}, {"sha": "0f79a8942d342e98258fdab600e94d4fe003ec26", "parents": ["5299e9fda3d53b74ebae0fdf3dc2c4f5f20c1713"], "message": "Fix route notificaiton"}, {"sha": "520f2cfdb4d2fba67412b66b90402398a62d814a", "parents": ["0f79a8942d342e98258fdab600e94d4fe003ec26"], "message": "Remove implicit inbound ssh firewall rules and change default port"}, {"sha": "6ed846ae298aff7221ad2ec65db9c1b56cc9d373", "parents": ["520f2cfdb4d2fba67412b66b90402398a62d814a"], "message": "Refactor ssh server and client"}, {"sha": "f56075ca159820ba99f090631280f2df14a4a1ed", "parents": ["6ed846ae298aff7221ad2ec65db9c1b56cc9d373"], "message": "Tidy mod"}, {"sha": "9d1554f9f7a01d2ae7eaac6bb19aef78660f7466", "parents": ["f56075ca159820ba99f090631280f2df14a4a1ed"], "message": "Complete overhaul"}, {"sha": "279b77dee00f3e01b8f1188b60eb4d3c7b1923f8", "parents": ["9d1554f9f7a01d2ae7eaac6bb19aef78660f7466"], "message": "Bump sftp"}, {"sha": "4bbca28eb6170769801a8c40ca1d822edbc346ea", "parents": ["279b77dee00f3e01b8f1188b60eb4d3c7b1923f8"], "message": "Fix lint"}, {"sha": "96084e3a026626a5b35b5b63ea22485f6c0a05fd", "parents": ["4bbca28eb6170769801a8c40ca1d822edbc346ea"], "message": "Reduce complexity"}, {"sha": "0d5408baecd247a3daadd1798325c8bcbf85849c", "parents": ["96084e3a026626a5b35b5b63ea22485f6c0a05fd"], "message": "Fix lint"}, {"sha": "5970591d24d34514bb1a5be78c4199193065440a", "parents": ["0d5408baecd247a3daadd1798325c8bcbf85849c"], "message": "Fix lint"}, {"sha": "1fdde66c312329ad62d1333815a3e51735faf6a2", "parents": ["5970591d24d34514bb1a5be78c4199193065440a"], "message": "More lint"}, {"sha": "612de2c784de284a67036a478df62256e309b8f0", "parents": ["1fdde66c312329ad62d1333815a3e51735faf6a2"], "message": "Remove socketfilter temporarily"}, {"sha": "76f9e11b2950f2d285ecf8b59861a0db068fec94", "parents": ["612de2c784de284a67036a478df62256e309b8f0"], "message": "Fix tests"}, {"sha": "6e15882c1152e2038e76fa5cb9f847ff28bdb182", "parents": ["76f9e11b2950f2d285ecf8b59861a0db068fec94"], "message": "Fix tests and windows username validation"}, {"sha": "04bb314426dbcc445f72c33fecbe42c21b6718e8", "parents": ["6e15882c1152e2038e76fa5cb9f847ff28bdb182"], "message": "Allow sftp same user switching on windows"}, {"sha": "3e490d974c99d30ffd19b0bde35aa87d751b6343", "parents": ["04bb314426dbcc445f72c33fecbe42c21b6718e8"], "message": "Remove duplicated code"}, {"sha": "9e51d2e8fbc5ddaee26681cc8d86ecd299e6d00c", "parents": ["3e490d974c99d30ffd19b0bde35aa87d751b6343"], "message": "Fix lint and sonar"}, {"sha": "a21f924b2618a6e72339fa553d12c7bdce75d9bf", "parents": ["9e51d2e8fbc5ddaee26681cc8d86ecd299e6d00c"], "message": "Fix some windows tests"}, {"sha": "a476b8d12f4cc9f8dbd890b4d704e2849a2c9913", "parents": ["a21f924b2618a6e72339fa553d12c7bdce75d9bf"], "message": "Fix more windows tests"}, {"sha": "982841e25b047ebd17d0c88b33cbea5dc317cb87", "parents": ["a476b8d12f4cc9f8dbd890b4d704e2849a2c9913"], "message": "Test up tests users if none are available on CI"}, {"sha": "f1bb4d2ac3d05346825e33941d867573db704c88", "parents": ["982841e25b047ebd17d0c88b33cbea5dc317cb87"], "message": "Fix more Windows tests"}, {"sha": "aa30b7afe848eee8bdcb358404f7728c48b827f2", "parents": ["f1bb4d2ac3d05346825e33941d867573db704c88"], "message": "More windows tests"}, {"sha": "088956645fcfd95a1a787e75cc3dd3f30cfcc2b3", "parents": ["aa30b7afe848eee8bdcb358404f7728c48b827f2"], "message": "Fix username validation and skip ci tests properly"}, {"sha": "a4b067553d0d2fab9c0244acda6a3abb68a319c5", "parents": ["088956645fcfd95a1a787e75cc3dd3f30cfcc2b3", "77ec32dd6fc87f8498c4bff55dba12f31dc9b2e1"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "e4e0b8fff97b88111283606ed6669a4737e7d8a5", "parents": ["a4b067553d0d2fab9c0244acda6a3abb68a319c5"], "message": "Remove empty file"}, {"sha": "cdded8c22e131a550f35e53aa09f8d5d1427d4e0", "parents": ["e4e0b8fff97b88111283606ed6669a4737e7d8a5", "a76c8eafb46cda5e44de0f3784160a34e8cdb4a2"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "9a7daa132e749bda07a2d96fabb6e73153633028", "parents": ["cdded8c22e131a550f35e53aa09f8d5d1427d4e0"], "message": "Fix client ssh file"}, {"sha": "ac7120871ba1e510b8027ffd126700cde9048b01", "parents": ["9a7daa132e749bda07a2d96fabb6e73153633028"], "message": "Fix proto"}, {"sha": "fa893aa0a4b85a13dac42ff785bc7c5199b7eb25", "parents": ["ac7120871ba1e510b8027ffd126700cde9048b01"], "message": "Fix build"}, {"sha": "d93b7c2f3863e91783b2dfd7ce11ad9c598c4e6c", "parents": ["fa893aa0a4b85a13dac42ff785bc7c5199b7eb25"], "message": "Fix known hosts entries"}, {"sha": "758a97c35210e3c8d7e3cc5b61e94abf026e8d91", "parents": ["d93b7c2f3863e91783b2dfd7ce11ad9c598c4e6c"], "message": "Generate ssh_config independently of ssh server"}, {"sha": "b43ef4f17b84054abc88869d129ff904f07fc3a9", "parents": ["758a97c35210e3c8d7e3cc5b61e94abf026e8d91", "f063866ce8c62b27b00cf2098a68e89542f837f9"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "b1a9242c984209a68be56ee97fa5daecbb8a1fdf", "parents": ["b43ef4f17b84054abc88869d129ff904f07fc3a9"], "message": "Fix merge commit changes"}, {"sha": "cdd5c6c005ac772a27743eef6ae48cd6c008c4c8", "parents": ["b1a9242c984209a68be56ee97fa5daecbb8a1fdf"], "message": "Address review"}, {"sha": "77a352763d64c2b5a29f1fcec0bb2b21ce59dc70", "parents": ["cdd5c6c005ac772a27743eef6ae48cd6c008c4c8"], "message": "Fix button style"}, {"sha": "79d28b71ee1d7bdae82879a4ff3ef8a1726200ec", "parents": ["77a352763d64c2b5a29f1fcec0bb2b21ce59dc70"], "message": "Improve forwarding cancellation"}, {"sha": "4c53372815b52b4f1cccecafc262a41902a9cf13", "parents": ["79d28b71ee1d7bdae82879a4ff3ef8a1726200ec"], "message": "Add missing flags"}, {"sha": "5272fc2b1895e679be458d308786b79df77e305c", "parents": ["4c53372815b52b4f1cccecafc262a41902a9cf13", "644ed4b934452d578ec4854ebda311cd42341f08"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "66483ab48def71538253dd9ab236da99cab22836", "parents": ["5272fc2b1895e679be458d308786b79df77e305c", "e7b5537dcc280384470668f461bbb1f7d2f41218"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "b3c7b3c7b2baa7b24612a8de1a7b1f3302471e5d", "parents": ["66483ab48def71538253dd9ab236da99cab22836"], "message": "Fix js build"}, {"sha": "7e0bbaaa3cf536bd61e0308a2595d63ffdd4f266", "parents": ["b3c7b3c7b2baa7b24612a8de1a7b1f3302471e5d", "88467883fc4a14607393beaac412f573eaaa1d43"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "d9efe4e944829f4dd65dfeff7d14ed4c793f2d02", "parents": ["7e0bbaaa3cf536bd61e0308a2595d63ffdd4f266"], "message": "Add ssh authenatication with jwt (#4550)"}, {"sha": "f3d31698da2c6ebe42d9b369c3bfac113eaeb8b7", "parents": ["d9efe4e944829f4dd65dfeff7d14ed4c793f2d02"], "message": "Skip some auth tests on windows that are already covered"}, {"sha": "19adcb5f63d4ee025a7f9175343948fc8e0be68d", "parents": ["f3d31698da2c6ebe42d9b369c3bfac113eaeb8b7", "4d33567888fe704fb75f0c0a74ed8a27fd131052"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "610c880ec9943570ef069a9658e66e9413fdafab", "parents": ["19adcb5f63d4ee025a7f9175343948fc8e0be68d"], "message": "Fix missing jwt config passed to peers"}, {"sha": "4d89d0f11560fe2118b099a343d1a2782d6a0598", "parents": ["610c880ec9943570ef069a9658e66e9413fdafab"], "message": "Remove unused code"}, {"sha": "7216c201dab5d906c23b5bb6e2a7c8c007dcd8f8", "parents": ["4d89d0f11560fe2118b099a343d1a2782d6a0598"], "message": "Log priv check errors"}, {"sha": "559f6aeeaf8b05f32de35a9c9ded7879e16e7663", "parents": ["7216c201dab5d906c23b5bb6e2a7c8c007dcd8f8"], "message": "Improve logging"}, {"sha": "4d297205c395456a516b75f9c3957ed1d93e9484", "parents": ["559f6aeeaf8b05f32de35a9c9ded7879e16e7663"], "message": "Fix test build"}, {"sha": "cf97799db83e85170f763370c060fb3e27f339fc", "parents": ["4d297205c395456a516b75f9c3957ed1d93e9484"], "message": "Fix test"}, {"sha": "316c0afa9a4875692caaca03c01686e41f2bcbb5", "parents": ["cf97799db83e85170f763370c060fb3e27f339fc"], "message": "Remove unused arg"}, {"sha": "34b55c600e8ca0851e6ea94ab7c2e54c60f85461", "parents": ["316c0afa9a4875692caaca03c01686e41f2bcbb5"], "message": "Log errors on debug"}, {"sha": "4dadcfd9bdc6cc7159999ef527273b938716a836", "parents": ["34b55c600e8ca0851e6ea94ab7c2e54c60f85461"], "message": "Remove client.log check"}, {"sha": "11d71e6e228e16b645279211a90e0eda7173c7d9", "parents": ["4dadcfd9bdc6cc7159999ef527273b938716a836"], "message": "Ignore default log file"}, {"sha": "5882daf5d990592b64a8970b2ae3d385240f07cd", "parents": ["11d71e6e228e16b645279211a90e0eda7173c7d9"], "message": "Force relay connection, do not waste signaling resources on ICE connection (#4628)"}, {"sha": "4386a21956f7d2d4368e823e1e7a57f8310f5fd4", "parents": ["5882daf5d990592b64a8970b2ae3d385240f07cd", "f5301230bfef5d8b3abaf60634646793fa7b63ac"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "c20202a6c3af35ee137334fd1cbc952a4123407f", "parents": ["4386a21956f7d2d4368e823e1e7a57f8310f5fd4"], "message": "Add new flags to test"}, {"sha": "6f141349887d1e3e84fd79d80152877b2c5344bf", "parents": ["c20202a6c3af35ee137334fd1cbc952a4123407f", "d7321c130b56bc831bfdd8cbec5ff211d37e7de4"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "e6854dfd9955710919dc120613350ac67e0840bc", "parents": ["6f141349887d1e3e84fd79d80152877b2c5344bf"], "message": "Improve session logging"}, {"sha": "576b4a779c77d6958041842059865fdcd99d2888", "parents": ["e6854dfd9955710919dc120613350ac67e0840bc"], "message": "Log shell"}, {"sha": "a7a85d4dc8f30c6b12ff9182fb4d70157ed2db78", "parents": ["576b4a779c77d6958041842059865fdcd99d2888"], "message": "Fix tests"}, {"sha": "107066fa3da35ccf6171f7d3a6358a469d5d41d6", "parents": ["a7a85d4dc8f30c6b12ff9182fb4d70157ed2db78", "d3a34adcc948800e7d96b59e2b814348ef5569a0"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "e3bb8c1b7bbf5ac0a88526f72e14b46ebc5338db", "parents": ["107066fa3da35ccf6171f7d3a6358a469d5d41d6", "a2313a5ba4959a5550c242947a4faf3f9b0cde9b"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "6f817cad6d1962728cd48db76d24a7cd135eb227", "parents": ["e3bb8c1b7bbf5ac0a88526f72e14b46ebc5338db"], "message": "Remove duplicate code"}, {"sha": "8db91abfdf63e790fa11455719325e6941a94e0c", "parents": ["6f817cad6d1962728cd48db76d24a7cd135eb227", "c92e6c1b5fd040248b4fd36a2e397daeeb21ba9f"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "3779a3385f72e81f5d24eb1efa89bb7a9ad1e059", "parents": ["8db91abfdf63e790fa11455719325e6941a94e0c"], "message": "Fix tests"}, {"sha": "ce196ab9c63e817f0ae1d9431c520bb72e17e695", "parents": ["3779a3385f72e81f5d24eb1efa89bb7a9ad1e059"], "message": "[client, management] Move client-imported GPL code to separate package (#4692)"}, {"sha": "848c4e769f72ef413601e3b5c0414234356960e0", "parents": ["ce196ab9c63e817f0ae1d9431c520bb72e17e695"], "message": "Translate usernames to UPN format for domain login"}, {"sha": "9cfdc6e6e4b017a63de8d2e1b0e056d05d31c427", "parents": ["848c4e769f72ef413601e3b5c0414234356960e0", "229e0038ee643ec775d0670c030db70670ae298c"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "0a36d0d97c946f6d8dfdb1f3dd09ea4034cf569e", "parents": ["9cfdc6e6e4b017a63de8d2e1b0e056d05d31c427"], "message": "Fix login hint cycle"}, {"sha": "f6019b994e4f78ab091c1b304b45eb79a5fb3194", "parents": ["0a36d0d97c946f6d8dfdb1f3dd09ea4034cf569e"], "message": "Disable jwt cache by default and add flag"}, {"sha": "37e47464b8bedc0dd2a1ea54ed153c938115acfa", "parents": ["f6019b994e4f78ab091c1b304b45eb79a5fb3194", "2e16c9914a7ba92fa92f56c66c079e4dd1e0fd34"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "e61935893eecd297098f0921724984bcfd01aae7", "parents": ["37e47464b8bedc0dd2a1ea54ed153c938115acfa", "6aa4ba7af441c9c07fd76d7946e179ea5257e975"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "e1ef294448d96f014ee1d925181bc826b96cb0a5", "parents": ["e61935893eecd297098f0921724984bcfd01aae7"], "message": "Set default token age if mgmt sends 0"}, {"sha": "79c400a01c57339844ce8114fc91466e8c5a3ab5", "parents": ["e1ef294448d96f014ee1d925181bc826b96cb0a5", "dbfc8a52c932a4a246c07938eeabfaef78f66c3b"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "2d90799e940d5c196302652d91f48ea586389514", "parents": ["79c400a01c57339844ce8114fc91466e8c5a3ab5"], "message": "Fix tests after merge"}, {"sha": "25d2675a85c69567d962daa42c159c7c749c27ca", "parents": ["2d90799e940d5c196302652d91f48ea586389514"], "message": "[client] Add PTY support to ssh with a command (#4754)"}, {"sha": "5a78ecbdd04b21a2a07b3029b462771f66e6f893", "parents": ["25d2675a85c69567d962daa42c159c7c749c27ca"], "message": "[client] Add ssh server status output (#4760)"}, {"sha": "9176f8b2aa86b5c25ef3e86d66ef3699dc7553d9", "parents": ["5a78ecbdd04b21a2a07b3029b462771f66e6f893"], "message": "Address review"}, {"sha": "0c8dc0274d4d010b744bea2ed922fb490d34328a", "parents": ["9176f8b2aa86b5c25ef3e86d66ef3699dc7553d9"], "message": "Address rest of the review"}, {"sha": "619e35fd2a3f144d426f070a1d7e5f4f466526c3", "parents": ["0c8dc0274d4d010b744bea2ed922fb490d34328a"], "message": "Pass through exit code"}, {"sha": "f7a37ed0ac618d66b46b1bd0a07f9c35be100643", "parents": ["619e35fd2a3f144d426f070a1d7e5f4f466526c3"], "message": "Address more review comments"}, {"sha": "c8fae06555320e800ded474ab85b10ff908e3970", "parents": ["f7a37ed0ac618d66b46b1bd0a07f9c35be100643"], "message": "Fix long flags"}, {"sha": "706ad49e1b0ee6f65e60b4a9611ff0232040aac9", "parents": ["c8fae06555320e800ded474ab85b10ff908e3970", "e4b41d0ad70676b3f3f4a18f621b5467bd1c509c"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "30518f443a45b01343e7b4246e524191fc2ef215", "parents": ["706ad49e1b0ee6f65e60b4a9611ff0232040aac9"], "message": "Ignore no exit status err"}, {"sha": "0dfe473ab146d09d829c5791bea8dcaa8ba9a92f", "parents": ["30518f443a45b01343e7b4246e524191fc2ef215"], "message": "Fix invalid flag parsing"}, {"sha": "3c8c0972dc56ab8d5505a81d54af1245d04b7083", "parents": ["0dfe473ab146d09d829c5791bea8dcaa8ba9a92f"], "message": "Fix merge log msg"}, {"sha": "06042aa8813a4ec421654d8cd45363cc849e7170", "parents": ["3c8c0972dc56ab8d5505a81d54af1245d04b7083"], "message": "Fix lint"}, {"sha": "f518a895918c91e91cc47e3c35ab89a04bd19188", "parents": ["06042aa8813a4ec421654d8cd45363cc849e7170"], "message": "Fix ui detecting changes on ttl"}, {"sha": "5f6d415a25b250b9bf8276194009e8fb77146c03", "parents": ["f518a895918c91e91cc47e3c35ab89a04bd19188"], "message": "Remove hardcoded jwks path"}, {"sha": "8ee50ea31053602e229f075b01843c3c40d32e76", "parents": ["5f6d415a25b250b9bf8276194009e8fb77146c03"], "message": "Fix cli flag test"}, {"sha": "0812992a54006193a53c8c1a9684817f10c5a3ea", "parents": ["8ee50ea31053602e229f075b01843c3c40d32e76"], "message": "Check nil in priv result"}], "resolved_issues": [{"org": "netbirdio", "repo": "netbird", "number": -1, "state": "unknown", "title": "[client,management] Rewrite the SSH feature", "body": "## Describe your changes\r\n\r\n\r\n### NetBird SSH Client\r\n- Port forwarding\r\n- Windows support\r\n- Non-interactive commands\r\n- Single command execution over SSH\r\n\r\n### SSH Server\r\n- SFTP\r\n- Port forwarding (without user switching)\r\n- PTY (interactive, non-interactive)\r\n- Non-PTY (commands)\r\n- Windows support\r\n- JWT auth (user identity instead of machine identity, can be turned off) \r\n\r\n### New Flags\r\n```\r\n# server\r\n--enable-ssh-local-port-forwarding\r\n--enable-ssh-remote-port-forwarding\r\n--enable-ssh-root\r\n--enable-ssh-sftp\r\n--disable-ssh-auth\r\n\r\n# client\r\n--ssh-jwt-cache-ttl\r\n```\r\n\r\n### UI\r\n\r\n- Better organization\r\n<img width=\"608\" height=\"432\" alt=\"image\" src=\"https://github.com/user-attachments/assets/7e8f7415-7f7f-47f4-b945-d1e6135e8bd7\" />\r\n\r\n<img width=\"608\" height=\"432\" alt=\"image\" src=\"https://github.com/user-attachments/assets/d463c3d3-0742-4700-91ca-29db0b47c1f4\" />\r\n \r\n<img width=\"608\" height=\"432\" alt=\"image\" src=\"https://github.com/user-attachments/assets/8023d3de-f6fd-4c5d-8985-a49a452a6491\" />\r\n\r\n\r\n### Changes\r\n- Default port changed to 22022\r\n- Redirect port 22 to 22022 when SSH server enabled\r\n- Remove implicit OpenSSH firewall port\r\n- Management now passes its `jwks` config to peers with enabled ssh server\r\n- SSH server peers verify incoming clients' `jwt` with max token age \r\n- SSH clients request `jwt`s from the IdP and send these for authentication with remote ssh peers\r\n- Add `netbird ssh detect` command to detect if the remote peer is running the NetBird server\r\n- Add `netbird ssh proxy` command for native ssh and sftp clients. The proxy requests `jwt`s just like `netbird ssh`, passes them for authentication and bridges the connection between the native client and the remote server.\r\n- Add jwt capability to the wasm ssh client\r\n\r\n\r\n### Auth Flows\r\n\r\n  1. NetBird SSH Flow (`netbird ssh <peer>`)\r\n\r\n  ```mermaid\r\n  flowchart TD\r\n      A[User: netbird ssh &lt;peer&gt;] --> B[Connect to peer:22]\r\n      B --> C[Detect Server Type]\r\n      C --> D[Send 'netbird-detect' request]\r\n\r\n      D --> E{Server Response}\r\n\r\n      E -->|No NetBird identifier| F[Regular SSH Server]\r\n      E -->|NetBird + JWT required| G[NetBird with JWT Auth]\r\n      E -->|NetBird + No JWT| H[NetBird without JWT]\r\n\r\n      F --> I[Standard SSH Connection]\r\n      H --> I\r\n\r\n      G --> J[Request JWT from NetBird daemon]\r\n\r\n      J --> J1{Check JWT cache}\r\n      J1 -->|Cache valid| J2[Use cached JWT token]\r\n      J1 -->|No cache/expired| J3[OIDC flow:<br/>User authorizes via IDP callback]\r\n      J3 --> J4[Receive & cache JWT token]\r\n      J4 --> K[Connect to peer SSH server]\r\n      J2 --> K\r\n\r\n      K --> M[Send JWT authentication request]\r\n      M --> N{JWT Valid?}\r\n\r\n      N -->|No| O[Connection Rejected]\r\n      N -->|Yes| P[SSH Session Established]\r\n      I --> P\r\n\r\n      P --> Q[Interactive Shell / Execute Command / Port Forwarding]\r\n\r\n      style G fill:#f57c00,color:#fff\r\n      style J fill:#1976d2,color:#fff\r\n      style J1 fill:#1976d2,color:#fff\r\n      style J3 fill:#e65100,color:#fff\r\n      style P fill:#388e3c,color:#fff\r\n  ```\r\n\r\n  2. Native SSH Flow (e.g. openssh client)\r\n\r\n  ```mermaid\r\n  flowchart TD\r\n      A[User: ssh &lt;peer&gt;] --> B[OpenSSH loads config:<br/>/etc/ssh/ssh_config.d/99-netbird.conf]\r\n      B --> D{Host matches NetBird pattern?}\r\n\r\n      D -->|No| E[Standard SSH connection]\r\n\r\n      D -->|Yes| F[Run detection check:<br/>netbird ssh detect &lt;peer&gt; 22]\r\n      F --> G{Is NetBird SSH server?}\r\n\r\n      G -->|No| E\r\n\r\n      G -->|Yes - JWT required| H[Activate ProxyCommand:<br/>netbird ssh proxy &lt;peer&gt; 22]\r\n\r\n      H --> I[Local SSH Proxy Started]\r\n      I --> J[OpenSSH connects to proxy via stdio]\r\n\r\n      J --> K[Proxy requests JWT from daemon]\r\n\r\n      K --> K1{Check JWT cache}\r\n      K1 -->|Cache valid| K2[Use cached JWT token]\r\n      K1 -->|No cache/expired| K3[OIDC flow:<br/>User authorizes via IDP callback]\r\n      K3 --> K4[Receive & cache JWT token]\r\n      K4 --> L[Proxy connects to peer SSH server]\r\n      K2 --> L\r\n\r\n      L --> M[Proxy sends JWT authentication]\r\n\r\n      M --> N{JWT Valid?}\r\n      N -->|No| O[Connection Rejected]\r\n      N -->|Yes| P[Proxy establishes session]\r\n\r\n      P --> Q[Bidirectional forwarding:<br/>OpenSSH â†” Proxy â†” Peer SSH Server]\r\n\r\n      Q --> R[User interacts with remote shell]\r\n\r\n      style H fill:#f57c00,color:#fff\r\n      style I fill:#1976d2,color:#fff\r\n      style K fill:#1976d2,color:#fff\r\n      style K1 fill:#1976d2,color:#fff\r\n      style K3 fill:#e65100,color:#fff\r\n      style Q fill:#388e3c,color:#fff\r\n\r\n      classDef proxyBox fill:#1565c0,stroke:#0d47a1,stroke-width:2px,color:#fff\r\n      class I,K,L,M,P,Q proxyBox\r\n  ```\r\n\r\n## Issue ticket number and link\r\n\r\nFixes https://github.com/netbirdio/netbird/issues/4759 https://github.com/netbirdio/netbird/issues/4672 https://github.com/netbirdio/netbird/issues/4456  https://github.com/netbirdio/netbird/issues/4039 https://github.com/netbirdio/netbird/issues/3985 https://github.com/netbirdio/netbird/issues/2498 https://github.com/netbirdio/netbird/issues/4457\r\n\r\n\r\n## Stack\r\n\r\n<!-- branch-stack -->\r\n\r\n### Checklist\r\n- [x] Is it a bug fix\r\n- [ ] Is a typo/documentation fix\r\n- [x] Is a feature enhancement\r\n- [x] It is a refactor\r\n- [x] Created tests that fail without the change (if possible)\r\n- [ ] Extended the README / documentation, if necessary\r\n\r\n## Documentation\r\nSelect exactly one:\r\n\r\n- [x] I added/updated documentation for this change [ netbirdio/docs/pull/475 ]\r\n- [ ] Documentation is **not needed** for this change \r\n---\r\n\r\n\r\n> By submitting this pull request, you confirm that you have read and agree to the terms of the [Contributor License Agreement](https://github.com/netbirdio/netbird/blob/main/CONTRIBUTOR_LICENSE_AGREEMENT.md).\r\n\r\n\r\n<!-- This is an auto-generated comment: release notes by coderabbit.ai -->\r\n## Summary by CodeRabbit\r\n\r\n* **New Features**\r\n  * Complete SSH support: embedded SSH server and client (JWT-backed auth), SFTP, local/remote port forwarding, SSH proxy, host-key retrieval, session listing, SSH client config generation, server detection, and UI/WASM controls including SSH JWT cache TTL.\r\n* **Bug Fixes**\r\n  * License check made quieter and more robust by suppressing noisy errors during scanning.\r\n<!-- end of auto-generated comment: release notes by coderabbit.ai -->"}], "fix_patch": "diff --git a/.github/workflows/check-license-dependencies.yml b/.github/workflows/check-license-dependencies.yml\nindex 2a3e7d42413..543ba2ab223 100644\n--- a/.github/workflows/check-license-dependencies.yml\n+++ b/.github/workflows/check-license-dependencies.yml\n@@ -19,35 +19,37 @@ jobs:\n     runs-on: ubuntu-latest\n \n     steps:\n-    - uses: actions/checkout@v4\n+      - uses: actions/checkout@v4\n \n-    - name: Check for problematic license dependencies\n-      run: |\n-        echo \"Checking for dependencies on management/, signal/, and relay/ packages...\"\n-\n-        # Find all directories except the problematic ones and system dirs\n-        FOUND_ISSUES=0\n-        find . -maxdepth 1 -type d -not -name \".\" -not -name \"management\" -not -name \"signal\" -not -name \"relay\" -not -name \".git*\" | sort | while read dir; do\n-          echo \"=== Checking $dir ===\"\n-          # Search for problematic imports, excluding test files\n-          RESULTS=$(grep -r \"github.com/netbirdio/netbird/\\(management\\|signal\\|relay\\)\" \"$dir\" --include=\"*.go\" | grep -v \"_test.go\" | grep -v \"test_\" | grep -v \"/test/\" || true)\n-          if [ ! -z \"$RESULTS\" ]; then\n-            echo \"âŒ Found problematic dependencies:\"\n-            echo \"$RESULTS\"\n-            FOUND_ISSUES=1\n-          else\n-            echo \"âœ“ No problematic dependencies found\"\n-          fi\n-        done\n-        if [ $FOUND_ISSUES -eq 1 ]; then\n+      - name: Check for problematic license dependencies\n+        run: |\n+          echo \"Checking for dependencies on management/, signal/, and relay/ packages...\"\n           echo \"\"\n-          echo \"âŒ Found dependencies on management/, signal/, or relay/ packages\"\n-          echo \"These packages are licensed under AGPLv3 and must not be imported by BSD-licensed code\"\n-          exit 1\n-        else\n+\n+          # Find all directories except the problematic ones and system dirs\n+          FOUND_ISSUES=0\n+          while IFS= read -r dir; do\n+            echo \"=== Checking $dir ===\"\n+            # Search for problematic imports, excluding test files\n+            RESULTS=$(grep -r \"github.com/netbirdio/netbird/\\(management\\|signal\\|relay\\)\" \"$dir\" --include=\"*.go\" 2>/dev/null | grep -v \"_test.go\" | grep -v \"test_\" | grep -v \"/test/\" || true)\n+            if [ -n \"$RESULTS\" ]; then\n+              echo \"âŒ Found problematic dependencies:\"\n+              echo \"$RESULTS\"\n+              FOUND_ISSUES=1\n+            else\n+              echo \"âœ“ No problematic dependencies found\"\n+            fi\n+          done < <(find . -maxdepth 1 -type d -not -name \".\" -not -name \"management\" -not -name \"signal\" -not -name \"relay\" -not -name \".git*\" | sort)\n+\n           echo \"\"\n-          echo \"âœ… All internal license dependencies are clean\"\n-        fi\n+          if [ $FOUND_ISSUES -eq 1 ]; then\n+            echo \"âŒ Found dependencies on management/, signal/, or relay/ packages\"\n+            echo \"These packages are licensed under AGPLv3 and must not be imported by BSD-licensed code\"\n+            exit 1\n+          else\n+            echo \"\"\n+            echo \"âœ… All internal license dependencies are clean\"\n+          fi\n \n   check-external-licenses:\n     name: Check External GPL/AGPL Licenses\ndiff --git a/client/android/client.go b/client/android/client.go\nindex d2d0c37f65e..86fb1445d76 100644\n--- a/client/android/client.go\n+++ b/client/android/client.go\n@@ -17,9 +17,9 @@ import (\n \t\"github.com/netbirdio/netbird/client/internal/peer\"\n \t\"github.com/netbirdio/netbird/client/internal/profilemanager\"\n \t\"github.com/netbirdio/netbird/client/internal/stdnet\"\n+\t\"github.com/netbirdio/netbird/client/net\"\n \t\"github.com/netbirdio/netbird/client/system\"\n \t\"github.com/netbirdio/netbird/formatter\"\n-\t\"github.com/netbirdio/netbird/client/net\"\n )\n \n // ConnectionListener export internal Listener for mobile\ndiff --git a/client/android/preferences.go b/client/android/preferences.go\nindex 9a5d6bb21c1..c3c8eb3fbc9 100644\n--- a/client/android/preferences.go\n+++ b/client/android/preferences.go\n@@ -201,6 +201,94 @@ func (p *Preferences) SetServerSSHAllowed(allowed bool) {\n \tp.configInput.ServerSSHAllowed = &allowed\n }\n \n+// GetEnableSSHRoot reads SSH root login setting from config file\n+func (p *Preferences) GetEnableSSHRoot() (bool, error) {\n+\tif p.configInput.EnableSSHRoot != nil {\n+\t\treturn *p.configInput.EnableSSHRoot, nil\n+\t}\n+\n+\tcfg, err := profilemanager.ReadConfig(p.configInput.ConfigPath)\n+\tif err != nil {\n+\t\treturn false, err\n+\t}\n+\tif cfg.EnableSSHRoot == nil {\n+\t\t// Default to false for security on Android\n+\t\treturn false, nil\n+\t}\n+\treturn *cfg.EnableSSHRoot, err\n+}\n+\n+// SetEnableSSHRoot stores the given value and waits for commit\n+func (p *Preferences) SetEnableSSHRoot(enabled bool) {\n+\tp.configInput.EnableSSHRoot = &enabled\n+}\n+\n+// GetEnableSSHSFTP reads SSH SFTP setting from config file\n+func (p *Preferences) GetEnableSSHSFTP() (bool, error) {\n+\tif p.configInput.EnableSSHSFTP != nil {\n+\t\treturn *p.configInput.EnableSSHSFTP, nil\n+\t}\n+\n+\tcfg, err := profilemanager.ReadConfig(p.configInput.ConfigPath)\n+\tif err != nil {\n+\t\treturn false, err\n+\t}\n+\tif cfg.EnableSSHSFTP == nil {\n+\t\t// Default to false for security on Android\n+\t\treturn false, nil\n+\t}\n+\treturn *cfg.EnableSSHSFTP, err\n+}\n+\n+// SetEnableSSHSFTP stores the given value and waits for commit\n+func (p *Preferences) SetEnableSSHSFTP(enabled bool) {\n+\tp.configInput.EnableSSHSFTP = &enabled\n+}\n+\n+// GetEnableSSHLocalPortForwarding reads SSH local port forwarding setting from config file\n+func (p *Preferences) GetEnableSSHLocalPortForwarding() (bool, error) {\n+\tif p.configInput.EnableSSHLocalPortForwarding != nil {\n+\t\treturn *p.configInput.EnableSSHLocalPortForwarding, nil\n+\t}\n+\n+\tcfg, err := profilemanager.ReadConfig(p.configInput.ConfigPath)\n+\tif err != nil {\n+\t\treturn false, err\n+\t}\n+\tif cfg.EnableSSHLocalPortForwarding == nil {\n+\t\t// Default to false for security on Android\n+\t\treturn false, nil\n+\t}\n+\treturn *cfg.EnableSSHLocalPortForwarding, err\n+}\n+\n+// SetEnableSSHLocalPortForwarding stores the given value and waits for commit\n+func (p *Preferences) SetEnableSSHLocalPortForwarding(enabled bool) {\n+\tp.configInput.EnableSSHLocalPortForwarding = &enabled\n+}\n+\n+// GetEnableSSHRemotePortForwarding reads SSH remote port forwarding setting from config file\n+func (p *Preferences) GetEnableSSHRemotePortForwarding() (bool, error) {\n+\tif p.configInput.EnableSSHRemotePortForwarding != nil {\n+\t\treturn *p.configInput.EnableSSHRemotePortForwarding, nil\n+\t}\n+\n+\tcfg, err := profilemanager.ReadConfig(p.configInput.ConfigPath)\n+\tif err != nil {\n+\t\treturn false, err\n+\t}\n+\tif cfg.EnableSSHRemotePortForwarding == nil {\n+\t\t// Default to false for security on Android\n+\t\treturn false, nil\n+\t}\n+\treturn *cfg.EnableSSHRemotePortForwarding, err\n+}\n+\n+// SetEnableSSHRemotePortForwarding stores the given value and waits for commit\n+func (p *Preferences) SetEnableSSHRemotePortForwarding(enabled bool) {\n+\tp.configInput.EnableSSHRemotePortForwarding = &enabled\n+}\n+\n // GetBlockInbound reads block inbound setting from config file\n func (p *Preferences) GetBlockInbound() (bool, error) {\n \tif p.configInput.BlockInbound != nil {\ndiff --git a/client/cmd/root.go b/client/cmd/root.go\nindex 11e5228f1e4..9f2eb109c5e 100644\n--- a/client/cmd/root.go\n+++ b/client/cmd/root.go\n@@ -35,7 +35,6 @@ const (\n \twireguardPortFlag        = \"wireguard-port\"\n \tnetworkMonitorFlag       = \"network-monitor\"\n \tdisableAutoConnectFlag   = \"disable-auto-connect\"\n-\tserverSSHAllowedFlag     = \"allow-server-ssh\"\n \textraIFaceBlackListFlag  = \"extra-iface-blacklist\"\n \tdnsRouteIntervalFlag     = \"dns-router-interval\"\n \tenableLazyConnectionFlag = \"enable-lazy-connection\"\n@@ -64,7 +63,6 @@ var (\n \tcustomDNSAddress        string\n \trosenpassEnabled        bool\n \trosenpassPermissive     bool\n-\tserverSSHAllowed        bool\n \tinterfaceName           string\n \twireguardPort           uint16\n \tnetworkMonitor          bool\n@@ -176,7 +174,6 @@ func init() {\n \t)\n \tupCmd.PersistentFlags().BoolVar(&rosenpassEnabled, enableRosenpassFlag, false, \"[Experimental] Enable Rosenpass feature. If enabled, the connection will be post-quantum secured via Rosenpass.\")\n \tupCmd.PersistentFlags().BoolVar(&rosenpassPermissive, rosenpassPermissiveFlag, false, \"[Experimental] Enable Rosenpass in permissive mode to allow this peer to accept WireGuard connections without requiring Rosenpass functionality from peers that do not have Rosenpass enabled.\")\n-\tupCmd.PersistentFlags().BoolVar(&serverSSHAllowed, serverSSHAllowedFlag, false, \"Allow SSH server on peer. If enabled, the SSH server will be permitted\")\n \tupCmd.PersistentFlags().BoolVar(&autoConnectDisabled, disableAutoConnectFlag, false, \"Disables auto-connect feature. If enabled, then the client won't connect automatically when the service starts.\")\n \tupCmd.PersistentFlags().BoolVar(&lazyConnEnabled, enableLazyConnectionFlag, false, \"[Experimental] Enable the lazy connection feature. If enabled, the client will establish connections on-demand. Note: this setting may be overridden by management configuration.\")\n \ndiff --git a/client/cmd/ssh.go b/client/cmd/ssh.go\nindex 5358ddacbd6..70c7dbcffe9 100644\n--- a/client/cmd/ssh.go\n+++ b/client/cmd/ssh.go\n@@ -3,125 +3,809 @@ package cmd\n import (\n \t\"context\"\n \t\"errors\"\n+\t\"flag\"\n \t\"fmt\"\n+\t\"net\"\n \t\"os\"\n \t\"os/signal\"\n+\t\"os/user\"\n+\t\"slices\"\n+\t\"strconv\"\n \t\"strings\"\n \t\"syscall\"\n \n+\tlog \"github.com/sirupsen/logrus\"\n \t\"github.com/spf13/cobra\"\n+\t\"golang.org/x/crypto/ssh\"\n \n \t\"github.com/netbirdio/netbird/client/internal\"\n-\t\"github.com/netbirdio/netbird/client/internal/profilemanager\"\n-\tnbssh \"github.com/netbirdio/netbird/client/ssh\"\n+\tsshclient \"github.com/netbirdio/netbird/client/ssh/client\"\n+\t\"github.com/netbirdio/netbird/client/ssh/detection\"\n+\tsshproxy \"github.com/netbirdio/netbird/client/ssh/proxy\"\n+\tsshserver \"github.com/netbirdio/netbird/client/ssh/server\"\n \t\"github.com/netbirdio/netbird/util\"\n )\n \n+const (\n+\tsshUsernameDesc      = \"SSH username\"\n+\thostArgumentRequired = \"host argument required\"\n+\n+\tserverSSHAllowedFlag           = \"allow-server-ssh\"\n+\tenableSSHRootFlag              = \"enable-ssh-root\"\n+\tenableSSHSFTPFlag              = \"enable-ssh-sftp\"\n+\tenableSSHLocalPortForwardFlag  = \"enable-ssh-local-port-forwarding\"\n+\tenableSSHRemotePortForwardFlag = \"enable-ssh-remote-port-forwarding\"\n+\tdisableSSHAuthFlag             = \"disable-ssh-auth\"\n+\tsshJWTCacheTTLFlag             = \"ssh-jwt-cache-ttl\"\n+)\n+\n+var (\n+\tport                  int\n+\tusername              string\n+\thost                  string\n+\tcommand               string\n+\tlocalForwards         []string\n+\tremoteForwards        []string\n+\tstrictHostKeyChecking bool\n+\tknownHostsFile        string\n+\tidentityFile          string\n+\tskipCachedToken       bool\n+\trequestPTY            bool\n+)\n+\n var (\n-\tport     int\n-\tuserName = \"root\"\n-\thost     string\n+\tserverSSHAllowed           bool\n+\tenableSSHRoot              bool\n+\tenableSSHSFTP              bool\n+\tenableSSHLocalPortForward  bool\n+\tenableSSHRemotePortForward bool\n+\tdisableSSHAuth             bool\n+\tsshJWTCacheTTL             int\n )\n \n+func init() {\n+\tupCmd.PersistentFlags().BoolVar(&serverSSHAllowed, serverSSHAllowedFlag, false, \"Allow SSH server on peer\")\n+\tupCmd.PersistentFlags().BoolVar(&enableSSHRoot, enableSSHRootFlag, false, \"Enable root login for SSH server\")\n+\tupCmd.PersistentFlags().BoolVar(&enableSSHSFTP, enableSSHSFTPFlag, false, \"Enable SFTP subsystem for SSH server\")\n+\tupCmd.PersistentFlags().BoolVar(&enableSSHLocalPortForward, enableSSHLocalPortForwardFlag, false, \"Enable local port forwarding for SSH server\")\n+\tupCmd.PersistentFlags().BoolVar(&enableSSHRemotePortForward, enableSSHRemotePortForwardFlag, false, \"Enable remote port forwarding for SSH server\")\n+\tupCmd.PersistentFlags().BoolVar(&disableSSHAuth, disableSSHAuthFlag, false, \"Disable SSH authentication\")\n+\tupCmd.PersistentFlags().IntVar(&sshJWTCacheTTL, sshJWTCacheTTLFlag, 0, \"SSH JWT token cache TTL in seconds (0=disabled)\")\n+\n+\tsshCmd.PersistentFlags().IntVarP(&port, \"port\", \"p\", sshserver.DefaultSSHPort, \"Remote SSH port\")\n+\tsshCmd.PersistentFlags().StringVarP(&username, \"user\", \"u\", \"\", sshUsernameDesc)\n+\tsshCmd.PersistentFlags().StringVar(&username, \"login\", \"\", sshUsernameDesc+\" (alias for --user)\")\n+\tsshCmd.PersistentFlags().BoolVarP(&requestPTY, \"tty\", \"t\", false, \"Force pseudo-terminal allocation\")\n+\tsshCmd.PersistentFlags().BoolVar(&strictHostKeyChecking, \"strict-host-key-checking\", true, \"Enable strict host key checking (default: true)\")\n+\tsshCmd.PersistentFlags().StringVarP(&knownHostsFile, \"known-hosts\", \"o\", \"\", \"Path to known_hosts file (default: ~/.ssh/known_hosts)\")\n+\tsshCmd.PersistentFlags().StringVarP(&identityFile, \"identity\", \"i\", \"\", \"Path to SSH private key file (deprecated)\")\n+\t_ = sshCmd.PersistentFlags().MarkDeprecated(\"identity\", \"this flag is no longer used\")\n+\tsshCmd.PersistentFlags().BoolVar(&skipCachedToken, \"no-cache\", false, \"Skip cached JWT token and force fresh authentication\")\n+\n+\tsshCmd.PersistentFlags().StringArrayP(\"L\", \"L\", []string{}, \"Local port forwarding [bind_address:]port:host:hostport\")\n+\tsshCmd.PersistentFlags().StringArrayP(\"R\", \"R\", []string{}, \"Remote port forwarding [bind_address:]port:host:hostport\")\n+\n+\tsshCmd.AddCommand(sshSftpCmd)\n+\tsshCmd.AddCommand(sshProxyCmd)\n+\tsshCmd.AddCommand(sshDetectCmd)\n+}\n+\n var sshCmd = &cobra.Command{\n-\tUse: \"ssh [user@]host\",\n-\tArgs: func(cmd *cobra.Command, args []string) error {\n-\t\tif len(args) < 1 {\n-\t\t\treturn errors.New(\"requires a host argument\")\n+\tUse:   \"ssh [flags] [user@]host [command]\",\n+\tShort: \"Connect to a NetBird peer via SSH\",\n+\tLong: `Connect to a NetBird peer using SSH with support for port forwarding.\n+\n+Port Forwarding:\n+  -L [bind_address:]port:host:hostport   Local port forwarding\n+  -L [bind_address:]port:/path/to/socket Local port forwarding to Unix socket\n+  -R [bind_address:]port:host:hostport   Remote port forwarding\n+  -R [bind_address:]port:/path/to/socket Remote port forwarding to Unix socket\n+\n+SSH Options:\n+  -p, --port int                       Remote SSH port (default 22)\n+  -u, --user string                    SSH username\n+      --login string                   SSH username (alias for --user)\n+  -t, --tty                            Force pseudo-terminal allocation\n+      --strict-host-key-checking       Enable strict host key checking (default: true)\n+  -o, --known-hosts string             Path to known_hosts file\n+\n+Examples:\n+  netbird ssh peer-hostname\n+  netbird ssh root@peer-hostname\n+  netbird ssh --login root peer-hostname\n+  netbird ssh peer-hostname ls -la\n+  netbird ssh peer-hostname whoami\n+  netbird ssh -t peer-hostname tmux                  # Force PTY for tmux/screen\n+  netbird ssh -t peer-hostname sudo -i               # Force PTY for interactive sudo\n+  netbird ssh -L 8080:localhost:80 peer-hostname     # Local port forwarding\n+  netbird ssh -R 9090:localhost:3000 peer-hostname   # Remote port forwarding\n+  netbird ssh -L \"*:8080:localhost:80\" peer-hostname # Bind to all interfaces\n+  netbird ssh -L 8080:/tmp/socket peer-hostname      # Unix socket forwarding`,\n+\tDisableFlagParsing: true,\n+\tArgs:               validateSSHArgsWithoutFlagParsing,\n+\tRunE:               sshFn,\n+\tAliases:            []string{\"ssh\"},\n+}\n+\n+func sshFn(cmd *cobra.Command, args []string) error {\n+\tfor _, arg := range args {\n+\t\tif arg == \"-h\" || arg == \"--help\" {\n+\t\t\treturn cmd.Help()\n \t\t}\n+\t}\n \n-\t\tsplit := strings.Split(args[0], \"@\")\n-\t\tif len(split) == 2 {\n-\t\t\tuserName = split[0]\n-\t\t\thost = split[1]\n-\t\t} else {\n-\t\t\thost = args[0]\n+\tSetFlagsFromEnvVars(rootCmd)\n+\tSetFlagsFromEnvVars(cmd)\n+\n+\tcmd.SetOut(cmd.OutOrStdout())\n+\n+\tlogOutput := \"console\"\n+\tif firstLogFile := util.FindFirstLogPath(logFiles); firstLogFile != \"\" && firstLogFile != defaultLogFile {\n+\t\tlogOutput = firstLogFile\n+\t}\n+\tif err := util.InitLog(logLevel, logOutput); err != nil {\n+\t\treturn fmt.Errorf(\"init log: %w\", err)\n+\t}\n+\n+\tctx := internal.CtxInitState(cmd.Context())\n+\n+\tsig := make(chan os.Signal, 1)\n+\tsignal.Notify(sig, syscall.SIGTERM, syscall.SIGINT)\n+\tsshctx, cancel := context.WithCancel(ctx)\n+\n+\terrCh := make(chan error, 1)\n+\tgo func() {\n+\t\tif err := runSSH(sshctx, host, cmd); err != nil {\n+\t\t\terrCh <- err\n \t\t}\n+\t\tcancel()\n+\t}()\n \n+\tselect {\n+\tcase <-sig:\n+\t\tcancel()\n+\t\t<-sshctx.Done()\n \t\treturn nil\n-\t},\n-\tShort: \"Connect to a remote SSH server\",\n-\tRunE: func(cmd *cobra.Command, args []string) error {\n-\t\tSetFlagsFromEnvVars(rootCmd)\n-\t\tSetFlagsFromEnvVars(cmd)\n+\tcase err := <-errCh:\n+\t\treturn err\n+\tcase <-sshctx.Done():\n+\t}\n \n-\t\tcmd.SetOut(cmd.OutOrStdout())\n+\treturn nil\n+}\n \n-\t\terr := util.InitLog(logLevel, util.LogConsole)\n-\t\tif err != nil {\n-\t\t\treturn fmt.Errorf(\"failed initializing log %v\", err)\n+// getEnvOrDefault checks for environment variables with WT_ and NB_ prefixes\n+func getEnvOrDefault(flagName, defaultValue string) string {\n+\tif envValue := os.Getenv(\"WT_\" + flagName); envValue != \"\" {\n+\t\treturn envValue\n+\t}\n+\tif envValue := os.Getenv(\"NB_\" + flagName); envValue != \"\" {\n+\t\treturn envValue\n+\t}\n+\treturn defaultValue\n+}\n+\n+// resetSSHGlobals sets SSH globals to their default values\n+func resetSSHGlobals() {\n+\tport = sshserver.DefaultSSHPort\n+\tusername = \"\"\n+\thost = \"\"\n+\tcommand = \"\"\n+\tlocalForwards = nil\n+\tremoteForwards = nil\n+\tstrictHostKeyChecking = true\n+\tknownHostsFile = \"\"\n+\tidentityFile = \"\"\n+}\n+\n+// parseCustomSSHFlags extracts -L, -R flags and returns filtered args\n+func parseCustomSSHFlags(args []string) ([]string, []string, []string) {\n+\tvar localForwardFlags []string\n+\tvar remoteForwardFlags []string\n+\tvar filteredArgs []string\n+\n+\tfor i := 0; i < len(args); i++ {\n+\t\targ := args[i]\n+\t\tswitch {\n+\t\tcase strings.HasPrefix(arg, \"-L\"):\n+\t\t\tlocalForwardFlags, i = parseForwardFlag(arg, args, i, localForwardFlags)\n+\t\tcase strings.HasPrefix(arg, \"-R\"):\n+\t\t\tremoteForwardFlags, i = parseForwardFlag(arg, args, i, remoteForwardFlags)\n+\t\tdefault:\n+\t\t\tfilteredArgs = append(filteredArgs, arg)\n \t\t}\n+\t}\n \n-\t\tif !util.IsAdmin() {\n-\t\t\tcmd.Printf(\"error: you must have Administrator privileges to run this command\\n\")\n-\t\t\treturn nil\n+\treturn filteredArgs, localForwardFlags, remoteForwardFlags\n+}\n+\n+func parseForwardFlag(arg string, args []string, i int, flags []string) ([]string, int) {\n+\tif arg == \"-L\" || arg == \"-R\" {\n+\t\tif i+1 < len(args) {\n+\t\t\tflags = append(flags, args[i+1])\n+\t\t\ti++\n \t\t}\n+\t} else if len(arg) > 2 {\n+\t\tflags = append(flags, arg[2:])\n+\t}\n+\treturn flags, i\n+}\n+\n+// extractGlobalFlags parses global flags that were passed before 'ssh' command\n+func extractGlobalFlags(args []string) {\n+\tsshPos := findSSHCommandPosition(args)\n+\tif sshPos == -1 {\n+\t\treturn\n+\t}\n \n-\t\tctx := internal.CtxInitState(cmd.Context())\n+\tglobalArgs := args[:sshPos]\n+\tparseGlobalArgs(globalArgs)\n+}\n \n-\t\tsm := profilemanager.NewServiceManager(configPath)\n-\t\tactiveProf, err := sm.GetActiveProfileState()\n-\t\tif err != nil {\n-\t\t\treturn fmt.Errorf(\"get active profile: %v\", err)\n+// findSSHCommandPosition locates the 'ssh' command in the argument list\n+func findSSHCommandPosition(args []string) int {\n+\tfor i, arg := range args {\n+\t\tif arg == \"ssh\" {\n+\t\t\treturn i\n \t\t}\n-\t\tprofPath, err := activeProf.FilePath()\n-\t\tif err != nil {\n-\t\t\treturn fmt.Errorf(\"get active profile path: %v\", err)\n+\t}\n+\treturn -1\n+}\n+\n+const (\n+\tconfigFlag   = \"config\"\n+\tlogLevelFlag = \"log-level\"\n+\tlogFileFlag  = \"log-file\"\n+)\n+\n+// parseGlobalArgs processes the global arguments and sets the corresponding variables\n+func parseGlobalArgs(globalArgs []string) {\n+\tflagHandlers := map[string]func(string){\n+\t\tconfigFlag:   func(value string) { configPath = value },\n+\t\tlogLevelFlag: func(value string) { logLevel = value },\n+\t\tlogFileFlag: func(value string) {\n+\t\t\tif !slices.Contains(logFiles, value) {\n+\t\t\t\tlogFiles = append(logFiles, value)\n+\t\t\t}\n+\t\t},\n+\t}\n+\n+\tshortFlags := map[string]string{\n+\t\t\"c\": configFlag,\n+\t\t\"l\": logLevelFlag,\n+\t}\n+\n+\tfor i := 0; i < len(globalArgs); i++ {\n+\t\targ := globalArgs[i]\n+\n+\t\tif handled, nextIndex := parseFlag(arg, globalArgs, i, flagHandlers, shortFlags); handled {\n+\t\t\ti = nextIndex\n+\t\t}\n+\t}\n+}\n+\n+// parseFlag handles generic flag parsing for both long and short forms\n+func parseFlag(arg string, args []string, currentIndex int, flagHandlers map[string]func(string), shortFlags map[string]string) (bool, int) {\n+\tif parsedValue, found := parseEqualsFormat(arg, flagHandlers, shortFlags); found {\n+\t\tflagHandlers[parsedValue.flagName](parsedValue.value)\n+\t\treturn true, currentIndex\n+\t}\n+\n+\tif parsedValue, found := parseSpacedFormat(arg, args, currentIndex, flagHandlers, shortFlags); found {\n+\t\tflagHandlers[parsedValue.flagName](parsedValue.value)\n+\t\treturn true, currentIndex + 1\n+\t}\n+\n+\treturn false, currentIndex\n+}\n+\n+type parsedFlag struct {\n+\tflagName string\n+\tvalue    string\n+}\n+\n+// parseEqualsFormat handles --flag=value and -f=value formats\n+func parseEqualsFormat(arg string, flagHandlers map[string]func(string), shortFlags map[string]string) (parsedFlag, bool) {\n+\tif !strings.Contains(arg, \"=\") {\n+\t\treturn parsedFlag{}, false\n+\t}\n+\n+\tparts := strings.SplitN(arg, \"=\", 2)\n+\tif len(parts) != 2 {\n+\t\treturn parsedFlag{}, false\n+\t}\n+\n+\tif strings.HasPrefix(parts[0], \"--\") {\n+\t\tflagName := strings.TrimPrefix(parts[0], \"--\")\n+\t\tif _, exists := flagHandlers[flagName]; exists {\n+\t\t\treturn parsedFlag{flagName: flagName, value: parts[1]}, true\n \t\t}\n+\t}\n \n-\t\tconfig, err := profilemanager.ReadConfig(profPath)\n-\t\tif err != nil {\n-\t\t\treturn fmt.Errorf(\"read profile config: %v\", err)\n+\tif strings.HasPrefix(parts[0], \"-\") && len(parts[0]) == 2 {\n+\t\tshortFlag := strings.TrimPrefix(parts[0], \"-\")\n+\t\tif longFlag, exists := shortFlags[shortFlag]; exists {\n+\t\t\tif _, exists := flagHandlers[longFlag]; exists {\n+\t\t\t\treturn parsedFlag{flagName: longFlag, value: parts[1]}, true\n+\t\t\t}\n \t\t}\n+\t}\n+\n+\treturn parsedFlag{}, false\n+}\n+\n+// parseSpacedFormat handles --flag value and -f value formats\n+func parseSpacedFormat(arg string, args []string, currentIndex int, flagHandlers map[string]func(string), shortFlags map[string]string) (parsedFlag, bool) {\n+\tif currentIndex+1 >= len(args) {\n+\t\treturn parsedFlag{}, false\n+\t}\n \n-\t\tsig := make(chan os.Signal, 1)\n-\t\tsignal.Notify(sig, syscall.SIGTERM, syscall.SIGINT)\n-\t\tsshctx, cancel := context.WithCancel(ctx)\n+\tif strings.HasPrefix(arg, \"--\") {\n+\t\tflagName := strings.TrimPrefix(arg, \"--\")\n+\t\tif _, exists := flagHandlers[flagName]; exists {\n+\t\t\treturn parsedFlag{flagName: flagName, value: args[currentIndex+1]}, true\n+\t\t}\n+\t}\n \n-\t\tgo func() {\n-\t\t\t// blocking\n-\t\t\tif err := runSSH(sshctx, host, []byte(config.SSHKey), cmd); err != nil {\n-\t\t\t\tcmd.Printf(\"Error: %v\\n\", err)\n-\t\t\t\tos.Exit(1)\n+\tif strings.HasPrefix(arg, \"-\") && len(arg) == 2 {\n+\t\tshortFlag := strings.TrimPrefix(arg, \"-\")\n+\t\tif longFlag, exists := shortFlags[shortFlag]; exists {\n+\t\t\tif _, exists := flagHandlers[longFlag]; exists {\n+\t\t\t\treturn parsedFlag{flagName: longFlag, value: args[currentIndex+1]}, true\n \t\t\t}\n-\t\t\tcancel()\n-\t\t}()\n+\t\t}\n+\t}\n+\n+\treturn parsedFlag{}, false\n+}\n+\n+// createSSHFlagSet creates and configures the flag set for SSH command parsing\n+// sshFlags contains all SSH-related flags and parameters\n+type sshFlags struct {\n+\tPort                  int\n+\tUsername              string\n+\tLogin                 string\n+\tRequestPTY            bool\n+\tStrictHostKeyChecking bool\n+\tKnownHostsFile        string\n+\tIdentityFile          string\n+\tSkipCachedToken       bool\n+\tConfigPath            string\n+\tLogLevel              string\n+\tLocalForwards         []string\n+\tRemoteForwards        []string\n+\tHost                  string\n+\tCommand               string\n+}\n+\n+func createSSHFlagSet() (*flag.FlagSet, *sshFlags) {\n+\tdefaultConfigPath := getEnvOrDefault(\"CONFIG\", configPath)\n+\tdefaultLogLevel := getEnvOrDefault(\"LOG_LEVEL\", logLevel)\n+\n+\tfs := flag.NewFlagSet(\"ssh-flags\", flag.ContinueOnError)\n+\tfs.SetOutput(nil)\n+\n+\tflags := &sshFlags{}\n+\n+\tfs.IntVar(&flags.Port, \"p\", sshserver.DefaultSSHPort, \"SSH port\")\n+\tfs.IntVar(&flags.Port, \"port\", sshserver.DefaultSSHPort, \"SSH port\")\n+\tfs.StringVar(&flags.Username, \"u\", \"\", sshUsernameDesc)\n+\tfs.StringVar(&flags.Username, \"user\", \"\", sshUsernameDesc)\n+\tfs.StringVar(&flags.Login, \"login\", \"\", sshUsernameDesc+\" (alias for --user)\")\n+\tfs.BoolVar(&flags.RequestPTY, \"t\", false, \"Force pseudo-terminal allocation\")\n+\tfs.BoolVar(&flags.RequestPTY, \"tty\", false, \"Force pseudo-terminal allocation\")\n+\n+\tfs.BoolVar(&flags.StrictHostKeyChecking, \"strict-host-key-checking\", true, \"Enable strict host key checking\")\n+\tfs.StringVar(&flags.KnownHostsFile, \"o\", \"\", \"Path to known_hosts file\")\n+\tfs.StringVar(&flags.KnownHostsFile, \"known-hosts\", \"\", \"Path to known_hosts file\")\n+\tfs.StringVar(&flags.IdentityFile, \"i\", \"\", \"Path to SSH private key file\")\n+\tfs.StringVar(&flags.IdentityFile, \"identity\", \"\", \"Path to SSH private key file\")\n+\tfs.BoolVar(&flags.SkipCachedToken, \"no-cache\", false, \"Skip cached JWT token and force fresh authentication\")\n \n-\t\tselect {\n-\t\tcase <-sig:\n-\t\t\tcancel()\n-\t\tcase <-sshctx.Done():\n+\tfs.StringVar(&flags.ConfigPath, \"c\", defaultConfigPath, \"Netbird config file location\")\n+\tfs.StringVar(&flags.ConfigPath, \"config\", defaultConfigPath, \"Netbird config file location\")\n+\tfs.StringVar(&flags.LogLevel, \"l\", defaultLogLevel, \"sets Netbird log level\")\n+\tfs.StringVar(&flags.LogLevel, \"log-level\", defaultLogLevel, \"sets Netbird log level\")\n+\n+\treturn fs, flags\n+}\n+\n+func validateSSHArgsWithoutFlagParsing(_ *cobra.Command, args []string) error {\n+\tif len(args) < 1 {\n+\t\treturn errors.New(hostArgumentRequired)\n+\t}\n+\n+\tresetSSHGlobals()\n+\n+\tif len(os.Args) > 2 {\n+\t\textractGlobalFlags(os.Args[1:])\n+\t}\n+\n+\tfilteredArgs, localForwardFlags, remoteForwardFlags := parseCustomSSHFlags(args)\n+\n+\tfs, flags := createSSHFlagSet()\n+\n+\tif err := fs.Parse(filteredArgs); err != nil {\n+\t\tif errors.Is(err, flag.ErrHelp) {\n+\t\t\treturn nil\n \t\t}\n+\t\treturn err\n+\t}\n \n-\t\treturn nil\n-\t},\n+\tremaining := fs.Args()\n+\tif len(remaining) < 1 {\n+\t\treturn errors.New(hostArgumentRequired)\n+\t}\n+\n+\tport = flags.Port\n+\tif flags.Username != \"\" {\n+\t\tusername = flags.Username\n+\t} else if flags.Login != \"\" {\n+\t\tusername = flags.Login\n+\t}\n+\n+\trequestPTY = flags.RequestPTY\n+\tstrictHostKeyChecking = flags.StrictHostKeyChecking\n+\tknownHostsFile = flags.KnownHostsFile\n+\tidentityFile = flags.IdentityFile\n+\tskipCachedToken = flags.SkipCachedToken\n+\n+\tif flags.ConfigPath != getEnvOrDefault(\"CONFIG\", configPath) {\n+\t\tconfigPath = flags.ConfigPath\n+\t}\n+\tif flags.LogLevel != getEnvOrDefault(\"LOG_LEVEL\", logLevel) {\n+\t\tlogLevel = flags.LogLevel\n+\t}\n+\n+\tlocalForwards = localForwardFlags\n+\tremoteForwards = remoteForwardFlags\n+\n+\treturn parseHostnameAndCommand(remaining)\n }\n \n-func runSSH(ctx context.Context, addr string, pemKey []byte, cmd *cobra.Command) error {\n-\tc, err := nbssh.DialWithKey(fmt.Sprintf(\"%s:%d\", addr, port), userName, pemKey)\n+func parseHostnameAndCommand(args []string) error {\n+\tif len(args) < 1 {\n+\t\treturn errors.New(hostArgumentRequired)\n+\t}\n+\n+\targ := args[0]\n+\tif strings.Contains(arg, \"@\") {\n+\t\tparts := strings.SplitN(arg, \"@\", 2)\n+\t\tif len(parts) != 2 || parts[0] == \"\" || parts[1] == \"\" {\n+\t\t\treturn errors.New(\"invalid user@host format\")\n+\t\t}\n+\t\tif username == \"\" {\n+\t\t\tusername = parts[0]\n+\t\t}\n+\t\thost = parts[1]\n+\t} else {\n+\t\thost = arg\n+\t}\n+\n+\tif username == \"\" {\n+\t\tif sudoUser := os.Getenv(\"SUDO_USER\"); sudoUser != \"\" {\n+\t\t\tusername = sudoUser\n+\t\t} else if currentUser, err := user.Current(); err == nil {\n+\t\t\tusername = currentUser.Username\n+\t\t} else {\n+\t\t\tusername = \"root\"\n+\t\t}\n+\t}\n+\n+\t// Everything after hostname becomes the command\n+\tif len(args) > 1 {\n+\t\tcommand = strings.Join(args[1:], \" \")\n+\t}\n+\n+\treturn nil\n+}\n+\n+func runSSH(ctx context.Context, addr string, cmd *cobra.Command) error {\n+\ttarget := fmt.Sprintf(\"%s:%d\", addr, port)\n+\tc, err := sshclient.Dial(ctx, target, username, sshclient.DialOptions{\n+\t\tKnownHostsFile:     knownHostsFile,\n+\t\tIdentityFile:       identityFile,\n+\t\tDaemonAddr:         daemonAddr,\n+\t\tSkipCachedToken:    skipCachedToken,\n+\t\tInsecureSkipVerify: !strictHostKeyChecking,\n+\t})\n+\n+\tif err != nil {\n+\t\tcmd.Printf(\"Failed to connect to %s@%s\\n\", username, target)\n+\t\tcmd.Printf(\"\\nTroubleshooting steps:\\n\")\n+\t\tcmd.Printf(\"  1. Check peer connectivity: netbird status -d\\n\")\n+\t\tcmd.Printf(\"  2. Verify SSH server is enabled on the peer\\n\")\n+\t\tcmd.Printf(\"  3. Ensure correct hostname/IP is used\\n\")\n+\t\treturn fmt.Errorf(\"dial %s: %w\", target, err)\n+\t}\n+\n+\tsshCtx, cancel := context.WithCancel(ctx)\n+\tdefer cancel()\n+\n+\tgo func() {\n+\t\t<-sshCtx.Done()\n+\t\tif err := c.Close(); err != nil {\n+\t\t\tcmd.Printf(\"Error closing SSH connection: %v\\n\", err)\n+\t\t}\n+\t}()\n+\n+\tif err := startPortForwarding(sshCtx, c, cmd); err != nil {\n+\t\treturn fmt.Errorf(\"start port forwarding: %w\", err)\n+\t}\n+\n+\tif command != \"\" {\n+\t\treturn executeSSHCommand(sshCtx, c, command)\n+\t}\n+\treturn openSSHTerminal(sshCtx, c)\n+}\n+\n+// executeSSHCommand executes a command over SSH.\n+func executeSSHCommand(ctx context.Context, c *sshclient.Client, command string) error {\n+\tvar err error\n+\tif requestPTY {\n+\t\terr = c.ExecuteCommandWithPTY(ctx, command)\n+\t} else {\n+\t\terr = c.ExecuteCommandWithIO(ctx, command)\n+\t}\n+\n+\tif err != nil {\n+\t\tif errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) {\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\tvar exitErr *ssh.ExitError\n+\t\tif errors.As(err, &exitErr) {\n+\t\t\tos.Exit(exitErr.ExitStatus())\n+\t\t}\n+\n+\t\tvar exitMissingErr *ssh.ExitMissingError\n+\t\tif errors.As(err, &exitMissingErr) {\n+\t\t\tlog.Debugf(\"Remote command exited without exit status: %v\", err)\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\treturn fmt.Errorf(\"execute command: %w\", err)\n+\t}\n+\treturn nil\n+}\n+\n+// openSSHTerminal opens an interactive SSH terminal.\n+func openSSHTerminal(ctx context.Context, c *sshclient.Client) error {\n+\tif err := c.OpenTerminal(ctx); err != nil {\n+\t\tif errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) {\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\tvar exitMissingErr *ssh.ExitMissingError\n+\t\tif errors.As(err, &exitMissingErr) {\n+\t\t\tlog.Debugf(\"Remote terminal exited without exit status: %v\", err)\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\treturn fmt.Errorf(\"open terminal: %w\", err)\n+\t}\n+\treturn nil\n+}\n+\n+// startPortForwarding starts local and remote port forwarding based on command line flags\n+func startPortForwarding(ctx context.Context, c *sshclient.Client, cmd *cobra.Command) error {\n+\tfor _, forward := range localForwards {\n+\t\tif err := parseAndStartLocalForward(ctx, c, forward, cmd); err != nil {\n+\t\t\treturn fmt.Errorf(\"local port forward %s: %w\", forward, err)\n+\t\t}\n+\t}\n+\n+\tfor _, forward := range remoteForwards {\n+\t\tif err := parseAndStartRemoteForward(ctx, c, forward, cmd); err != nil {\n+\t\t\treturn fmt.Errorf(\"remote port forward %s: %w\", forward, err)\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// parseAndStartLocalForward parses and starts a local port forward (-L)\n+func parseAndStartLocalForward(ctx context.Context, c *sshclient.Client, forward string, cmd *cobra.Command) error {\n+\tlocalAddr, remoteAddr, err := parsePortForwardSpec(forward)\n \tif err != nil {\n-\t\tcmd.Printf(\"Error: %v\\n\", err)\n-\t\tcmd.Printf(\"Couldn't connect. Please check the connection status or if the ssh server is enabled on the other peer\" +\n-\t\t\t\"\\nYou can verify the connection by running:\\n\\n\" +\n-\t\t\t\" netbird status\\n\\n\")\n \t\treturn err\n \t}\n+\n+\tcmd.Printf(\"Local port forwarding: %s -> %s\\n\", localAddr, remoteAddr)\n+\n \tgo func() {\n-\t\t<-ctx.Done()\n-\t\terr = c.Close()\n-\t\tif err != nil {\n-\t\t\treturn\n+\t\tif err := c.LocalPortForward(ctx, localAddr, remoteAddr); err != nil && !errors.Is(err, context.Canceled) {\n+\t\t\tcmd.Printf(\"Local port forward error: %v\\n\", err)\n \t\t}\n \t}()\n \n-\terr = c.OpenTerminal()\n+\treturn nil\n+}\n+\n+// parseAndStartRemoteForward parses and starts a remote port forward (-R)\n+func parseAndStartRemoteForward(ctx context.Context, c *sshclient.Client, forward string, cmd *cobra.Command) error {\n+\tremoteAddr, localAddr, err := parsePortForwardSpec(forward)\n \tif err != nil {\n \t\treturn err\n \t}\n \n+\tcmd.Printf(\"Remote port forwarding: %s -> %s\\n\", remoteAddr, localAddr)\n+\n+\tgo func() {\n+\t\tif err := c.RemotePortForward(ctx, remoteAddr, localAddr); err != nil && !errors.Is(err, context.Canceled) {\n+\t\t\tcmd.Printf(\"Remote port forward error: %v\\n\", err)\n+\t\t}\n+\t}()\n+\n \treturn nil\n }\n \n-func init() {\n-\tsshCmd.PersistentFlags().IntVarP(&port, \"port\", \"p\", nbssh.DefaultSSHPort, \"Sets remote SSH port. Defaults to \"+fmt.Sprint(nbssh.DefaultSSHPort))\n+// parsePortForwardSpec parses port forward specifications like \"8080:localhost:80\" or \"[::1]:8080:localhost:80\".\n+// Also supports Unix sockets like \"8080:/tmp/socket\" or \"127.0.0.1:8080:/tmp/socket\".\n+func parsePortForwardSpec(spec string) (string, string, error) {\n+\t// Support formats:\n+\t// port:host:hostport  -> localhost:port -> host:hostport\n+\t// host:port:host:hostport  -> host:port -> host:hostport\n+\t// [host]:port:host:hostport -> [host]:port -> host:hostport\n+\t// port:unix_socket_path -> localhost:port -> unix_socket_path\n+\t// host:port:unix_socket_path -> host:port -> unix_socket_path\n+\n+\tif strings.HasPrefix(spec, \"[\") && strings.Contains(spec, \"]:\") {\n+\t\treturn parseIPv6ForwardSpec(spec)\n+\t}\n+\n+\tparts := strings.Split(spec, \":\")\n+\tif len(parts) < 2 {\n+\t\treturn \"\", \"\", fmt.Errorf(\"invalid port forward specification: %s (expected format: [local_host:]local_port:remote_target)\", spec)\n+\t}\n+\n+\tswitch len(parts) {\n+\tcase 2:\n+\t\treturn parseTwoPartForwardSpec(parts, spec)\n+\tcase 3:\n+\t\treturn parseThreePartForwardSpec(parts)\n+\tcase 4:\n+\t\treturn parseFourPartForwardSpec(parts)\n+\tdefault:\n+\t\treturn \"\", \"\", fmt.Errorf(\"invalid port forward specification: %s\", spec)\n+\t}\n+}\n+\n+// parseTwoPartForwardSpec handles \"port:unix_socket\" format.\n+func parseTwoPartForwardSpec(parts []string, spec string) (string, string, error) {\n+\tif isUnixSocket(parts[1]) {\n+\t\tlocalAddr := \"localhost:\" + parts[0]\n+\t\tremoteAddr := parts[1]\n+\t\treturn localAddr, remoteAddr, nil\n+\t}\n+\treturn \"\", \"\", fmt.Errorf(\"invalid port forward specification: %s (expected format: [local_host:]local_port:remote_host:remote_port or [local_host:]local_port:unix_socket)\", spec)\n+}\n+\n+// parseThreePartForwardSpec handles \"port:host:hostport\" or \"host:port:unix_socket\" formats.\n+func parseThreePartForwardSpec(parts []string) (string, string, error) {\n+\tif isUnixSocket(parts[2]) {\n+\t\tlocalHost := normalizeLocalHost(parts[0])\n+\t\tlocalAddr := localHost + \":\" + parts[1]\n+\t\tremoteAddr := parts[2]\n+\t\treturn localAddr, remoteAddr, nil\n+\t}\n+\tlocalAddr := \"localhost:\" + parts[0]\n+\tremoteAddr := parts[1] + \":\" + parts[2]\n+\treturn localAddr, remoteAddr, nil\n+}\n+\n+// parseFourPartForwardSpec handles \"host:port:host:hostport\" format.\n+func parseFourPartForwardSpec(parts []string) (string, string, error) {\n+\tlocalHost := normalizeLocalHost(parts[0])\n+\tlocalAddr := localHost + \":\" + parts[1]\n+\tremoteAddr := parts[2] + \":\" + parts[3]\n+\treturn localAddr, remoteAddr, nil\n+}\n+\n+// parseIPv6ForwardSpec handles \"[host]:port:host:hostport\" format.\n+func parseIPv6ForwardSpec(spec string) (string, string, error) {\n+\tidx := strings.Index(spec, \"]:\")\n+\tif idx == -1 {\n+\t\treturn \"\", \"\", fmt.Errorf(\"invalid IPv6 port forward specification: %s\", spec)\n+\t}\n+\n+\tipv6Host := spec[:idx+1]\n+\tremaining := spec[idx+2:]\n+\n+\tparts := strings.Split(remaining, \":\")\n+\tif len(parts) != 3 {\n+\t\treturn \"\", \"\", fmt.Errorf(\"invalid IPv6 port forward specification: %s (expected [ipv6]:port:host:hostport)\", spec)\n+\t}\n+\n+\tlocalAddr := ipv6Host + \":\" + parts[0]\n+\tremoteAddr := parts[1] + \":\" + parts[2]\n+\treturn localAddr, remoteAddr, nil\n+}\n+\n+// isUnixSocket checks if a path is a Unix socket path.\n+func isUnixSocket(path string) bool {\n+\treturn strings.HasPrefix(path, \"/\") || strings.HasPrefix(path, \"./\")\n+}\n+\n+// normalizeLocalHost converts \"*\" to \"0.0.0.0\" for binding to all interfaces.\n+func normalizeLocalHost(host string) string {\n+\tif host == \"*\" {\n+\t\treturn \"0.0.0.0\"\n+\t}\n+\treturn host\n+}\n+\n+var sshProxyCmd = &cobra.Command{\n+\tUse:    \"proxy <host> <port>\",\n+\tShort:  \"Internal SSH proxy for native SSH client integration\",\n+\tLong:   \"Internal command used by SSH ProxyCommand to handle JWT authentication\",\n+\tHidden: true,\n+\tArgs:   cobra.ExactArgs(2),\n+\tRunE:   sshProxyFn,\n+}\n+\n+func sshProxyFn(cmd *cobra.Command, args []string) error {\n+\tlogOutput := \"console\"\n+\tif firstLogFile := util.FindFirstLogPath(logFiles); firstLogFile != \"\" && firstLogFile != defaultLogFile {\n+\t\tlogOutput = firstLogFile\n+\t}\n+\tif err := util.InitLog(logLevel, logOutput); err != nil {\n+\t\treturn fmt.Errorf(\"init log: %w\", err)\n+\t}\n+\n+\thost := args[0]\n+\tportStr := args[1]\n+\n+\tport, err := strconv.Atoi(portStr)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"invalid port: %s\", portStr)\n+\t}\n+\n+\tproxy, err := sshproxy.New(daemonAddr, host, port, cmd.ErrOrStderr())\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"create SSH proxy: %w\", err)\n+\t}\n+\tdefer func() {\n+\t\tif err := proxy.Close(); err != nil {\n+\t\t\tlog.Debugf(\"close SSH proxy: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tif err := proxy.Connect(cmd.Context()); err != nil {\n+\t\treturn fmt.Errorf(\"SSH proxy: %w\", err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+var sshDetectCmd = &cobra.Command{\n+\tUse:    \"detect <host> <port>\",\n+\tShort:  \"Detect if a host is running NetBird SSH\",\n+\tLong:   \"Internal command used by SSH Match exec to detect NetBird SSH servers. Exit codes: 0=JWT, 1=no-JWT, 2=regular SSH\",\n+\tHidden: true,\n+\tArgs:   cobra.ExactArgs(2),\n+\tRunE:   sshDetectFn,\n+}\n+\n+func sshDetectFn(cmd *cobra.Command, args []string) error {\n+\tif err := util.InitLog(logLevel, \"console\"); err != nil {\n+\t\tos.Exit(detection.ServerTypeRegular.ExitCode())\n+\t}\n+\n+\thost := args[0]\n+\tportStr := args[1]\n+\n+\tport, err := strconv.Atoi(portStr)\n+\tif err != nil {\n+\t\tos.Exit(detection.ServerTypeRegular.ExitCode())\n+\t}\n+\n+\tdialer := &net.Dialer{Timeout: detection.Timeout}\n+\tserverType, err := detection.DetectSSHServerType(cmd.Context(), dialer, host, port)\n+\tif err != nil {\n+\t\tos.Exit(detection.ServerTypeRegular.ExitCode())\n+\t}\n+\n+\tos.Exit(serverType.ExitCode())\n+\treturn nil\n }\ndiff --git a/client/cmd/ssh_exec_unix.go b/client/cmd/ssh_exec_unix.go\nnew file mode 100644\nindex 00000000000..2412f072c5e\n--- /dev/null\n+++ b/client/cmd/ssh_exec_unix.go\n@@ -0,0 +1,74 @@\n+//go:build unix\n+\n+package cmd\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\n+\t\"github.com/spf13/cobra\"\n+\n+\tsshserver \"github.com/netbirdio/netbird/client/ssh/server\"\n+)\n+\n+var (\n+\tsshExecUID        uint32\n+\tsshExecGID        uint32\n+\tsshExecGroups     []uint\n+\tsshExecWorkingDir string\n+\tsshExecShell      string\n+\tsshExecCommand    string\n+\tsshExecPTY        bool\n+)\n+\n+// sshExecCmd represents the hidden ssh exec subcommand for privilege dropping\n+var sshExecCmd = &cobra.Command{\n+\tUse:    \"exec\",\n+\tShort:  \"Internal SSH execution with privilege dropping (hidden)\",\n+\tHidden: true,\n+\tRunE:   runSSHExec,\n+}\n+\n+func init() {\n+\tsshExecCmd.Flags().Uint32Var(&sshExecUID, \"uid\", 0, \"Target user ID\")\n+\tsshExecCmd.Flags().Uint32Var(&sshExecGID, \"gid\", 0, \"Target group ID\")\n+\tsshExecCmd.Flags().UintSliceVar(&sshExecGroups, \"groups\", nil, \"Supplementary group IDs (can be repeated)\")\n+\tsshExecCmd.Flags().StringVar(&sshExecWorkingDir, \"working-dir\", \"\", \"Working directory\")\n+\tsshExecCmd.Flags().StringVar(&sshExecShell, \"shell\", \"/bin/sh\", \"Shell to execute\")\n+\tsshExecCmd.Flags().BoolVar(&sshExecPTY, \"pty\", false, \"Request PTY (will fail as executor doesn't support PTY)\")\n+\tsshExecCmd.Flags().StringVar(&sshExecCommand, \"cmd\", \"\", \"Command to execute\")\n+\n+\tif err := sshExecCmd.MarkFlagRequired(\"uid\"); err != nil {\n+\t\t_, _ = fmt.Fprintf(os.Stderr, \"failed to mark uid flag as required: %v\\n\", err)\n+\t\tos.Exit(1)\n+\t}\n+\tif err := sshExecCmd.MarkFlagRequired(\"gid\"); err != nil {\n+\t\t_, _ = fmt.Fprintf(os.Stderr, \"failed to mark gid flag as required: %v\\n\", err)\n+\t\tos.Exit(1)\n+\t}\n+\n+\tsshCmd.AddCommand(sshExecCmd)\n+}\n+\n+// runSSHExec handles the SSH exec subcommand execution.\n+func runSSHExec(cmd *cobra.Command, _ []string) error {\n+\tprivilegeDropper := sshserver.NewPrivilegeDropper()\n+\n+\tvar groups []uint32\n+\tfor _, groupInt := range sshExecGroups {\n+\t\tgroups = append(groups, uint32(groupInt))\n+\t}\n+\n+\tconfig := sshserver.ExecutorConfig{\n+\t\tUID:        sshExecUID,\n+\t\tGID:        sshExecGID,\n+\t\tGroups:     groups,\n+\t\tWorkingDir: sshExecWorkingDir,\n+\t\tShell:      sshExecShell,\n+\t\tCommand:    sshExecCommand,\n+\t\tPTY:        sshExecPTY,\n+\t}\n+\n+\tprivilegeDropper.ExecuteWithPrivilegeDrop(cmd.Context(), config)\n+\treturn nil\n+}\ndiff --git a/client/cmd/ssh_sftp_unix.go b/client/cmd/ssh_sftp_unix.go\nnew file mode 100644\nindex 00000000000..c06aab01713\n--- /dev/null\n+++ b/client/cmd/ssh_sftp_unix.go\n@@ -0,0 +1,94 @@\n+//go:build unix\n+\n+package cmd\n+\n+import (\n+\t\"errors\"\n+\t\"io\"\n+\t\"os\"\n+\n+\t\"github.com/pkg/sftp\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"github.com/spf13/cobra\"\n+\n+\tsshserver \"github.com/netbirdio/netbird/client/ssh/server\"\n+)\n+\n+var (\n+\tsftpUID        uint32\n+\tsftpGID        uint32\n+\tsftpGroupsInt  []uint\n+\tsftpWorkingDir string\n+)\n+\n+var sshSftpCmd = &cobra.Command{\n+\tUse:    \"sftp\",\n+\tShort:  \"SFTP server with privilege dropping (internal use)\",\n+\tHidden: true,\n+\tRunE:   sftpMain,\n+}\n+\n+func init() {\n+\tsshSftpCmd.Flags().Uint32Var(&sftpUID, \"uid\", 0, \"Target user ID\")\n+\tsshSftpCmd.Flags().Uint32Var(&sftpGID, \"gid\", 0, \"Target group ID\")\n+\tsshSftpCmd.Flags().UintSliceVar(&sftpGroupsInt, \"groups\", nil, \"Supplementary group IDs (can be repeated)\")\n+\tsshSftpCmd.Flags().StringVar(&sftpWorkingDir, \"working-dir\", \"\", \"Working directory\")\n+}\n+\n+func sftpMain(cmd *cobra.Command, _ []string) error {\n+\tprivilegeDropper := sshserver.NewPrivilegeDropper()\n+\n+\tvar groups []uint32\n+\tfor _, groupInt := range sftpGroupsInt {\n+\t\tgroups = append(groups, uint32(groupInt))\n+\t}\n+\n+\tconfig := sshserver.ExecutorConfig{\n+\t\tUID:        sftpUID,\n+\t\tGID:        sftpGID,\n+\t\tGroups:     groups,\n+\t\tWorkingDir: sftpWorkingDir,\n+\t\tShell:      \"\",\n+\t\tCommand:    \"\",\n+\t}\n+\n+\tlog.Tracef(\"dropping privileges for SFTP to UID=%d, GID=%d, groups=%v\", config.UID, config.GID, config.Groups)\n+\n+\tif err := privilegeDropper.DropPrivileges(config.UID, config.GID, config.Groups); err != nil {\n+\t\tcmd.PrintErrf(\"privilege drop failed: %v\\n\", err)\n+\t\tos.Exit(sshserver.ExitCodePrivilegeDropFail)\n+\t}\n+\n+\tif config.WorkingDir != \"\" {\n+\t\tif err := os.Chdir(config.WorkingDir); err != nil {\n+\t\t\tcmd.PrintErrf(\"failed to change to working directory %s: %v\\n\", config.WorkingDir, err)\n+\t\t}\n+\t}\n+\n+\tsftpServer, err := sftp.NewServer(struct {\n+\t\tio.Reader\n+\t\tio.WriteCloser\n+\t}{\n+\t\tReader:      os.Stdin,\n+\t\tWriteCloser: os.Stdout,\n+\t})\n+\tif err != nil {\n+\t\tcmd.PrintErrf(\"SFTP server creation failed: %v\\n\", err)\n+\t\tos.Exit(sshserver.ExitCodeShellExecFail)\n+\t}\n+\n+\tlog.Tracef(\"starting SFTP server with dropped privileges\")\n+\tif err := sftpServer.Serve(); err != nil && !errors.Is(err, io.EOF) {\n+\t\tcmd.PrintErrf(\"SFTP server error: %v\\n\", err)\n+\t\tif closeErr := sftpServer.Close(); closeErr != nil {\n+\t\t\tcmd.PrintErrf(\"SFTP server close error: %v\\n\", closeErr)\n+\t\t}\n+\t\tos.Exit(sshserver.ExitCodeShellExecFail)\n+\t}\n+\n+\tif closeErr := sftpServer.Close(); closeErr != nil {\n+\t\tcmd.PrintErrf(\"SFTP server close error: %v\\n\", closeErr)\n+\t}\n+\tos.Exit(sshserver.ExitCodeSuccess)\n+\treturn nil\n+}\ndiff --git a/client/cmd/ssh_sftp_windows.go b/client/cmd/ssh_sftp_windows.go\nnew file mode 100644\nindex 00000000000..ffd2d11487e\n--- /dev/null\n+++ b/client/cmd/ssh_sftp_windows.go\n@@ -0,0 +1,94 @@\n+//go:build windows\n+\n+package cmd\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"os/user\"\n+\t\"strings\"\n+\n+\t\"github.com/pkg/sftp\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"github.com/spf13/cobra\"\n+\n+\tsshserver \"github.com/netbirdio/netbird/client/ssh/server\"\n+)\n+\n+var (\n+\tsftpWorkingDir  string\n+\twindowsUsername string\n+\twindowsDomain   string\n+)\n+\n+var sshSftpCmd = &cobra.Command{\n+\tUse:    \"sftp\",\n+\tShort:  \"SFTP server with user switching for Windows (internal use)\",\n+\tHidden: true,\n+\tRunE:   sftpMain,\n+}\n+\n+func init() {\n+\tsshSftpCmd.Flags().StringVar(&sftpWorkingDir, \"working-dir\", \"\", \"Working directory\")\n+\tsshSftpCmd.Flags().StringVar(&windowsUsername, \"windows-username\", \"\", \"Windows username for user switching\")\n+\tsshSftpCmd.Flags().StringVar(&windowsDomain, \"windows-domain\", \"\", \"Windows domain for user switching\")\n+}\n+\n+func sftpMain(cmd *cobra.Command, _ []string) error {\n+\treturn sftpMainDirect(cmd)\n+}\n+\n+func sftpMainDirect(cmd *cobra.Command) error {\n+\tcurrentUser, err := user.Current()\n+\tif err != nil {\n+\t\tcmd.PrintErrf(\"failed to get current user: %v\\n\", err)\n+\t\tos.Exit(sshserver.ExitCodeValidationFail)\n+\t}\n+\n+\tif windowsUsername != \"\" {\n+\t\texpectedUsername := windowsUsername\n+\t\tif windowsDomain != \"\" {\n+\t\t\texpectedUsername = fmt.Sprintf(`%s\\%s`, windowsDomain, windowsUsername)\n+\t\t}\n+\t\tif !strings.EqualFold(currentUser.Username, expectedUsername) && !strings.EqualFold(currentUser.Username, windowsUsername) {\n+\t\t\tcmd.PrintErrf(\"user switching failed\\n\")\n+\t\t\tos.Exit(sshserver.ExitCodeValidationFail)\n+\t\t}\n+\t}\n+\n+\tlog.Debugf(\"SFTP process running as: %s (UID: %s, Name: %s)\", currentUser.Username, currentUser.Uid, currentUser.Name)\n+\n+\tif sftpWorkingDir != \"\" {\n+\t\tif err := os.Chdir(sftpWorkingDir); err != nil {\n+\t\t\tcmd.PrintErrf(\"failed to change to working directory %s: %v\\n\", sftpWorkingDir, err)\n+\t\t}\n+\t}\n+\n+\tsftpServer, err := sftp.NewServer(struct {\n+\t\tio.Reader\n+\t\tio.WriteCloser\n+\t}{\n+\t\tReader:      os.Stdin,\n+\t\tWriteCloser: os.Stdout,\n+\t})\n+\tif err != nil {\n+\t\tcmd.PrintErrf(\"SFTP server creation failed: %v\\n\", err)\n+\t\tos.Exit(sshserver.ExitCodeShellExecFail)\n+\t}\n+\n+\tlog.Debugf(\"starting SFTP server\")\n+\texitCode := sshserver.ExitCodeSuccess\n+\tif err := sftpServer.Serve(); err != nil && !errors.Is(err, io.EOF) {\n+\t\tcmd.PrintErrf(\"SFTP server error: %v\\n\", err)\n+\t\texitCode = sshserver.ExitCodeShellExecFail\n+\t}\n+\n+\tif err := sftpServer.Close(); err != nil {\n+\t\tlog.Debugf(\"SFTP server close error: %v\", err)\n+\t}\n+\n+\tos.Exit(exitCode)\n+\treturn nil\n+}\ndiff --git a/client/cmd/status.go b/client/cmd/status.go\nindex 6e57ceb894e..06460a6a7ee 100644\n--- a/client/cmd/status.go\n+++ b/client/cmd/status.go\n@@ -109,7 +109,7 @@ func statusFunc(cmd *cobra.Command, args []string) error {\n \tcase yamlFlag:\n \t\tstatusOutputString, err = nbstatus.ParseToYAML(outputInformationHolder)\n \tdefault:\n-\t\tstatusOutputString = nbstatus.ParseGeneralSummary(outputInformationHolder, false, false, false)\n+\t\tstatusOutputString = nbstatus.ParseGeneralSummary(outputInformationHolder, false, false, false, false)\n \t}\n \n \tif err != nil {\ndiff --git a/client/cmd/up.go b/client/cmd/up.go\nindex 80175f7be59..140ba2cb29c 100644\n--- a/client/cmd/up.go\n+++ b/client/cmd/up.go\n@@ -355,6 +355,25 @@ func setupSetConfigReq(customDNSAddressConverted []byte, cmd *cobra.Command, pro\n \tif cmd.Flag(serverSSHAllowedFlag).Changed {\n \t\treq.ServerSSHAllowed = &serverSSHAllowed\n \t}\n+\tif cmd.Flag(enableSSHRootFlag).Changed {\n+\t\treq.EnableSSHRoot = &enableSSHRoot\n+\t}\n+\tif cmd.Flag(enableSSHSFTPFlag).Changed {\n+\t\treq.EnableSSHSFTP = &enableSSHSFTP\n+\t}\n+\tif cmd.Flag(enableSSHLocalPortForwardFlag).Changed {\n+\t\treq.EnableSSHLocalPortForwarding = &enableSSHLocalPortForward\n+\t}\n+\tif cmd.Flag(enableSSHRemotePortForwardFlag).Changed {\n+\t\treq.EnableSSHRemotePortForwarding = &enableSSHRemotePortForward\n+\t}\n+\tif cmd.Flag(disableSSHAuthFlag).Changed {\n+\t\treq.DisableSSHAuth = &disableSSHAuth\n+\t}\n+\tif cmd.Flag(sshJWTCacheTTLFlag).Changed {\n+\t\tsshJWTCacheTTL32 := int32(sshJWTCacheTTL)\n+\t\treq.SshJWTCacheTTL = &sshJWTCacheTTL32\n+\t}\n \tif cmd.Flag(interfaceNameFlag).Changed {\n \t\tif err := parseInterfaceName(interfaceName); err != nil {\n \t\t\tlog.Errorf(\"parse interface name: %v\", err)\n@@ -439,6 +458,30 @@ func setupConfig(customDNSAddressConverted []byte, cmd *cobra.Command, configFil\n \t\tic.ServerSSHAllowed = &serverSSHAllowed\n \t}\n \n+\tif cmd.Flag(enableSSHRootFlag).Changed {\n+\t\tic.EnableSSHRoot = &enableSSHRoot\n+\t}\n+\n+\tif cmd.Flag(enableSSHSFTPFlag).Changed {\n+\t\tic.EnableSSHSFTP = &enableSSHSFTP\n+\t}\n+\n+\tif cmd.Flag(enableSSHLocalPortForwardFlag).Changed {\n+\t\tic.EnableSSHLocalPortForwarding = &enableSSHLocalPortForward\n+\t}\n+\n+\tif cmd.Flag(enableSSHRemotePortForwardFlag).Changed {\n+\t\tic.EnableSSHRemotePortForwarding = &enableSSHRemotePortForward\n+\t}\n+\n+\tif cmd.Flag(disableSSHAuthFlag).Changed {\n+\t\tic.DisableSSHAuth = &disableSSHAuth\n+\t}\n+\n+\tif cmd.Flag(sshJWTCacheTTLFlag).Changed {\n+\t\tic.SSHJWTCacheTTL = &sshJWTCacheTTL\n+\t}\n+\n \tif cmd.Flag(interfaceNameFlag).Changed {\n \t\tif err := parseInterfaceName(interfaceName); err != nil {\n \t\t\treturn nil, err\n@@ -539,6 +582,31 @@ func setupLoginRequest(providedSetupKey string, customDNSAddressConverted []byte\n \t\tloginRequest.ServerSSHAllowed = &serverSSHAllowed\n \t}\n \n+\tif cmd.Flag(enableSSHRootFlag).Changed {\n+\t\tloginRequest.EnableSSHRoot = &enableSSHRoot\n+\t}\n+\n+\tif cmd.Flag(enableSSHSFTPFlag).Changed {\n+\t\tloginRequest.EnableSSHSFTP = &enableSSHSFTP\n+\t}\n+\n+\tif cmd.Flag(enableSSHLocalPortForwardFlag).Changed {\n+\t\tloginRequest.EnableSSHLocalPortForwarding = &enableSSHLocalPortForward\n+\t}\n+\n+\tif cmd.Flag(enableSSHRemotePortForwardFlag).Changed {\n+\t\tloginRequest.EnableSSHRemotePortForwarding = &enableSSHRemotePortForward\n+\t}\n+\n+\tif cmd.Flag(disableSSHAuthFlag).Changed {\n+\t\tloginRequest.DisableSSHAuth = &disableSSHAuth\n+\t}\n+\n+\tif cmd.Flag(sshJWTCacheTTLFlag).Changed {\n+\t\tsshJWTCacheTTL32 := int32(sshJWTCacheTTL)\n+\t\tloginRequest.SshJWTCacheTTL = &sshJWTCacheTTL32\n+\t}\n+\n \tif cmd.Flag(disableAutoConnectFlag).Changed {\n \t\tloginRequest.DisableAutoConnect = &autoConnectDisabled\n \t}\ndiff --git a/client/embed/embed.go b/client/embed/embed.go\nindex e918235ed13..3090ca6a2e0 100644\n--- a/client/embed/embed.go\n+++ b/client/embed/embed.go\n@@ -18,12 +18,16 @@ import (\n \t\"github.com/netbirdio/netbird/client/internal\"\n \t\"github.com/netbirdio/netbird/client/internal/peer\"\n \t\"github.com/netbirdio/netbird/client/internal/profilemanager\"\n+\tsshcommon \"github.com/netbirdio/netbird/client/ssh\"\n \t\"github.com/netbirdio/netbird/client/system\"\n )\n \n-var ErrClientAlreadyStarted = errors.New(\"client already started\")\n-var ErrClientNotStarted = errors.New(\"client not started\")\n-var ErrConfigNotInitialized = errors.New(\"config not initialized\")\n+var (\n+\tErrClientAlreadyStarted = errors.New(\"client already started\")\n+\tErrClientNotStarted     = errors.New(\"client not started\")\n+\tErrEngineNotStarted     = errors.New(\"engine not started\")\n+\tErrConfigNotInitialized = errors.New(\"config not initialized\")\n+)\n \n // Client manages a netbird embedded client instance.\n type Client struct {\n@@ -238,17 +242,9 @@ func (c *Client) GetConfig() (profilemanager.Config, error) {\n // Dial dials a network address in the netbird network.\n // Not applicable if the userspace networking mode is disabled.\n func (c *Client) Dial(ctx context.Context, network, address string) (net.Conn, error) {\n-\tc.mu.Lock()\n-\tconnect := c.connect\n-\tif connect == nil {\n-\t\tc.mu.Unlock()\n-\t\treturn nil, ErrClientNotStarted\n-\t}\n-\tc.mu.Unlock()\n-\n-\tengine := connect.Engine()\n-\tif engine == nil {\n-\t\treturn nil, errors.New(\"engine not started\")\n+\tengine, err := c.getEngine()\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n \n \tnsnet, err := engine.GetNet()\n@@ -259,6 +255,11 @@ func (c *Client) Dial(ctx context.Context, network, address string) (net.Conn, e\n \treturn nsnet.DialContext(ctx, network, address)\n }\n \n+// DialContext dials a network address in the netbird network with context\n+func (c *Client) DialContext(ctx context.Context, network, address string) (net.Conn, error) {\n+\treturn c.Dial(ctx, network, address)\n+}\n+\n // ListenTCP listens on the given address in the netbird network.\n // Not applicable if the userspace networking mode is disabled.\n func (c *Client) ListenTCP(address string) (net.Listener, error) {\n@@ -314,18 +315,47 @@ func (c *Client) NewHTTPClient() *http.Client {\n \t}\n }\n \n-func (c *Client) getNet() (*wgnetstack.Net, netip.Addr, error) {\n+// VerifySSHHostKey verifies an SSH host key against stored peer keys.\n+// Returns nil if the key matches, ErrPeerNotFound if peer is not in network,\n+// ErrNoStoredKey if peer has no stored key, or an error for verification failures.\n+func (c *Client) VerifySSHHostKey(peerAddress string, key []byte) error {\n+\tengine, err := c.getEngine()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tstoredKey, found := engine.GetPeerSSHKey(peerAddress)\n+\tif !found {\n+\t\treturn sshcommon.ErrPeerNotFound\n+\t}\n+\n+\treturn sshcommon.VerifyHostKey(storedKey, key, peerAddress)\n+}\n+\n+// getEngine safely retrieves the engine from the client with proper locking.\n+// Returns ErrClientNotStarted if the client is not started.\n+// Returns ErrEngineNotStarted if the engine is not available.\n+func (c *Client) getEngine() (*internal.Engine, error) {\n \tc.mu.Lock()\n \tconnect := c.connect\n+\tc.mu.Unlock()\n+\n \tif connect == nil {\n-\t\tc.mu.Unlock()\n-\t\treturn nil, netip.Addr{}, errors.New(\"client not started\")\n+\t\treturn nil, ErrClientNotStarted\n \t}\n-\tc.mu.Unlock()\n \n \tengine := connect.Engine()\n \tif engine == nil {\n-\t\treturn nil, netip.Addr{}, errors.New(\"engine not started\")\n+\t\treturn nil, ErrEngineNotStarted\n+\t}\n+\n+\treturn engine, nil\n+}\n+\n+func (c *Client) getNet() (*wgnetstack.Net, netip.Addr, error) {\n+\tengine, err := c.getEngine()\n+\tif err != nil {\n+\t\treturn nil, netip.Addr{}, err\n \t}\n \n \taddr, err := engine.Address()\ndiff --git a/client/firewall/uspfilter/filter.go b/client/firewall/uspfilter/filter.go\nindex 990630ee4e3..4e22bde3fbd 100644\n--- a/client/firewall/uspfilter/filter.go\n+++ b/client/firewall/uspfilter/filter.go\n@@ -35,6 +35,12 @@ const (\n \tipTCPHeaderMinSize = 40\n )\n \n+// serviceKey represents a protocol/port combination for netstack service registry\n+type serviceKey struct {\n+\tprotocol gopacket.LayerType\n+\tport     uint16\n+}\n+\n const (\n \t// EnvDisableConntrack disables the stateful filter, replies to outbound traffic won't be allowed.\n \tEnvDisableConntrack = \"NB_DISABLE_CONNTRACK\"\n@@ -59,12 +65,6 @@ const (\n \n var errNatNotSupported = errors.New(\"nat not supported with userspace firewall\")\n \n-// serviceKey represents a protocol/port combination for netstack service registry\n-type serviceKey struct {\n-\tprotocol gopacket.LayerType\n-\tport     uint16\n-}\n-\n // RuleSet is a set of rules grouped by a string key\n type RuleSet map[string]PeerRule\n \ndiff --git a/client/internal/acl/manager.go b/client/internal/acl/manager.go\nindex 965decc7380..dd6f9479a30 100644\n--- a/client/internal/acl/manager.go\n+++ b/client/internal/acl/manager.go\n@@ -17,7 +17,6 @@ import (\n \tnberrors \"github.com/netbirdio/netbird/client/errors\"\n \tfirewall \"github.com/netbirdio/netbird/client/firewall/manager\"\n \t\"github.com/netbirdio/netbird/client/internal/acl/id\"\n-\t\"github.com/netbirdio/netbird/client/ssh\"\n \t\"github.com/netbirdio/netbird/shared/management/domain\"\n \tmgmProto \"github.com/netbirdio/netbird/shared/management/proto\"\n )\n@@ -83,22 +82,6 @@ func (d *DefaultManager) ApplyFiltering(networkMap *mgmProto.NetworkMap, dnsRout\n func (d *DefaultManager) applyPeerACLs(networkMap *mgmProto.NetworkMap) {\n \trules := networkMap.FirewallRules\n \n-\tenableSSH := networkMap.PeerConfig != nil &&\n-\t\tnetworkMap.PeerConfig.SshConfig != nil &&\n-\t\tnetworkMap.PeerConfig.SshConfig.SshEnabled\n-\n-\t// If SSH enabled, add default firewall rule which accepts connection to any peer\n-\t// in the network by SSH (TCP port defined by ssh.DefaultSSHPort).\n-\tif enableSSH {\n-\t\trules = append(rules, &mgmProto.FirewallRule{\n-\t\t\tPeerIP:    \"0.0.0.0\",\n-\t\t\tDirection: mgmProto.RuleDirection_IN,\n-\t\t\tAction:    mgmProto.RuleAction_ACCEPT,\n-\t\t\tProtocol:  mgmProto.RuleProtocol_TCP,\n-\t\t\tPort:      strconv.Itoa(ssh.DefaultSSHPort),\n-\t\t})\n-\t}\n-\n \t// if we got empty rules list but management not set networkMap.FirewallRulesIsEmpty flag\n \t// we have old version of management without rules handling, we should allow all traffic\n \tif len(networkMap.FirewallRules) == 0 && !networkMap.FirewallRulesIsEmpty {\ndiff --git a/client/internal/connect.go b/client/internal/connect.go\nindex bb7c2b38b0e..6ad5f264bc9 100644\n--- a/client/internal/connect.go\n+++ b/client/internal/connect.go\n@@ -416,20 +416,25 @@ func createEngineConfig(key wgtypes.Key, config *profilemanager.Config, peerConf\n \t\tnm = *config.NetworkMonitor\n \t}\n \tengineConf := &EngineConfig{\n-\t\tWgIfaceName:          config.WgIface,\n-\t\tWgAddr:               peerConfig.Address,\n-\t\tIFaceBlackList:       config.IFaceBlackList,\n-\t\tDisableIPv6Discovery: config.DisableIPv6Discovery,\n-\t\tWgPrivateKey:         key,\n-\t\tWgPort:               config.WgPort,\n-\t\tNetworkMonitor:       nm,\n-\t\tSSHKey:               []byte(config.SSHKey),\n-\t\tNATExternalIPs:       config.NATExternalIPs,\n-\t\tCustomDNSAddress:     config.CustomDNSAddress,\n-\t\tRosenpassEnabled:     config.RosenpassEnabled,\n-\t\tRosenpassPermissive:  config.RosenpassPermissive,\n-\t\tServerSSHAllowed:     util.ReturnBoolWithDefaultTrue(config.ServerSSHAllowed),\n-\t\tDNSRouteInterval:     config.DNSRouteInterval,\n+\t\tWgIfaceName:                   config.WgIface,\n+\t\tWgAddr:                        peerConfig.Address,\n+\t\tIFaceBlackList:                config.IFaceBlackList,\n+\t\tDisableIPv6Discovery:          config.DisableIPv6Discovery,\n+\t\tWgPrivateKey:                  key,\n+\t\tWgPort:                        config.WgPort,\n+\t\tNetworkMonitor:                nm,\n+\t\tSSHKey:                        []byte(config.SSHKey),\n+\t\tNATExternalIPs:                config.NATExternalIPs,\n+\t\tCustomDNSAddress:              config.CustomDNSAddress,\n+\t\tRosenpassEnabled:              config.RosenpassEnabled,\n+\t\tRosenpassPermissive:           config.RosenpassPermissive,\n+\t\tServerSSHAllowed:              util.ReturnBoolWithDefaultTrue(config.ServerSSHAllowed),\n+\t\tEnableSSHRoot:                 config.EnableSSHRoot,\n+\t\tEnableSSHSFTP:                 config.EnableSSHSFTP,\n+\t\tEnableSSHLocalPortForwarding:  config.EnableSSHLocalPortForwarding,\n+\t\tEnableSSHRemotePortForwarding: config.EnableSSHRemotePortForwarding,\n+\t\tDisableSSHAuth:                config.DisableSSHAuth,\n+\t\tDNSRouteInterval:              config.DNSRouteInterval,\n \n \t\tDisableClientRoutes: config.DisableClientRoutes,\n \t\tDisableServerRoutes: config.DisableServerRoutes || config.BlockInbound,\n@@ -515,6 +520,11 @@ func loginToManagement(ctx context.Context, client mgm.Client, pubSSHKey []byte,\n \t\tconfig.BlockLANAccess,\n \t\tconfig.BlockInbound,\n \t\tconfig.LazyConnectionEnabled,\n+\t\tconfig.EnableSSHRoot,\n+\t\tconfig.EnableSSHSFTP,\n+\t\tconfig.EnableSSHLocalPortForwarding,\n+\t\tconfig.EnableSSHRemotePortForwarding,\n+\t\tconfig.DisableSSHAuth,\n \t)\n \tloginResp, err := client.Login(*serverPublicKey, sysInfo, pubSSHKey, config.DNSLabels)\n \tif err != nil {\ndiff --git a/client/internal/debug/debug.go b/client/internal/debug/debug.go\nindex fbec29ce38b..58977b8844d 100644\n--- a/client/internal/debug/debug.go\n+++ b/client/internal/debug/debug.go\n@@ -453,6 +453,18 @@ func (g *BundleGenerator) addCommonConfigFields(configContent *strings.Builder)\n \tif g.internalConfig.ServerSSHAllowed != nil {\n \t\tconfigContent.WriteString(fmt.Sprintf(\"ServerSSHAllowed: %v\\n\", *g.internalConfig.ServerSSHAllowed))\n \t}\n+\tif g.internalConfig.EnableSSHRoot != nil {\n+\t\tconfigContent.WriteString(fmt.Sprintf(\"EnableSSHRoot: %v\\n\", *g.internalConfig.EnableSSHRoot))\n+\t}\n+\tif g.internalConfig.EnableSSHSFTP != nil {\n+\t\tconfigContent.WriteString(fmt.Sprintf(\"EnableSSHSFTP: %v\\n\", *g.internalConfig.EnableSSHSFTP))\n+\t}\n+\tif g.internalConfig.EnableSSHLocalPortForwarding != nil {\n+\t\tconfigContent.WriteString(fmt.Sprintf(\"EnableSSHLocalPortForwarding: %v\\n\", *g.internalConfig.EnableSSHLocalPortForwarding))\n+\t}\n+\tif g.internalConfig.EnableSSHRemotePortForwarding != nil {\n+\t\tconfigContent.WriteString(fmt.Sprintf(\"EnableSSHRemotePortForwarding: %v\\n\", *g.internalConfig.EnableSSHRemotePortForwarding))\n+\t}\n \n \tconfigContent.WriteString(fmt.Sprintf(\"DisableClientRoutes: %v\\n\", g.internalConfig.DisableClientRoutes))\n \tconfigContent.WriteString(fmt.Sprintf(\"DisableServerRoutes: %v\\n\", g.internalConfig.DisableServerRoutes))\ndiff --git a/client/internal/engine.go b/client/internal/engine.go\nindex ebc05c45355..1deb3d3cfca 100644\n--- a/client/internal/engine.go\n+++ b/client/internal/engine.go\n@@ -9,7 +9,6 @@ import (\n \t\"net/netip\"\n \t\"net/url\"\n \t\"os\"\n-\t\"reflect\"\n \t\"runtime\"\n \t\"slices\"\n \t\"sort\"\n@@ -30,7 +29,6 @@ import (\n \tfirewallManager \"github.com/netbirdio/netbird/client/firewall/manager\"\n \t\"github.com/netbirdio/netbird/client/iface\"\n \t\"github.com/netbirdio/netbird/client/iface/device\"\n-\tnbnetstack \"github.com/netbirdio/netbird/client/iface/netstack\"\n \t\"github.com/netbirdio/netbird/client/iface/udpmux\"\n \t\"github.com/netbirdio/netbird/client/internal/acl\"\n \t\"github.com/netbirdio/netbird/client/internal/dns\"\n@@ -51,10 +49,10 @@ import (\n \t\"github.com/netbirdio/netbird/client/internal/routemanager/systemops\"\n \t\"github.com/netbirdio/netbird/client/internal/statemanager\"\n \tcProto \"github.com/netbirdio/netbird/client/proto\"\n+\tsshconfig \"github.com/netbirdio/netbird/client/ssh/config\"\n \t\"github.com/netbirdio/netbird/shared/management/domain\"\n \tsemaphoregroup \"github.com/netbirdio/netbird/util/semaphore-group\"\n \n-\tnbssh \"github.com/netbirdio/netbird/client/ssh\"\n \t\"github.com/netbirdio/netbird/client/system\"\n \tnbdns \"github.com/netbirdio/netbird/dns\"\n \t\"github.com/netbirdio/netbird/route\"\n@@ -115,7 +113,12 @@ type EngineConfig struct {\n \tRosenpassEnabled    bool\n \tRosenpassPermissive bool\n \n-\tServerSSHAllowed bool\n+\tServerSSHAllowed              bool\n+\tEnableSSHRoot                 *bool\n+\tEnableSSHSFTP                 *bool\n+\tEnableSSHLocalPortForwarding  *bool\n+\tEnableSSHRemotePortForwarding *bool\n+\tDisableSSHAuth                *bool\n \n \tDNSRouteInterval time.Duration\n \n@@ -148,8 +151,6 @@ type Engine struct {\n \n \t// syncMsgMux is used to guarantee sequential Management Service message processing\n \tsyncMsgMux *sync.Mutex\n-\t// sshMux protects sshServer field access\n-\tsshMux sync.Mutex\n \n \tconfig    *EngineConfig\n \tmobileDep MobileDependency\n@@ -175,8 +176,7 @@ type Engine struct {\n \n \tnetworkMonitor *networkmonitor.NetworkMonitor\n \n-\tsshServerFunc func(hostKeyPEM []byte, addr string) (nbssh.Server, error)\n-\tsshServer     nbssh.Server\n+\tsshServer sshServer\n \n \tstatusRecorder *peer.Status\n \n@@ -246,7 +246,6 @@ func NewEngine(\n \t\tSTUNs:          []*stun.URI{},\n \t\tTURNs:          []*stun.URI{},\n \t\tnetworkSerial:  0,\n-\t\tsshServerFunc:  nbssh.DefaultSSHServer,\n \t\tstatusRecorder: statusRecorder,\n \t\tchecks:         checks,\n \t\tconnSemaphore:  semaphoregroup.NewSemaphoreGroup(connInitLimit),\n@@ -268,6 +267,7 @@ func NewEngine(\n \t\tpath = mobileDep.StateFilePath\n \t}\n \tengine.stateManager = statemanager.New(path)\n+\tengine.stateManager.RegisterState(&sshconfig.ShutdownState{})\n \n \tlog.Infof(\"I am: %s\", config.WgPrivateKey.PublicKey().String())\n \treturn engine\n@@ -292,6 +292,12 @@ func (e *Engine) Stop() error {\n \t}\n \tlog.Info(\"Network monitor: stopped\")\n \n+\tif err := e.stopSSHServer(); err != nil {\n+\t\tlog.Warnf(\"failed to stop SSH server: %v\", err)\n+\t}\n+\n+\te.cleanupSSHConfig()\n+\n \t// stop/restore DNS first so dbus and friends don't complain because of a missing interface\n \te.stopDNSServer()\n \n@@ -703,16 +709,10 @@ func (e *Engine) removeAllPeers() error {\n \treturn nil\n }\n \n-// removePeer closes an existing peer connection, removes a peer, and clears authorized key of the SSH server\n+// removePeer closes an existing peer connection and removes a peer\n func (e *Engine) removePeer(peerKey string) error {\n \tlog.Debugf(\"removing peer from engine %s\", peerKey)\n \n-\te.sshMux.Lock()\n-\tif !isNil(e.sshServer) {\n-\t\te.sshServer.RemoveAuthorizedKey(peerKey)\n-\t}\n-\te.sshMux.Unlock()\n-\n \te.connMgr.RemovePeerConn(peerKey)\n \n \terr := e.statusRecorder.RemovePeer(peerKey)\n@@ -884,6 +884,11 @@ func (e *Engine) updateChecksIfNew(checks []*mgmProto.Checks) error {\n \t\te.config.BlockLANAccess,\n \t\te.config.BlockInbound,\n \t\te.config.LazyConnectionEnabled,\n+\t\te.config.EnableSSHRoot,\n+\t\te.config.EnableSSHSFTP,\n+\t\te.config.EnableSSHLocalPortForwarding,\n+\t\te.config.EnableSSHRemotePortForwarding,\n+\t\te.config.DisableSSHAuth,\n \t)\n \n \tif err := e.mgmClient.SyncMeta(info); err != nil {\n@@ -893,74 +898,6 @@ func (e *Engine) updateChecksIfNew(checks []*mgmProto.Checks) error {\n \treturn nil\n }\n \n-func isNil(server nbssh.Server) bool {\n-\treturn server == nil || reflect.ValueOf(server).IsNil()\n-}\n-\n-func (e *Engine) updateSSH(sshConf *mgmProto.SSHConfig) error {\n-\tif e.config.BlockInbound {\n-\t\tlog.Infof(\"SSH server is disabled because inbound connections are blocked\")\n-\t\treturn nil\n-\t}\n-\n-\tif !e.config.ServerSSHAllowed {\n-\t\tlog.Info(\"SSH server is not enabled\")\n-\t\treturn nil\n-\t}\n-\n-\tif sshConf.GetSshEnabled() {\n-\t\tif runtime.GOOS == \"windows\" {\n-\t\t\tlog.Warnf(\"running SSH server on %s is not supported\", runtime.GOOS)\n-\t\t\treturn nil\n-\t\t}\n-\t\te.sshMux.Lock()\n-\t\t// start SSH server if it wasn't running\n-\t\tif isNil(e.sshServer) {\n-\t\t\tlistenAddr := fmt.Sprintf(\"%s:%d\", e.wgInterface.Address().IP.String(), nbssh.DefaultSSHPort)\n-\t\t\tif nbnetstack.IsEnabled() {\n-\t\t\t\tlistenAddr = fmt.Sprintf(\"127.0.0.1:%d\", nbssh.DefaultSSHPort)\n-\t\t\t}\n-\t\t\t// nil sshServer means it has not yet been started\n-\t\t\tserver, err := e.sshServerFunc(e.config.SSHKey, listenAddr)\n-\t\t\tif err != nil {\n-\t\t\t\te.sshMux.Unlock()\n-\t\t\t\treturn fmt.Errorf(\"create ssh server: %w\", err)\n-\t\t\t}\n-\n-\t\t\te.sshServer = server\n-\t\t\te.sshMux.Unlock()\n-\n-\t\t\tgo func() {\n-\t\t\t\t// blocking\n-\t\t\t\terr = server.Start()\n-\t\t\t\tif err != nil {\n-\t\t\t\t\t// will throw error when we stop it even if it is a graceful stop\n-\t\t\t\t\tlog.Debugf(\"stopped SSH server with error %v\", err)\n-\t\t\t\t}\n-\t\t\t\te.sshMux.Lock()\n-\t\t\t\te.sshServer = nil\n-\t\t\t\te.sshMux.Unlock()\n-\t\t\t\tlog.Infof(\"stopped SSH server\")\n-\t\t\t}()\n-\t\t} else {\n-\t\t\te.sshMux.Unlock()\n-\t\t\tlog.Debugf(\"SSH server is already running\")\n-\t\t}\n-\t} else {\n-\t\te.sshMux.Lock()\n-\t\tif !isNil(e.sshServer) {\n-\t\t\t// Disable SSH server request, so stop it if it was running\n-\t\t\terr := e.sshServer.Stop()\n-\t\t\tif err != nil {\n-\t\t\t\tlog.Warnf(\"failed to stop SSH server %v\", err)\n-\t\t\t}\n-\t\t\te.sshServer = nil\n-\t\t}\n-\t\te.sshMux.Unlock()\n-\t}\n-\treturn nil\n-}\n-\n func (e *Engine) updateConfig(conf *mgmProto.PeerConfig) error {\n \tif e.wgInterface == nil {\n \t\treturn errors.New(\"wireguard interface is not initialized\")\n@@ -973,8 +910,7 @@ func (e *Engine) updateConfig(conf *mgmProto.PeerConfig) error {\n \t}\n \n \tif conf.GetSshConfig() != nil {\n-\t\terr := e.updateSSH(conf.GetSshConfig())\n-\t\tif err != nil {\n+\t\tif err := e.updateSSH(conf.GetSshConfig()); err != nil {\n \t\t\tlog.Warnf(\"failed handling SSH server setup: %v\", err)\n \t\t}\n \t}\n@@ -1012,6 +948,11 @@ func (e *Engine) receiveManagementEvents() {\n \t\t\te.config.BlockLANAccess,\n \t\t\te.config.BlockInbound,\n \t\t\te.config.LazyConnectionEnabled,\n+\t\t\te.config.EnableSSHRoot,\n+\t\t\te.config.EnableSSHSFTP,\n+\t\t\te.config.EnableSSHLocalPortForwarding,\n+\t\t\te.config.EnableSSHRemotePortForwarding,\n+\t\t\te.config.DisableSSHAuth,\n \t\t)\n \n \t\terr = e.mgmClient.Sync(e.ctx, info, e.handleSync)\n@@ -1170,19 +1111,11 @@ func (e *Engine) updateNetworkMap(networkMap *mgmProto.NetworkMap) error {\n \n \t\te.statusRecorder.FinishPeerListModifications()\n \n-\t\t// update SSHServer by adding remote peer SSH keys\n-\t\te.sshMux.Lock()\n-\t\tif !isNil(e.sshServer) {\n-\t\t\tfor _, config := range networkMap.GetRemotePeers() {\n-\t\t\t\tif config.GetSshConfig() != nil && config.GetSshConfig().GetSshPubKey() != nil {\n-\t\t\t\t\terr := e.sshServer.AddAuthorizedKey(config.WgPubKey, string(config.GetSshConfig().GetSshPubKey()))\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\tlog.Warnf(\"failed adding authorized key to SSH DefaultServer %v\", err)\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n+\t\te.updatePeerSSHHostKeys(networkMap.GetRemotePeers())\n+\n+\t\tif err := e.updateSSHClientConfig(networkMap.GetRemotePeers()); err != nil {\n+\t\t\tlog.Warnf(\"failed to update SSH client config: %v\", err)\n \t\t}\n-\t\te.sshMux.Unlock()\n \t}\n \n \t// must set the exclude list after the peers are added. Without it the manager can not figure out the peers parameters from the store\n@@ -1544,15 +1477,6 @@ func (e *Engine) close() {\n \t\te.statusRecorder.SetWgIface(nil)\n \t}\n \n-\te.sshMux.Lock()\n-\tif !isNil(e.sshServer) {\n-\t\terr := e.sshServer.Stop()\n-\t\tif err != nil {\n-\t\t\tlog.Warnf(\"failed stopping the SSH server: %v\", err)\n-\t\t}\n-\t}\n-\te.sshMux.Unlock()\n-\n \tif e.firewall != nil {\n \t\terr := e.firewall.Close(e.stateManager)\n \t\tif err != nil {\n@@ -1583,6 +1507,11 @@ func (e *Engine) readInitialSettings() ([]*route.Route, *nbdns.Config, bool, err\n \t\te.config.BlockLANAccess,\n \t\te.config.BlockInbound,\n \t\te.config.LazyConnectionEnabled,\n+\t\te.config.EnableSSHRoot,\n+\t\te.config.EnableSSHSFTP,\n+\t\te.config.EnableSSHLocalPortForwarding,\n+\t\te.config.EnableSSHRemotePortForwarding,\n+\t\te.config.DisableSSHAuth,\n \t)\n \n \tnetMap, err := e.mgmClient.GetNetworkMap(info)\ndiff --git a/client/internal/engine_ssh.go b/client/internal/engine_ssh.go\nnew file mode 100644\nindex 00000000000..861b3d6d215\n--- /dev/null\n+++ b/client/internal/engine_ssh.go\n@@ -0,0 +1,355 @@\n+package internal\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"net/netip\"\n+\t\"strings\"\n+\n+\tlog \"github.com/sirupsen/logrus\"\n+\n+\tfirewallManager \"github.com/netbirdio/netbird/client/firewall/manager\"\n+\tnftypes \"github.com/netbirdio/netbird/client/internal/netflow/types\"\n+\tsshconfig \"github.com/netbirdio/netbird/client/ssh/config\"\n+\tsshserver \"github.com/netbirdio/netbird/client/ssh/server\"\n+\tmgmProto \"github.com/netbirdio/netbird/shared/management/proto\"\n+)\n+\n+type sshServer interface {\n+\tStart(ctx context.Context, addr netip.AddrPort) error\n+\tStop() error\n+\tGetStatus() (bool, []sshserver.SessionInfo)\n+}\n+\n+func (e *Engine) setupSSHPortRedirection() error {\n+\tif e.firewall == nil || e.wgInterface == nil {\n+\t\treturn nil\n+\t}\n+\n+\tlocalAddr := e.wgInterface.Address().IP\n+\tif !localAddr.IsValid() {\n+\t\treturn errors.New(\"invalid local NetBird address\")\n+\t}\n+\n+\tif err := e.firewall.AddInboundDNAT(localAddr, firewallManager.ProtocolTCP, 22, 22022); err != nil {\n+\t\treturn fmt.Errorf(\"add SSH port redirection: %w\", err)\n+\t}\n+\tlog.Infof(\"SSH port redirection enabled: %s:22 -> %s:22022\", localAddr, localAddr)\n+\n+\treturn nil\n+}\n+\n+func (e *Engine) updateSSH(sshConf *mgmProto.SSHConfig) error {\n+\tif e.config.BlockInbound {\n+\t\tlog.Info(\"SSH server is disabled because inbound connections are blocked\")\n+\t\treturn e.stopSSHServer()\n+\t}\n+\n+\tif !e.config.ServerSSHAllowed {\n+\t\tlog.Info(\"SSH server is disabled in config\")\n+\t\treturn e.stopSSHServer()\n+\t}\n+\n+\tif !sshConf.GetSshEnabled() {\n+\t\tif e.config.ServerSSHAllowed {\n+\t\t\tlog.Info(\"SSH server is locally allowed but disabled by management server\")\n+\t\t}\n+\t\treturn e.stopSSHServer()\n+\t}\n+\n+\tif e.sshServer != nil {\n+\t\tlog.Debug(\"SSH server is already running\")\n+\t\treturn nil\n+\t}\n+\n+\tif e.config.DisableSSHAuth != nil && *e.config.DisableSSHAuth {\n+\t\tlog.Info(\"starting SSH server without JWT authentication (authentication disabled by config)\")\n+\t\treturn e.startSSHServer(nil)\n+\t}\n+\n+\tif protoJWT := sshConf.GetJwtConfig(); protoJWT != nil {\n+\t\tjwtConfig := &sshserver.JWTConfig{\n+\t\t\tIssuer:       protoJWT.GetIssuer(),\n+\t\t\tAudience:     protoJWT.GetAudience(),\n+\t\t\tKeysLocation: protoJWT.GetKeysLocation(),\n+\t\t\tMaxTokenAge:  protoJWT.GetMaxTokenAge(),\n+\t\t}\n+\n+\t\treturn e.startSSHServer(jwtConfig)\n+\t}\n+\n+\treturn errors.New(\"SSH server requires valid JWT configuration\")\n+}\n+\n+// updateSSHClientConfig updates the SSH client configuration with peer information\n+func (e *Engine) updateSSHClientConfig(remotePeers []*mgmProto.RemotePeerConfig) error {\n+\tpeerInfo := e.extractPeerSSHInfo(remotePeers)\n+\tif len(peerInfo) == 0 {\n+\t\tlog.Debug(\"no SSH-enabled peers found, skipping SSH config update\")\n+\t\treturn nil\n+\t}\n+\n+\tconfigMgr := sshconfig.New()\n+\tif err := configMgr.SetupSSHClientConfig(peerInfo); err != nil {\n+\t\tlog.Warnf(\"failed to update SSH client config: %v\", err)\n+\t\treturn nil // Don't fail engine startup on SSH config issues\n+\t}\n+\n+\tlog.Debugf(\"updated SSH client config with %d peers\", len(peerInfo))\n+\n+\tif err := e.stateManager.UpdateState(&sshconfig.ShutdownState{\n+\t\tSSHConfigDir:  configMgr.GetSSHConfigDir(),\n+\t\tSSHConfigFile: configMgr.GetSSHConfigFile(),\n+\t}); err != nil {\n+\t\tlog.Warnf(\"failed to update SSH config state: %v\", err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// extractPeerSSHInfo extracts SSH information from peer configurations\n+func (e *Engine) extractPeerSSHInfo(remotePeers []*mgmProto.RemotePeerConfig) []sshconfig.PeerSSHInfo {\n+\tvar peerInfo []sshconfig.PeerSSHInfo\n+\n+\tfor _, peerConfig := range remotePeers {\n+\t\tif peerConfig.GetSshConfig() == nil {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tsshPubKeyBytes := peerConfig.GetSshConfig().GetSshPubKey()\n+\t\tif len(sshPubKeyBytes) == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tpeerIP := e.extractPeerIP(peerConfig)\n+\t\thostname := e.extractHostname(peerConfig)\n+\n+\t\tpeerInfo = append(peerInfo, sshconfig.PeerSSHInfo{\n+\t\t\tHostname: hostname,\n+\t\t\tIP:       peerIP,\n+\t\t\tFQDN:     peerConfig.GetFqdn(),\n+\t\t})\n+\t}\n+\n+\treturn peerInfo\n+}\n+\n+// extractPeerIP extracts IP address from peer's allowed IPs\n+func (e *Engine) extractPeerIP(peerConfig *mgmProto.RemotePeerConfig) string {\n+\tif len(peerConfig.GetAllowedIps()) == 0 {\n+\t\treturn \"\"\n+\t}\n+\n+\tif prefix, err := netip.ParsePrefix(peerConfig.GetAllowedIps()[0]); err == nil {\n+\t\treturn prefix.Addr().String()\n+\t}\n+\treturn \"\"\n+}\n+\n+// extractHostname extracts short hostname from FQDN\n+func (e *Engine) extractHostname(peerConfig *mgmProto.RemotePeerConfig) string {\n+\tfqdn := peerConfig.GetFqdn()\n+\tif fqdn == \"\" {\n+\t\treturn \"\"\n+\t}\n+\n+\tparts := strings.Split(fqdn, \".\")\n+\tif len(parts) > 0 && parts[0] != \"\" {\n+\t\treturn parts[0]\n+\t}\n+\treturn \"\"\n+}\n+\n+// updatePeerSSHHostKeys updates peer SSH host keys in the status recorder for daemon API access\n+func (e *Engine) updatePeerSSHHostKeys(remotePeers []*mgmProto.RemotePeerConfig) {\n+\tfor _, peerConfig := range remotePeers {\n+\t\tif peerConfig.GetSshConfig() == nil {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tsshPubKeyBytes := peerConfig.GetSshConfig().GetSshPubKey()\n+\t\tif len(sshPubKeyBytes) == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif err := e.statusRecorder.UpdatePeerSSHHostKey(peerConfig.GetWgPubKey(), sshPubKeyBytes); err != nil {\n+\t\t\tlog.Warnf(\"failed to update SSH host key for peer %s: %v\", peerConfig.GetWgPubKey(), err)\n+\t\t}\n+\t}\n+\n+\tlog.Debugf(\"updated peer SSH host keys for daemon API access\")\n+}\n+\n+// GetPeerSSHKey returns the SSH host key for a specific peer by IP or FQDN\n+func (e *Engine) GetPeerSSHKey(peerAddress string) ([]byte, bool) {\n+\te.syncMsgMux.Lock()\n+\tstatusRecorder := e.statusRecorder\n+\te.syncMsgMux.Unlock()\n+\n+\tif statusRecorder == nil {\n+\t\treturn nil, false\n+\t}\n+\n+\tfullStatus := statusRecorder.GetFullStatus()\n+\tfor _, peerState := range fullStatus.Peers {\n+\t\tif peerState.IP == peerAddress || peerState.FQDN == peerAddress {\n+\t\t\tif len(peerState.SSHHostKey) > 0 {\n+\t\t\t\treturn peerState.SSHHostKey, true\n+\t\t\t}\n+\t\t\treturn nil, false\n+\t\t}\n+\t}\n+\n+\treturn nil, false\n+}\n+\n+// cleanupSSHConfig removes NetBird SSH client configuration on shutdown\n+func (e *Engine) cleanupSSHConfig() {\n+\tconfigMgr := sshconfig.New()\n+\n+\tif err := configMgr.RemoveSSHClientConfig(); err != nil {\n+\t\tlog.Warnf(\"failed to remove SSH client config: %v\", err)\n+\t} else {\n+\t\tlog.Debugf(\"SSH client config cleanup completed\")\n+\t}\n+}\n+\n+// startSSHServer initializes and starts the SSH server with proper configuration.\n+func (e *Engine) startSSHServer(jwtConfig *sshserver.JWTConfig) error {\n+\tif e.wgInterface == nil {\n+\t\treturn errors.New(\"wg interface not initialized\")\n+\t}\n+\n+\tserverConfig := &sshserver.Config{\n+\t\tHostKeyPEM: e.config.SSHKey,\n+\t\tJWT:        jwtConfig,\n+\t}\n+\tserver := sshserver.New(serverConfig)\n+\n+\twgAddr := e.wgInterface.Address()\n+\tserver.SetNetworkValidation(wgAddr)\n+\n+\tnetbirdIP := wgAddr.IP\n+\tlistenAddr := netip.AddrPortFrom(netbirdIP, sshserver.InternalSSHPort)\n+\n+\tif netstackNet := e.wgInterface.GetNet(); netstackNet != nil {\n+\t\tserver.SetNetstackNet(netstackNet)\n+\t}\n+\n+\te.configureSSHServer(server)\n+\n+\tif err := server.Start(e.ctx, listenAddr); err != nil {\n+\t\treturn fmt.Errorf(\"start SSH server: %w\", err)\n+\t}\n+\n+\te.sshServer = server\n+\n+\tif netstackNet := e.wgInterface.GetNet(); netstackNet != nil {\n+\t\tif registrar, ok := e.firewall.(interface {\n+\t\t\tRegisterNetstackService(protocol nftypes.Protocol, port uint16)\n+\t\t}); ok {\n+\t\t\tregistrar.RegisterNetstackService(nftypes.TCP, sshserver.InternalSSHPort)\n+\t\t\tlog.Debugf(\"registered SSH service with netstack for TCP:%d\", sshserver.InternalSSHPort)\n+\t\t}\n+\t}\n+\n+\tif err := e.setupSSHPortRedirection(); err != nil {\n+\t\tlog.Warnf(\"failed to setup SSH port redirection: %v\", err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// configureSSHServer applies SSH configuration options to the server.\n+func (e *Engine) configureSSHServer(server *sshserver.Server) {\n+\tif e.config.EnableSSHRoot != nil && *e.config.EnableSSHRoot {\n+\t\tserver.SetAllowRootLogin(true)\n+\t\tlog.Info(\"SSH root login enabled\")\n+\t} else {\n+\t\tserver.SetAllowRootLogin(false)\n+\t\tlog.Info(\"SSH root login disabled (default)\")\n+\t}\n+\n+\tif e.config.EnableSSHSFTP != nil && *e.config.EnableSSHSFTP {\n+\t\tserver.SetAllowSFTP(true)\n+\t\tlog.Info(\"SSH SFTP subsystem enabled\")\n+\t} else {\n+\t\tserver.SetAllowSFTP(false)\n+\t\tlog.Info(\"SSH SFTP subsystem disabled (default)\")\n+\t}\n+\n+\tif e.config.EnableSSHLocalPortForwarding != nil && *e.config.EnableSSHLocalPortForwarding {\n+\t\tserver.SetAllowLocalPortForwarding(true)\n+\t\tlog.Info(\"SSH local port forwarding enabled\")\n+\t} else {\n+\t\tserver.SetAllowLocalPortForwarding(false)\n+\t\tlog.Info(\"SSH local port forwarding disabled (default)\")\n+\t}\n+\n+\tif e.config.EnableSSHRemotePortForwarding != nil && *e.config.EnableSSHRemotePortForwarding {\n+\t\tserver.SetAllowRemotePortForwarding(true)\n+\t\tlog.Info(\"SSH remote port forwarding enabled\")\n+\t} else {\n+\t\tserver.SetAllowRemotePortForwarding(false)\n+\t\tlog.Info(\"SSH remote port forwarding disabled (default)\")\n+\t}\n+}\n+\n+func (e *Engine) cleanupSSHPortRedirection() error {\n+\tif e.firewall == nil || e.wgInterface == nil {\n+\t\treturn nil\n+\t}\n+\n+\tlocalAddr := e.wgInterface.Address().IP\n+\tif !localAddr.IsValid() {\n+\t\treturn errors.New(\"invalid local NetBird address\")\n+\t}\n+\n+\tif err := e.firewall.RemoveInboundDNAT(localAddr, firewallManager.ProtocolTCP, 22, 22022); err != nil {\n+\t\treturn fmt.Errorf(\"remove SSH port redirection: %w\", err)\n+\t}\n+\tlog.Debugf(\"SSH port redirection removed: %s:22 -> %s:22022\", localAddr, localAddr)\n+\n+\treturn nil\n+}\n+\n+func (e *Engine) stopSSHServer() error {\n+\tif e.sshServer == nil {\n+\t\treturn nil\n+\t}\n+\n+\tif err := e.cleanupSSHPortRedirection(); err != nil {\n+\t\tlog.Warnf(\"failed to cleanup SSH port redirection: %v\", err)\n+\t}\n+\n+\tif netstackNet := e.wgInterface.GetNet(); netstackNet != nil {\n+\t\tif registrar, ok := e.firewall.(interface {\n+\t\t\tUnregisterNetstackService(protocol nftypes.Protocol, port uint16)\n+\t\t}); ok {\n+\t\t\tregistrar.UnregisterNetstackService(nftypes.TCP, sshserver.InternalSSHPort)\n+\t\t\tlog.Debugf(\"unregistered SSH service from netstack for TCP:%d\", sshserver.InternalSSHPort)\n+\t\t}\n+\t}\n+\n+\tlog.Info(\"stopping SSH server\")\n+\terr := e.sshServer.Stop()\n+\te.sshServer = nil\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"stop: %w\", err)\n+\t}\n+\treturn nil\n+}\n+\n+// GetSSHServerStatus returns the SSH server status and active sessions\n+func (e *Engine) GetSSHServerStatus() (enabled bool, sessions []sshserver.SessionInfo) {\n+\te.syncMsgMux.Lock()\n+\tsshServer := e.sshServer\n+\te.syncMsgMux.Unlock()\n+\n+\tif sshServer == nil {\n+\t\treturn false, nil\n+\t}\n+\n+\treturn sshServer.GetStatus()\n+}\ndiff --git a/client/internal/login.go b/client/internal/login.go\nindex 257e3c3acb9..f528783ef0d 100644\n--- a/client/internal/login.go\n+++ b/client/internal/login.go\n@@ -124,6 +124,11 @@ func doMgmLogin(ctx context.Context, mgmClient *mgm.GrpcClient, pubSSHKey []byte\n \t\tconfig.BlockLANAccess,\n \t\tconfig.BlockInbound,\n \t\tconfig.LazyConnectionEnabled,\n+\t\tconfig.EnableSSHRoot,\n+\t\tconfig.EnableSSHSFTP,\n+\t\tconfig.EnableSSHLocalPortForwarding,\n+\t\tconfig.EnableSSHRemotePortForwarding,\n+\t\tconfig.DisableSSHAuth,\n \t)\n \tloginResp, err := mgmClient.Login(*serverKey, sysInfo, pubSSHKey, config.DNSLabels)\n \treturn serverKey, loginResp, err\n@@ -150,6 +155,11 @@ func registerPeer(ctx context.Context, serverPublicKey wgtypes.Key, client *mgm.\n \t\tconfig.BlockLANAccess,\n \t\tconfig.BlockInbound,\n \t\tconfig.LazyConnectionEnabled,\n+\t\tconfig.EnableSSHRoot,\n+\t\tconfig.EnableSSHSFTP,\n+\t\tconfig.EnableSSHLocalPortForwarding,\n+\t\tconfig.EnableSSHRemotePortForwarding,\n+\t\tconfig.DisableSSHAuth,\n \t)\n \tloginResp, err := client.Register(serverPublicKey, validSetupKey.String(), jwtToken, info, pubSSHKey, config.DNSLabels)\n \tif err != nil {\ndiff --git a/client/internal/peer/conn.go b/client/internal/peer/conn.go\nindex 68afe986a48..426c31e1ad2 100644\n--- a/client/internal/peer/conn.go\n+++ b/client/internal/peer/conn.go\n@@ -666,7 +666,7 @@ func (conn *Conn) isConnectedOnAllWay() (connected bool) {\n \t\t}\n \t}()\n \n-\tif conn.statusICE.Get() == worker.StatusDisconnected && !conn.workerICE.InProgress() {\n+\tif runtime.GOOS != \"js\" && conn.statusICE.Get() == worker.StatusDisconnected && !conn.workerICE.InProgress() {\n \t\treturn false\n \t}\n \ndiff --git a/client/internal/peer/env.go b/client/internal/peer/env.go\nindex 32a458d00a0..7f500c410c3 100644\n--- a/client/internal/peer/env.go\n+++ b/client/internal/peer/env.go\n@@ -2,6 +2,7 @@ package peer\n \n import (\n \t\"os\"\n+\t\"runtime\"\n \t\"strings\"\n )\n \n@@ -10,5 +11,8 @@ const (\n )\n \n func isForceRelayed() bool {\n+\tif runtime.GOOS == \"js\" {\n+\t\treturn true\n+\t}\n \treturn strings.EqualFold(os.Getenv(EnvKeyNBForceRelay), \"true\")\n }\ndiff --git a/client/internal/peer/status.go b/client/internal/peer/status.go\nindex 239cce7e032..76f4f523c1b 100644\n--- a/client/internal/peer/status.go\n+++ b/client/internal/peer/status.go\n@@ -21,9 +21,9 @@ import (\n \t\"github.com/netbirdio/netbird/client/internal/ingressgw\"\n \t\"github.com/netbirdio/netbird/client/internal/relay\"\n \t\"github.com/netbirdio/netbird/client/proto\"\n+\t\"github.com/netbirdio/netbird/route\"\n \t\"github.com/netbirdio/netbird/shared/management/domain\"\n \trelayClient \"github.com/netbirdio/netbird/shared/relay/client\"\n-\t\"github.com/netbirdio/netbird/route\"\n )\n \n const eventQueueSize = 10\n@@ -67,6 +67,7 @@ type State struct {\n \tBytesRx                    int64\n \tLatency                    time.Duration\n \tRosenpassEnabled           bool\n+\tSSHHostKey                 []byte\n \troutes                     map[string]struct{}\n }\n \n@@ -572,6 +573,22 @@ func (d *Status) UpdatePeerFQDN(peerPubKey, fqdn string) error {\n \treturn nil\n }\n \n+// UpdatePeerSSHHostKey updates peer's SSH host key\n+func (d *Status) UpdatePeerSSHHostKey(peerPubKey string, sshHostKey []byte) error {\n+\td.mux.Lock()\n+\tdefer d.mux.Unlock()\n+\n+\tpeerState, ok := d.peers[peerPubKey]\n+\tif !ok {\n+\t\treturn errors.New(\"peer doesn't exist\")\n+\t}\n+\n+\tpeerState.SSHHostKey = sshHostKey\n+\td.peers[peerPubKey] = peerState\n+\n+\treturn nil\n+}\n+\n // FinishPeerListModifications this event invoke the notification\n func (d *Status) FinishPeerListModifications() {\n \td.mux.Lock()\ndiff --git a/client/internal/profilemanager/config.go b/client/internal/profilemanager/config.go\nindex f038220891e..8f467a21475 100644\n--- a/client/internal/profilemanager/config.go\n+++ b/client/internal/profilemanager/config.go\n@@ -44,24 +44,30 @@ var DefaultInterfaceBlacklist = []string{\n \n // ConfigInput carries configuration changes to the client\n type ConfigInput struct {\n-\tManagementURL       string\n-\tAdminURL            string\n-\tConfigPath          string\n-\tStateFilePath       string\n-\tPreSharedKey        *string\n-\tServerSSHAllowed    *bool\n-\tNATExternalIPs      []string\n-\tCustomDNSAddress    []byte\n-\tRosenpassEnabled    *bool\n-\tRosenpassPermissive *bool\n-\tInterfaceName       *string\n-\tWireguardPort       *int\n-\tNetworkMonitor      *bool\n-\tDisableAutoConnect  *bool\n-\tExtraIFaceBlackList []string\n-\tDNSRouteInterval    *time.Duration\n-\tClientCertPath      string\n-\tClientCertKeyPath   string\n+\tManagementURL                 string\n+\tAdminURL                      string\n+\tConfigPath                    string\n+\tStateFilePath                 string\n+\tPreSharedKey                  *string\n+\tServerSSHAllowed              *bool\n+\tEnableSSHRoot                 *bool\n+\tEnableSSHSFTP                 *bool\n+\tEnableSSHLocalPortForwarding  *bool\n+\tEnableSSHRemotePortForwarding *bool\n+\tDisableSSHAuth                *bool\n+\tSSHJWTCacheTTL                *int\n+\tNATExternalIPs                []string\n+\tCustomDNSAddress              []byte\n+\tRosenpassEnabled              *bool\n+\tRosenpassPermissive           *bool\n+\tInterfaceName                 *string\n+\tWireguardPort                 *int\n+\tNetworkMonitor                *bool\n+\tDisableAutoConnect            *bool\n+\tExtraIFaceBlackList           []string\n+\tDNSRouteInterval              *time.Duration\n+\tClientCertPath                string\n+\tClientCertKeyPath             string\n \n \tDisableClientRoutes *bool\n \tDisableServerRoutes *bool\n@@ -82,18 +88,24 @@ type ConfigInput struct {\n // Config Configuration type\n type Config struct {\n \t// Wireguard private key of local peer\n-\tPrivateKey           string\n-\tPreSharedKey         string\n-\tManagementURL        *url.URL\n-\tAdminURL             *url.URL\n-\tWgIface              string\n-\tWgPort               int\n-\tNetworkMonitor       *bool\n-\tIFaceBlackList       []string\n-\tDisableIPv6Discovery bool\n-\tRosenpassEnabled     bool\n-\tRosenpassPermissive  bool\n-\tServerSSHAllowed     *bool\n+\tPrivateKey                    string\n+\tPreSharedKey                  string\n+\tManagementURL                 *url.URL\n+\tAdminURL                      *url.URL\n+\tWgIface                       string\n+\tWgPort                        int\n+\tNetworkMonitor                *bool\n+\tIFaceBlackList                []string\n+\tDisableIPv6Discovery          bool\n+\tRosenpassEnabled              bool\n+\tRosenpassPermissive           bool\n+\tServerSSHAllowed              *bool\n+\tEnableSSHRoot                 *bool\n+\tEnableSSHSFTP                 *bool\n+\tEnableSSHLocalPortForwarding  *bool\n+\tEnableSSHRemotePortForwarding *bool\n+\tDisableSSHAuth                *bool\n+\tSSHJWTCacheTTL                *int\n \n \tDisableClientRoutes bool\n \tDisableServerRoutes bool\n@@ -376,6 +388,62 @@ func (config *Config) apply(input ConfigInput) (updated bool, err error) {\n \t\tupdated = true\n \t}\n \n+\tif input.EnableSSHRoot != nil && input.EnableSSHRoot != config.EnableSSHRoot {\n+\t\tif *input.EnableSSHRoot {\n+\t\t\tlog.Infof(\"enabling SSH root login\")\n+\t\t} else {\n+\t\t\tlog.Infof(\"disabling SSH root login\")\n+\t\t}\n+\t\tconfig.EnableSSHRoot = input.EnableSSHRoot\n+\t\tupdated = true\n+\t}\n+\n+\tif input.EnableSSHSFTP != nil && input.EnableSSHSFTP != config.EnableSSHSFTP {\n+\t\tif *input.EnableSSHSFTP {\n+\t\t\tlog.Infof(\"enabling SSH SFTP subsystem\")\n+\t\t} else {\n+\t\t\tlog.Infof(\"disabling SSH SFTP subsystem\")\n+\t\t}\n+\t\tconfig.EnableSSHSFTP = input.EnableSSHSFTP\n+\t\tupdated = true\n+\t}\n+\n+\tif input.EnableSSHLocalPortForwarding != nil && input.EnableSSHLocalPortForwarding != config.EnableSSHLocalPortForwarding {\n+\t\tif *input.EnableSSHLocalPortForwarding {\n+\t\t\tlog.Infof(\"enabling SSH local port forwarding\")\n+\t\t} else {\n+\t\t\tlog.Infof(\"disabling SSH local port forwarding\")\n+\t\t}\n+\t\tconfig.EnableSSHLocalPortForwarding = input.EnableSSHLocalPortForwarding\n+\t\tupdated = true\n+\t}\n+\n+\tif input.EnableSSHRemotePortForwarding != nil && input.EnableSSHRemotePortForwarding != config.EnableSSHRemotePortForwarding {\n+\t\tif *input.EnableSSHRemotePortForwarding {\n+\t\t\tlog.Infof(\"enabling SSH remote port forwarding\")\n+\t\t} else {\n+\t\t\tlog.Infof(\"disabling SSH remote port forwarding\")\n+\t\t}\n+\t\tconfig.EnableSSHRemotePortForwarding = input.EnableSSHRemotePortForwarding\n+\t\tupdated = true\n+\t}\n+\n+\tif input.DisableSSHAuth != nil && input.DisableSSHAuth != config.DisableSSHAuth {\n+\t\tif *input.DisableSSHAuth {\n+\t\t\tlog.Infof(\"disabling SSH authentication\")\n+\t\t} else {\n+\t\t\tlog.Infof(\"enabling SSH authentication\")\n+\t\t}\n+\t\tconfig.DisableSSHAuth = input.DisableSSHAuth\n+\t\tupdated = true\n+\t}\n+\n+\tif input.SSHJWTCacheTTL != nil && input.SSHJWTCacheTTL != config.SSHJWTCacheTTL {\n+\t\tlog.Infof(\"updating SSH JWT cache TTL to %d seconds\", *input.SSHJWTCacheTTL)\n+\t\tconfig.SSHJWTCacheTTL = input.SSHJWTCacheTTL\n+\t\tupdated = true\n+\t}\n+\n \tif input.DNSRouteInterval != nil && *input.DNSRouteInterval != config.DNSRouteInterval {\n \t\tlog.Infof(\"updating DNS route interval to %s (old value %s)\",\n \t\t\tinput.DNSRouteInterval.String(), config.DNSRouteInterval.String())\ndiff --git a/client/internal/profilemanager/profilemanager.go b/client/internal/profilemanager/profilemanager.go\nindex fe0afae2bff..c87f521cb13 100644\n--- a/client/internal/profilemanager/profilemanager.go\n+++ b/client/internal/profilemanager/profilemanager.go\n@@ -132,3 +132,21 @@ func (pm *ProfileManager) setActiveProfileState(profileName string) error {\n \n \treturn nil\n }\n+\n+// GetLoginHint retrieves the email from the active profile to use as login_hint.\n+func GetLoginHint() string {\n+\tpm := NewProfileManager()\n+\tactiveProf, err := pm.GetActiveProfile()\n+\tif err != nil {\n+\t\tlog.Debugf(\"failed to get active profile for login hint: %v\", err)\n+\t\treturn \"\"\n+\t}\n+\n+\tprofileState, err := pm.GetProfileState(activeProf.Name)\n+\tif err != nil {\n+\t\tlog.Debugf(\"failed to get profile state for login hint: %v\", err)\n+\t\treturn \"\"\n+\t}\n+\n+\treturn profileState.Email\n+}\ndiff --git a/client/internal/routemanager/dynamic/route.go b/client/internal/routemanager/dynamic/route.go\nindex 587e05c7422..8d1398a7a37 100644\n--- a/client/internal/routemanager/dynamic/route.go\n+++ b/client/internal/routemanager/dynamic/route.go\n@@ -18,8 +18,8 @@ import (\n \t\"github.com/netbirdio/netbird/client/internal/routemanager/iface\"\n \t\"github.com/netbirdio/netbird/client/internal/routemanager/refcounter\"\n \t\"github.com/netbirdio/netbird/client/internal/routemanager/util\"\n-\t\"github.com/netbirdio/netbird/shared/management/domain\"\n \t\"github.com/netbirdio/netbird/route\"\n+\t\"github.com/netbirdio/netbird/shared/management/domain\"\n )\n \n const (\ndiff --git a/client/internal/routemanager/manager.go b/client/internal/routemanager/manager.go\nindex 26cf758d90f..2baa0e6683a 100644\n--- a/client/internal/routemanager/manager.go\n+++ b/client/internal/routemanager/manager.go\n@@ -24,7 +24,6 @@ import (\n \t\"github.com/netbirdio/netbird/client/iface/netstack\"\n \t\"github.com/netbirdio/netbird/client/internal/dns\"\n \t\"github.com/netbirdio/netbird/client/internal/listener\"\n-\tnbdns \"github.com/netbirdio/netbird/dns\"\n \t\"github.com/netbirdio/netbird/client/internal/peer\"\n \t\"github.com/netbirdio/netbird/client/internal/peerstore\"\n \t\"github.com/netbirdio/netbird/client/internal/routemanager/client\"\n@@ -39,6 +38,7 @@ import (\n \t\"github.com/netbirdio/netbird/client/internal/routeselector\"\n \t\"github.com/netbirdio/netbird/client/internal/statemanager\"\n \tnbnet \"github.com/netbirdio/netbird/client/net\"\n+\tnbdns \"github.com/netbirdio/netbird/dns\"\n \t\"github.com/netbirdio/netbird/route\"\n \trelayClient \"github.com/netbirdio/netbird/shared/relay/client\"\n \t\"github.com/netbirdio/netbird/version\"\ndiff --git a/client/ios/NetBirdSDK/client.go b/client/ios/NetBirdSDK/client.go\nindex fa1c89aab6a..b0d377c21bf 100644\n--- a/client/ios/NetBirdSDK/client.go\n+++ b/client/ios/NetBirdSDK/client.go\n@@ -20,8 +20,8 @@ import (\n \t\"github.com/netbirdio/netbird/client/internal/profilemanager\"\n \t\"github.com/netbirdio/netbird/client/system\"\n \t\"github.com/netbirdio/netbird/formatter\"\n-\t\"github.com/netbirdio/netbird/shared/management/domain\"\n \t\"github.com/netbirdio/netbird/route\"\n+\t\"github.com/netbirdio/netbird/shared/management/domain\"\n )\n \n // ConnectionListener export internal Listener for mobile\ndiff --git a/client/proto/daemon.pb.go b/client/proto/daemon.pb.go\nindex 02f09b08a0d..7b9ae25f755 100644\n--- a/client/proto/daemon.pb.go\n+++ b/client/proto/daemon.pb.go\n@@ -137,7 +137,7 @@ func (x SystemEvent_Severity) Number() protoreflect.EnumNumber {\n \n // Deprecated: Use SystemEvent_Severity.Descriptor instead.\n func (SystemEvent_Severity) EnumDescriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{49, 0}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{51, 0}\n }\n \n type SystemEvent_Category int32\n@@ -192,7 +192,7 @@ func (x SystemEvent_Category) Number() protoreflect.EnumNumber {\n \n // Deprecated: Use SystemEvent_Category.Descriptor instead.\n func (SystemEvent_Category) EnumDescriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{49, 1}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{51, 1}\n }\n \n type EmptyRequest struct {\n@@ -280,9 +280,15 @@ type LoginRequest struct {\n \tUsername              *string `protobuf:\"bytes,31,opt,name=username,proto3,oneof\" json:\"username,omitempty\"`\n \tMtu                   *int64  `protobuf:\"varint,32,opt,name=mtu,proto3,oneof\" json:\"mtu,omitempty\"`\n \t// hint is used to pre-fill the email/username field during SSO authentication\n-\tHint          *string `protobuf:\"bytes,33,opt,name=hint,proto3,oneof\" json:\"hint,omitempty\"`\n-\tunknownFields protoimpl.UnknownFields\n-\tsizeCache     protoimpl.SizeCache\n+\tHint                          *string `protobuf:\"bytes,33,opt,name=hint,proto3,oneof\" json:\"hint,omitempty\"`\n+\tEnableSSHRoot                 *bool   `protobuf:\"varint,34,opt,name=enableSSHRoot,proto3,oneof\" json:\"enableSSHRoot,omitempty\"`\n+\tEnableSSHSFTP                 *bool   `protobuf:\"varint,35,opt,name=enableSSHSFTP,proto3,oneof\" json:\"enableSSHSFTP,omitempty\"`\n+\tEnableSSHLocalPortForwarding  *bool   `protobuf:\"varint,36,opt,name=enableSSHLocalPortForwarding,proto3,oneof\" json:\"enableSSHLocalPortForwarding,omitempty\"`\n+\tEnableSSHRemotePortForwarding *bool   `protobuf:\"varint,37,opt,name=enableSSHRemotePortForwarding,proto3,oneof\" json:\"enableSSHRemotePortForwarding,omitempty\"`\n+\tDisableSSHAuth                *bool   `protobuf:\"varint,38,opt,name=disableSSHAuth,proto3,oneof\" json:\"disableSSHAuth,omitempty\"`\n+\tSshJWTCacheTTL                *int32  `protobuf:\"varint,39,opt,name=sshJWTCacheTTL,proto3,oneof\" json:\"sshJWTCacheTTL,omitempty\"`\n+\tunknownFields                 protoimpl.UnknownFields\n+\tsizeCache                     protoimpl.SizeCache\n }\n \n func (x *LoginRequest) Reset() {\n@@ -547,6 +553,48 @@ func (x *LoginRequest) GetHint() string {\n \treturn \"\"\n }\n \n+func (x *LoginRequest) GetEnableSSHRoot() bool {\n+\tif x != nil && x.EnableSSHRoot != nil {\n+\t\treturn *x.EnableSSHRoot\n+\t}\n+\treturn false\n+}\n+\n+func (x *LoginRequest) GetEnableSSHSFTP() bool {\n+\tif x != nil && x.EnableSSHSFTP != nil {\n+\t\treturn *x.EnableSSHSFTP\n+\t}\n+\treturn false\n+}\n+\n+func (x *LoginRequest) GetEnableSSHLocalPortForwarding() bool {\n+\tif x != nil && x.EnableSSHLocalPortForwarding != nil {\n+\t\treturn *x.EnableSSHLocalPortForwarding\n+\t}\n+\treturn false\n+}\n+\n+func (x *LoginRequest) GetEnableSSHRemotePortForwarding() bool {\n+\tif x != nil && x.EnableSSHRemotePortForwarding != nil {\n+\t\treturn *x.EnableSSHRemotePortForwarding\n+\t}\n+\treturn false\n+}\n+\n+func (x *LoginRequest) GetDisableSSHAuth() bool {\n+\tif x != nil && x.DisableSSHAuth != nil {\n+\t\treturn *x.DisableSSHAuth\n+\t}\n+\treturn false\n+}\n+\n+func (x *LoginRequest) GetSshJWTCacheTTL() int32 {\n+\tif x != nil && x.SshJWTCacheTTL != nil {\n+\t\treturn *x.SshJWTCacheTTL\n+\t}\n+\treturn 0\n+}\n+\n type LoginResponse struct {\n \tstate                   protoimpl.MessageState `protogen:\"open.v1\"`\n \tNeedsSSOLogin           bool                   `protobuf:\"varint,1,opt,name=needsSSOLogin,proto3\" json:\"needsSSOLogin,omitempty\"`\n@@ -1057,24 +1105,30 @@ type GetConfigResponse struct {\n \t// preSharedKey settings value.\n \tPreSharedKey string `protobuf:\"bytes,4,opt,name=preSharedKey,proto3\" json:\"preSharedKey,omitempty\"`\n \t// adminURL settings value.\n-\tAdminURL              string `protobuf:\"bytes,5,opt,name=adminURL,proto3\" json:\"adminURL,omitempty\"`\n-\tInterfaceName         string `protobuf:\"bytes,6,opt,name=interfaceName,proto3\" json:\"interfaceName,omitempty\"`\n-\tWireguardPort         int64  `protobuf:\"varint,7,opt,name=wireguardPort,proto3\" json:\"wireguardPort,omitempty\"`\n-\tMtu                   int64  `protobuf:\"varint,8,opt,name=mtu,proto3\" json:\"mtu,omitempty\"`\n-\tDisableAutoConnect    bool   `protobuf:\"varint,9,opt,name=disableAutoConnect,proto3\" json:\"disableAutoConnect,omitempty\"`\n-\tServerSSHAllowed      bool   `protobuf:\"varint,10,opt,name=serverSSHAllowed,proto3\" json:\"serverSSHAllowed,omitempty\"`\n-\tRosenpassEnabled      bool   `protobuf:\"varint,11,opt,name=rosenpassEnabled,proto3\" json:\"rosenpassEnabled,omitempty\"`\n-\tRosenpassPermissive   bool   `protobuf:\"varint,12,opt,name=rosenpassPermissive,proto3\" json:\"rosenpassPermissive,omitempty\"`\n-\tDisableNotifications  bool   `protobuf:\"varint,13,opt,name=disable_notifications,json=disableNotifications,proto3\" json:\"disable_notifications,omitempty\"`\n-\tLazyConnectionEnabled bool   `protobuf:\"varint,14,opt,name=lazyConnectionEnabled,proto3\" json:\"lazyConnectionEnabled,omitempty\"`\n-\tBlockInbound          bool   `protobuf:\"varint,15,opt,name=blockInbound,proto3\" json:\"blockInbound,omitempty\"`\n-\tNetworkMonitor        bool   `protobuf:\"varint,16,opt,name=networkMonitor,proto3\" json:\"networkMonitor,omitempty\"`\n-\tDisableDns            bool   `protobuf:\"varint,17,opt,name=disable_dns,json=disableDns,proto3\" json:\"disable_dns,omitempty\"`\n-\tDisableClientRoutes   bool   `protobuf:\"varint,18,opt,name=disable_client_routes,json=disableClientRoutes,proto3\" json:\"disable_client_routes,omitempty\"`\n-\tDisableServerRoutes   bool   `protobuf:\"varint,19,opt,name=disable_server_routes,json=disableServerRoutes,proto3\" json:\"disable_server_routes,omitempty\"`\n-\tBlockLanAccess        bool   `protobuf:\"varint,20,opt,name=block_lan_access,json=blockLanAccess,proto3\" json:\"block_lan_access,omitempty\"`\n-\tunknownFields         protoimpl.UnknownFields\n-\tsizeCache             protoimpl.SizeCache\n+\tAdminURL                      string `protobuf:\"bytes,5,opt,name=adminURL,proto3\" json:\"adminURL,omitempty\"`\n+\tInterfaceName                 string `protobuf:\"bytes,6,opt,name=interfaceName,proto3\" json:\"interfaceName,omitempty\"`\n+\tWireguardPort                 int64  `protobuf:\"varint,7,opt,name=wireguardPort,proto3\" json:\"wireguardPort,omitempty\"`\n+\tMtu                           int64  `protobuf:\"varint,8,opt,name=mtu,proto3\" json:\"mtu,omitempty\"`\n+\tDisableAutoConnect            bool   `protobuf:\"varint,9,opt,name=disableAutoConnect,proto3\" json:\"disableAutoConnect,omitempty\"`\n+\tServerSSHAllowed              bool   `protobuf:\"varint,10,opt,name=serverSSHAllowed,proto3\" json:\"serverSSHAllowed,omitempty\"`\n+\tRosenpassEnabled              bool   `protobuf:\"varint,11,opt,name=rosenpassEnabled,proto3\" json:\"rosenpassEnabled,omitempty\"`\n+\tRosenpassPermissive           bool   `protobuf:\"varint,12,opt,name=rosenpassPermissive,proto3\" json:\"rosenpassPermissive,omitempty\"`\n+\tDisableNotifications          bool   `protobuf:\"varint,13,opt,name=disable_notifications,json=disableNotifications,proto3\" json:\"disable_notifications,omitempty\"`\n+\tLazyConnectionEnabled         bool   `protobuf:\"varint,14,opt,name=lazyConnectionEnabled,proto3\" json:\"lazyConnectionEnabled,omitempty\"`\n+\tBlockInbound                  bool   `protobuf:\"varint,15,opt,name=blockInbound,proto3\" json:\"blockInbound,omitempty\"`\n+\tNetworkMonitor                bool   `protobuf:\"varint,16,opt,name=networkMonitor,proto3\" json:\"networkMonitor,omitempty\"`\n+\tDisableDns                    bool   `protobuf:\"varint,17,opt,name=disable_dns,json=disableDns,proto3\" json:\"disable_dns,omitempty\"`\n+\tDisableClientRoutes           bool   `protobuf:\"varint,18,opt,name=disable_client_routes,json=disableClientRoutes,proto3\" json:\"disable_client_routes,omitempty\"`\n+\tDisableServerRoutes           bool   `protobuf:\"varint,19,opt,name=disable_server_routes,json=disableServerRoutes,proto3\" json:\"disable_server_routes,omitempty\"`\n+\tBlockLanAccess                bool   `protobuf:\"varint,20,opt,name=block_lan_access,json=blockLanAccess,proto3\" json:\"block_lan_access,omitempty\"`\n+\tEnableSSHRoot                 bool   `protobuf:\"varint,21,opt,name=enableSSHRoot,proto3\" json:\"enableSSHRoot,omitempty\"`\n+\tEnableSSHSFTP                 bool   `protobuf:\"varint,24,opt,name=enableSSHSFTP,proto3\" json:\"enableSSHSFTP,omitempty\"`\n+\tEnableSSHLocalPortForwarding  bool   `protobuf:\"varint,22,opt,name=enableSSHLocalPortForwarding,proto3\" json:\"enableSSHLocalPortForwarding,omitempty\"`\n+\tEnableSSHRemotePortForwarding bool   `protobuf:\"varint,23,opt,name=enableSSHRemotePortForwarding,proto3\" json:\"enableSSHRemotePortForwarding,omitempty\"`\n+\tDisableSSHAuth                bool   `protobuf:\"varint,25,opt,name=disableSSHAuth,proto3\" json:\"disableSSHAuth,omitempty\"`\n+\tSshJWTCacheTTL                int32  `protobuf:\"varint,26,opt,name=sshJWTCacheTTL,proto3\" json:\"sshJWTCacheTTL,omitempty\"`\n+\tunknownFields                 protoimpl.UnknownFields\n+\tsizeCache                     protoimpl.SizeCache\n }\n \n func (x *GetConfigResponse) Reset() {\n@@ -1247,6 +1301,48 @@ func (x *GetConfigResponse) GetBlockLanAccess() bool {\n \treturn false\n }\n \n+func (x *GetConfigResponse) GetEnableSSHRoot() bool {\n+\tif x != nil {\n+\t\treturn x.EnableSSHRoot\n+\t}\n+\treturn false\n+}\n+\n+func (x *GetConfigResponse) GetEnableSSHSFTP() bool {\n+\tif x != nil {\n+\t\treturn x.EnableSSHSFTP\n+\t}\n+\treturn false\n+}\n+\n+func (x *GetConfigResponse) GetEnableSSHLocalPortForwarding() bool {\n+\tif x != nil {\n+\t\treturn x.EnableSSHLocalPortForwarding\n+\t}\n+\treturn false\n+}\n+\n+func (x *GetConfigResponse) GetEnableSSHRemotePortForwarding() bool {\n+\tif x != nil {\n+\t\treturn x.EnableSSHRemotePortForwarding\n+\t}\n+\treturn false\n+}\n+\n+func (x *GetConfigResponse) GetDisableSSHAuth() bool {\n+\tif x != nil {\n+\t\treturn x.DisableSSHAuth\n+\t}\n+\treturn false\n+}\n+\n+func (x *GetConfigResponse) GetSshJWTCacheTTL() int32 {\n+\tif x != nil {\n+\t\treturn x.SshJWTCacheTTL\n+\t}\n+\treturn 0\n+}\n+\n // PeerState contains the latest state of a peer\n type PeerState struct {\n \tstate                      protoimpl.MessageState `protogen:\"open.v1\"`\n@@ -1267,6 +1363,7 @@ type PeerState struct {\n \tNetworks                   []string               `protobuf:\"bytes,16,rep,name=networks,proto3\" json:\"networks,omitempty\"`\n \tLatency                    *durationpb.Duration   `protobuf:\"bytes,17,opt,name=latency,proto3\" json:\"latency,omitempty\"`\n \tRelayAddress               string                 `protobuf:\"bytes,18,opt,name=relayAddress,proto3\" json:\"relayAddress,omitempty\"`\n+\tSshHostKey                 []byte                 `protobuf:\"bytes,19,opt,name=sshHostKey,proto3\" json:\"sshHostKey,omitempty\"`\n \tunknownFields              protoimpl.UnknownFields\n \tsizeCache                  protoimpl.SizeCache\n }\n@@ -1420,6 +1517,13 @@ func (x *PeerState) GetRelayAddress() string {\n \treturn \"\"\n }\n \n+func (x *PeerState) GetSshHostKey() []byte {\n+\tif x != nil {\n+\t\treturn x.SshHostKey\n+\t}\n+\treturn nil\n+}\n+\n // LocalPeerState contains the latest state of the local peer\n type LocalPeerState struct {\n \tstate               protoimpl.MessageState `protogen:\"open.v1\"`\n@@ -1764,6 +1868,128 @@ func (x *NSGroupState) GetError() string {\n \treturn \"\"\n }\n \n+// SSHSessionInfo contains information about an active SSH session\n+type SSHSessionInfo struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tUsername      string                 `protobuf:\"bytes,1,opt,name=username,proto3\" json:\"username,omitempty\"`\n+\tRemoteAddress string                 `protobuf:\"bytes,2,opt,name=remoteAddress,proto3\" json:\"remoteAddress,omitempty\"`\n+\tCommand       string                 `protobuf:\"bytes,3,opt,name=command,proto3\" json:\"command,omitempty\"`\n+\tJwtUsername   string                 `protobuf:\"bytes,4,opt,name=jwtUsername,proto3\" json:\"jwtUsername,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *SSHSessionInfo) Reset() {\n+\t*x = SSHSessionInfo{}\n+\tmi := &file_daemon_proto_msgTypes[19]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *SSHSessionInfo) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*SSHSessionInfo) ProtoMessage() {}\n+\n+func (x *SSHSessionInfo) ProtoReflect() protoreflect.Message {\n+\tmi := &file_daemon_proto_msgTypes[19]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use SSHSessionInfo.ProtoReflect.Descriptor instead.\n+func (*SSHSessionInfo) Descriptor() ([]byte, []int) {\n+\treturn file_daemon_proto_rawDescGZIP(), []int{19}\n+}\n+\n+func (x *SSHSessionInfo) GetUsername() string {\n+\tif x != nil {\n+\t\treturn x.Username\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *SSHSessionInfo) GetRemoteAddress() string {\n+\tif x != nil {\n+\t\treturn x.RemoteAddress\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *SSHSessionInfo) GetCommand() string {\n+\tif x != nil {\n+\t\treturn x.Command\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *SSHSessionInfo) GetJwtUsername() string {\n+\tif x != nil {\n+\t\treturn x.JwtUsername\n+\t}\n+\treturn \"\"\n+}\n+\n+// SSHServerState contains the latest state of the SSH server\n+type SSHServerState struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tEnabled       bool                   `protobuf:\"varint,1,opt,name=enabled,proto3\" json:\"enabled,omitempty\"`\n+\tSessions      []*SSHSessionInfo      `protobuf:\"bytes,2,rep,name=sessions,proto3\" json:\"sessions,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *SSHServerState) Reset() {\n+\t*x = SSHServerState{}\n+\tmi := &file_daemon_proto_msgTypes[20]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *SSHServerState) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*SSHServerState) ProtoMessage() {}\n+\n+func (x *SSHServerState) ProtoReflect() protoreflect.Message {\n+\tmi := &file_daemon_proto_msgTypes[20]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use SSHServerState.ProtoReflect.Descriptor instead.\n+func (*SSHServerState) Descriptor() ([]byte, []int) {\n+\treturn file_daemon_proto_rawDescGZIP(), []int{20}\n+}\n+\n+func (x *SSHServerState) GetEnabled() bool {\n+\tif x != nil {\n+\t\treturn x.Enabled\n+\t}\n+\treturn false\n+}\n+\n+func (x *SSHServerState) GetSessions() []*SSHSessionInfo {\n+\tif x != nil {\n+\t\treturn x.Sessions\n+\t}\n+\treturn nil\n+}\n+\n // FullStatus contains the full state held by the Status instance\n type FullStatus struct {\n \tstate                   protoimpl.MessageState `protogen:\"open.v1\"`\n@@ -1776,13 +2002,14 @@ type FullStatus struct {\n \tNumberOfForwardingRules int32                  `protobuf:\"varint,8,opt,name=NumberOfForwardingRules,proto3\" json:\"NumberOfForwardingRules,omitempty\"`\n \tEvents                  []*SystemEvent         `protobuf:\"bytes,7,rep,name=events,proto3\" json:\"events,omitempty\"`\n \tLazyConnectionEnabled   bool                   `protobuf:\"varint,9,opt,name=lazyConnectionEnabled,proto3\" json:\"lazyConnectionEnabled,omitempty\"`\n+\tSshServerState          *SSHServerState        `protobuf:\"bytes,10,opt,name=sshServerState,proto3\" json:\"sshServerState,omitempty\"`\n \tunknownFields           protoimpl.UnknownFields\n \tsizeCache               protoimpl.SizeCache\n }\n \n func (x *FullStatus) Reset() {\n \t*x = FullStatus{}\n-\tmi := &file_daemon_proto_msgTypes[19]\n+\tmi := &file_daemon_proto_msgTypes[21]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -1794,7 +2021,7 @@ func (x *FullStatus) String() string {\n func (*FullStatus) ProtoMessage() {}\n \n func (x *FullStatus) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[19]\n+\tmi := &file_daemon_proto_msgTypes[21]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -1807,7 +2034,7 @@ func (x *FullStatus) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use FullStatus.ProtoReflect.Descriptor instead.\n func (*FullStatus) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{19}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{21}\n }\n \n func (x *FullStatus) GetManagementState() *ManagementState {\n@@ -1873,6 +2100,13 @@ func (x *FullStatus) GetLazyConnectionEnabled() bool {\n \treturn false\n }\n \n+func (x *FullStatus) GetSshServerState() *SSHServerState {\n+\tif x != nil {\n+\t\treturn x.SshServerState\n+\t}\n+\treturn nil\n+}\n+\n // Networks\n type ListNetworksRequest struct {\n \tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n@@ -1882,7 +2116,7 @@ type ListNetworksRequest struct {\n \n func (x *ListNetworksRequest) Reset() {\n \t*x = ListNetworksRequest{}\n-\tmi := &file_daemon_proto_msgTypes[20]\n+\tmi := &file_daemon_proto_msgTypes[22]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -1894,7 +2128,7 @@ func (x *ListNetworksRequest) String() string {\n func (*ListNetworksRequest) ProtoMessage() {}\n \n func (x *ListNetworksRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[20]\n+\tmi := &file_daemon_proto_msgTypes[22]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -1907,7 +2141,7 @@ func (x *ListNetworksRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use ListNetworksRequest.ProtoReflect.Descriptor instead.\n func (*ListNetworksRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{20}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{22}\n }\n \n type ListNetworksResponse struct {\n@@ -1919,7 +2153,7 @@ type ListNetworksResponse struct {\n \n func (x *ListNetworksResponse) Reset() {\n \t*x = ListNetworksResponse{}\n-\tmi := &file_daemon_proto_msgTypes[21]\n+\tmi := &file_daemon_proto_msgTypes[23]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -1931,7 +2165,7 @@ func (x *ListNetworksResponse) String() string {\n func (*ListNetworksResponse) ProtoMessage() {}\n \n func (x *ListNetworksResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[21]\n+\tmi := &file_daemon_proto_msgTypes[23]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -1944,7 +2178,7 @@ func (x *ListNetworksResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use ListNetworksResponse.ProtoReflect.Descriptor instead.\n func (*ListNetworksResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{21}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{23}\n }\n \n func (x *ListNetworksResponse) GetRoutes() []*Network {\n@@ -1965,7 +2199,7 @@ type SelectNetworksRequest struct {\n \n func (x *SelectNetworksRequest) Reset() {\n \t*x = SelectNetworksRequest{}\n-\tmi := &file_daemon_proto_msgTypes[22]\n+\tmi := &file_daemon_proto_msgTypes[24]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -1977,7 +2211,7 @@ func (x *SelectNetworksRequest) String() string {\n func (*SelectNetworksRequest) ProtoMessage() {}\n \n func (x *SelectNetworksRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[22]\n+\tmi := &file_daemon_proto_msgTypes[24]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -1990,7 +2224,7 @@ func (x *SelectNetworksRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SelectNetworksRequest.ProtoReflect.Descriptor instead.\n func (*SelectNetworksRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{22}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{24}\n }\n \n func (x *SelectNetworksRequest) GetNetworkIDs() []string {\n@@ -2022,7 +2256,7 @@ type SelectNetworksResponse struct {\n \n func (x *SelectNetworksResponse) Reset() {\n \t*x = SelectNetworksResponse{}\n-\tmi := &file_daemon_proto_msgTypes[23]\n+\tmi := &file_daemon_proto_msgTypes[25]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2034,7 +2268,7 @@ func (x *SelectNetworksResponse) String() string {\n func (*SelectNetworksResponse) ProtoMessage() {}\n \n func (x *SelectNetworksResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[23]\n+\tmi := &file_daemon_proto_msgTypes[25]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2047,7 +2281,7 @@ func (x *SelectNetworksResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SelectNetworksResponse.ProtoReflect.Descriptor instead.\n func (*SelectNetworksResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{23}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{25}\n }\n \n type IPList struct {\n@@ -2059,7 +2293,7 @@ type IPList struct {\n \n func (x *IPList) Reset() {\n \t*x = IPList{}\n-\tmi := &file_daemon_proto_msgTypes[24]\n+\tmi := &file_daemon_proto_msgTypes[26]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2071,7 +2305,7 @@ func (x *IPList) String() string {\n func (*IPList) ProtoMessage() {}\n \n func (x *IPList) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[24]\n+\tmi := &file_daemon_proto_msgTypes[26]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2084,7 +2318,7 @@ func (x *IPList) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use IPList.ProtoReflect.Descriptor instead.\n func (*IPList) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{24}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{26}\n }\n \n func (x *IPList) GetIps() []string {\n@@ -2107,7 +2341,7 @@ type Network struct {\n \n func (x *Network) Reset() {\n \t*x = Network{}\n-\tmi := &file_daemon_proto_msgTypes[25]\n+\tmi := &file_daemon_proto_msgTypes[27]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2119,7 +2353,7 @@ func (x *Network) String() string {\n func (*Network) ProtoMessage() {}\n \n func (x *Network) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[25]\n+\tmi := &file_daemon_proto_msgTypes[27]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2132,7 +2366,7 @@ func (x *Network) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use Network.ProtoReflect.Descriptor instead.\n func (*Network) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{25}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{27}\n }\n \n func (x *Network) GetID() string {\n@@ -2184,7 +2418,7 @@ type PortInfo struct {\n \n func (x *PortInfo) Reset() {\n \t*x = PortInfo{}\n-\tmi := &file_daemon_proto_msgTypes[26]\n+\tmi := &file_daemon_proto_msgTypes[28]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2196,7 +2430,7 @@ func (x *PortInfo) String() string {\n func (*PortInfo) ProtoMessage() {}\n \n func (x *PortInfo) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[26]\n+\tmi := &file_daemon_proto_msgTypes[28]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2209,7 +2443,7 @@ func (x *PortInfo) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use PortInfo.ProtoReflect.Descriptor instead.\n func (*PortInfo) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{26}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{28}\n }\n \n func (x *PortInfo) GetPortSelection() isPortInfo_PortSelection {\n@@ -2266,7 +2500,7 @@ type ForwardingRule struct {\n \n func (x *ForwardingRule) Reset() {\n \t*x = ForwardingRule{}\n-\tmi := &file_daemon_proto_msgTypes[27]\n+\tmi := &file_daemon_proto_msgTypes[29]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2278,7 +2512,7 @@ func (x *ForwardingRule) String() string {\n func (*ForwardingRule) ProtoMessage() {}\n \n func (x *ForwardingRule) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[27]\n+\tmi := &file_daemon_proto_msgTypes[29]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2291,7 +2525,7 @@ func (x *ForwardingRule) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use ForwardingRule.ProtoReflect.Descriptor instead.\n func (*ForwardingRule) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{27}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{29}\n }\n \n func (x *ForwardingRule) GetProtocol() string {\n@@ -2338,7 +2572,7 @@ type ForwardingRulesResponse struct {\n \n func (x *ForwardingRulesResponse) Reset() {\n \t*x = ForwardingRulesResponse{}\n-\tmi := &file_daemon_proto_msgTypes[28]\n+\tmi := &file_daemon_proto_msgTypes[30]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2350,7 +2584,7 @@ func (x *ForwardingRulesResponse) String() string {\n func (*ForwardingRulesResponse) ProtoMessage() {}\n \n func (x *ForwardingRulesResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[28]\n+\tmi := &file_daemon_proto_msgTypes[30]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2363,7 +2597,7 @@ func (x *ForwardingRulesResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use ForwardingRulesResponse.ProtoReflect.Descriptor instead.\n func (*ForwardingRulesResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{28}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{30}\n }\n \n func (x *ForwardingRulesResponse) GetRules() []*ForwardingRule {\n@@ -2387,7 +2621,7 @@ type DebugBundleRequest struct {\n \n func (x *DebugBundleRequest) Reset() {\n \t*x = DebugBundleRequest{}\n-\tmi := &file_daemon_proto_msgTypes[29]\n+\tmi := &file_daemon_proto_msgTypes[31]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2399,7 +2633,7 @@ func (x *DebugBundleRequest) String() string {\n func (*DebugBundleRequest) ProtoMessage() {}\n \n func (x *DebugBundleRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[29]\n+\tmi := &file_daemon_proto_msgTypes[31]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2412,7 +2646,7 @@ func (x *DebugBundleRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use DebugBundleRequest.ProtoReflect.Descriptor instead.\n func (*DebugBundleRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{29}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{31}\n }\n \n func (x *DebugBundleRequest) GetAnonymize() bool {\n@@ -2461,7 +2695,7 @@ type DebugBundleResponse struct {\n \n func (x *DebugBundleResponse) Reset() {\n \t*x = DebugBundleResponse{}\n-\tmi := &file_daemon_proto_msgTypes[30]\n+\tmi := &file_daemon_proto_msgTypes[32]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2473,7 +2707,7 @@ func (x *DebugBundleResponse) String() string {\n func (*DebugBundleResponse) ProtoMessage() {}\n \n func (x *DebugBundleResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[30]\n+\tmi := &file_daemon_proto_msgTypes[32]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2486,7 +2720,7 @@ func (x *DebugBundleResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use DebugBundleResponse.ProtoReflect.Descriptor instead.\n func (*DebugBundleResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{30}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{32}\n }\n \n func (x *DebugBundleResponse) GetPath() string {\n@@ -2518,7 +2752,7 @@ type GetLogLevelRequest struct {\n \n func (x *GetLogLevelRequest) Reset() {\n \t*x = GetLogLevelRequest{}\n-\tmi := &file_daemon_proto_msgTypes[31]\n+\tmi := &file_daemon_proto_msgTypes[33]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2530,7 +2764,7 @@ func (x *GetLogLevelRequest) String() string {\n func (*GetLogLevelRequest) ProtoMessage() {}\n \n func (x *GetLogLevelRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[31]\n+\tmi := &file_daemon_proto_msgTypes[33]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2543,7 +2777,7 @@ func (x *GetLogLevelRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use GetLogLevelRequest.ProtoReflect.Descriptor instead.\n func (*GetLogLevelRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{31}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{33}\n }\n \n type GetLogLevelResponse struct {\n@@ -2555,7 +2789,7 @@ type GetLogLevelResponse struct {\n \n func (x *GetLogLevelResponse) Reset() {\n \t*x = GetLogLevelResponse{}\n-\tmi := &file_daemon_proto_msgTypes[32]\n+\tmi := &file_daemon_proto_msgTypes[34]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2567,7 +2801,7 @@ func (x *GetLogLevelResponse) String() string {\n func (*GetLogLevelResponse) ProtoMessage() {}\n \n func (x *GetLogLevelResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[32]\n+\tmi := &file_daemon_proto_msgTypes[34]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2580,7 +2814,7 @@ func (x *GetLogLevelResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use GetLogLevelResponse.ProtoReflect.Descriptor instead.\n func (*GetLogLevelResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{32}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{34}\n }\n \n func (x *GetLogLevelResponse) GetLevel() LogLevel {\n@@ -2599,7 +2833,7 @@ type SetLogLevelRequest struct {\n \n func (x *SetLogLevelRequest) Reset() {\n \t*x = SetLogLevelRequest{}\n-\tmi := &file_daemon_proto_msgTypes[33]\n+\tmi := &file_daemon_proto_msgTypes[35]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2611,7 +2845,7 @@ func (x *SetLogLevelRequest) String() string {\n func (*SetLogLevelRequest) ProtoMessage() {}\n \n func (x *SetLogLevelRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[33]\n+\tmi := &file_daemon_proto_msgTypes[35]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2624,7 +2858,7 @@ func (x *SetLogLevelRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SetLogLevelRequest.ProtoReflect.Descriptor instead.\n func (*SetLogLevelRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{33}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{35}\n }\n \n func (x *SetLogLevelRequest) GetLevel() LogLevel {\n@@ -2642,7 +2876,7 @@ type SetLogLevelResponse struct {\n \n func (x *SetLogLevelResponse) Reset() {\n \t*x = SetLogLevelResponse{}\n-\tmi := &file_daemon_proto_msgTypes[34]\n+\tmi := &file_daemon_proto_msgTypes[36]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2654,7 +2888,7 @@ func (x *SetLogLevelResponse) String() string {\n func (*SetLogLevelResponse) ProtoMessage() {}\n \n func (x *SetLogLevelResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[34]\n+\tmi := &file_daemon_proto_msgTypes[36]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2667,7 +2901,7 @@ func (x *SetLogLevelResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SetLogLevelResponse.ProtoReflect.Descriptor instead.\n func (*SetLogLevelResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{34}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{36}\n }\n \n // State represents a daemon state entry\n@@ -2680,7 +2914,7 @@ type State struct {\n \n func (x *State) Reset() {\n \t*x = State{}\n-\tmi := &file_daemon_proto_msgTypes[35]\n+\tmi := &file_daemon_proto_msgTypes[37]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2692,7 +2926,7 @@ func (x *State) String() string {\n func (*State) ProtoMessage() {}\n \n func (x *State) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[35]\n+\tmi := &file_daemon_proto_msgTypes[37]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2705,7 +2939,7 @@ func (x *State) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use State.ProtoReflect.Descriptor instead.\n func (*State) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{35}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{37}\n }\n \n func (x *State) GetName() string {\n@@ -2724,7 +2958,7 @@ type ListStatesRequest struct {\n \n func (x *ListStatesRequest) Reset() {\n \t*x = ListStatesRequest{}\n-\tmi := &file_daemon_proto_msgTypes[36]\n+\tmi := &file_daemon_proto_msgTypes[38]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2736,7 +2970,7 @@ func (x *ListStatesRequest) String() string {\n func (*ListStatesRequest) ProtoMessage() {}\n \n func (x *ListStatesRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[36]\n+\tmi := &file_daemon_proto_msgTypes[38]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2749,7 +2983,7 @@ func (x *ListStatesRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use ListStatesRequest.ProtoReflect.Descriptor instead.\n func (*ListStatesRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{36}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{38}\n }\n \n // ListStatesResponse contains a list of states\n@@ -2762,7 +2996,7 @@ type ListStatesResponse struct {\n \n func (x *ListStatesResponse) Reset() {\n \t*x = ListStatesResponse{}\n-\tmi := &file_daemon_proto_msgTypes[37]\n+\tmi := &file_daemon_proto_msgTypes[39]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2774,7 +3008,7 @@ func (x *ListStatesResponse) String() string {\n func (*ListStatesResponse) ProtoMessage() {}\n \n func (x *ListStatesResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[37]\n+\tmi := &file_daemon_proto_msgTypes[39]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2787,7 +3021,7 @@ func (x *ListStatesResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use ListStatesResponse.ProtoReflect.Descriptor instead.\n func (*ListStatesResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{37}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{39}\n }\n \n func (x *ListStatesResponse) GetStates() []*State {\n@@ -2808,7 +3042,7 @@ type CleanStateRequest struct {\n \n func (x *CleanStateRequest) Reset() {\n \t*x = CleanStateRequest{}\n-\tmi := &file_daemon_proto_msgTypes[38]\n+\tmi := &file_daemon_proto_msgTypes[40]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2820,7 +3054,7 @@ func (x *CleanStateRequest) String() string {\n func (*CleanStateRequest) ProtoMessage() {}\n \n func (x *CleanStateRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[38]\n+\tmi := &file_daemon_proto_msgTypes[40]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2833,7 +3067,7 @@ func (x *CleanStateRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use CleanStateRequest.ProtoReflect.Descriptor instead.\n func (*CleanStateRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{38}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{40}\n }\n \n func (x *CleanStateRequest) GetStateName() string {\n@@ -2860,7 +3094,7 @@ type CleanStateResponse struct {\n \n func (x *CleanStateResponse) Reset() {\n \t*x = CleanStateResponse{}\n-\tmi := &file_daemon_proto_msgTypes[39]\n+\tmi := &file_daemon_proto_msgTypes[41]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2872,7 +3106,7 @@ func (x *CleanStateResponse) String() string {\n func (*CleanStateResponse) ProtoMessage() {}\n \n func (x *CleanStateResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[39]\n+\tmi := &file_daemon_proto_msgTypes[41]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2885,7 +3119,7 @@ func (x *CleanStateResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use CleanStateResponse.ProtoReflect.Descriptor instead.\n func (*CleanStateResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{39}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{41}\n }\n \n func (x *CleanStateResponse) GetCleanedStates() int32 {\n@@ -2906,7 +3140,7 @@ type DeleteStateRequest struct {\n \n func (x *DeleteStateRequest) Reset() {\n \t*x = DeleteStateRequest{}\n-\tmi := &file_daemon_proto_msgTypes[40]\n+\tmi := &file_daemon_proto_msgTypes[42]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2918,7 +3152,7 @@ func (x *DeleteStateRequest) String() string {\n func (*DeleteStateRequest) ProtoMessage() {}\n \n func (x *DeleteStateRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[40]\n+\tmi := &file_daemon_proto_msgTypes[42]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2931,7 +3165,7 @@ func (x *DeleteStateRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use DeleteStateRequest.ProtoReflect.Descriptor instead.\n func (*DeleteStateRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{40}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{42}\n }\n \n func (x *DeleteStateRequest) GetStateName() string {\n@@ -2958,7 +3192,7 @@ type DeleteStateResponse struct {\n \n func (x *DeleteStateResponse) Reset() {\n \t*x = DeleteStateResponse{}\n-\tmi := &file_daemon_proto_msgTypes[41]\n+\tmi := &file_daemon_proto_msgTypes[43]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2970,7 +3204,7 @@ func (x *DeleteStateResponse) String() string {\n func (*DeleteStateResponse) ProtoMessage() {}\n \n func (x *DeleteStateResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[41]\n+\tmi := &file_daemon_proto_msgTypes[43]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2983,7 +3217,7 @@ func (x *DeleteStateResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use DeleteStateResponse.ProtoReflect.Descriptor instead.\n func (*DeleteStateResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{41}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{43}\n }\n \n func (x *DeleteStateResponse) GetDeletedStates() int32 {\n@@ -3002,7 +3236,7 @@ type SetSyncResponsePersistenceRequest struct {\n \n func (x *SetSyncResponsePersistenceRequest) Reset() {\n \t*x = SetSyncResponsePersistenceRequest{}\n-\tmi := &file_daemon_proto_msgTypes[42]\n+\tmi := &file_daemon_proto_msgTypes[44]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3014,7 +3248,7 @@ func (x *SetSyncResponsePersistenceRequest) String() string {\n func (*SetSyncResponsePersistenceRequest) ProtoMessage() {}\n \n func (x *SetSyncResponsePersistenceRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[42]\n+\tmi := &file_daemon_proto_msgTypes[44]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3027,7 +3261,7 @@ func (x *SetSyncResponsePersistenceRequest) ProtoReflect() protoreflect.Message\n \n // Deprecated: Use SetSyncResponsePersistenceRequest.ProtoReflect.Descriptor instead.\n func (*SetSyncResponsePersistenceRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{42}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{44}\n }\n \n func (x *SetSyncResponsePersistenceRequest) GetEnabled() bool {\n@@ -3045,7 +3279,7 @@ type SetSyncResponsePersistenceResponse struct {\n \n func (x *SetSyncResponsePersistenceResponse) Reset() {\n \t*x = SetSyncResponsePersistenceResponse{}\n-\tmi := &file_daemon_proto_msgTypes[43]\n+\tmi := &file_daemon_proto_msgTypes[45]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3057,7 +3291,7 @@ func (x *SetSyncResponsePersistenceResponse) String() string {\n func (*SetSyncResponsePersistenceResponse) ProtoMessage() {}\n \n func (x *SetSyncResponsePersistenceResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[43]\n+\tmi := &file_daemon_proto_msgTypes[45]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3070,7 +3304,7 @@ func (x *SetSyncResponsePersistenceResponse) ProtoReflect() protoreflect.Message\n \n // Deprecated: Use SetSyncResponsePersistenceResponse.ProtoReflect.Descriptor instead.\n func (*SetSyncResponsePersistenceResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{43}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{45}\n }\n \n type TCPFlags struct {\n@@ -3087,7 +3321,7 @@ type TCPFlags struct {\n \n func (x *TCPFlags) Reset() {\n \t*x = TCPFlags{}\n-\tmi := &file_daemon_proto_msgTypes[44]\n+\tmi := &file_daemon_proto_msgTypes[46]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3099,7 +3333,7 @@ func (x *TCPFlags) String() string {\n func (*TCPFlags) ProtoMessage() {}\n \n func (x *TCPFlags) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[44]\n+\tmi := &file_daemon_proto_msgTypes[46]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3112,7 +3346,7 @@ func (x *TCPFlags) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use TCPFlags.ProtoReflect.Descriptor instead.\n func (*TCPFlags) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{44}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{46}\n }\n \n func (x *TCPFlags) GetSyn() bool {\n@@ -3174,7 +3408,7 @@ type TracePacketRequest struct {\n \n func (x *TracePacketRequest) Reset() {\n \t*x = TracePacketRequest{}\n-\tmi := &file_daemon_proto_msgTypes[45]\n+\tmi := &file_daemon_proto_msgTypes[47]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3186,7 +3420,7 @@ func (x *TracePacketRequest) String() string {\n func (*TracePacketRequest) ProtoMessage() {}\n \n func (x *TracePacketRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[45]\n+\tmi := &file_daemon_proto_msgTypes[47]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3199,7 +3433,7 @@ func (x *TracePacketRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use TracePacketRequest.ProtoReflect.Descriptor instead.\n func (*TracePacketRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{45}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{47}\n }\n \n func (x *TracePacketRequest) GetSourceIp() string {\n@@ -3277,7 +3511,7 @@ type TraceStage struct {\n \n func (x *TraceStage) Reset() {\n \t*x = TraceStage{}\n-\tmi := &file_daemon_proto_msgTypes[46]\n+\tmi := &file_daemon_proto_msgTypes[48]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3289,7 +3523,7 @@ func (x *TraceStage) String() string {\n func (*TraceStage) ProtoMessage() {}\n \n func (x *TraceStage) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[46]\n+\tmi := &file_daemon_proto_msgTypes[48]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3302,7 +3536,7 @@ func (x *TraceStage) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use TraceStage.ProtoReflect.Descriptor instead.\n func (*TraceStage) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{46}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{48}\n }\n \n func (x *TraceStage) GetName() string {\n@@ -3343,7 +3577,7 @@ type TracePacketResponse struct {\n \n func (x *TracePacketResponse) Reset() {\n \t*x = TracePacketResponse{}\n-\tmi := &file_daemon_proto_msgTypes[47]\n+\tmi := &file_daemon_proto_msgTypes[49]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3355,7 +3589,7 @@ func (x *TracePacketResponse) String() string {\n func (*TracePacketResponse) ProtoMessage() {}\n \n func (x *TracePacketResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[47]\n+\tmi := &file_daemon_proto_msgTypes[49]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3368,7 +3602,7 @@ func (x *TracePacketResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use TracePacketResponse.ProtoReflect.Descriptor instead.\n func (*TracePacketResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{47}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{49}\n }\n \n func (x *TracePacketResponse) GetStages() []*TraceStage {\n@@ -3393,7 +3627,7 @@ type SubscribeRequest struct {\n \n func (x *SubscribeRequest) Reset() {\n \t*x = SubscribeRequest{}\n-\tmi := &file_daemon_proto_msgTypes[48]\n+\tmi := &file_daemon_proto_msgTypes[50]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3405,7 +3639,7 @@ func (x *SubscribeRequest) String() string {\n func (*SubscribeRequest) ProtoMessage() {}\n \n func (x *SubscribeRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[48]\n+\tmi := &file_daemon_proto_msgTypes[50]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3418,7 +3652,7 @@ func (x *SubscribeRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SubscribeRequest.ProtoReflect.Descriptor instead.\n func (*SubscribeRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{48}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{50}\n }\n \n type SystemEvent struct {\n@@ -3436,7 +3670,7 @@ type SystemEvent struct {\n \n func (x *SystemEvent) Reset() {\n \t*x = SystemEvent{}\n-\tmi := &file_daemon_proto_msgTypes[49]\n+\tmi := &file_daemon_proto_msgTypes[51]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3448,7 +3682,7 @@ func (x *SystemEvent) String() string {\n func (*SystemEvent) ProtoMessage() {}\n \n func (x *SystemEvent) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[49]\n+\tmi := &file_daemon_proto_msgTypes[51]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3461,7 +3695,7 @@ func (x *SystemEvent) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SystemEvent.ProtoReflect.Descriptor instead.\n func (*SystemEvent) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{49}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{51}\n }\n \n func (x *SystemEvent) GetId() string {\n@@ -3521,7 +3755,7 @@ type GetEventsRequest struct {\n \n func (x *GetEventsRequest) Reset() {\n \t*x = GetEventsRequest{}\n-\tmi := &file_daemon_proto_msgTypes[50]\n+\tmi := &file_daemon_proto_msgTypes[52]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3533,7 +3767,7 @@ func (x *GetEventsRequest) String() string {\n func (*GetEventsRequest) ProtoMessage() {}\n \n func (x *GetEventsRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[50]\n+\tmi := &file_daemon_proto_msgTypes[52]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3546,7 +3780,7 @@ func (x *GetEventsRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use GetEventsRequest.ProtoReflect.Descriptor instead.\n func (*GetEventsRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{50}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{52}\n }\n \n type GetEventsResponse struct {\n@@ -3558,7 +3792,7 @@ type GetEventsResponse struct {\n \n func (x *GetEventsResponse) Reset() {\n \t*x = GetEventsResponse{}\n-\tmi := &file_daemon_proto_msgTypes[51]\n+\tmi := &file_daemon_proto_msgTypes[53]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3570,7 +3804,7 @@ func (x *GetEventsResponse) String() string {\n func (*GetEventsResponse) ProtoMessage() {}\n \n func (x *GetEventsResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[51]\n+\tmi := &file_daemon_proto_msgTypes[53]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3583,7 +3817,7 @@ func (x *GetEventsResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use GetEventsResponse.ProtoReflect.Descriptor instead.\n func (*GetEventsResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{51}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{53}\n }\n \n func (x *GetEventsResponse) GetEvents() []*SystemEvent {\n@@ -3603,7 +3837,7 @@ type SwitchProfileRequest struct {\n \n func (x *SwitchProfileRequest) Reset() {\n \t*x = SwitchProfileRequest{}\n-\tmi := &file_daemon_proto_msgTypes[52]\n+\tmi := &file_daemon_proto_msgTypes[54]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3615,7 +3849,7 @@ func (x *SwitchProfileRequest) String() string {\n func (*SwitchProfileRequest) ProtoMessage() {}\n \n func (x *SwitchProfileRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[52]\n+\tmi := &file_daemon_proto_msgTypes[54]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3628,7 +3862,7 @@ func (x *SwitchProfileRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SwitchProfileRequest.ProtoReflect.Descriptor instead.\n func (*SwitchProfileRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{52}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{54}\n }\n \n func (x *SwitchProfileRequest) GetProfileName() string {\n@@ -3653,7 +3887,7 @@ type SwitchProfileResponse struct {\n \n func (x *SwitchProfileResponse) Reset() {\n \t*x = SwitchProfileResponse{}\n-\tmi := &file_daemon_proto_msgTypes[53]\n+\tmi := &file_daemon_proto_msgTypes[55]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3665,7 +3899,7 @@ func (x *SwitchProfileResponse) String() string {\n func (*SwitchProfileResponse) ProtoMessage() {}\n \n func (x *SwitchProfileResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[53]\n+\tmi := &file_daemon_proto_msgTypes[55]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3678,7 +3912,7 @@ func (x *SwitchProfileResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SwitchProfileResponse.ProtoReflect.Descriptor instead.\n func (*SwitchProfileResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{53}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{55}\n }\n \n type SetConfigRequest struct {\n@@ -3711,16 +3945,22 @@ type SetConfigRequest struct {\n \tExtraIFaceBlacklist   []string `protobuf:\"bytes,24,rep,name=extraIFaceBlacklist,proto3\" json:\"extraIFaceBlacklist,omitempty\"`\n \tDnsLabels             []string `protobuf:\"bytes,25,rep,name=dns_labels,json=dnsLabels,proto3\" json:\"dns_labels,omitempty\"`\n \t// cleanDNSLabels clean map list of DNS labels.\n-\tCleanDNSLabels   bool                 `protobuf:\"varint,26,opt,name=cleanDNSLabels,proto3\" json:\"cleanDNSLabels,omitempty\"`\n-\tDnsRouteInterval *durationpb.Duration `protobuf:\"bytes,27,opt,name=dnsRouteInterval,proto3,oneof\" json:\"dnsRouteInterval,omitempty\"`\n-\tMtu              *int64               `protobuf:\"varint,28,opt,name=mtu,proto3,oneof\" json:\"mtu,omitempty\"`\n-\tunknownFields    protoimpl.UnknownFields\n-\tsizeCache        protoimpl.SizeCache\n+\tCleanDNSLabels                bool                 `protobuf:\"varint,26,opt,name=cleanDNSLabels,proto3\" json:\"cleanDNSLabels,omitempty\"`\n+\tDnsRouteInterval              *durationpb.Duration `protobuf:\"bytes,27,opt,name=dnsRouteInterval,proto3,oneof\" json:\"dnsRouteInterval,omitempty\"`\n+\tMtu                           *int64               `protobuf:\"varint,28,opt,name=mtu,proto3,oneof\" json:\"mtu,omitempty\"`\n+\tEnableSSHRoot                 *bool                `protobuf:\"varint,29,opt,name=enableSSHRoot,proto3,oneof\" json:\"enableSSHRoot,omitempty\"`\n+\tEnableSSHSFTP                 *bool                `protobuf:\"varint,30,opt,name=enableSSHSFTP,proto3,oneof\" json:\"enableSSHSFTP,omitempty\"`\n+\tEnableSSHLocalPortForwarding  *bool                `protobuf:\"varint,31,opt,name=enableSSHLocalPortForwarding,proto3,oneof\" json:\"enableSSHLocalPortForwarding,omitempty\"`\n+\tEnableSSHRemotePortForwarding *bool                `protobuf:\"varint,32,opt,name=enableSSHRemotePortForwarding,proto3,oneof\" json:\"enableSSHRemotePortForwarding,omitempty\"`\n+\tDisableSSHAuth                *bool                `protobuf:\"varint,33,opt,name=disableSSHAuth,proto3,oneof\" json:\"disableSSHAuth,omitempty\"`\n+\tSshJWTCacheTTL                *int32               `protobuf:\"varint,34,opt,name=sshJWTCacheTTL,proto3,oneof\" json:\"sshJWTCacheTTL,omitempty\"`\n+\tunknownFields                 protoimpl.UnknownFields\n+\tsizeCache                     protoimpl.SizeCache\n }\n \n func (x *SetConfigRequest) Reset() {\n \t*x = SetConfigRequest{}\n-\tmi := &file_daemon_proto_msgTypes[54]\n+\tmi := &file_daemon_proto_msgTypes[56]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3732,7 +3972,7 @@ func (x *SetConfigRequest) String() string {\n func (*SetConfigRequest) ProtoMessage() {}\n \n func (x *SetConfigRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[54]\n+\tmi := &file_daemon_proto_msgTypes[56]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3745,7 +3985,7 @@ func (x *SetConfigRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SetConfigRequest.ProtoReflect.Descriptor instead.\n func (*SetConfigRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{54}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{56}\n }\n \n func (x *SetConfigRequest) GetUsername() string {\n@@ -3944,6 +4184,48 @@ func (x *SetConfigRequest) GetMtu() int64 {\n \treturn 0\n }\n \n+func (x *SetConfigRequest) GetEnableSSHRoot() bool {\n+\tif x != nil && x.EnableSSHRoot != nil {\n+\t\treturn *x.EnableSSHRoot\n+\t}\n+\treturn false\n+}\n+\n+func (x *SetConfigRequest) GetEnableSSHSFTP() bool {\n+\tif x != nil && x.EnableSSHSFTP != nil {\n+\t\treturn *x.EnableSSHSFTP\n+\t}\n+\treturn false\n+}\n+\n+func (x *SetConfigRequest) GetEnableSSHLocalPortForwarding() bool {\n+\tif x != nil && x.EnableSSHLocalPortForwarding != nil {\n+\t\treturn *x.EnableSSHLocalPortForwarding\n+\t}\n+\treturn false\n+}\n+\n+func (x *SetConfigRequest) GetEnableSSHRemotePortForwarding() bool {\n+\tif x != nil && x.EnableSSHRemotePortForwarding != nil {\n+\t\treturn *x.EnableSSHRemotePortForwarding\n+\t}\n+\treturn false\n+}\n+\n+func (x *SetConfigRequest) GetDisableSSHAuth() bool {\n+\tif x != nil && x.DisableSSHAuth != nil {\n+\t\treturn *x.DisableSSHAuth\n+\t}\n+\treturn false\n+}\n+\n+func (x *SetConfigRequest) GetSshJWTCacheTTL() int32 {\n+\tif x != nil && x.SshJWTCacheTTL != nil {\n+\t\treturn *x.SshJWTCacheTTL\n+\t}\n+\treturn 0\n+}\n+\n type SetConfigResponse struct {\n \tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n \tunknownFields protoimpl.UnknownFields\n@@ -3952,7 +4234,7 @@ type SetConfigResponse struct {\n \n func (x *SetConfigResponse) Reset() {\n \t*x = SetConfigResponse{}\n-\tmi := &file_daemon_proto_msgTypes[55]\n+\tmi := &file_daemon_proto_msgTypes[57]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3964,7 +4246,7 @@ func (x *SetConfigResponse) String() string {\n func (*SetConfigResponse) ProtoMessage() {}\n \n func (x *SetConfigResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[55]\n+\tmi := &file_daemon_proto_msgTypes[57]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3977,7 +4259,7 @@ func (x *SetConfigResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SetConfigResponse.ProtoReflect.Descriptor instead.\n func (*SetConfigResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{55}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{57}\n }\n \n type AddProfileRequest struct {\n@@ -3990,7 +4272,7 @@ type AddProfileRequest struct {\n \n func (x *AddProfileRequest) Reset() {\n \t*x = AddProfileRequest{}\n-\tmi := &file_daemon_proto_msgTypes[56]\n+\tmi := &file_daemon_proto_msgTypes[58]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4002,7 +4284,7 @@ func (x *AddProfileRequest) String() string {\n func (*AddProfileRequest) ProtoMessage() {}\n \n func (x *AddProfileRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[56]\n+\tmi := &file_daemon_proto_msgTypes[58]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4015,7 +4297,7 @@ func (x *AddProfileRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use AddProfileRequest.ProtoReflect.Descriptor instead.\n func (*AddProfileRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{56}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{58}\n }\n \n func (x *AddProfileRequest) GetUsername() string {\n@@ -4040,7 +4322,7 @@ type AddProfileResponse struct {\n \n func (x *AddProfileResponse) Reset() {\n \t*x = AddProfileResponse{}\n-\tmi := &file_daemon_proto_msgTypes[57]\n+\tmi := &file_daemon_proto_msgTypes[59]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4052,7 +4334,7 @@ func (x *AddProfileResponse) String() string {\n func (*AddProfileResponse) ProtoMessage() {}\n \n func (x *AddProfileResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[57]\n+\tmi := &file_daemon_proto_msgTypes[59]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4065,7 +4347,7 @@ func (x *AddProfileResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use AddProfileResponse.ProtoReflect.Descriptor instead.\n func (*AddProfileResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{57}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{59}\n }\n \n type RemoveProfileRequest struct {\n@@ -4078,7 +4360,7 @@ type RemoveProfileRequest struct {\n \n func (x *RemoveProfileRequest) Reset() {\n \t*x = RemoveProfileRequest{}\n-\tmi := &file_daemon_proto_msgTypes[58]\n+\tmi := &file_daemon_proto_msgTypes[60]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4090,7 +4372,7 @@ func (x *RemoveProfileRequest) String() string {\n func (*RemoveProfileRequest) ProtoMessage() {}\n \n func (x *RemoveProfileRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[58]\n+\tmi := &file_daemon_proto_msgTypes[60]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4103,7 +4385,7 @@ func (x *RemoveProfileRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use RemoveProfileRequest.ProtoReflect.Descriptor instead.\n func (*RemoveProfileRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{58}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{60}\n }\n \n func (x *RemoveProfileRequest) GetUsername() string {\n@@ -4128,7 +4410,7 @@ type RemoveProfileResponse struct {\n \n func (x *RemoveProfileResponse) Reset() {\n \t*x = RemoveProfileResponse{}\n-\tmi := &file_daemon_proto_msgTypes[59]\n+\tmi := &file_daemon_proto_msgTypes[61]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4140,7 +4422,7 @@ func (x *RemoveProfileResponse) String() string {\n func (*RemoveProfileResponse) ProtoMessage() {}\n \n func (x *RemoveProfileResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[59]\n+\tmi := &file_daemon_proto_msgTypes[61]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4153,7 +4435,7 @@ func (x *RemoveProfileResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use RemoveProfileResponse.ProtoReflect.Descriptor instead.\n func (*RemoveProfileResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{59}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{61}\n }\n \n type ListProfilesRequest struct {\n@@ -4165,7 +4447,7 @@ type ListProfilesRequest struct {\n \n func (x *ListProfilesRequest) Reset() {\n \t*x = ListProfilesRequest{}\n-\tmi := &file_daemon_proto_msgTypes[60]\n+\tmi := &file_daemon_proto_msgTypes[62]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4177,7 +4459,7 @@ func (x *ListProfilesRequest) String() string {\n func (*ListProfilesRequest) ProtoMessage() {}\n \n func (x *ListProfilesRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[60]\n+\tmi := &file_daemon_proto_msgTypes[62]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4190,7 +4472,7 @@ func (x *ListProfilesRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use ListProfilesRequest.ProtoReflect.Descriptor instead.\n func (*ListProfilesRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{60}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{62}\n }\n \n func (x *ListProfilesRequest) GetUsername() string {\n@@ -4209,7 +4491,7 @@ type ListProfilesResponse struct {\n \n func (x *ListProfilesResponse) Reset() {\n \t*x = ListProfilesResponse{}\n-\tmi := &file_daemon_proto_msgTypes[61]\n+\tmi := &file_daemon_proto_msgTypes[63]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4221,7 +4503,7 @@ func (x *ListProfilesResponse) String() string {\n func (*ListProfilesResponse) ProtoMessage() {}\n \n func (x *ListProfilesResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[61]\n+\tmi := &file_daemon_proto_msgTypes[63]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4234,7 +4516,7 @@ func (x *ListProfilesResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use ListProfilesResponse.ProtoReflect.Descriptor instead.\n func (*ListProfilesResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{61}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{63}\n }\n \n func (x *ListProfilesResponse) GetProfiles() []*Profile {\n@@ -4254,7 +4536,7 @@ type Profile struct {\n \n func (x *Profile) Reset() {\n \t*x = Profile{}\n-\tmi := &file_daemon_proto_msgTypes[62]\n+\tmi := &file_daemon_proto_msgTypes[64]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4266,7 +4548,7 @@ func (x *Profile) String() string {\n func (*Profile) ProtoMessage() {}\n \n func (x *Profile) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[62]\n+\tmi := &file_daemon_proto_msgTypes[64]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4279,7 +4561,7 @@ func (x *Profile) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use Profile.ProtoReflect.Descriptor instead.\n func (*Profile) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{62}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{64}\n }\n \n func (x *Profile) GetName() string {\n@@ -4304,7 +4586,7 @@ type GetActiveProfileRequest struct {\n \n func (x *GetActiveProfileRequest) Reset() {\n \t*x = GetActiveProfileRequest{}\n-\tmi := &file_daemon_proto_msgTypes[63]\n+\tmi := &file_daemon_proto_msgTypes[65]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4316,7 +4598,7 @@ func (x *GetActiveProfileRequest) String() string {\n func (*GetActiveProfileRequest) ProtoMessage() {}\n \n func (x *GetActiveProfileRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[63]\n+\tmi := &file_daemon_proto_msgTypes[65]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4329,7 +4611,7 @@ func (x *GetActiveProfileRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use GetActiveProfileRequest.ProtoReflect.Descriptor instead.\n func (*GetActiveProfileRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{63}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{65}\n }\n \n type GetActiveProfileResponse struct {\n@@ -4342,7 +4624,7 @@ type GetActiveProfileResponse struct {\n \n func (x *GetActiveProfileResponse) Reset() {\n \t*x = GetActiveProfileResponse{}\n-\tmi := &file_daemon_proto_msgTypes[64]\n+\tmi := &file_daemon_proto_msgTypes[66]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4354,7 +4636,7 @@ func (x *GetActiveProfileResponse) String() string {\n func (*GetActiveProfileResponse) ProtoMessage() {}\n \n func (x *GetActiveProfileResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[64]\n+\tmi := &file_daemon_proto_msgTypes[66]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4367,7 +4649,7 @@ func (x *GetActiveProfileResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use GetActiveProfileResponse.ProtoReflect.Descriptor instead.\n func (*GetActiveProfileResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{64}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{66}\n }\n \n func (x *GetActiveProfileResponse) GetProfileName() string {\n@@ -4394,7 +4676,7 @@ type LogoutRequest struct {\n \n func (x *LogoutRequest) Reset() {\n \t*x = LogoutRequest{}\n-\tmi := &file_daemon_proto_msgTypes[65]\n+\tmi := &file_daemon_proto_msgTypes[67]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4406,7 +4688,7 @@ func (x *LogoutRequest) String() string {\n func (*LogoutRequest) ProtoMessage() {}\n \n func (x *LogoutRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[65]\n+\tmi := &file_daemon_proto_msgTypes[67]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4419,7 +4701,7 @@ func (x *LogoutRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use LogoutRequest.ProtoReflect.Descriptor instead.\n func (*LogoutRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{65}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{67}\n }\n \n func (x *LogoutRequest) GetProfileName() string {\n@@ -4444,7 +4726,7 @@ type LogoutResponse struct {\n \n func (x *LogoutResponse) Reset() {\n \t*x = LogoutResponse{}\n-\tmi := &file_daemon_proto_msgTypes[66]\n+\tmi := &file_daemon_proto_msgTypes[68]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4456,7 +4738,7 @@ func (x *LogoutResponse) String() string {\n func (*LogoutResponse) ProtoMessage() {}\n \n func (x *LogoutResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[66]\n+\tmi := &file_daemon_proto_msgTypes[68]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4469,7 +4751,7 @@ func (x *LogoutResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use LogoutResponse.ProtoReflect.Descriptor instead.\n func (*LogoutResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{66}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{68}\n }\n \n type GetFeaturesRequest struct {\n@@ -4480,7 +4762,7 @@ type GetFeaturesRequest struct {\n \n func (x *GetFeaturesRequest) Reset() {\n \t*x = GetFeaturesRequest{}\n-\tmi := &file_daemon_proto_msgTypes[67]\n+\tmi := &file_daemon_proto_msgTypes[69]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4492,7 +4774,7 @@ func (x *GetFeaturesRequest) String() string {\n func (*GetFeaturesRequest) ProtoMessage() {}\n \n func (x *GetFeaturesRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[67]\n+\tmi := &file_daemon_proto_msgTypes[69]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4505,7 +4787,7 @@ func (x *GetFeaturesRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use GetFeaturesRequest.ProtoReflect.Descriptor instead.\n func (*GetFeaturesRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{67}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{69}\n }\n \n type GetFeaturesResponse struct {\n@@ -4518,7 +4800,7 @@ type GetFeaturesResponse struct {\n \n func (x *GetFeaturesResponse) Reset() {\n \t*x = GetFeaturesResponse{}\n-\tmi := &file_daemon_proto_msgTypes[68]\n+\tmi := &file_daemon_proto_msgTypes[70]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4530,7 +4812,7 @@ func (x *GetFeaturesResponse) String() string {\n func (*GetFeaturesResponse) ProtoMessage() {}\n \n func (x *GetFeaturesResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[68]\n+\tmi := &file_daemon_proto_msgTypes[70]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4543,7 +4825,7 @@ func (x *GetFeaturesResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use GetFeaturesResponse.ProtoReflect.Descriptor instead.\n func (*GetFeaturesResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{68}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{70}\n }\n \n func (x *GetFeaturesResponse) GetDisableProfiles() bool {\n@@ -4560,6 +4842,390 @@ func (x *GetFeaturesResponse) GetDisableUpdateSettings() bool {\n \treturn false\n }\n \n+// GetPeerSSHHostKeyRequest for retrieving SSH host key for a specific peer\n+type GetPeerSSHHostKeyRequest struct {\n+\tstate protoimpl.MessageState `protogen:\"open.v1\"`\n+\t// peer IP address or FQDN to get SSH host key for\n+\tPeerAddress   string `protobuf:\"bytes,1,opt,name=peerAddress,proto3\" json:\"peerAddress,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *GetPeerSSHHostKeyRequest) Reset() {\n+\t*x = GetPeerSSHHostKeyRequest{}\n+\tmi := &file_daemon_proto_msgTypes[71]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *GetPeerSSHHostKeyRequest) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*GetPeerSSHHostKeyRequest) ProtoMessage() {}\n+\n+func (x *GetPeerSSHHostKeyRequest) ProtoReflect() protoreflect.Message {\n+\tmi := &file_daemon_proto_msgTypes[71]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use GetPeerSSHHostKeyRequest.ProtoReflect.Descriptor instead.\n+func (*GetPeerSSHHostKeyRequest) Descriptor() ([]byte, []int) {\n+\treturn file_daemon_proto_rawDescGZIP(), []int{71}\n+}\n+\n+func (x *GetPeerSSHHostKeyRequest) GetPeerAddress() string {\n+\tif x != nil {\n+\t\treturn x.PeerAddress\n+\t}\n+\treturn \"\"\n+}\n+\n+// GetPeerSSHHostKeyResponse contains the SSH host key for the requested peer\n+type GetPeerSSHHostKeyResponse struct {\n+\tstate protoimpl.MessageState `protogen:\"open.v1\"`\n+\t// SSH host key in SSH public key format (e.g., \"ssh-ed25519 AAAAC3... hostname\")\n+\tSshHostKey []byte `protobuf:\"bytes,1,opt,name=sshHostKey,proto3\" json:\"sshHostKey,omitempty\"`\n+\t// peer IP address\n+\tPeerIP string `protobuf:\"bytes,2,opt,name=peerIP,proto3\" json:\"peerIP,omitempty\"`\n+\t// peer FQDN\n+\tPeerFQDN string `protobuf:\"bytes,3,opt,name=peerFQDN,proto3\" json:\"peerFQDN,omitempty\"`\n+\t// indicates if the SSH host key was found\n+\tFound         bool `protobuf:\"varint,4,opt,name=found,proto3\" json:\"found,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *GetPeerSSHHostKeyResponse) Reset() {\n+\t*x = GetPeerSSHHostKeyResponse{}\n+\tmi := &file_daemon_proto_msgTypes[72]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *GetPeerSSHHostKeyResponse) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*GetPeerSSHHostKeyResponse) ProtoMessage() {}\n+\n+func (x *GetPeerSSHHostKeyResponse) ProtoReflect() protoreflect.Message {\n+\tmi := &file_daemon_proto_msgTypes[72]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use GetPeerSSHHostKeyResponse.ProtoReflect.Descriptor instead.\n+func (*GetPeerSSHHostKeyResponse) Descriptor() ([]byte, []int) {\n+\treturn file_daemon_proto_rawDescGZIP(), []int{72}\n+}\n+\n+func (x *GetPeerSSHHostKeyResponse) GetSshHostKey() []byte {\n+\tif x != nil {\n+\t\treturn x.SshHostKey\n+\t}\n+\treturn nil\n+}\n+\n+func (x *GetPeerSSHHostKeyResponse) GetPeerIP() string {\n+\tif x != nil {\n+\t\treturn x.PeerIP\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *GetPeerSSHHostKeyResponse) GetPeerFQDN() string {\n+\tif x != nil {\n+\t\treturn x.PeerFQDN\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *GetPeerSSHHostKeyResponse) GetFound() bool {\n+\tif x != nil {\n+\t\treturn x.Found\n+\t}\n+\treturn false\n+}\n+\n+// RequestJWTAuthRequest for initiating JWT authentication flow\n+type RequestJWTAuthRequest struct {\n+\tstate protoimpl.MessageState `protogen:\"open.v1\"`\n+\t// hint for OIDC login_hint parameter (typically email address)\n+\tHint          *string `protobuf:\"bytes,1,opt,name=hint,proto3,oneof\" json:\"hint,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *RequestJWTAuthRequest) Reset() {\n+\t*x = RequestJWTAuthRequest{}\n+\tmi := &file_daemon_proto_msgTypes[73]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *RequestJWTAuthRequest) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*RequestJWTAuthRequest) ProtoMessage() {}\n+\n+func (x *RequestJWTAuthRequest) ProtoReflect() protoreflect.Message {\n+\tmi := &file_daemon_proto_msgTypes[73]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use RequestJWTAuthRequest.ProtoReflect.Descriptor instead.\n+func (*RequestJWTAuthRequest) Descriptor() ([]byte, []int) {\n+\treturn file_daemon_proto_rawDescGZIP(), []int{73}\n+}\n+\n+func (x *RequestJWTAuthRequest) GetHint() string {\n+\tif x != nil && x.Hint != nil {\n+\t\treturn *x.Hint\n+\t}\n+\treturn \"\"\n+}\n+\n+// RequestJWTAuthResponse contains authentication flow information\n+type RequestJWTAuthResponse struct {\n+\tstate protoimpl.MessageState `protogen:\"open.v1\"`\n+\t// verification URI for user authentication\n+\tVerificationURI string `protobuf:\"bytes,1,opt,name=verificationURI,proto3\" json:\"verificationURI,omitempty\"`\n+\t// complete verification URI (with embedded user code)\n+\tVerificationURIComplete string `protobuf:\"bytes,2,opt,name=verificationURIComplete,proto3\" json:\"verificationURIComplete,omitempty\"`\n+\t// user code to enter on verification URI\n+\tUserCode string `protobuf:\"bytes,3,opt,name=userCode,proto3\" json:\"userCode,omitempty\"`\n+\t// device code for polling\n+\tDeviceCode string `protobuf:\"bytes,4,opt,name=deviceCode,proto3\" json:\"deviceCode,omitempty\"`\n+\t// expiration time in seconds\n+\tExpiresIn int64 `protobuf:\"varint,5,opt,name=expiresIn,proto3\" json:\"expiresIn,omitempty\"`\n+\t// if a cached token is available, it will be returned here\n+\tCachedToken string `protobuf:\"bytes,6,opt,name=cachedToken,proto3\" json:\"cachedToken,omitempty\"`\n+\t// maximum age of JWT tokens in seconds (from management server)\n+\tMaxTokenAge   int64 `protobuf:\"varint,7,opt,name=maxTokenAge,proto3\" json:\"maxTokenAge,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *RequestJWTAuthResponse) Reset() {\n+\t*x = RequestJWTAuthResponse{}\n+\tmi := &file_daemon_proto_msgTypes[74]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *RequestJWTAuthResponse) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*RequestJWTAuthResponse) ProtoMessage() {}\n+\n+func (x *RequestJWTAuthResponse) ProtoReflect() protoreflect.Message {\n+\tmi := &file_daemon_proto_msgTypes[74]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use RequestJWTAuthResponse.ProtoReflect.Descriptor instead.\n+func (*RequestJWTAuthResponse) Descriptor() ([]byte, []int) {\n+\treturn file_daemon_proto_rawDescGZIP(), []int{74}\n+}\n+\n+func (x *RequestJWTAuthResponse) GetVerificationURI() string {\n+\tif x != nil {\n+\t\treturn x.VerificationURI\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *RequestJWTAuthResponse) GetVerificationURIComplete() string {\n+\tif x != nil {\n+\t\treturn x.VerificationURIComplete\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *RequestJWTAuthResponse) GetUserCode() string {\n+\tif x != nil {\n+\t\treturn x.UserCode\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *RequestJWTAuthResponse) GetDeviceCode() string {\n+\tif x != nil {\n+\t\treturn x.DeviceCode\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *RequestJWTAuthResponse) GetExpiresIn() int64 {\n+\tif x != nil {\n+\t\treturn x.ExpiresIn\n+\t}\n+\treturn 0\n+}\n+\n+func (x *RequestJWTAuthResponse) GetCachedToken() string {\n+\tif x != nil {\n+\t\treturn x.CachedToken\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *RequestJWTAuthResponse) GetMaxTokenAge() int64 {\n+\tif x != nil {\n+\t\treturn x.MaxTokenAge\n+\t}\n+\treturn 0\n+}\n+\n+// WaitJWTTokenRequest for waiting for authentication completion\n+type WaitJWTTokenRequest struct {\n+\tstate protoimpl.MessageState `protogen:\"open.v1\"`\n+\t// device code from RequestJWTAuthResponse\n+\tDeviceCode string `protobuf:\"bytes,1,opt,name=deviceCode,proto3\" json:\"deviceCode,omitempty\"`\n+\t// user code for verification\n+\tUserCode      string `protobuf:\"bytes,2,opt,name=userCode,proto3\" json:\"userCode,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *WaitJWTTokenRequest) Reset() {\n+\t*x = WaitJWTTokenRequest{}\n+\tmi := &file_daemon_proto_msgTypes[75]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *WaitJWTTokenRequest) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*WaitJWTTokenRequest) ProtoMessage() {}\n+\n+func (x *WaitJWTTokenRequest) ProtoReflect() protoreflect.Message {\n+\tmi := &file_daemon_proto_msgTypes[75]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use WaitJWTTokenRequest.ProtoReflect.Descriptor instead.\n+func (*WaitJWTTokenRequest) Descriptor() ([]byte, []int) {\n+\treturn file_daemon_proto_rawDescGZIP(), []int{75}\n+}\n+\n+func (x *WaitJWTTokenRequest) GetDeviceCode() string {\n+\tif x != nil {\n+\t\treturn x.DeviceCode\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *WaitJWTTokenRequest) GetUserCode() string {\n+\tif x != nil {\n+\t\treturn x.UserCode\n+\t}\n+\treturn \"\"\n+}\n+\n+// WaitJWTTokenResponse contains the JWT token after authentication\n+type WaitJWTTokenResponse struct {\n+\tstate protoimpl.MessageState `protogen:\"open.v1\"`\n+\t// JWT token (access token or ID token)\n+\tToken string `protobuf:\"bytes,1,opt,name=token,proto3\" json:\"token,omitempty\"`\n+\t// token type (e.g., \"Bearer\")\n+\tTokenType string `protobuf:\"bytes,2,opt,name=tokenType,proto3\" json:\"tokenType,omitempty\"`\n+\t// expiration time in seconds\n+\tExpiresIn     int64 `protobuf:\"varint,3,opt,name=expiresIn,proto3\" json:\"expiresIn,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *WaitJWTTokenResponse) Reset() {\n+\t*x = WaitJWTTokenResponse{}\n+\tmi := &file_daemon_proto_msgTypes[76]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *WaitJWTTokenResponse) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*WaitJWTTokenResponse) ProtoMessage() {}\n+\n+func (x *WaitJWTTokenResponse) ProtoReflect() protoreflect.Message {\n+\tmi := &file_daemon_proto_msgTypes[76]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use WaitJWTTokenResponse.ProtoReflect.Descriptor instead.\n+func (*WaitJWTTokenResponse) Descriptor() ([]byte, []int) {\n+\treturn file_daemon_proto_rawDescGZIP(), []int{76}\n+}\n+\n+func (x *WaitJWTTokenResponse) GetToken() string {\n+\tif x != nil {\n+\t\treturn x.Token\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *WaitJWTTokenResponse) GetTokenType() string {\n+\tif x != nil {\n+\t\treturn x.TokenType\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *WaitJWTTokenResponse) GetExpiresIn() int64 {\n+\tif x != nil {\n+\t\treturn x.ExpiresIn\n+\t}\n+\treturn 0\n+}\n+\n type PortInfo_Range struct {\n \tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n \tStart         uint32                 `protobuf:\"varint,1,opt,name=start,proto3\" json:\"start,omitempty\"`\n@@ -4570,7 +5236,7 @@ type PortInfo_Range struct {\n \n func (x *PortInfo_Range) Reset() {\n \t*x = PortInfo_Range{}\n-\tmi := &file_daemon_proto_msgTypes[70]\n+\tmi := &file_daemon_proto_msgTypes[78]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4582,7 +5248,7 @@ func (x *PortInfo_Range) String() string {\n func (*PortInfo_Range) ProtoMessage() {}\n \n func (x *PortInfo_Range) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[70]\n+\tmi := &file_daemon_proto_msgTypes[78]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4595,7 +5261,7 @@ func (x *PortInfo_Range) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use PortInfo_Range.ProtoReflect.Descriptor instead.\n func (*PortInfo_Range) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{26, 0}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{28, 0}\n }\n \n func (x *PortInfo_Range) GetStart() uint32 {\n@@ -4617,7 +5283,7 @@ var File_daemon_proto protoreflect.FileDescriptor\n const file_daemon_proto_rawDesc = \"\" +\n \t\"\\n\" +\n \t\"\\fdaemon.proto\\x12\\x06daemon\\x1a google/protobuf/descriptor.proto\\x1a\\x1fgoogle/protobuf/timestamp.proto\\x1a\\x1egoogle/protobuf/duration.proto\\\"\\x0e\\n\" +\n-\t\"\\fEmptyRequest\\\"\\xe5\\x0e\\n\" +\n+\t\"\\fEmptyRequest\\\"\\xb6\\x12\\n\" +\n \t\"\\fLoginRequest\\x12\\x1a\\n\" +\n \t\"\\bsetupKey\\x18\\x01 \\x01(\\tR\\bsetupKey\\x12&\\n\" +\n \t\"\\fpreSharedKey\\x18\\x02 \\x01(\\tB\\x02\\x18\\x01R\\fpreSharedKey\\x12$\\n\" +\n@@ -4655,7 +5321,13 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"\\vprofileName\\x18\\x1e \\x01(\\tH\\x11R\\vprofileName\\x88\\x01\\x01\\x12\\x1f\\n\" +\n \t\"\\busername\\x18\\x1f \\x01(\\tH\\x12R\\busername\\x88\\x01\\x01\\x12\\x15\\n\" +\n \t\"\\x03mtu\\x18  \\x01(\\x03H\\x13R\\x03mtu\\x88\\x01\\x01\\x12\\x17\\n\" +\n-\t\"\\x04hint\\x18! \\x01(\\tH\\x14R\\x04hint\\x88\\x01\\x01B\\x13\\n\" +\n+\t\"\\x04hint\\x18! \\x01(\\tH\\x14R\\x04hint\\x88\\x01\\x01\\x12)\\n\" +\n+\t\"\\renableSSHRoot\\x18\\\" \\x01(\\bH\\x15R\\renableSSHRoot\\x88\\x01\\x01\\x12)\\n\" +\n+\t\"\\renableSSHSFTP\\x18# \\x01(\\bH\\x16R\\renableSSHSFTP\\x88\\x01\\x01\\x12G\\n\" +\n+\t\"\\x1cenableSSHLocalPortForwarding\\x18$ \\x01(\\bH\\x17R\\x1cenableSSHLocalPortForwarding\\x88\\x01\\x01\\x12I\\n\" +\n+\t\"\\x1denableSSHRemotePortForwarding\\x18% \\x01(\\bH\\x18R\\x1denableSSHRemotePortForwarding\\x88\\x01\\x01\\x12+\\n\" +\n+\t\"\\x0edisableSSHAuth\\x18& \\x01(\\bH\\x19R\\x0edisableSSHAuth\\x88\\x01\\x01\\x12+\\n\" +\n+\t\"\\x0esshJWTCacheTTL\\x18' \\x01(\\x05H\\x1aR\\x0esshJWTCacheTTL\\x88\\x01\\x01B\\x13\\n\" +\n \t\"\\x11_rosenpassEnabledB\\x10\\n\" +\n \t\"\\x0e_interfaceNameB\\x10\\n\" +\n \t\"\\x0e_wireguardPortB\\x17\\n\" +\n@@ -4676,7 +5348,13 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"\\f_profileNameB\\v\\n\" +\n \t\"\\t_usernameB\\x06\\n\" +\n \t\"\\x04_mtuB\\a\\n\" +\n-\t\"\\x05_hint\\\"\\xb5\\x01\\n\" +\n+\t\"\\x05_hintB\\x10\\n\" +\n+\t\"\\x0e_enableSSHRootB\\x10\\n\" +\n+\t\"\\x0e_enableSSHSFTPB\\x1f\\n\" +\n+\t\"\\x1d_enableSSHLocalPortForwardingB \\n\" +\n+\t\"\\x1e_enableSSHRemotePortForwardingB\\x11\\n\" +\n+\t\"\\x0f_disableSSHAuthB\\x11\\n\" +\n+\t\"\\x0f_sshJWTCacheTTL\\\"\\xb5\\x01\\n\" +\n \t\"\\rLoginResponse\\x12$\\n\" +\n \t\"\\rneedsSSOLogin\\x18\\x01 \\x01(\\bR\\rneedsSSOLogin\\x12\\x1a\\n\" +\n \t\"\\buserCode\\x18\\x02 \\x01(\\tR\\buserCode\\x12(\\n\" +\n@@ -4709,7 +5387,7 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"\\fDownResponse\\\"P\\n\" +\n \t\"\\x10GetConfigRequest\\x12 \\n\" +\n \t\"\\vprofileName\\x18\\x01 \\x01(\\tR\\vprofileName\\x12\\x1a\\n\" +\n-\t\"\\busername\\x18\\x02 \\x01(\\tR\\busername\\\"\\xb5\\x06\\n\" +\n+\t\"\\busername\\x18\\x02 \\x01(\\tR\\busername\\\"\\xdb\\b\\n\" +\n \t\"\\x11GetConfigResponse\\x12$\\n\" +\n \t\"\\rmanagementUrl\\x18\\x01 \\x01(\\tR\\rmanagementUrl\\x12\\x1e\\n\" +\n \t\"\\n\" +\n@@ -4734,7 +5412,13 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"disableDns\\x122\\n\" +\n \t\"\\x15disable_client_routes\\x18\\x12 \\x01(\\bR\\x13disableClientRoutes\\x122\\n\" +\n \t\"\\x15disable_server_routes\\x18\\x13 \\x01(\\bR\\x13disableServerRoutes\\x12(\\n\" +\n-\t\"\\x10block_lan_access\\x18\\x14 \\x01(\\bR\\x0eblockLanAccess\\\"\\xde\\x05\\n\" +\n+\t\"\\x10block_lan_access\\x18\\x14 \\x01(\\bR\\x0eblockLanAccess\\x12$\\n\" +\n+\t\"\\renableSSHRoot\\x18\\x15 \\x01(\\bR\\renableSSHRoot\\x12$\\n\" +\n+\t\"\\renableSSHSFTP\\x18\\x18 \\x01(\\bR\\renableSSHSFTP\\x12B\\n\" +\n+\t\"\\x1cenableSSHLocalPortForwarding\\x18\\x16 \\x01(\\bR\\x1cenableSSHLocalPortForwarding\\x12D\\n\" +\n+\t\"\\x1denableSSHRemotePortForwarding\\x18\\x17 \\x01(\\bR\\x1denableSSHRemotePortForwarding\\x12&\\n\" +\n+\t\"\\x0edisableSSHAuth\\x18\\x19 \\x01(\\bR\\x0edisableSSHAuth\\x12&\\n\" +\n+\t\"\\x0esshJWTCacheTTL\\x18\\x1a \\x01(\\x05R\\x0esshJWTCacheTTL\\\"\\xfe\\x05\\n\" +\n \t\"\\tPeerState\\x12\\x0e\\n\" +\n \t\"\\x02IP\\x18\\x01 \\x01(\\tR\\x02IP\\x12\\x16\\n\" +\n \t\"\\x06pubKey\\x18\\x02 \\x01(\\tR\\x06pubKey\\x12\\x1e\\n\" +\n@@ -4755,7 +5439,10 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"\\x10rosenpassEnabled\\x18\\x0f \\x01(\\bR\\x10rosenpassEnabled\\x12\\x1a\\n\" +\n \t\"\\bnetworks\\x18\\x10 \\x03(\\tR\\bnetworks\\x123\\n\" +\n \t\"\\alatency\\x18\\x11 \\x01(\\v2\\x19.google.protobuf.DurationR\\alatency\\x12\\\"\\n\" +\n-\t\"\\frelayAddress\\x18\\x12 \\x01(\\tR\\frelayAddress\\\"\\xf0\\x01\\n\" +\n+\t\"\\frelayAddress\\x18\\x12 \\x01(\\tR\\frelayAddress\\x12\\x1e\\n\" +\n+\t\"\\n\" +\n+\t\"sshHostKey\\x18\\x13 \\x01(\\fR\\n\" +\n+\t\"sshHostKey\\\"\\xf0\\x01\\n\" +\n \t\"\\x0eLocalPeerState\\x12\\x0e\\n\" +\n \t\"\\x02IP\\x18\\x01 \\x01(\\tR\\x02IP\\x12\\x16\\n\" +\n \t\"\\x06pubKey\\x18\\x02 \\x01(\\tR\\x06pubKey\\x12(\\n\" +\n@@ -4781,7 +5468,15 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"\\aservers\\x18\\x01 \\x03(\\tR\\aservers\\x12\\x18\\n\" +\n \t\"\\adomains\\x18\\x02 \\x03(\\tR\\adomains\\x12\\x18\\n\" +\n \t\"\\aenabled\\x18\\x03 \\x01(\\bR\\aenabled\\x12\\x14\\n\" +\n-\t\"\\x05error\\x18\\x04 \\x01(\\tR\\x05error\\\"\\xef\\x03\\n\" +\n+\t\"\\x05error\\x18\\x04 \\x01(\\tR\\x05error\\\"\\x8e\\x01\\n\" +\n+\t\"\\x0eSSHSessionInfo\\x12\\x1a\\n\" +\n+\t\"\\busername\\x18\\x01 \\x01(\\tR\\busername\\x12$\\n\" +\n+\t\"\\rremoteAddress\\x18\\x02 \\x01(\\tR\\rremoteAddress\\x12\\x18\\n\" +\n+\t\"\\acommand\\x18\\x03 \\x01(\\tR\\acommand\\x12 \\n\" +\n+\t\"\\vjwtUsername\\x18\\x04 \\x01(\\tR\\vjwtUsername\\\"^\\n\" +\n+\t\"\\x0eSSHServerState\\x12\\x18\\n\" +\n+\t\"\\aenabled\\x18\\x01 \\x01(\\bR\\aenabled\\x122\\n\" +\n+\t\"\\bsessions\\x18\\x02 \\x03(\\v2\\x16.daemon.SSHSessionInfoR\\bsessions\\\"\\xaf\\x04\\n\" +\n \t\"\\n\" +\n \t\"FullStatus\\x12A\\n\" +\n \t\"\\x0fmanagementState\\x18\\x01 \\x01(\\v2\\x17.daemon.ManagementStateR\\x0fmanagementState\\x125\\n\" +\n@@ -4793,7 +5488,9 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"dnsServers\\x128\\n\" +\n \t\"\\x17NumberOfForwardingRules\\x18\\b \\x01(\\x05R\\x17NumberOfForwardingRules\\x12+\\n\" +\n \t\"\\x06events\\x18\\a \\x03(\\v2\\x13.daemon.SystemEventR\\x06events\\x124\\n\" +\n-\t\"\\x15lazyConnectionEnabled\\x18\\t \\x01(\\bR\\x15lazyConnectionEnabled\\\"\\x15\\n\" +\n+\t\"\\x15lazyConnectionEnabled\\x18\\t \\x01(\\bR\\x15lazyConnectionEnabled\\x12>\\n\" +\n+\t\"\\x0esshServerState\\x18\\n\" +\n+\t\" \\x01(\\v2\\x16.daemon.SSHServerStateR\\x0esshServerState\\\"\\x15\\n\" +\n \t\"\\x13ListNetworksRequest\\\"?\\n\" +\n \t\"\\x14ListNetworksResponse\\x12'\\n\" +\n \t\"\\x06routes\\x18\\x01 \\x03(\\v2\\x0f.daemon.NetworkR\\x06routes\\\"a\\n\" +\n@@ -4934,7 +5631,7 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"\\busername\\x18\\x02 \\x01(\\tH\\x01R\\busername\\x88\\x01\\x01B\\x0e\\n\" +\n \t\"\\f_profileNameB\\v\\n\" +\n \t\"\\t_username\\\"\\x17\\n\" +\n-\t\"\\x15SwitchProfileResponse\\\"\\x8e\\r\\n\" +\n+\t\"\\x15SwitchProfileResponse\\\"\\xdf\\x10\\n\" +\n \t\"\\x10SetConfigRequest\\x12\\x1a\\n\" +\n \t\"\\busername\\x18\\x01 \\x01(\\tR\\busername\\x12 \\n\" +\n \t\"\\vprofileName\\x18\\x02 \\x01(\\tR\\vprofileName\\x12$\\n\" +\n@@ -4967,7 +5664,13 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"dns_labels\\x18\\x19 \\x03(\\tR\\tdnsLabels\\x12&\\n\" +\n \t\"\\x0ecleanDNSLabels\\x18\\x1a \\x01(\\bR\\x0ecleanDNSLabels\\x12J\\n\" +\n \t\"\\x10dnsRouteInterval\\x18\\x1b \\x01(\\v2\\x19.google.protobuf.DurationH\\x10R\\x10dnsRouteInterval\\x88\\x01\\x01\\x12\\x15\\n\" +\n-\t\"\\x03mtu\\x18\\x1c \\x01(\\x03H\\x11R\\x03mtu\\x88\\x01\\x01B\\x13\\n\" +\n+\t\"\\x03mtu\\x18\\x1c \\x01(\\x03H\\x11R\\x03mtu\\x88\\x01\\x01\\x12)\\n\" +\n+\t\"\\renableSSHRoot\\x18\\x1d \\x01(\\bH\\x12R\\renableSSHRoot\\x88\\x01\\x01\\x12)\\n\" +\n+\t\"\\renableSSHSFTP\\x18\\x1e \\x01(\\bH\\x13R\\renableSSHSFTP\\x88\\x01\\x01\\x12G\\n\" +\n+\t\"\\x1cenableSSHLocalPortForwarding\\x18\\x1f \\x01(\\bH\\x14R\\x1cenableSSHLocalPortForwarding\\x88\\x01\\x01\\x12I\\n\" +\n+\t\"\\x1denableSSHRemotePortForwarding\\x18  \\x01(\\bH\\x15R\\x1denableSSHRemotePortForwarding\\x88\\x01\\x01\\x12+\\n\" +\n+\t\"\\x0edisableSSHAuth\\x18! \\x01(\\bH\\x16R\\x0edisableSSHAuth\\x88\\x01\\x01\\x12+\\n\" +\n+\t\"\\x0esshJWTCacheTTL\\x18\\\" \\x01(\\x05H\\x17R\\x0esshJWTCacheTTL\\x88\\x01\\x01B\\x13\\n\" +\n \t\"\\x11_rosenpassEnabledB\\x10\\n\" +\n \t\"\\x0e_interfaceNameB\\x10\\n\" +\n \t\"\\x0e_wireguardPortB\\x17\\n\" +\n@@ -4985,7 +5688,13 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"\\x16_lazyConnectionEnabledB\\x10\\n\" +\n \t\"\\x0e_block_inboundB\\x13\\n\" +\n \t\"\\x11_dnsRouteIntervalB\\x06\\n\" +\n-\t\"\\x04_mtu\\\"\\x13\\n\" +\n+\t\"\\x04_mtuB\\x10\\n\" +\n+\t\"\\x0e_enableSSHRootB\\x10\\n\" +\n+\t\"\\x0e_enableSSHSFTPB\\x1f\\n\" +\n+\t\"\\x1d_enableSSHLocalPortForwardingB \\n\" +\n+\t\"\\x1e_enableSSHRemotePortForwardingB\\x11\\n\" +\n+\t\"\\x0f_disableSSHAuthB\\x11\\n\" +\n+\t\"\\x0f_sshJWTCacheTTL\\\"\\x13\\n\" +\n \t\"\\x11SetConfigResponse\\\"Q\\n\" +\n \t\"\\x11AddProfileRequest\\x12\\x1a\\n\" +\n \t\"\\busername\\x18\\x01 \\x01(\\tR\\busername\\x12 \\n\" +\n@@ -5015,7 +5724,38 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"\\x12GetFeaturesRequest\\\"x\\n\" +\n \t\"\\x13GetFeaturesResponse\\x12)\\n\" +\n \t\"\\x10disable_profiles\\x18\\x01 \\x01(\\bR\\x0fdisableProfiles\\x126\\n\" +\n-\t\"\\x17disable_update_settings\\x18\\x02 \\x01(\\bR\\x15disableUpdateSettings*b\\n\" +\n+\t\"\\x17disable_update_settings\\x18\\x02 \\x01(\\bR\\x15disableUpdateSettings\\\"<\\n\" +\n+\t\"\\x18GetPeerSSHHostKeyRequest\\x12 \\n\" +\n+\t\"\\vpeerAddress\\x18\\x01 \\x01(\\tR\\vpeerAddress\\\"\\x85\\x01\\n\" +\n+\t\"\\x19GetPeerSSHHostKeyResponse\\x12\\x1e\\n\" +\n+\t\"\\n\" +\n+\t\"sshHostKey\\x18\\x01 \\x01(\\fR\\n\" +\n+\t\"sshHostKey\\x12\\x16\\n\" +\n+\t\"\\x06peerIP\\x18\\x02 \\x01(\\tR\\x06peerIP\\x12\\x1a\\n\" +\n+\t\"\\bpeerFQDN\\x18\\x03 \\x01(\\tR\\bpeerFQDN\\x12\\x14\\n\" +\n+\t\"\\x05found\\x18\\x04 \\x01(\\bR\\x05found\\\"9\\n\" +\n+\t\"\\x15RequestJWTAuthRequest\\x12\\x17\\n\" +\n+\t\"\\x04hint\\x18\\x01 \\x01(\\tH\\x00R\\x04hint\\x88\\x01\\x01B\\a\\n\" +\n+\t\"\\x05_hint\\\"\\x9a\\x02\\n\" +\n+\t\"\\x16RequestJWTAuthResponse\\x12(\\n\" +\n+\t\"\\x0fverificationURI\\x18\\x01 \\x01(\\tR\\x0fverificationURI\\x128\\n\" +\n+\t\"\\x17verificationURIComplete\\x18\\x02 \\x01(\\tR\\x17verificationURIComplete\\x12\\x1a\\n\" +\n+\t\"\\buserCode\\x18\\x03 \\x01(\\tR\\buserCode\\x12\\x1e\\n\" +\n+\t\"\\n\" +\n+\t\"deviceCode\\x18\\x04 \\x01(\\tR\\n\" +\n+\t\"deviceCode\\x12\\x1c\\n\" +\n+\t\"\\texpiresIn\\x18\\x05 \\x01(\\x03R\\texpiresIn\\x12 \\n\" +\n+\t\"\\vcachedToken\\x18\\x06 \\x01(\\tR\\vcachedToken\\x12 \\n\" +\n+\t\"\\vmaxTokenAge\\x18\\a \\x01(\\x03R\\vmaxTokenAge\\\"Q\\n\" +\n+\t\"\\x13WaitJWTTokenRequest\\x12\\x1e\\n\" +\n+\t\"\\n\" +\n+\t\"deviceCode\\x18\\x01 \\x01(\\tR\\n\" +\n+\t\"deviceCode\\x12\\x1a\\n\" +\n+\t\"\\buserCode\\x18\\x02 \\x01(\\tR\\buserCode\\\"h\\n\" +\n+\t\"\\x14WaitJWTTokenResponse\\x12\\x14\\n\" +\n+\t\"\\x05token\\x18\\x01 \\x01(\\tR\\x05token\\x12\\x1c\\n\" +\n+\t\"\\ttokenType\\x18\\x02 \\x01(\\tR\\ttokenType\\x12\\x1c\\n\" +\n+\t\"\\texpiresIn\\x18\\x03 \\x01(\\x03R\\texpiresIn*b\\n\" +\n \t\"\\bLogLevel\\x12\\v\\n\" +\n \t\"\\aUNKNOWN\\x10\\x00\\x12\\t\\n\" +\n \t\"\\x05PANIC\\x10\\x01\\x12\\t\\n\" +\n@@ -5024,7 +5764,7 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"\\x04WARN\\x10\\x04\\x12\\b\\n\" +\n \t\"\\x04INFO\\x10\\x05\\x12\\t\\n\" +\n \t\"\\x05DEBUG\\x10\\x06\\x12\\t\\n\" +\n-\t\"\\x05TRACE\\x10\\a2\\x8f\\x10\\n\" +\n+\t\"\\x05TRACE\\x10\\a2\\x8b\\x12\\n\" +\n \t\"\\rDaemonService\\x126\\n\" +\n \t\"\\x05Login\\x12\\x14.daemon.LoginRequest\\x1a\\x15.daemon.LoginResponse\\\"\\x00\\x12K\\n\" +\n \t\"\\fWaitSSOLogin\\x12\\x1b.daemon.WaitSSOLoginRequest\\x1a\\x1c.daemon.WaitSSOLoginResponse\\\"\\x00\\x12-\\n\" +\n@@ -5056,7 +5796,10 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"\\fListProfiles\\x12\\x1b.daemon.ListProfilesRequest\\x1a\\x1c.daemon.ListProfilesResponse\\\"\\x00\\x12W\\n\" +\n \t\"\\x10GetActiveProfile\\x12\\x1f.daemon.GetActiveProfileRequest\\x1a .daemon.GetActiveProfileResponse\\\"\\x00\\x129\\n\" +\n \t\"\\x06Logout\\x12\\x15.daemon.LogoutRequest\\x1a\\x16.daemon.LogoutResponse\\\"\\x00\\x12H\\n\" +\n-\t\"\\vGetFeatures\\x12\\x1a.daemon.GetFeaturesRequest\\x1a\\x1b.daemon.GetFeaturesResponse\\\"\\x00B\\bZ\\x06/protob\\x06proto3\"\n+\t\"\\vGetFeatures\\x12\\x1a.daemon.GetFeaturesRequest\\x1a\\x1b.daemon.GetFeaturesResponse\\\"\\x00\\x12Z\\n\" +\n+\t\"\\x11GetPeerSSHHostKey\\x12 .daemon.GetPeerSSHHostKeyRequest\\x1a!.daemon.GetPeerSSHHostKeyResponse\\\"\\x00\\x12Q\\n\" +\n+\t\"\\x0eRequestJWTAuth\\x12\\x1d.daemon.RequestJWTAuthRequest\\x1a\\x1e.daemon.RequestJWTAuthResponse\\\"\\x00\\x12K\\n\" +\n+\t\"\\fWaitJWTToken\\x12\\x1b.daemon.WaitJWTTokenRequest\\x1a\\x1c.daemon.WaitJWTTokenResponse\\\"\\x00B\\bZ\\x06/protob\\x06proto3\"\n \n var (\n \tfile_daemon_proto_rawDescOnce sync.Once\n@@ -5071,7 +5814,7 @@ func file_daemon_proto_rawDescGZIP() []byte {\n }\n \n var file_daemon_proto_enumTypes = make([]protoimpl.EnumInfo, 3)\n-var file_daemon_proto_msgTypes = make([]protoimpl.MessageInfo, 72)\n+var file_daemon_proto_msgTypes = make([]protoimpl.MessageInfo, 80)\n var file_daemon_proto_goTypes = []any{\n \t(LogLevel)(0),                              // 0: daemon.LogLevel\n \t(SystemEvent_Severity)(0),                  // 1: daemon.SystemEvent.Severity\n@@ -5095,155 +5838,171 @@ var file_daemon_proto_goTypes = []any{\n \t(*ManagementState)(nil),                    // 19: daemon.ManagementState\n \t(*RelayState)(nil),                         // 20: daemon.RelayState\n \t(*NSGroupState)(nil),                       // 21: daemon.NSGroupState\n-\t(*FullStatus)(nil),                         // 22: daemon.FullStatus\n-\t(*ListNetworksRequest)(nil),                // 23: daemon.ListNetworksRequest\n-\t(*ListNetworksResponse)(nil),               // 24: daemon.ListNetworksResponse\n-\t(*SelectNetworksRequest)(nil),              // 25: daemon.SelectNetworksRequest\n-\t(*SelectNetworksResponse)(nil),             // 26: daemon.SelectNetworksResponse\n-\t(*IPList)(nil),                             // 27: daemon.IPList\n-\t(*Network)(nil),                            // 28: daemon.Network\n-\t(*PortInfo)(nil),                           // 29: daemon.PortInfo\n-\t(*ForwardingRule)(nil),                     // 30: daemon.ForwardingRule\n-\t(*ForwardingRulesResponse)(nil),            // 31: daemon.ForwardingRulesResponse\n-\t(*DebugBundleRequest)(nil),                 // 32: daemon.DebugBundleRequest\n-\t(*DebugBundleResponse)(nil),                // 33: daemon.DebugBundleResponse\n-\t(*GetLogLevelRequest)(nil),                 // 34: daemon.GetLogLevelRequest\n-\t(*GetLogLevelResponse)(nil),                // 35: daemon.GetLogLevelResponse\n-\t(*SetLogLevelRequest)(nil),                 // 36: daemon.SetLogLevelRequest\n-\t(*SetLogLevelResponse)(nil),                // 37: daemon.SetLogLevelResponse\n-\t(*State)(nil),                              // 38: daemon.State\n-\t(*ListStatesRequest)(nil),                  // 39: daemon.ListStatesRequest\n-\t(*ListStatesResponse)(nil),                 // 40: daemon.ListStatesResponse\n-\t(*CleanStateRequest)(nil),                  // 41: daemon.CleanStateRequest\n-\t(*CleanStateResponse)(nil),                 // 42: daemon.CleanStateResponse\n-\t(*DeleteStateRequest)(nil),                 // 43: daemon.DeleteStateRequest\n-\t(*DeleteStateResponse)(nil),                // 44: daemon.DeleteStateResponse\n-\t(*SetSyncResponsePersistenceRequest)(nil),  // 45: daemon.SetSyncResponsePersistenceRequest\n-\t(*SetSyncResponsePersistenceResponse)(nil), // 46: daemon.SetSyncResponsePersistenceResponse\n-\t(*TCPFlags)(nil),                           // 47: daemon.TCPFlags\n-\t(*TracePacketRequest)(nil),                 // 48: daemon.TracePacketRequest\n-\t(*TraceStage)(nil),                         // 49: daemon.TraceStage\n-\t(*TracePacketResponse)(nil),                // 50: daemon.TracePacketResponse\n-\t(*SubscribeRequest)(nil),                   // 51: daemon.SubscribeRequest\n-\t(*SystemEvent)(nil),                        // 52: daemon.SystemEvent\n-\t(*GetEventsRequest)(nil),                   // 53: daemon.GetEventsRequest\n-\t(*GetEventsResponse)(nil),                  // 54: daemon.GetEventsResponse\n-\t(*SwitchProfileRequest)(nil),               // 55: daemon.SwitchProfileRequest\n-\t(*SwitchProfileResponse)(nil),              // 56: daemon.SwitchProfileResponse\n-\t(*SetConfigRequest)(nil),                   // 57: daemon.SetConfigRequest\n-\t(*SetConfigResponse)(nil),                  // 58: daemon.SetConfigResponse\n-\t(*AddProfileRequest)(nil),                  // 59: daemon.AddProfileRequest\n-\t(*AddProfileResponse)(nil),                 // 60: daemon.AddProfileResponse\n-\t(*RemoveProfileRequest)(nil),               // 61: daemon.RemoveProfileRequest\n-\t(*RemoveProfileResponse)(nil),              // 62: daemon.RemoveProfileResponse\n-\t(*ListProfilesRequest)(nil),                // 63: daemon.ListProfilesRequest\n-\t(*ListProfilesResponse)(nil),               // 64: daemon.ListProfilesResponse\n-\t(*Profile)(nil),                            // 65: daemon.Profile\n-\t(*GetActiveProfileRequest)(nil),            // 66: daemon.GetActiveProfileRequest\n-\t(*GetActiveProfileResponse)(nil),           // 67: daemon.GetActiveProfileResponse\n-\t(*LogoutRequest)(nil),                      // 68: daemon.LogoutRequest\n-\t(*LogoutResponse)(nil),                     // 69: daemon.LogoutResponse\n-\t(*GetFeaturesRequest)(nil),                 // 70: daemon.GetFeaturesRequest\n-\t(*GetFeaturesResponse)(nil),                // 71: daemon.GetFeaturesResponse\n-\tnil,                                        // 72: daemon.Network.ResolvedIPsEntry\n-\t(*PortInfo_Range)(nil),                     // 73: daemon.PortInfo.Range\n-\tnil,                                        // 74: daemon.SystemEvent.MetadataEntry\n-\t(*durationpb.Duration)(nil),                // 75: google.protobuf.Duration\n-\t(*timestamppb.Timestamp)(nil),              // 76: google.protobuf.Timestamp\n+\t(*SSHSessionInfo)(nil),                     // 22: daemon.SSHSessionInfo\n+\t(*SSHServerState)(nil),                     // 23: daemon.SSHServerState\n+\t(*FullStatus)(nil),                         // 24: daemon.FullStatus\n+\t(*ListNetworksRequest)(nil),                // 25: daemon.ListNetworksRequest\n+\t(*ListNetworksResponse)(nil),               // 26: daemon.ListNetworksResponse\n+\t(*SelectNetworksRequest)(nil),              // 27: daemon.SelectNetworksRequest\n+\t(*SelectNetworksResponse)(nil),             // 28: daemon.SelectNetworksResponse\n+\t(*IPList)(nil),                             // 29: daemon.IPList\n+\t(*Network)(nil),                            // 30: daemon.Network\n+\t(*PortInfo)(nil),                           // 31: daemon.PortInfo\n+\t(*ForwardingRule)(nil),                     // 32: daemon.ForwardingRule\n+\t(*ForwardingRulesResponse)(nil),            // 33: daemon.ForwardingRulesResponse\n+\t(*DebugBundleRequest)(nil),                 // 34: daemon.DebugBundleRequest\n+\t(*DebugBundleResponse)(nil),                // 35: daemon.DebugBundleResponse\n+\t(*GetLogLevelRequest)(nil),                 // 36: daemon.GetLogLevelRequest\n+\t(*GetLogLevelResponse)(nil),                // 37: daemon.GetLogLevelResponse\n+\t(*SetLogLevelRequest)(nil),                 // 38: daemon.SetLogLevelRequest\n+\t(*SetLogLevelResponse)(nil),                // 39: daemon.SetLogLevelResponse\n+\t(*State)(nil),                              // 40: daemon.State\n+\t(*ListStatesRequest)(nil),                  // 41: daemon.ListStatesRequest\n+\t(*ListStatesResponse)(nil),                 // 42: daemon.ListStatesResponse\n+\t(*CleanStateRequest)(nil),                  // 43: daemon.CleanStateRequest\n+\t(*CleanStateResponse)(nil),                 // 44: daemon.CleanStateResponse\n+\t(*DeleteStateRequest)(nil),                 // 45: daemon.DeleteStateRequest\n+\t(*DeleteStateResponse)(nil),                // 46: daemon.DeleteStateResponse\n+\t(*SetSyncResponsePersistenceRequest)(nil),  // 47: daemon.SetSyncResponsePersistenceRequest\n+\t(*SetSyncResponsePersistenceResponse)(nil), // 48: daemon.SetSyncResponsePersistenceResponse\n+\t(*TCPFlags)(nil),                           // 49: daemon.TCPFlags\n+\t(*TracePacketRequest)(nil),                 // 50: daemon.TracePacketRequest\n+\t(*TraceStage)(nil),                         // 51: daemon.TraceStage\n+\t(*TracePacketResponse)(nil),                // 52: daemon.TracePacketResponse\n+\t(*SubscribeRequest)(nil),                   // 53: daemon.SubscribeRequest\n+\t(*SystemEvent)(nil),                        // 54: daemon.SystemEvent\n+\t(*GetEventsRequest)(nil),                   // 55: daemon.GetEventsRequest\n+\t(*GetEventsResponse)(nil),                  // 56: daemon.GetEventsResponse\n+\t(*SwitchProfileRequest)(nil),               // 57: daemon.SwitchProfileRequest\n+\t(*SwitchProfileResponse)(nil),              // 58: daemon.SwitchProfileResponse\n+\t(*SetConfigRequest)(nil),                   // 59: daemon.SetConfigRequest\n+\t(*SetConfigResponse)(nil),                  // 60: daemon.SetConfigResponse\n+\t(*AddProfileRequest)(nil),                  // 61: daemon.AddProfileRequest\n+\t(*AddProfileResponse)(nil),                 // 62: daemon.AddProfileResponse\n+\t(*RemoveProfileRequest)(nil),               // 63: daemon.RemoveProfileRequest\n+\t(*RemoveProfileResponse)(nil),              // 64: daemon.RemoveProfileResponse\n+\t(*ListProfilesRequest)(nil),                // 65: daemon.ListProfilesRequest\n+\t(*ListProfilesResponse)(nil),               // 66: daemon.ListProfilesResponse\n+\t(*Profile)(nil),                            // 67: daemon.Profile\n+\t(*GetActiveProfileRequest)(nil),            // 68: daemon.GetActiveProfileRequest\n+\t(*GetActiveProfileResponse)(nil),           // 69: daemon.GetActiveProfileResponse\n+\t(*LogoutRequest)(nil),                      // 70: daemon.LogoutRequest\n+\t(*LogoutResponse)(nil),                     // 71: daemon.LogoutResponse\n+\t(*GetFeaturesRequest)(nil),                 // 72: daemon.GetFeaturesRequest\n+\t(*GetFeaturesResponse)(nil),                // 73: daemon.GetFeaturesResponse\n+\t(*GetPeerSSHHostKeyRequest)(nil),           // 74: daemon.GetPeerSSHHostKeyRequest\n+\t(*GetPeerSSHHostKeyResponse)(nil),          // 75: daemon.GetPeerSSHHostKeyResponse\n+\t(*RequestJWTAuthRequest)(nil),              // 76: daemon.RequestJWTAuthRequest\n+\t(*RequestJWTAuthResponse)(nil),             // 77: daemon.RequestJWTAuthResponse\n+\t(*WaitJWTTokenRequest)(nil),                // 78: daemon.WaitJWTTokenRequest\n+\t(*WaitJWTTokenResponse)(nil),               // 79: daemon.WaitJWTTokenResponse\n+\tnil,                                        // 80: daemon.Network.ResolvedIPsEntry\n+\t(*PortInfo_Range)(nil),                     // 81: daemon.PortInfo.Range\n+\tnil,                                        // 82: daemon.SystemEvent.MetadataEntry\n+\t(*durationpb.Duration)(nil),                // 83: google.protobuf.Duration\n+\t(*timestamppb.Timestamp)(nil),              // 84: google.protobuf.Timestamp\n }\n var file_daemon_proto_depIdxs = []int32{\n-\t75, // 0: daemon.LoginRequest.dnsRouteInterval:type_name -> google.protobuf.Duration\n-\t22, // 1: daemon.StatusResponse.fullStatus:type_name -> daemon.FullStatus\n-\t76, // 2: daemon.PeerState.connStatusUpdate:type_name -> google.protobuf.Timestamp\n-\t76, // 3: daemon.PeerState.lastWireguardHandshake:type_name -> google.protobuf.Timestamp\n-\t75, // 4: daemon.PeerState.latency:type_name -> google.protobuf.Duration\n-\t19, // 5: daemon.FullStatus.managementState:type_name -> daemon.ManagementState\n-\t18, // 6: daemon.FullStatus.signalState:type_name -> daemon.SignalState\n-\t17, // 7: daemon.FullStatus.localPeerState:type_name -> daemon.LocalPeerState\n-\t16, // 8: daemon.FullStatus.peers:type_name -> daemon.PeerState\n-\t20, // 9: daemon.FullStatus.relays:type_name -> daemon.RelayState\n-\t21, // 10: daemon.FullStatus.dns_servers:type_name -> daemon.NSGroupState\n-\t52, // 11: daemon.FullStatus.events:type_name -> daemon.SystemEvent\n-\t28, // 12: daemon.ListNetworksResponse.routes:type_name -> daemon.Network\n-\t72, // 13: daemon.Network.resolvedIPs:type_name -> daemon.Network.ResolvedIPsEntry\n-\t73, // 14: daemon.PortInfo.range:type_name -> daemon.PortInfo.Range\n-\t29, // 15: daemon.ForwardingRule.destinationPort:type_name -> daemon.PortInfo\n-\t29, // 16: daemon.ForwardingRule.translatedPort:type_name -> daemon.PortInfo\n-\t30, // 17: daemon.ForwardingRulesResponse.rules:type_name -> daemon.ForwardingRule\n-\t0,  // 18: daemon.GetLogLevelResponse.level:type_name -> daemon.LogLevel\n-\t0,  // 19: daemon.SetLogLevelRequest.level:type_name -> daemon.LogLevel\n-\t38, // 20: daemon.ListStatesResponse.states:type_name -> daemon.State\n-\t47, // 21: daemon.TracePacketRequest.tcp_flags:type_name -> daemon.TCPFlags\n-\t49, // 22: daemon.TracePacketResponse.stages:type_name -> daemon.TraceStage\n-\t1,  // 23: daemon.SystemEvent.severity:type_name -> daemon.SystemEvent.Severity\n-\t2,  // 24: daemon.SystemEvent.category:type_name -> daemon.SystemEvent.Category\n-\t76, // 25: daemon.SystemEvent.timestamp:type_name -> google.protobuf.Timestamp\n-\t74, // 26: daemon.SystemEvent.metadata:type_name -> daemon.SystemEvent.MetadataEntry\n-\t52, // 27: daemon.GetEventsResponse.events:type_name -> daemon.SystemEvent\n-\t75, // 28: daemon.SetConfigRequest.dnsRouteInterval:type_name -> google.protobuf.Duration\n-\t65, // 29: daemon.ListProfilesResponse.profiles:type_name -> daemon.Profile\n-\t27, // 30: daemon.Network.ResolvedIPsEntry.value:type_name -> daemon.IPList\n-\t4,  // 31: daemon.DaemonService.Login:input_type -> daemon.LoginRequest\n-\t6,  // 32: daemon.DaemonService.WaitSSOLogin:input_type -> daemon.WaitSSOLoginRequest\n-\t8,  // 33: daemon.DaemonService.Up:input_type -> daemon.UpRequest\n-\t10, // 34: daemon.DaemonService.Status:input_type -> daemon.StatusRequest\n-\t12, // 35: daemon.DaemonService.Down:input_type -> daemon.DownRequest\n-\t14, // 36: daemon.DaemonService.GetConfig:input_type -> daemon.GetConfigRequest\n-\t23, // 37: daemon.DaemonService.ListNetworks:input_type -> daemon.ListNetworksRequest\n-\t25, // 38: daemon.DaemonService.SelectNetworks:input_type -> daemon.SelectNetworksRequest\n-\t25, // 39: daemon.DaemonService.DeselectNetworks:input_type -> daemon.SelectNetworksRequest\n-\t3,  // 40: daemon.DaemonService.ForwardingRules:input_type -> daemon.EmptyRequest\n-\t32, // 41: daemon.DaemonService.DebugBundle:input_type -> daemon.DebugBundleRequest\n-\t34, // 42: daemon.DaemonService.GetLogLevel:input_type -> daemon.GetLogLevelRequest\n-\t36, // 43: daemon.DaemonService.SetLogLevel:input_type -> daemon.SetLogLevelRequest\n-\t39, // 44: daemon.DaemonService.ListStates:input_type -> daemon.ListStatesRequest\n-\t41, // 45: daemon.DaemonService.CleanState:input_type -> daemon.CleanStateRequest\n-\t43, // 46: daemon.DaemonService.DeleteState:input_type -> daemon.DeleteStateRequest\n-\t45, // 47: daemon.DaemonService.SetSyncResponsePersistence:input_type -> daemon.SetSyncResponsePersistenceRequest\n-\t48, // 48: daemon.DaemonService.TracePacket:input_type -> daemon.TracePacketRequest\n-\t51, // 49: daemon.DaemonService.SubscribeEvents:input_type -> daemon.SubscribeRequest\n-\t53, // 50: daemon.DaemonService.GetEvents:input_type -> daemon.GetEventsRequest\n-\t55, // 51: daemon.DaemonService.SwitchProfile:input_type -> daemon.SwitchProfileRequest\n-\t57, // 52: daemon.DaemonService.SetConfig:input_type -> daemon.SetConfigRequest\n-\t59, // 53: daemon.DaemonService.AddProfile:input_type -> daemon.AddProfileRequest\n-\t61, // 54: daemon.DaemonService.RemoveProfile:input_type -> daemon.RemoveProfileRequest\n-\t63, // 55: daemon.DaemonService.ListProfiles:input_type -> daemon.ListProfilesRequest\n-\t66, // 56: daemon.DaemonService.GetActiveProfile:input_type -> daemon.GetActiveProfileRequest\n-\t68, // 57: daemon.DaemonService.Logout:input_type -> daemon.LogoutRequest\n-\t70, // 58: daemon.DaemonService.GetFeatures:input_type -> daemon.GetFeaturesRequest\n-\t5,  // 59: daemon.DaemonService.Login:output_type -> daemon.LoginResponse\n-\t7,  // 60: daemon.DaemonService.WaitSSOLogin:output_type -> daemon.WaitSSOLoginResponse\n-\t9,  // 61: daemon.DaemonService.Up:output_type -> daemon.UpResponse\n-\t11, // 62: daemon.DaemonService.Status:output_type -> daemon.StatusResponse\n-\t13, // 63: daemon.DaemonService.Down:output_type -> daemon.DownResponse\n-\t15, // 64: daemon.DaemonService.GetConfig:output_type -> daemon.GetConfigResponse\n-\t24, // 65: daemon.DaemonService.ListNetworks:output_type -> daemon.ListNetworksResponse\n-\t26, // 66: daemon.DaemonService.SelectNetworks:output_type -> daemon.SelectNetworksResponse\n-\t26, // 67: daemon.DaemonService.DeselectNetworks:output_type -> daemon.SelectNetworksResponse\n-\t31, // 68: daemon.DaemonService.ForwardingRules:output_type -> daemon.ForwardingRulesResponse\n-\t33, // 69: daemon.DaemonService.DebugBundle:output_type -> daemon.DebugBundleResponse\n-\t35, // 70: daemon.DaemonService.GetLogLevel:output_type -> daemon.GetLogLevelResponse\n-\t37, // 71: daemon.DaemonService.SetLogLevel:output_type -> daemon.SetLogLevelResponse\n-\t40, // 72: daemon.DaemonService.ListStates:output_type -> daemon.ListStatesResponse\n-\t42, // 73: daemon.DaemonService.CleanState:output_type -> daemon.CleanStateResponse\n-\t44, // 74: daemon.DaemonService.DeleteState:output_type -> daemon.DeleteStateResponse\n-\t46, // 75: daemon.DaemonService.SetSyncResponsePersistence:output_type -> daemon.SetSyncResponsePersistenceResponse\n-\t50, // 76: daemon.DaemonService.TracePacket:output_type -> daemon.TracePacketResponse\n-\t52, // 77: daemon.DaemonService.SubscribeEvents:output_type -> daemon.SystemEvent\n-\t54, // 78: daemon.DaemonService.GetEvents:output_type -> daemon.GetEventsResponse\n-\t56, // 79: daemon.DaemonService.SwitchProfile:output_type -> daemon.SwitchProfileResponse\n-\t58, // 80: daemon.DaemonService.SetConfig:output_type -> daemon.SetConfigResponse\n-\t60, // 81: daemon.DaemonService.AddProfile:output_type -> daemon.AddProfileResponse\n-\t62, // 82: daemon.DaemonService.RemoveProfile:output_type -> daemon.RemoveProfileResponse\n-\t64, // 83: daemon.DaemonService.ListProfiles:output_type -> daemon.ListProfilesResponse\n-\t67, // 84: daemon.DaemonService.GetActiveProfile:output_type -> daemon.GetActiveProfileResponse\n-\t69, // 85: daemon.DaemonService.Logout:output_type -> daemon.LogoutResponse\n-\t71, // 86: daemon.DaemonService.GetFeatures:output_type -> daemon.GetFeaturesResponse\n-\t59, // [59:87] is the sub-list for method output_type\n-\t31, // [31:59] is the sub-list for method input_type\n-\t31, // [31:31] is the sub-list for extension type_name\n-\t31, // [31:31] is the sub-list for extension extendee\n-\t0,  // [0:31] is the sub-list for field type_name\n+\t83, // 0: daemon.LoginRequest.dnsRouteInterval:type_name -> google.protobuf.Duration\n+\t24, // 1: daemon.StatusResponse.fullStatus:type_name -> daemon.FullStatus\n+\t84, // 2: daemon.PeerState.connStatusUpdate:type_name -> google.protobuf.Timestamp\n+\t84, // 3: daemon.PeerState.lastWireguardHandshake:type_name -> google.protobuf.Timestamp\n+\t83, // 4: daemon.PeerState.latency:type_name -> google.protobuf.Duration\n+\t22, // 5: daemon.SSHServerState.sessions:type_name -> daemon.SSHSessionInfo\n+\t19, // 6: daemon.FullStatus.managementState:type_name -> daemon.ManagementState\n+\t18, // 7: daemon.FullStatus.signalState:type_name -> daemon.SignalState\n+\t17, // 8: daemon.FullStatus.localPeerState:type_name -> daemon.LocalPeerState\n+\t16, // 9: daemon.FullStatus.peers:type_name -> daemon.PeerState\n+\t20, // 10: daemon.FullStatus.relays:type_name -> daemon.RelayState\n+\t21, // 11: daemon.FullStatus.dns_servers:type_name -> daemon.NSGroupState\n+\t54, // 12: daemon.FullStatus.events:type_name -> daemon.SystemEvent\n+\t23, // 13: daemon.FullStatus.sshServerState:type_name -> daemon.SSHServerState\n+\t30, // 14: daemon.ListNetworksResponse.routes:type_name -> daemon.Network\n+\t80, // 15: daemon.Network.resolvedIPs:type_name -> daemon.Network.ResolvedIPsEntry\n+\t81, // 16: daemon.PortInfo.range:type_name -> daemon.PortInfo.Range\n+\t31, // 17: daemon.ForwardingRule.destinationPort:type_name -> daemon.PortInfo\n+\t31, // 18: daemon.ForwardingRule.translatedPort:type_name -> daemon.PortInfo\n+\t32, // 19: daemon.ForwardingRulesResponse.rules:type_name -> daemon.ForwardingRule\n+\t0,  // 20: daemon.GetLogLevelResponse.level:type_name -> daemon.LogLevel\n+\t0,  // 21: daemon.SetLogLevelRequest.level:type_name -> daemon.LogLevel\n+\t40, // 22: daemon.ListStatesResponse.states:type_name -> daemon.State\n+\t49, // 23: daemon.TracePacketRequest.tcp_flags:type_name -> daemon.TCPFlags\n+\t51, // 24: daemon.TracePacketResponse.stages:type_name -> daemon.TraceStage\n+\t1,  // 25: daemon.SystemEvent.severity:type_name -> daemon.SystemEvent.Severity\n+\t2,  // 26: daemon.SystemEvent.category:type_name -> daemon.SystemEvent.Category\n+\t84, // 27: daemon.SystemEvent.timestamp:type_name -> google.protobuf.Timestamp\n+\t82, // 28: daemon.SystemEvent.metadata:type_name -> daemon.SystemEvent.MetadataEntry\n+\t54, // 29: daemon.GetEventsResponse.events:type_name -> daemon.SystemEvent\n+\t83, // 30: daemon.SetConfigRequest.dnsRouteInterval:type_name -> google.protobuf.Duration\n+\t67, // 31: daemon.ListProfilesResponse.profiles:type_name -> daemon.Profile\n+\t29, // 32: daemon.Network.ResolvedIPsEntry.value:type_name -> daemon.IPList\n+\t4,  // 33: daemon.DaemonService.Login:input_type -> daemon.LoginRequest\n+\t6,  // 34: daemon.DaemonService.WaitSSOLogin:input_type -> daemon.WaitSSOLoginRequest\n+\t8,  // 35: daemon.DaemonService.Up:input_type -> daemon.UpRequest\n+\t10, // 36: daemon.DaemonService.Status:input_type -> daemon.StatusRequest\n+\t12, // 37: daemon.DaemonService.Down:input_type -> daemon.DownRequest\n+\t14, // 38: daemon.DaemonService.GetConfig:input_type -> daemon.GetConfigRequest\n+\t25, // 39: daemon.DaemonService.ListNetworks:input_type -> daemon.ListNetworksRequest\n+\t27, // 40: daemon.DaemonService.SelectNetworks:input_type -> daemon.SelectNetworksRequest\n+\t27, // 41: daemon.DaemonService.DeselectNetworks:input_type -> daemon.SelectNetworksRequest\n+\t3,  // 42: daemon.DaemonService.ForwardingRules:input_type -> daemon.EmptyRequest\n+\t34, // 43: daemon.DaemonService.DebugBundle:input_type -> daemon.DebugBundleRequest\n+\t36, // 44: daemon.DaemonService.GetLogLevel:input_type -> daemon.GetLogLevelRequest\n+\t38, // 45: daemon.DaemonService.SetLogLevel:input_type -> daemon.SetLogLevelRequest\n+\t41, // 46: daemon.DaemonService.ListStates:input_type -> daemon.ListStatesRequest\n+\t43, // 47: daemon.DaemonService.CleanState:input_type -> daemon.CleanStateRequest\n+\t45, // 48: daemon.DaemonService.DeleteState:input_type -> daemon.DeleteStateRequest\n+\t47, // 49: daemon.DaemonService.SetSyncResponsePersistence:input_type -> daemon.SetSyncResponsePersistenceRequest\n+\t50, // 50: daemon.DaemonService.TracePacket:input_type -> daemon.TracePacketRequest\n+\t53, // 51: daemon.DaemonService.SubscribeEvents:input_type -> daemon.SubscribeRequest\n+\t55, // 52: daemon.DaemonService.GetEvents:input_type -> daemon.GetEventsRequest\n+\t57, // 53: daemon.DaemonService.SwitchProfile:input_type -> daemon.SwitchProfileRequest\n+\t59, // 54: daemon.DaemonService.SetConfig:input_type -> daemon.SetConfigRequest\n+\t61, // 55: daemon.DaemonService.AddProfile:input_type -> daemon.AddProfileRequest\n+\t63, // 56: daemon.DaemonService.RemoveProfile:input_type -> daemon.RemoveProfileRequest\n+\t65, // 57: daemon.DaemonService.ListProfiles:input_type -> daemon.ListProfilesRequest\n+\t68, // 58: daemon.DaemonService.GetActiveProfile:input_type -> daemon.GetActiveProfileRequest\n+\t70, // 59: daemon.DaemonService.Logout:input_type -> daemon.LogoutRequest\n+\t72, // 60: daemon.DaemonService.GetFeatures:input_type -> daemon.GetFeaturesRequest\n+\t74, // 61: daemon.DaemonService.GetPeerSSHHostKey:input_type -> daemon.GetPeerSSHHostKeyRequest\n+\t76, // 62: daemon.DaemonService.RequestJWTAuth:input_type -> daemon.RequestJWTAuthRequest\n+\t78, // 63: daemon.DaemonService.WaitJWTToken:input_type -> daemon.WaitJWTTokenRequest\n+\t5,  // 64: daemon.DaemonService.Login:output_type -> daemon.LoginResponse\n+\t7,  // 65: daemon.DaemonService.WaitSSOLogin:output_type -> daemon.WaitSSOLoginResponse\n+\t9,  // 66: daemon.DaemonService.Up:output_type -> daemon.UpResponse\n+\t11, // 67: daemon.DaemonService.Status:output_type -> daemon.StatusResponse\n+\t13, // 68: daemon.DaemonService.Down:output_type -> daemon.DownResponse\n+\t15, // 69: daemon.DaemonService.GetConfig:output_type -> daemon.GetConfigResponse\n+\t26, // 70: daemon.DaemonService.ListNetworks:output_type -> daemon.ListNetworksResponse\n+\t28, // 71: daemon.DaemonService.SelectNetworks:output_type -> daemon.SelectNetworksResponse\n+\t28, // 72: daemon.DaemonService.DeselectNetworks:output_type -> daemon.SelectNetworksResponse\n+\t33, // 73: daemon.DaemonService.ForwardingRules:output_type -> daemon.ForwardingRulesResponse\n+\t35, // 74: daemon.DaemonService.DebugBundle:output_type -> daemon.DebugBundleResponse\n+\t37, // 75: daemon.DaemonService.GetLogLevel:output_type -> daemon.GetLogLevelResponse\n+\t39, // 76: daemon.DaemonService.SetLogLevel:output_type -> daemon.SetLogLevelResponse\n+\t42, // 77: daemon.DaemonService.ListStates:output_type -> daemon.ListStatesResponse\n+\t44, // 78: daemon.DaemonService.CleanState:output_type -> daemon.CleanStateResponse\n+\t46, // 79: daemon.DaemonService.DeleteState:output_type -> daemon.DeleteStateResponse\n+\t48, // 80: daemon.DaemonService.SetSyncResponsePersistence:output_type -> daemon.SetSyncResponsePersistenceResponse\n+\t52, // 81: daemon.DaemonService.TracePacket:output_type -> daemon.TracePacketResponse\n+\t54, // 82: daemon.DaemonService.SubscribeEvents:output_type -> daemon.SystemEvent\n+\t56, // 83: daemon.DaemonService.GetEvents:output_type -> daemon.GetEventsResponse\n+\t58, // 84: daemon.DaemonService.SwitchProfile:output_type -> daemon.SwitchProfileResponse\n+\t60, // 85: daemon.DaemonService.SetConfig:output_type -> daemon.SetConfigResponse\n+\t62, // 86: daemon.DaemonService.AddProfile:output_type -> daemon.AddProfileResponse\n+\t64, // 87: daemon.DaemonService.RemoveProfile:output_type -> daemon.RemoveProfileResponse\n+\t66, // 88: daemon.DaemonService.ListProfiles:output_type -> daemon.ListProfilesResponse\n+\t69, // 89: daemon.DaemonService.GetActiveProfile:output_type -> daemon.GetActiveProfileResponse\n+\t71, // 90: daemon.DaemonService.Logout:output_type -> daemon.LogoutResponse\n+\t73, // 91: daemon.DaemonService.GetFeatures:output_type -> daemon.GetFeaturesResponse\n+\t75, // 92: daemon.DaemonService.GetPeerSSHHostKey:output_type -> daemon.GetPeerSSHHostKeyResponse\n+\t77, // 93: daemon.DaemonService.RequestJWTAuth:output_type -> daemon.RequestJWTAuthResponse\n+\t79, // 94: daemon.DaemonService.WaitJWTToken:output_type -> daemon.WaitJWTTokenResponse\n+\t64, // [64:95] is the sub-list for method output_type\n+\t33, // [33:64] is the sub-list for method input_type\n+\t33, // [33:33] is the sub-list for extension type_name\n+\t33, // [33:33] is the sub-list for extension extendee\n+\t0,  // [0:33] is the sub-list for field type_name\n }\n \n func init() { file_daemon_proto_init() }\n@@ -5254,22 +6013,23 @@ func file_daemon_proto_init() {\n \tfile_daemon_proto_msgTypes[1].OneofWrappers = []any{}\n \tfile_daemon_proto_msgTypes[5].OneofWrappers = []any{}\n \tfile_daemon_proto_msgTypes[7].OneofWrappers = []any{}\n-\tfile_daemon_proto_msgTypes[26].OneofWrappers = []any{\n+\tfile_daemon_proto_msgTypes[28].OneofWrappers = []any{\n \t\t(*PortInfo_Port)(nil),\n \t\t(*PortInfo_Range_)(nil),\n \t}\n-\tfile_daemon_proto_msgTypes[45].OneofWrappers = []any{}\n-\tfile_daemon_proto_msgTypes[46].OneofWrappers = []any{}\n-\tfile_daemon_proto_msgTypes[52].OneofWrappers = []any{}\n+\tfile_daemon_proto_msgTypes[47].OneofWrappers = []any{}\n+\tfile_daemon_proto_msgTypes[48].OneofWrappers = []any{}\n \tfile_daemon_proto_msgTypes[54].OneofWrappers = []any{}\n-\tfile_daemon_proto_msgTypes[65].OneofWrappers = []any{}\n+\tfile_daemon_proto_msgTypes[56].OneofWrappers = []any{}\n+\tfile_daemon_proto_msgTypes[67].OneofWrappers = []any{}\n+\tfile_daemon_proto_msgTypes[73].OneofWrappers = []any{}\n \ttype x struct{}\n \tout := protoimpl.TypeBuilder{\n \t\tFile: protoimpl.DescBuilder{\n \t\t\tGoPackagePath: reflect.TypeOf(x{}).PkgPath(),\n \t\t\tRawDescriptor: unsafe.Slice(unsafe.StringData(file_daemon_proto_rawDesc), len(file_daemon_proto_rawDesc)),\n \t\t\tNumEnums:      3,\n-\t\t\tNumMessages:   72,\n+\t\t\tNumMessages:   80,\n \t\t\tNumExtensions: 0,\n \t\t\tNumServices:   1,\n \t\t},\ndiff --git a/client/proto/daemon.proto b/client/proto/daemon.proto\nindex 8d10800515b..bf85537067b 100644\n--- a/client/proto/daemon.proto\n+++ b/client/proto/daemon.proto\n@@ -84,6 +84,15 @@ service DaemonService {\n   rpc Logout(LogoutRequest) returns (LogoutResponse) {}\n \n   rpc GetFeatures(GetFeaturesRequest) returns (GetFeaturesResponse) {}\n+\n+  // GetPeerSSHHostKey retrieves SSH host key for a specific peer\n+  rpc GetPeerSSHHostKey(GetPeerSSHHostKeyRequest) returns (GetPeerSSHHostKeyResponse) {}\n+\n+  // RequestJWTAuth initiates JWT authentication flow for SSH\n+  rpc RequestJWTAuth(RequestJWTAuthRequest) returns (RequestJWTAuthResponse) {}\n+\n+  // WaitJWTToken waits for JWT authentication completion\n+  rpc WaitJWTToken(WaitJWTTokenRequest) returns (WaitJWTTokenResponse) {}\n }\n \n \n@@ -161,6 +170,13 @@ message LoginRequest {\n \n   // hint is used to pre-fill the email/username field during SSO authentication\n   optional string hint = 33;\n+\n+  optional bool enableSSHRoot = 34;\n+  optional bool enableSSHSFTP = 35;\n+  optional bool enableSSHLocalPortForwarding = 36;\n+  optional bool enableSSHRemotePortForwarding = 37;\n+  optional bool disableSSHAuth = 38;\n+  optional int32 sshJWTCacheTTL = 39;\n }\n \n message LoginResponse {\n@@ -188,9 +204,9 @@ message UpResponse {}\n \n message StatusRequest{\n   bool getFullPeerStatus = 1;\n-  bool shouldRunProbes   = 2;\n+  bool shouldRunProbes = 2;\n   // the UI do not using this yet, but CLIs could use it to wait until the status is ready\n-  optional bool waitForReady     = 3;\n+  optional bool waitForReady = 3;\n }\n \n message StatusResponse{\n@@ -255,6 +271,18 @@ message GetConfigResponse {\n   bool disable_server_routes = 19;\n \n   bool block_lan_access = 20;\n+\n+  bool enableSSHRoot = 21;\n+\n+  bool enableSSHSFTP = 24;\n+\n+  bool enableSSHLocalPortForwarding = 22;\n+\n+  bool enableSSHRemotePortForwarding = 23;\n+\n+  bool disableSSHAuth = 25;\n+\n+  int32 sshJWTCacheTTL = 26;\n }\n \n // PeerState contains the latest state of a peer\n@@ -276,6 +304,7 @@ message PeerState {\n   repeated string networks = 16;\n   google.protobuf.Duration latency = 17;\n   string relayAddress = 18;\n+  bytes sshHostKey = 19;\n }\n \n // LocalPeerState contains the latest state of the local peer\n@@ -317,6 +346,20 @@ message NSGroupState {\n   string error = 4;\n }\n \n+// SSHSessionInfo contains information about an active SSH session\n+message SSHSessionInfo {\n+  string username = 1;\n+  string remoteAddress = 2;\n+  string command = 3;\n+  string jwtUsername = 4;\n+}\n+\n+// SSHServerState contains the latest state of the SSH server\n+message SSHServerState {\n+  bool enabled = 1;\n+  repeated SSHSessionInfo sessions = 2;\n+}\n+\n // FullStatus contains the full state held by the Status instance\n message FullStatus {\n   ManagementState managementState = 1;\n@@ -330,6 +373,7 @@ message FullStatus {\n   repeated SystemEvent events = 7;\n \n   bool lazyConnectionEnabled = 9;\n+  SSHServerState sshServerState = 10;\n }\n \n // Networks\n@@ -543,56 +587,63 @@ message SwitchProfileRequest {\n message SwitchProfileResponse {}\n \n message SetConfigRequest {\n-    string username = 1;\n-    string profileName = 2;\n-    // managementUrl to authenticate.\n-    string managementUrl = 3;\n+  string username = 1;\n+  string profileName = 2;\n+  // managementUrl to authenticate.\n+  string managementUrl = 3;\n+\n+  // adminUrl to manage keys.\n+  string adminURL = 4;\n \n-    // adminUrl to manage keys.\n-    string adminURL = 4;\n+  optional bool rosenpassEnabled = 5;\n \n-    optional bool rosenpassEnabled = 5;\n+  optional string interfaceName = 6;\n \n-    optional string interfaceName = 6;\n+  optional int64 wireguardPort = 7;\n \n-    optional int64 wireguardPort = 7;\n+  optional string optionalPreSharedKey = 8;\n \n-    optional string optionalPreSharedKey = 8;\n+  optional bool disableAutoConnect = 9;\n \n-    optional bool disableAutoConnect = 9;\n+  optional bool serverSSHAllowed = 10;\n \n-    optional bool serverSSHAllowed = 10;\n+  optional bool rosenpassPermissive = 11;\n \n-    optional bool rosenpassPermissive = 11;\n+  optional bool networkMonitor = 12;\n \n-    optional bool networkMonitor = 12;\n+  optional bool disable_client_routes = 13;\n+  optional bool disable_server_routes = 14;\n+  optional bool disable_dns = 15;\n+  optional bool disable_firewall = 16;\n+  optional bool block_lan_access = 17;\n \n-    optional bool disable_client_routes = 13;\n-    optional bool disable_server_routes = 14;\n-    optional bool disable_dns = 15;\n-    optional bool disable_firewall = 16;\n-    optional bool block_lan_access = 17;\n+  optional bool disable_notifications = 18;\n \n-    optional bool disable_notifications = 18;\n+  optional bool lazyConnectionEnabled = 19;\n \n-    optional bool lazyConnectionEnabled = 19;\n+  optional bool block_inbound = 20;\n \n-    optional bool block_inbound = 20;\n+  repeated string natExternalIPs = 21;\n+  bool cleanNATExternalIPs = 22;\n \n-    repeated string natExternalIPs = 21;\n-    bool cleanNATExternalIPs = 22;\n+  bytes customDNSAddress = 23;\n \n-    bytes customDNSAddress = 23;\n+  repeated string extraIFaceBlacklist = 24;\n \n-    repeated string extraIFaceBlacklist = 24;\n+  repeated string dns_labels = 25;\n+  // cleanDNSLabels clean map list of DNS labels.\n+  bool cleanDNSLabels = 26;\n \n-    repeated string dns_labels = 25;\n-    // cleanDNSLabels clean map list of DNS labels.\n-    bool cleanDNSLabels = 26;\n+  optional google.protobuf.Duration dnsRouteInterval = 27;\n \n-    optional google.protobuf.Duration dnsRouteInterval = 27;\n+  optional int64 mtu = 28;\n \n-    optional int64 mtu = 28;\n+  optional bool enableSSHRoot = 29;\n+  optional bool enableSSHSFTP = 30;\n+  optional bool enableSSHLocalPortForwarding = 31;\n+  optional bool enableSSHRemotePortForwarding = 32;\n+  optional bool disableSSHAuth = 33;\n+  optional int32 sshJWTCacheTTL = 34;\n }\n \n message SetConfigResponse{}\n@@ -644,3 +695,63 @@ message GetFeaturesResponse{\n   bool disable_profiles = 1;\n   bool disable_update_settings = 2;\n }\n+\n+// GetPeerSSHHostKeyRequest for retrieving SSH host key for a specific peer\n+message GetPeerSSHHostKeyRequest {\n+  // peer IP address or FQDN to get SSH host key for\n+  string peerAddress = 1;\n+}\n+\n+// GetPeerSSHHostKeyResponse contains the SSH host key for the requested peer\n+message GetPeerSSHHostKeyResponse {\n+  // SSH host key in SSH public key format (e.g., \"ssh-ed25519 AAAAC3... hostname\")\n+  bytes sshHostKey = 1;\n+  // peer IP address\n+  string peerIP = 2;\n+  // peer FQDN\n+  string peerFQDN = 3;\n+  // indicates if the SSH host key was found\n+  bool found = 4;\n+}\n+\n+// RequestJWTAuthRequest for initiating JWT authentication flow\n+message RequestJWTAuthRequest {\n+  // hint for OIDC login_hint parameter (typically email address)\n+  optional string hint = 1;\n+}\n+\n+// RequestJWTAuthResponse contains authentication flow information\n+message RequestJWTAuthResponse {\n+  // verification URI for user authentication\n+  string verificationURI = 1;\n+  // complete verification URI (with embedded user code)\n+  string verificationURIComplete = 2;\n+  // user code to enter on verification URI\n+  string userCode = 3;\n+  // device code for polling\n+  string deviceCode = 4;\n+  // expiration time in seconds\n+  int64 expiresIn = 5;\n+  // if a cached token is available, it will be returned here\n+  string cachedToken = 6;\n+  // maximum age of JWT tokens in seconds (from management server)\n+  int64 maxTokenAge = 7;\n+}\n+\n+// WaitJWTTokenRequest for waiting for authentication completion\n+message WaitJWTTokenRequest {\n+  // device code from RequestJWTAuthResponse\n+  string deviceCode = 1;\n+  // user code for verification\n+  string userCode = 2;\n+}\n+\n+// WaitJWTTokenResponse contains the JWT token after authentication\n+message WaitJWTTokenResponse {\n+  // JWT token (access token or ID token)\n+  string token = 1;\n+  // token type (e.g., \"Bearer\")\n+  string tokenType = 2;\n+  // expiration time in seconds\n+  int64 expiresIn = 3;\n+}\ndiff --git a/client/proto/daemon_grpc.pb.go b/client/proto/daemon_grpc.pb.go\nindex bf7c9c7b37b..b2bf716b26d 100644\n--- a/client/proto/daemon_grpc.pb.go\n+++ b/client/proto/daemon_grpc.pb.go\n@@ -64,6 +64,12 @@ type DaemonServiceClient interface {\n \t// Logout disconnects from the network and deletes the peer from the management server\n \tLogout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error)\n \tGetFeatures(ctx context.Context, in *GetFeaturesRequest, opts ...grpc.CallOption) (*GetFeaturesResponse, error)\n+\t// GetPeerSSHHostKey retrieves SSH host key for a specific peer\n+\tGetPeerSSHHostKey(ctx context.Context, in *GetPeerSSHHostKeyRequest, opts ...grpc.CallOption) (*GetPeerSSHHostKeyResponse, error)\n+\t// RequestJWTAuth initiates JWT authentication flow for SSH\n+\tRequestJWTAuth(ctx context.Context, in *RequestJWTAuthRequest, opts ...grpc.CallOption) (*RequestJWTAuthResponse, error)\n+\t// WaitJWTToken waits for JWT authentication completion\n+\tWaitJWTToken(ctx context.Context, in *WaitJWTTokenRequest, opts ...grpc.CallOption) (*WaitJWTTokenResponse, error)\n }\n \n type daemonServiceClient struct {\n@@ -349,6 +355,33 @@ func (c *daemonServiceClient) GetFeatures(ctx context.Context, in *GetFeaturesRe\n \treturn out, nil\n }\n \n+func (c *daemonServiceClient) GetPeerSSHHostKey(ctx context.Context, in *GetPeerSSHHostKeyRequest, opts ...grpc.CallOption) (*GetPeerSSHHostKeyResponse, error) {\n+\tout := new(GetPeerSSHHostKeyResponse)\n+\terr := c.cc.Invoke(ctx, \"/daemon.DaemonService/GetPeerSSHHostKey\", in, out, opts...)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn out, nil\n+}\n+\n+func (c *daemonServiceClient) RequestJWTAuth(ctx context.Context, in *RequestJWTAuthRequest, opts ...grpc.CallOption) (*RequestJWTAuthResponse, error) {\n+\tout := new(RequestJWTAuthResponse)\n+\terr := c.cc.Invoke(ctx, \"/daemon.DaemonService/RequestJWTAuth\", in, out, opts...)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn out, nil\n+}\n+\n+func (c *daemonServiceClient) WaitJWTToken(ctx context.Context, in *WaitJWTTokenRequest, opts ...grpc.CallOption) (*WaitJWTTokenResponse, error) {\n+\tout := new(WaitJWTTokenResponse)\n+\terr := c.cc.Invoke(ctx, \"/daemon.DaemonService/WaitJWTToken\", in, out, opts...)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn out, nil\n+}\n+\n // DaemonServiceServer is the server API for DaemonService service.\n // All implementations must embed UnimplementedDaemonServiceServer\n // for forward compatibility\n@@ -399,6 +432,12 @@ type DaemonServiceServer interface {\n \t// Logout disconnects from the network and deletes the peer from the management server\n \tLogout(context.Context, *LogoutRequest) (*LogoutResponse, error)\n \tGetFeatures(context.Context, *GetFeaturesRequest) (*GetFeaturesResponse, error)\n+\t// GetPeerSSHHostKey retrieves SSH host key for a specific peer\n+\tGetPeerSSHHostKey(context.Context, *GetPeerSSHHostKeyRequest) (*GetPeerSSHHostKeyResponse, error)\n+\t// RequestJWTAuth initiates JWT authentication flow for SSH\n+\tRequestJWTAuth(context.Context, *RequestJWTAuthRequest) (*RequestJWTAuthResponse, error)\n+\t// WaitJWTToken waits for JWT authentication completion\n+\tWaitJWTToken(context.Context, *WaitJWTTokenRequest) (*WaitJWTTokenResponse, error)\n \tmustEmbedUnimplementedDaemonServiceServer()\n }\n \n@@ -490,6 +529,15 @@ func (UnimplementedDaemonServiceServer) Logout(context.Context, *LogoutRequest)\n func (UnimplementedDaemonServiceServer) GetFeatures(context.Context, *GetFeaturesRequest) (*GetFeaturesResponse, error) {\n \treturn nil, status.Errorf(codes.Unimplemented, \"method GetFeatures not implemented\")\n }\n+func (UnimplementedDaemonServiceServer) GetPeerSSHHostKey(context.Context, *GetPeerSSHHostKeyRequest) (*GetPeerSSHHostKeyResponse, error) {\n+\treturn nil, status.Errorf(codes.Unimplemented, \"method GetPeerSSHHostKey not implemented\")\n+}\n+func (UnimplementedDaemonServiceServer) RequestJWTAuth(context.Context, *RequestJWTAuthRequest) (*RequestJWTAuthResponse, error) {\n+\treturn nil, status.Errorf(codes.Unimplemented, \"method RequestJWTAuth not implemented\")\n+}\n+func (UnimplementedDaemonServiceServer) WaitJWTToken(context.Context, *WaitJWTTokenRequest) (*WaitJWTTokenResponse, error) {\n+\treturn nil, status.Errorf(codes.Unimplemented, \"method WaitJWTToken not implemented\")\n+}\n func (UnimplementedDaemonServiceServer) mustEmbedUnimplementedDaemonServiceServer() {}\n \n // UnsafeDaemonServiceServer may be embedded to opt out of forward compatibility for this service.\n@@ -1010,6 +1058,60 @@ func _DaemonService_GetFeatures_Handler(srv interface{}, ctx context.Context, de\n \treturn interceptor(ctx, in, info, handler)\n }\n \n+func _DaemonService_GetPeerSSHHostKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n+\tin := new(GetPeerSSHHostKeyRequest)\n+\tif err := dec(in); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif interceptor == nil {\n+\t\treturn srv.(DaemonServiceServer).GetPeerSSHHostKey(ctx, in)\n+\t}\n+\tinfo := &grpc.UnaryServerInfo{\n+\t\tServer:     srv,\n+\t\tFullMethod: \"/daemon.DaemonService/GetPeerSSHHostKey\",\n+\t}\n+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n+\t\treturn srv.(DaemonServiceServer).GetPeerSSHHostKey(ctx, req.(*GetPeerSSHHostKeyRequest))\n+\t}\n+\treturn interceptor(ctx, in, info, handler)\n+}\n+\n+func _DaemonService_RequestJWTAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n+\tin := new(RequestJWTAuthRequest)\n+\tif err := dec(in); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif interceptor == nil {\n+\t\treturn srv.(DaemonServiceServer).RequestJWTAuth(ctx, in)\n+\t}\n+\tinfo := &grpc.UnaryServerInfo{\n+\t\tServer:     srv,\n+\t\tFullMethod: \"/daemon.DaemonService/RequestJWTAuth\",\n+\t}\n+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n+\t\treturn srv.(DaemonServiceServer).RequestJWTAuth(ctx, req.(*RequestJWTAuthRequest))\n+\t}\n+\treturn interceptor(ctx, in, info, handler)\n+}\n+\n+func _DaemonService_WaitJWTToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n+\tin := new(WaitJWTTokenRequest)\n+\tif err := dec(in); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif interceptor == nil {\n+\t\treturn srv.(DaemonServiceServer).WaitJWTToken(ctx, in)\n+\t}\n+\tinfo := &grpc.UnaryServerInfo{\n+\t\tServer:     srv,\n+\t\tFullMethod: \"/daemon.DaemonService/WaitJWTToken\",\n+\t}\n+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n+\t\treturn srv.(DaemonServiceServer).WaitJWTToken(ctx, req.(*WaitJWTTokenRequest))\n+\t}\n+\treturn interceptor(ctx, in, info, handler)\n+}\n+\n // DaemonService_ServiceDesc is the grpc.ServiceDesc for DaemonService service.\n // It's only intended for direct use with grpc.RegisterService,\n // and not to be introspected or modified (even as a copy)\n@@ -1125,6 +1227,18 @@ var DaemonService_ServiceDesc = grpc.ServiceDesc{\n \t\t\tMethodName: \"GetFeatures\",\n \t\t\tHandler:    _DaemonService_GetFeatures_Handler,\n \t\t},\n+\t\t{\n+\t\t\tMethodName: \"GetPeerSSHHostKey\",\n+\t\t\tHandler:    _DaemonService_GetPeerSSHHostKey_Handler,\n+\t\t},\n+\t\t{\n+\t\t\tMethodName: \"RequestJWTAuth\",\n+\t\t\tHandler:    _DaemonService_RequestJWTAuth_Handler,\n+\t\t},\n+\t\t{\n+\t\t\tMethodName: \"WaitJWTToken\",\n+\t\t\tHandler:    _DaemonService_WaitJWTToken_Handler,\n+\t\t},\n \t},\n \tStreams: []grpc.StreamDesc{\n \t\t{\ndiff --git a/client/server/jwt_cache.go b/client/server/jwt_cache.go\nnew file mode 100644\nindex 00000000000..21e17051742\n--- /dev/null\n+++ b/client/server/jwt_cache.go\n@@ -0,0 +1,79 @@\n+package server\n+\n+import (\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/awnumar/memguard\"\n+\tlog \"github.com/sirupsen/logrus\"\n+)\n+\n+type jwtCache struct {\n+\tmu           sync.RWMutex\n+\tenclave      *memguard.Enclave\n+\texpiresAt    time.Time\n+\ttimer        *time.Timer\n+\tmaxTokenSize int\n+}\n+\n+func newJWTCache() *jwtCache {\n+\treturn &jwtCache{\n+\t\tmaxTokenSize: 8192,\n+\t}\n+}\n+\n+func (c *jwtCache) store(token string, maxAge time.Duration) {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\n+\tc.cleanup()\n+\n+\tif c.timer != nil {\n+\t\tc.timer.Stop()\n+\t}\n+\n+\ttokenBytes := []byte(token)\n+\tc.enclave = memguard.NewEnclave(tokenBytes)\n+\n+\tc.expiresAt = time.Now().Add(maxAge)\n+\n+\tvar timer *time.Timer\n+\ttimer = time.AfterFunc(maxAge, func() {\n+\t\tc.mu.Lock()\n+\t\tdefer c.mu.Unlock()\n+\t\tif c.timer != timer {\n+\t\t\treturn\n+\t\t}\n+\t\tc.cleanup()\n+\t\tc.timer = nil\n+\t\tlog.Debugf(\"JWT token cache expired after %v, securely wiped from memory\", maxAge)\n+\t})\n+\tc.timer = timer\n+}\n+\n+func (c *jwtCache) get() (string, bool) {\n+\tc.mu.RLock()\n+\tdefer c.mu.RUnlock()\n+\n+\tif c.enclave == nil || time.Now().After(c.expiresAt) {\n+\t\treturn \"\", false\n+\t}\n+\n+\tbuffer, err := c.enclave.Open()\n+\tif err != nil {\n+\t\tlog.Debugf(\"Failed to open JWT token enclave: %v\", err)\n+\t\treturn \"\", false\n+\t}\n+\tdefer buffer.Destroy()\n+\n+\ttoken := string(buffer.Bytes())\n+\treturn token, true\n+}\n+\n+// cleanup destroys the secure enclave, must be called with lock held\n+func (c *jwtCache) cleanup() {\n+\tif c.enclave != nil {\n+\t\tc.enclave = nil\n+\t}\n+\tc.expiresAt = time.Time{}\n+}\ndiff --git a/client/server/network.go b/client/server/network.go\nindex 18b16795d09..bb1cce56c54 100644\n--- a/client/server/network.go\n+++ b/client/server/network.go\n@@ -11,8 +11,8 @@ import (\n \t\"golang.org/x/exp/maps\"\n \n \t\"github.com/netbirdio/netbird/client/proto\"\n-\t\"github.com/netbirdio/netbird/shared/management/domain\"\n \t\"github.com/netbirdio/netbird/route\"\n+\t\"github.com/netbirdio/netbird/shared/management/domain\"\n )\n \n type selectRoute struct {\ndiff --git a/client/server/server.go b/client/server/server.go\nindex 6699cdadc8f..a930e8a02a5 100644\n--- a/client/server/server.go\n+++ b/client/server/server.go\n@@ -46,6 +46,9 @@ const (\n \tdefaultMaxRetryTime     = 14 * 24 * time.Hour\n \tdefaultRetryMultiplier  = 1.7\n \n+\t// JWT token cache TTL for the client daemon (disabled by default)\n+\tdefaultJWTCacheTTL = 0\n+\n \terrRestoreResidualState   = \"failed to restore residual state: %v\"\n \terrProfilesDisabled       = \"profiles are disabled, you cannot use this feature without profiles enabled\"\n \terrUpdateSettingsDisabled = \"update settings are disabled, you cannot use this feature without update settings enabled\"\n@@ -81,6 +84,8 @@ type Server struct {\n \tprofileManager         *profilemanager.ServiceManager\n \tprofilesDisabled       bool\n \tupdateSettingsDisabled bool\n+\n+\tjwtCache *jwtCache\n }\n \n type oauthAuthFlow struct {\n@@ -100,6 +105,7 @@ func New(ctx context.Context, logFile string, configFile string, profilesDisable\n \t\tprofileManager:         profilemanager.NewServiceManager(configFile),\n \t\tprofilesDisabled:       profilesDisabled,\n \t\tupdateSettingsDisabled: updateSettingsDisabled,\n+\t\tjwtCache:               newJWTCache(),\n \t}\n }\n \n@@ -373,6 +379,17 @@ func (s *Server) SetConfig(callerCtx context.Context, msg *proto.SetConfigReques\n \tconfig.DisableNotifications = msg.DisableNotifications\n \tconfig.LazyConnectionEnabled = msg.LazyConnectionEnabled\n \tconfig.BlockInbound = msg.BlockInbound\n+\tconfig.EnableSSHRoot = msg.EnableSSHRoot\n+\tconfig.EnableSSHSFTP = msg.EnableSSHSFTP\n+\tconfig.EnableSSHLocalPortForwarding = msg.EnableSSHLocalPortForwarding\n+\tconfig.EnableSSHRemotePortForwarding = msg.EnableSSHRemotePortForwarding\n+\tif msg.DisableSSHAuth != nil {\n+\t\tconfig.DisableSSHAuth = msg.DisableSSHAuth\n+\t}\n+\tif msg.SshJWTCacheTTL != nil {\n+\t\tttl := int(*msg.SshJWTCacheTTL)\n+\t\tconfig.SSHJWTCacheTTL = &ttl\n+\t}\n \n \tif msg.Mtu != nil {\n \t\tmtu := uint16(*msg.Mtu)\n@@ -493,7 +510,7 @@ func (s *Server) Login(callerCtx context.Context, msg *proto.LoginRequest) (*pro\n \t\t\treturn nil, err\n \t\t}\n \n-\t\tif s.oauthAuthFlow.flow != nil && s.oauthAuthFlow.flow.GetClientID(ctx) == oAuthFlow.GetClientID(context.TODO()) {\n+\t\tif s.oauthAuthFlow.flow != nil && s.oauthAuthFlow.flow.GetClientID(ctx) == oAuthFlow.GetClientID(ctx) {\n \t\t\tif s.oauthAuthFlow.expiresAt.After(time.Now().Add(90 * time.Second)) {\n \t\t\t\tlog.Debugf(\"using previous oauth flow info\")\n \t\t\t\treturn &proto.LoginResponse{\n@@ -510,7 +527,7 @@ func (s *Server) Login(callerCtx context.Context, msg *proto.LoginRequest) (*pro\n \t\t\t}\n \t\t}\n \n-\t\tauthInfo, err := oAuthFlow.RequestAuthInfo(context.TODO())\n+\t\tauthInfo, err := oAuthFlow.RequestAuthInfo(ctx)\n \t\tif err != nil {\n \t\t\tlog.Errorf(\"getting a request OAuth flow failed: %v\", err)\n \t\t\treturn nil, err\n@@ -1065,12 +1082,235 @@ func (s *Server) Status(\n \t\tfullStatus := s.statusRecorder.GetFullStatus()\n \t\tpbFullStatus := toProtoFullStatus(fullStatus)\n \t\tpbFullStatus.Events = s.statusRecorder.GetEventHistory()\n+\n+\t\tpbFullStatus.SshServerState = s.getSSHServerState()\n+\n \t\tstatusResponse.FullStatus = pbFullStatus\n \t}\n \n \treturn &statusResponse, nil\n }\n \n+// getSSHServerState retrieves the current SSH server state including enabled status and active sessions\n+func (s *Server) getSSHServerState() *proto.SSHServerState {\n+\ts.mutex.Lock()\n+\tconnectClient := s.connectClient\n+\ts.mutex.Unlock()\n+\n+\tif connectClient == nil {\n+\t\treturn nil\n+\t}\n+\n+\tengine := connectClient.Engine()\n+\tif engine == nil {\n+\t\treturn nil\n+\t}\n+\n+\tenabled, sessions := engine.GetSSHServerStatus()\n+\tsshServerState := &proto.SSHServerState{\n+\t\tEnabled: enabled,\n+\t}\n+\n+\tfor _, session := range sessions {\n+\t\tsshServerState.Sessions = append(sshServerState.Sessions, &proto.SSHSessionInfo{\n+\t\t\tUsername:      session.Username,\n+\t\t\tRemoteAddress: session.RemoteAddress,\n+\t\t\tCommand:       session.Command,\n+\t\t\tJwtUsername:   session.JWTUsername,\n+\t\t})\n+\t}\n+\n+\treturn sshServerState\n+}\n+\n+// GetPeerSSHHostKey retrieves SSH host key for a specific peer\n+func (s *Server) GetPeerSSHHostKey(\n+\tctx context.Context,\n+\treq *proto.GetPeerSSHHostKeyRequest,\n+) (*proto.GetPeerSSHHostKeyResponse, error) {\n+\tif ctx.Err() != nil {\n+\t\treturn nil, ctx.Err()\n+\t}\n+\n+\ts.mutex.Lock()\n+\tconnectClient := s.connectClient\n+\tstatusRecorder := s.statusRecorder\n+\ts.mutex.Unlock()\n+\n+\tif connectClient == nil {\n+\t\treturn nil, errors.New(\"client not initialized\")\n+\t}\n+\n+\tengine := connectClient.Engine()\n+\tif engine == nil {\n+\t\treturn nil, errors.New(\"engine not started\")\n+\t}\n+\n+\tpeerAddress := req.GetPeerAddress()\n+\thostKey, found := engine.GetPeerSSHKey(peerAddress)\n+\n+\tresponse := &proto.GetPeerSSHHostKeyResponse{\n+\t\tFound: found,\n+\t}\n+\n+\tif !found {\n+\t\treturn response, nil\n+\t}\n+\n+\tresponse.SshHostKey = hostKey\n+\n+\tif statusRecorder == nil {\n+\t\treturn response, nil\n+\t}\n+\n+\tfullStatus := statusRecorder.GetFullStatus()\n+\tfor _, peerState := range fullStatus.Peers {\n+\t\tif peerState.IP == peerAddress || peerState.FQDN == peerAddress {\n+\t\t\tresponse.PeerIP = peerState.IP\n+\t\t\tresponse.PeerFQDN = peerState.FQDN\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\treturn response, nil\n+}\n+\n+// getJWTCacheTTL returns the JWT cache TTL from config or default (disabled)\n+func (s *Server) getJWTCacheTTL() time.Duration {\n+\ts.mutex.Lock()\n+\tconfig := s.config\n+\ts.mutex.Unlock()\n+\n+\tif config == nil || config.SSHJWTCacheTTL == nil {\n+\t\treturn defaultJWTCacheTTL\n+\t}\n+\n+\tseconds := *config.SSHJWTCacheTTL\n+\tif seconds == 0 {\n+\t\tlog.Debug(\"SSH JWT cache disabled (configured to 0)\")\n+\t\treturn 0\n+\t}\n+\n+\tttl := time.Duration(seconds) * time.Second\n+\tlog.Debugf(\"SSH JWT cache TTL set to %v from config\", ttl)\n+\treturn ttl\n+}\n+\n+// RequestJWTAuth initiates JWT authentication flow for SSH\n+func (s *Server) RequestJWTAuth(\n+\tctx context.Context,\n+\tmsg *proto.RequestJWTAuthRequest,\n+) (*proto.RequestJWTAuthResponse, error) {\n+\tif ctx.Err() != nil {\n+\t\treturn nil, ctx.Err()\n+\t}\n+\n+\ts.mutex.Lock()\n+\tconfig := s.config\n+\ts.mutex.Unlock()\n+\n+\tif config == nil {\n+\t\treturn nil, gstatus.Errorf(codes.FailedPrecondition, \"client is not configured\")\n+\t}\n+\n+\tjwtCacheTTL := s.getJWTCacheTTL()\n+\tif jwtCacheTTL > 0 {\n+\t\tif cachedToken, found := s.jwtCache.get(); found {\n+\t\t\tlog.Debugf(\"JWT token found in cache, returning cached token for SSH authentication\")\n+\n+\t\t\treturn &proto.RequestJWTAuthResponse{\n+\t\t\t\tCachedToken: cachedToken,\n+\t\t\t\tMaxTokenAge: int64(jwtCacheTTL.Seconds()),\n+\t\t\t}, nil\n+\t\t}\n+\t}\n+\n+\thint := \"\"\n+\tif msg.Hint != nil {\n+\t\thint = *msg.Hint\n+\t}\n+\n+\tif hint == \"\" {\n+\t\thint = profilemanager.GetLoginHint()\n+\t}\n+\n+\tisDesktop := isUnixRunningDesktop()\n+\toAuthFlow, err := auth.NewOAuthFlow(ctx, config, isDesktop, hint)\n+\tif err != nil {\n+\t\treturn nil, gstatus.Errorf(codes.Internal, \"failed to create OAuth flow: %v\", err)\n+\t}\n+\n+\tauthInfo, err := oAuthFlow.RequestAuthInfo(ctx)\n+\tif err != nil {\n+\t\treturn nil, gstatus.Errorf(codes.Internal, \"failed to request auth info: %v\", err)\n+\t}\n+\n+\ts.mutex.Lock()\n+\ts.oauthAuthFlow.flow = oAuthFlow\n+\ts.oauthAuthFlow.info = authInfo\n+\ts.oauthAuthFlow.expiresAt = time.Now().Add(time.Duration(authInfo.ExpiresIn) * time.Second)\n+\ts.mutex.Unlock()\n+\n+\treturn &proto.RequestJWTAuthResponse{\n+\t\tVerificationURI:         authInfo.VerificationURI,\n+\t\tVerificationURIComplete: authInfo.VerificationURIComplete,\n+\t\tUserCode:                authInfo.UserCode,\n+\t\tDeviceCode:              authInfo.DeviceCode,\n+\t\tExpiresIn:               int64(authInfo.ExpiresIn),\n+\t\tMaxTokenAge:             int64(jwtCacheTTL.Seconds()),\n+\t}, nil\n+}\n+\n+// WaitJWTToken waits for JWT authentication completion\n+func (s *Server) WaitJWTToken(\n+\tctx context.Context,\n+\treq *proto.WaitJWTTokenRequest,\n+) (*proto.WaitJWTTokenResponse, error) {\n+\tif ctx.Err() != nil {\n+\t\treturn nil, ctx.Err()\n+\t}\n+\n+\ts.mutex.Lock()\n+\toAuthFlow := s.oauthAuthFlow.flow\n+\tauthInfo := s.oauthAuthFlow.info\n+\ts.mutex.Unlock()\n+\n+\tif oAuthFlow == nil || authInfo.DeviceCode != req.DeviceCode {\n+\t\treturn nil, gstatus.Errorf(codes.InvalidArgument, \"invalid device code or no active auth flow\")\n+\t}\n+\n+\ttokenInfo, err := oAuthFlow.WaitToken(ctx, authInfo)\n+\tif err != nil {\n+\t\treturn nil, gstatus.Errorf(codes.Internal, \"failed to get token: %v\", err)\n+\t}\n+\n+\ttoken := tokenInfo.GetTokenToUse()\n+\n+\tjwtCacheTTL := s.getJWTCacheTTL()\n+\tif jwtCacheTTL > 0 {\n+\t\ts.jwtCache.store(token, jwtCacheTTL)\n+\t\tlog.Debugf(\"JWT token cached for SSH authentication, TTL: %v\", jwtCacheTTL)\n+\t} else {\n+\t\tlog.Debug(\"JWT caching disabled, not storing token\")\n+\t}\n+\n+\ts.mutex.Lock()\n+\ts.oauthAuthFlow = oauthAuthFlow{}\n+\ts.mutex.Unlock()\n+\treturn &proto.WaitJWTTokenResponse{\n+\t\tToken:     tokenInfo.GetTokenToUse(),\n+\t\tTokenType: tokenInfo.TokenType,\n+\t\tExpiresIn: int64(tokenInfo.ExpiresIn),\n+\t}, nil\n+}\n+\n+func isUnixRunningDesktop() bool {\n+\tif runtime.GOOS != \"linux\" && runtime.GOOS != \"freebsd\" {\n+\t\treturn false\n+\t}\n+\treturn os.Getenv(\"DESKTOP_SESSION\") != \"\" || os.Getenv(\"XDG_CURRENT_DESKTOP\") != \"\"\n+}\n+\n func (s *Server) runProbes(waitForProbeResult bool) {\n \tif s.connectClient == nil {\n \t\treturn\n@@ -1136,25 +1376,61 @@ func (s *Server) GetConfig(ctx context.Context, req *proto.GetConfigRequest) (*p\n \tdisableServerRoutes := cfg.DisableServerRoutes\n \tblockLANAccess := cfg.BlockLANAccess\n \n+\tenableSSHRoot := false\n+\tif cfg.EnableSSHRoot != nil {\n+\t\tenableSSHRoot = *cfg.EnableSSHRoot\n+\t}\n+\n+\tenableSSHSFTP := false\n+\tif cfg.EnableSSHSFTP != nil {\n+\t\tenableSSHSFTP = *cfg.EnableSSHSFTP\n+\t}\n+\n+\tenableSSHLocalPortForwarding := false\n+\tif cfg.EnableSSHLocalPortForwarding != nil {\n+\t\tenableSSHLocalPortForwarding = *cfg.EnableSSHLocalPortForwarding\n+\t}\n+\n+\tenableSSHRemotePortForwarding := false\n+\tif cfg.EnableSSHRemotePortForwarding != nil {\n+\t\tenableSSHRemotePortForwarding = *cfg.EnableSSHRemotePortForwarding\n+\t}\n+\n+\tdisableSSHAuth := false\n+\tif cfg.DisableSSHAuth != nil {\n+\t\tdisableSSHAuth = *cfg.DisableSSHAuth\n+\t}\n+\n+\tsshJWTCacheTTL := int32(0)\n+\tif cfg.SSHJWTCacheTTL != nil {\n+\t\tsshJWTCacheTTL = int32(*cfg.SSHJWTCacheTTL)\n+\t}\n+\n \treturn &proto.GetConfigResponse{\n-\t\tManagementUrl:         managementURL.String(),\n-\t\tPreSharedKey:          preSharedKey,\n-\t\tAdminURL:              adminURL.String(),\n-\t\tInterfaceName:         cfg.WgIface,\n-\t\tWireguardPort:         int64(cfg.WgPort),\n-\t\tMtu:                   int64(cfg.MTU),\n-\t\tDisableAutoConnect:    cfg.DisableAutoConnect,\n-\t\tServerSSHAllowed:      *cfg.ServerSSHAllowed,\n-\t\tRosenpassEnabled:      cfg.RosenpassEnabled,\n-\t\tRosenpassPermissive:   cfg.RosenpassPermissive,\n-\t\tLazyConnectionEnabled: cfg.LazyConnectionEnabled,\n-\t\tBlockInbound:          cfg.BlockInbound,\n-\t\tDisableNotifications:  disableNotifications,\n-\t\tNetworkMonitor:        networkMonitor,\n-\t\tDisableDns:            disableDNS,\n-\t\tDisableClientRoutes:   disableClientRoutes,\n-\t\tDisableServerRoutes:   disableServerRoutes,\n-\t\tBlockLanAccess:        blockLANAccess,\n+\t\tManagementUrl:                 managementURL.String(),\n+\t\tPreSharedKey:                  preSharedKey,\n+\t\tAdminURL:                      adminURL.String(),\n+\t\tInterfaceName:                 cfg.WgIface,\n+\t\tWireguardPort:                 int64(cfg.WgPort),\n+\t\tMtu:                           int64(cfg.MTU),\n+\t\tDisableAutoConnect:            cfg.DisableAutoConnect,\n+\t\tServerSSHAllowed:              *cfg.ServerSSHAllowed,\n+\t\tRosenpassEnabled:              cfg.RosenpassEnabled,\n+\t\tRosenpassPermissive:           cfg.RosenpassPermissive,\n+\t\tLazyConnectionEnabled:         cfg.LazyConnectionEnabled,\n+\t\tBlockInbound:                  cfg.BlockInbound,\n+\t\tDisableNotifications:          disableNotifications,\n+\t\tNetworkMonitor:                networkMonitor,\n+\t\tDisableDns:                    disableDNS,\n+\t\tDisableClientRoutes:           disableClientRoutes,\n+\t\tDisableServerRoutes:           disableServerRoutes,\n+\t\tBlockLanAccess:                blockLANAccess,\n+\t\tEnableSSHRoot:                 enableSSHRoot,\n+\t\tEnableSSHSFTP:                 enableSSHSFTP,\n+\t\tEnableSSHLocalPortForwarding:  enableSSHLocalPortForwarding,\n+\t\tEnableSSHRemotePortForwarding: enableSSHRemotePortForwarding,\n+\t\tDisableSSHAuth:                disableSSHAuth,\n+\t\tSshJWTCacheTTL:                sshJWTCacheTTL,\n \t}, nil\n }\n \n@@ -1385,6 +1661,7 @@ func toProtoFullStatus(fullStatus peer.FullStatus) *proto.FullStatus {\n \t\t\tRosenpassEnabled:           peerState.RosenpassEnabled,\n \t\t\tNetworks:                   maps.Keys(peerState.GetRoutes()),\n \t\t\tLatency:                    durationpb.New(peerState.Latency),\n+\t\t\tSshHostKey:                 peerState.SSHHostKey,\n \t\t}\n \t\tpbFullStatus.Peers = append(pbFullStatus.Peers, pbPeerState)\n \t}\ndiff --git a/client/server/state_generic.go b/client/server/state_generic.go\nindex e6c7bdd44d7..980ba0cda42 100644\n--- a/client/server/state_generic.go\n+++ b/client/server/state_generic.go\n@@ -6,9 +6,11 @@ import (\n \t\"github.com/netbirdio/netbird/client/internal/dns\"\n \t\"github.com/netbirdio/netbird/client/internal/routemanager/systemops\"\n \t\"github.com/netbirdio/netbird/client/internal/statemanager\"\n+\t\"github.com/netbirdio/netbird/client/ssh/config\"\n )\n \n func registerStates(mgr *statemanager.Manager) {\n \tmgr.RegisterState(&dns.ShutdownState{})\n \tmgr.RegisterState(&systemops.ShutdownState{})\n+\tmgr.RegisterState(&config.ShutdownState{})\n }\ndiff --git a/client/server/state_linux.go b/client/server/state_linux.go\nindex 08762890719..019477d8eae 100644\n--- a/client/server/state_linux.go\n+++ b/client/server/state_linux.go\n@@ -8,6 +8,7 @@ import (\n \t\"github.com/netbirdio/netbird/client/internal/dns\"\n \t\"github.com/netbirdio/netbird/client/internal/routemanager/systemops\"\n \t\"github.com/netbirdio/netbird/client/internal/statemanager\"\n+\t\"github.com/netbirdio/netbird/client/ssh/config\"\n )\n \n func registerStates(mgr *statemanager.Manager) {\n@@ -15,4 +16,5 @@ func registerStates(mgr *statemanager.Manager) {\n \tmgr.RegisterState(&systemops.ShutdownState{})\n \tmgr.RegisterState(&nftables.ShutdownState{})\n \tmgr.RegisterState(&iptables.ShutdownState{})\n+\tmgr.RegisterState(&config.ShutdownState{})\n }\ndiff --git a/client/ssh/client.go b/client/ssh/client.go\ndeleted file mode 100644\nindex afba347f809..00000000000\n--- a/client/ssh/client.go\n+++ /dev/null\n@@ -1,118 +0,0 @@\n-//go:build !js\n-\n-package ssh\n-\n-import (\n-\t\"fmt\"\n-\t\"net\"\n-\t\"os\"\n-\t\"time\"\n-\n-\t\"golang.org/x/crypto/ssh\"\n-\t\"golang.org/x/term\"\n-)\n-\n-// Client wraps crypto/ssh Client to simplify usage\n-type Client struct {\n-\tclient *ssh.Client\n-}\n-\n-// Close closes the wrapped SSH Client\n-func (c *Client) Close() error {\n-\treturn c.client.Close()\n-}\n-\n-// OpenTerminal starts an interactive terminal session with the remote SSH server\n-func (c *Client) OpenTerminal() error {\n-\tsession, err := c.client.NewSession()\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"failed to open new session: %v\", err)\n-\t}\n-\tdefer func() {\n-\t\terr := session.Close()\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t}()\n-\n-\tfd := int(os.Stdout.Fd())\n-\tstate, err := term.MakeRaw(fd)\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"failed to run raw terminal: %s\", err)\n-\t}\n-\tdefer func() {\n-\t\terr := term.Restore(fd, state)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t}()\n-\n-\tw, h, err := term.GetSize(fd)\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"terminal get size: %s\", err)\n-\t}\n-\n-\tmodes := ssh.TerminalModes{\n-\t\tssh.ECHO:          1,\n-\t\tssh.TTY_OP_ISPEED: 14400,\n-\t\tssh.TTY_OP_OSPEED: 14400,\n-\t}\n-\n-\tterminal := os.Getenv(\"TERM\")\n-\tif terminal == \"\" {\n-\t\tterminal = \"xterm-256color\"\n-\t}\n-\tif err := session.RequestPty(terminal, h, w, modes); err != nil {\n-\t\treturn fmt.Errorf(\"failed requesting pty session with xterm: %s\", err)\n-\t}\n-\n-\tsession.Stdout = os.Stdout\n-\tsession.Stderr = os.Stderr\n-\tsession.Stdin = os.Stdin\n-\n-\tif err := session.Shell(); err != nil {\n-\t\treturn fmt.Errorf(\"failed to start login shell on the remote host: %s\", err)\n-\t}\n-\n-\tif err := session.Wait(); err != nil {\n-\t\tif e, ok := err.(*ssh.ExitError); ok {\n-\t\t\tif e.ExitStatus() == 130 {\n-\t\t\t\treturn nil\n-\t\t\t}\n-\t\t}\n-\t\treturn fmt.Errorf(\"failed running SSH session: %s\", err)\n-\t}\n-\n-\treturn nil\n-}\n-\n-// DialWithKey connects to the remote SSH server with a provided private key file (PEM).\n-func DialWithKey(addr, user string, privateKey []byte) (*Client, error) {\n-\n-\tsigner, err := ssh.ParsePrivateKey(privateKey)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tconfig := &ssh.ClientConfig{\n-\t\tUser:    user,\n-\t\tTimeout: 5 * time.Second,\n-\t\tAuth: []ssh.AuthMethod{\n-\t\t\tssh.PublicKeys(signer),\n-\t\t},\n-\t\tHostKeyCallback: ssh.HostKeyCallback(func(hostname string, remote net.Addr, key ssh.PublicKey) error { return nil }),\n-\t}\n-\n-\treturn Dial(\"tcp\", addr, config)\n-}\n-\n-// Dial connects to the remote SSH server.\n-func Dial(network, addr string, config *ssh.ClientConfig) (*Client, error) {\n-\tclient, err := ssh.Dial(network, addr, config)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn &Client{\n-\t\tclient: client,\n-\t}, nil\n-}\ndiff --git a/client/ssh/client/client.go b/client/ssh/client/client.go\nnew file mode 100644\nindex 00000000000..8820563746b\n--- /dev/null\n+++ b/client/ssh/client/client.go\n@@ -0,0 +1,699 @@\n+package client\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"golang.org/x/crypto/ssh\"\n+\t\"golang.org/x/crypto/ssh/knownhosts\"\n+\t\"golang.org/x/term\"\n+\t\"google.golang.org/grpc\"\n+\t\"google.golang.org/grpc/credentials/insecure\"\n+\n+\t\"github.com/netbirdio/netbird/client/internal/profilemanager\"\n+\t\"github.com/netbirdio/netbird/client/proto\"\n+\tnbssh \"github.com/netbirdio/netbird/client/ssh\"\n+\t\"github.com/netbirdio/netbird/client/ssh/detection\"\n+)\n+\n+const (\n+\t// DefaultDaemonAddr is the default address for the NetBird daemon\n+\tDefaultDaemonAddr = \"unix:///var/run/netbird.sock\"\n+\t// DefaultDaemonAddrWindows is the default address for the NetBird daemon on Windows\n+\tDefaultDaemonAddrWindows = \"tcp://127.0.0.1:41731\"\n+)\n+\n+// Client wraps crypto/ssh Client for simplified SSH operations\n+type Client struct {\n+\tclient        *ssh.Client\n+\tterminalState *term.State\n+\tterminalFd    int\n+\n+\twindowsStdoutMode uint32 // nolint:unused\n+\twindowsStdinMode  uint32 // nolint:unused\n+}\n+\n+func (c *Client) Close() error {\n+\treturn c.client.Close()\n+}\n+\n+func (c *Client) OpenTerminal(ctx context.Context) error {\n+\tsession, err := c.client.NewSession()\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"new session: %w\", err)\n+\t}\n+\tdefer func() {\n+\t\tif err := session.Close(); err != nil {\n+\t\t\tlog.Debugf(\"session close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tif err := c.setupTerminalMode(ctx, session); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tc.setupSessionIO(session)\n+\n+\tif err := session.Shell(); err != nil {\n+\t\treturn fmt.Errorf(\"start shell: %w\", err)\n+\t}\n+\n+\treturn c.waitForSession(ctx, session)\n+}\n+\n+// setupSessionIO connects session streams to local terminal\n+func (c *Client) setupSessionIO(session *ssh.Session) {\n+\tsession.Stdout = os.Stdout\n+\tsession.Stderr = os.Stderr\n+\tsession.Stdin = os.Stdin\n+}\n+\n+// waitForSession waits for the session to complete with context cancellation\n+func (c *Client) waitForSession(ctx context.Context, session *ssh.Session) error {\n+\tdone := make(chan error, 1)\n+\tgo func() {\n+\t\tdone <- session.Wait()\n+\t}()\n+\n+\tdefer c.restoreTerminal()\n+\n+\tselect {\n+\tcase <-ctx.Done():\n+\t\treturn ctx.Err()\n+\tcase err := <-done:\n+\t\treturn c.handleSessionError(err)\n+\t}\n+}\n+\n+// handleSessionError processes session termination errors\n+func (c *Client) handleSessionError(err error) error {\n+\tif err == nil {\n+\t\treturn nil\n+\t}\n+\n+\tvar e *ssh.ExitError\n+\tvar em *ssh.ExitMissingError\n+\tif !errors.As(err, &e) && !errors.As(err, &em) {\n+\t\treturn fmt.Errorf(\"session wait: %w\", err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// restoreTerminal restores the terminal to its original state\n+func (c *Client) restoreTerminal() {\n+\tif c.terminalState != nil {\n+\t\t_ = term.Restore(c.terminalFd, c.terminalState)\n+\t\tc.terminalState = nil\n+\t\tc.terminalFd = 0\n+\t}\n+\n+\tif err := c.restoreWindowsConsoleState(); err != nil {\n+\t\tlog.Debugf(\"restore Windows console state: %v\", err)\n+\t}\n+}\n+\n+// ExecuteCommand executes a command on the remote host and returns the output\n+func (c *Client) ExecuteCommand(ctx context.Context, command string) ([]byte, error) {\n+\tsession, cleanup, err := c.createSession(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer cleanup()\n+\n+\toutput, err := session.CombinedOutput(command)\n+\tif err != nil {\n+\t\tvar e *ssh.ExitError\n+\t\tvar em *ssh.ExitMissingError\n+\t\tif !errors.As(err, &e) && !errors.As(err, &em) {\n+\t\t\treturn output, fmt.Errorf(\"execute command: %w\", err)\n+\t\t}\n+\t}\n+\n+\treturn output, nil\n+}\n+\n+// ExecuteCommandWithIO executes a command with interactive I/O connected to local terminal\n+func (c *Client) ExecuteCommandWithIO(ctx context.Context, command string) error {\n+\tsession, cleanup, err := c.createSession(ctx)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"create session: %w\", err)\n+\t}\n+\tdefer cleanup()\n+\n+\tc.setupSessionIO(session)\n+\n+\tif err := session.Start(command); err != nil {\n+\t\treturn fmt.Errorf(\"start command: %w\", err)\n+\t}\n+\n+\tdone := make(chan error, 1)\n+\tgo func() {\n+\t\tdone <- session.Wait()\n+\t}()\n+\n+\tselect {\n+\tcase <-ctx.Done():\n+\t\t_ = session.Signal(ssh.SIGTERM)\n+\t\tselect {\n+\t\tcase <-done:\n+\t\t\treturn ctx.Err()\n+\t\tcase <-time.After(100 * time.Millisecond):\n+\t\t\treturn ctx.Err()\n+\t\t}\n+\tcase err := <-done:\n+\t\treturn c.handleCommandError(err)\n+\t}\n+}\n+\n+// ExecuteCommandWithPTY executes a command with a pseudo-terminal for interactive sessions\n+func (c *Client) ExecuteCommandWithPTY(ctx context.Context, command string) error {\n+\tsession, cleanup, err := c.createSession(ctx)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"create session: %w\", err)\n+\t}\n+\tdefer cleanup()\n+\n+\tif err := c.setupTerminalMode(ctx, session); err != nil {\n+\t\treturn fmt.Errorf(\"setup terminal mode: %w\", err)\n+\t}\n+\n+\tc.setupSessionIO(session)\n+\n+\tif err := session.Start(command); err != nil {\n+\t\treturn fmt.Errorf(\"start command: %w\", err)\n+\t}\n+\n+\tdefer c.restoreTerminal()\n+\n+\tdone := make(chan error, 1)\n+\tgo func() {\n+\t\tdone <- session.Wait()\n+\t}()\n+\n+\tselect {\n+\tcase <-ctx.Done():\n+\t\t_ = session.Signal(ssh.SIGTERM)\n+\t\tselect {\n+\t\tcase <-done:\n+\t\t\treturn ctx.Err()\n+\t\tcase <-time.After(100 * time.Millisecond):\n+\t\t\treturn ctx.Err()\n+\t\t}\n+\tcase err := <-done:\n+\t\treturn c.handleCommandError(err)\n+\t}\n+}\n+\n+// handleCommandError processes command execution errors\n+func (c *Client) handleCommandError(err error) error {\n+\tif err == nil {\n+\t\treturn nil\n+\t}\n+\n+\tvar e *ssh.ExitError\n+\tvar em *ssh.ExitMissingError\n+\tif errors.As(err, &e) || errors.As(err, &em) {\n+\t\treturn err\n+\t}\n+\n+\treturn fmt.Errorf(\"execute command: %w\", err)\n+}\n+\n+// setupContextCancellation sets up context cancellation for a session\n+func (c *Client) setupContextCancellation(ctx context.Context, session *ssh.Session) func() {\n+\tdone := make(chan struct{})\n+\tgo func() {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\t\t_ = session.Signal(ssh.SIGTERM)\n+\t\t\t_ = session.Close()\n+\t\tcase <-done:\n+\t\t}\n+\t}()\n+\treturn func() { close(done) }\n+}\n+\n+// createSession creates a new SSH session with context cancellation setup\n+func (c *Client) createSession(ctx context.Context) (*ssh.Session, func(), error) {\n+\tsession, err := c.client.NewSession()\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"new session: %w\", err)\n+\t}\n+\n+\tcancel := c.setupContextCancellation(ctx, session)\n+\tcleanup := func() {\n+\t\tcancel()\n+\t\t_ = session.Close()\n+\t}\n+\n+\treturn session, cleanup, nil\n+}\n+\n+// getDefaultDaemonAddr returns the daemon address from environment or default for the OS\n+func getDefaultDaemonAddr() string {\n+\tif addr := os.Getenv(\"NB_DAEMON_ADDR\"); addr != \"\" {\n+\t\treturn addr\n+\t}\n+\tif runtime.GOOS == \"windows\" {\n+\t\treturn DefaultDaemonAddrWindows\n+\t}\n+\treturn DefaultDaemonAddr\n+}\n+\n+// DialOptions contains options for SSH connections\n+type DialOptions struct {\n+\tKnownHostsFile     string\n+\tIdentityFile       string\n+\tDaemonAddr         string\n+\tSkipCachedToken    bool\n+\tInsecureSkipVerify bool\n+}\n+\n+// Dial connects to the given ssh server with specified options\n+func Dial(ctx context.Context, addr, user string, opts DialOptions) (*Client, error) {\n+\tdaemonAddr := opts.DaemonAddr\n+\tif daemonAddr == \"\" {\n+\t\tdaemonAddr = getDefaultDaemonAddr()\n+\t}\n+\topts.DaemonAddr = daemonAddr\n+\n+\thostKeyCallback, err := createHostKeyCallback(opts)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"create host key callback: %w\", err)\n+\t}\n+\n+\tconfig := &ssh.ClientConfig{\n+\t\tUser:            user,\n+\t\tTimeout:         30 * time.Second,\n+\t\tHostKeyCallback: hostKeyCallback,\n+\t}\n+\n+\tif opts.IdentityFile != \"\" {\n+\t\tauthMethod, err := createSSHKeyAuth(opts.IdentityFile)\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"create SSH key auth: %w\", err)\n+\t\t}\n+\t\tconfig.Auth = append(config.Auth, authMethod)\n+\t}\n+\n+\treturn dialWithJWT(ctx, \"tcp\", addr, config, daemonAddr, opts.SkipCachedToken)\n+}\n+\n+// dialSSH establishes an SSH connection without JWT authentication\n+func dialSSH(ctx context.Context, network, addr string, config *ssh.ClientConfig) (*Client, error) {\n+\tdialer := &net.Dialer{}\n+\tconn, err := dialer.DialContext(ctx, network, addr)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"dial %s: %w\", addr, err)\n+\t}\n+\n+\tclientConn, chans, reqs, err := ssh.NewClientConn(conn, addr, config)\n+\tif err != nil {\n+\t\tif closeErr := conn.Close(); closeErr != nil {\n+\t\t\tlog.Debugf(\"connection close after handshake failure: %v\", closeErr)\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"ssh handshake: %w\", err)\n+\t}\n+\n+\tclient := ssh.NewClient(clientConn, chans, reqs)\n+\treturn &Client{\n+\t\tclient: client,\n+\t}, nil\n+}\n+\n+// dialWithJWT establishes an SSH connection with optional JWT authentication based on server detection\n+func dialWithJWT(ctx context.Context, network, addr string, config *ssh.ClientConfig, daemonAddr string, skipCache bool) (*Client, error) {\n+\thost, portStr, err := net.SplitHostPort(addr)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"parse address %s: %w\", addr, err)\n+\t}\n+\tport, err := strconv.Atoi(portStr)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"parse port %s: %w\", portStr, err)\n+\t}\n+\n+\tdialer := &net.Dialer{Timeout: detection.Timeout}\n+\tserverType, err := detection.DetectSSHServerType(ctx, dialer, host, port)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"SSH server detection failed: %w\", err)\n+\t}\n+\n+\tif !serverType.RequiresJWT() {\n+\t\treturn dialSSH(ctx, network, addr, config)\n+\t}\n+\n+\tjwtCtx, cancel := context.WithTimeout(ctx, config.Timeout)\n+\tdefer cancel()\n+\n+\tjwtToken, err := requestJWTToken(jwtCtx, daemonAddr, skipCache)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"request JWT token: %w\", err)\n+\t}\n+\n+\tconfigWithJWT := nbssh.AddJWTAuth(config, jwtToken)\n+\treturn dialSSH(ctx, network, addr, configWithJWT)\n+}\n+\n+// requestJWTToken requests a JWT token from the NetBird daemon\n+func requestJWTToken(ctx context.Context, daemonAddr string, skipCache bool) (string, error) {\n+\thint := profilemanager.GetLoginHint()\n+\n+\tconn, err := connectToDaemon(daemonAddr)\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"connect to daemon: %w\", err)\n+\t}\n+\tdefer conn.Close()\n+\n+\tclient := proto.NewDaemonServiceClient(conn)\n+\treturn nbssh.RequestJWTToken(ctx, client, os.Stdout, os.Stderr, !skipCache, hint)\n+}\n+\n+// verifyHostKeyViaDaemon verifies SSH host key by querying the NetBird daemon\n+func verifyHostKeyViaDaemon(hostname string, remote net.Addr, key ssh.PublicKey, daemonAddr string) error {\n+\tconn, err := connectToDaemon(daemonAddr)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer func() {\n+\t\tif err := conn.Close(); err != nil {\n+\t\t\tlog.Debugf(\"daemon connection close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tclient := proto.NewDaemonServiceClient(conn)\n+\tverifier := nbssh.NewDaemonHostKeyVerifier(client)\n+\tcallback := nbssh.CreateHostKeyCallback(verifier)\n+\treturn callback(hostname, remote, key)\n+}\n+\n+func connectToDaemon(daemonAddr string) (*grpc.ClientConn, error) {\n+\taddr := strings.TrimPrefix(daemonAddr, \"tcp://\")\n+\n+\tconn, err := grpc.NewClient(\n+\t\taddr,\n+\t\tgrpc.WithTransportCredentials(insecure.NewCredentials()),\n+\t)\n+\tif err != nil {\n+\t\tlog.Debugf(\"failed to create gRPC client for NetBird daemon at %s: %v\", daemonAddr, err)\n+\t\treturn nil, fmt.Errorf(\"failed to connect to NetBird daemon: %w\", err)\n+\t}\n+\n+\treturn conn, nil\n+}\n+\n+// getKnownHostsFiles returns paths to known_hosts files in order of preference\n+func getKnownHostsFiles() []string {\n+\tvar files []string\n+\n+\t// User's known_hosts file (highest priority)\n+\tif homeDir, err := os.UserHomeDir(); err == nil {\n+\t\tuserKnownHosts := filepath.Join(homeDir, \".ssh\", \"known_hosts\")\n+\t\tfiles = append(files, userKnownHosts)\n+\t}\n+\n+\t// NetBird managed known_hosts files\n+\tif runtime.GOOS == \"windows\" {\n+\t\tprogramData := os.Getenv(\"PROGRAMDATA\")\n+\t\tif programData == \"\" {\n+\t\t\tprogramData = `C:\\ProgramData`\n+\t\t}\n+\t\tnetbirdKnownHosts := filepath.Join(programData, \"ssh\", \"ssh_known_hosts.d\", \"99-netbird\")\n+\t\tfiles = append(files, netbirdKnownHosts)\n+\t} else {\n+\t\tfiles = append(files, \"/etc/ssh/ssh_known_hosts.d/99-netbird\")\n+\t\tfiles = append(files, \"/etc/ssh/ssh_known_hosts\")\n+\t}\n+\n+\treturn files\n+}\n+\n+// createHostKeyCallback creates a host key verification callback\n+func createHostKeyCallback(opts DialOptions) (ssh.HostKeyCallback, error) {\n+\tif opts.InsecureSkipVerify {\n+\t\treturn ssh.InsecureIgnoreHostKey(), nil // #nosec G106 - User explicitly requested insecure mode\n+\t}\n+\n+\treturn func(hostname string, remote net.Addr, key ssh.PublicKey) error {\n+\t\tif err := tryDaemonVerification(hostname, remote, key, opts.DaemonAddr); err == nil {\n+\t\t\treturn nil\n+\t\t}\n+\t\treturn tryKnownHostsVerification(hostname, remote, key, opts.KnownHostsFile)\n+\t}, nil\n+}\n+\n+func tryDaemonVerification(hostname string, remote net.Addr, key ssh.PublicKey, daemonAddr string) error {\n+\tif daemonAddr == \"\" {\n+\t\treturn fmt.Errorf(\"no daemon address\")\n+\t}\n+\treturn verifyHostKeyViaDaemon(hostname, remote, key, daemonAddr)\n+}\n+\n+func tryKnownHostsVerification(hostname string, remote net.Addr, key ssh.PublicKey, knownHostsFile string) error {\n+\tknownHostsFiles := getKnownHostsFilesList(knownHostsFile)\n+\thostKeyCallbacks := buildHostKeyCallbacks(knownHostsFiles)\n+\n+\tfor _, callback := range hostKeyCallbacks {\n+\t\tif err := callback(hostname, remote, key); err == nil {\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\treturn fmt.Errorf(\"host key verification failed: key for %s not found in any known_hosts file\", hostname)\n+}\n+\n+func getKnownHostsFilesList(knownHostsFile string) []string {\n+\tif knownHostsFile != \"\" {\n+\t\treturn []string{knownHostsFile}\n+\t}\n+\treturn getKnownHostsFiles()\n+}\n+\n+func buildHostKeyCallbacks(knownHostsFiles []string) []ssh.HostKeyCallback {\n+\tvar hostKeyCallbacks []ssh.HostKeyCallback\n+\tfor _, file := range knownHostsFiles {\n+\t\tif callback, err := knownhosts.New(file); err == nil {\n+\t\t\thostKeyCallbacks = append(hostKeyCallbacks, callback)\n+\t\t}\n+\t}\n+\treturn hostKeyCallbacks\n+}\n+\n+// createSSHKeyAuth creates SSH key authentication from a private key file\n+func createSSHKeyAuth(keyFile string) (ssh.AuthMethod, error) {\n+\tkeyData, err := os.ReadFile(keyFile)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"read SSH key file %s: %w\", keyFile, err)\n+\t}\n+\n+\tsigner, err := ssh.ParsePrivateKey(keyData)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"parse SSH private key: %w\", err)\n+\t}\n+\n+\treturn ssh.PublicKeys(signer), nil\n+}\n+\n+// LocalPortForward sets up local port forwarding, binding to localAddr and forwarding to remoteAddr\n+func (c *Client) LocalPortForward(ctx context.Context, localAddr, remoteAddr string) error {\n+\tlocalListener, err := net.Listen(\"tcp\", localAddr)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"listen on %s: %w\", localAddr, err)\n+\t}\n+\n+\tgo func() {\n+\t\tdefer func() {\n+\t\t\tif err := localListener.Close(); err != nil && !errors.Is(err, net.ErrClosed) {\n+\t\t\t\tlog.Debugf(\"local listener close error: %v\", err)\n+\t\t\t}\n+\t\t}()\n+\t\tfor {\n+\t\t\tlocalConn, err := localListener.Accept()\n+\t\t\tif err != nil {\n+\t\t\t\tif ctx.Err() != nil {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tgo c.handleLocalForward(localConn, remoteAddr)\n+\t\t}\n+\t}()\n+\n+\t<-ctx.Done()\n+\tif err := localListener.Close(); err != nil && !errors.Is(err, net.ErrClosed) {\n+\t\tlog.Debugf(\"local listener close error: %v\", err)\n+\t}\n+\treturn ctx.Err()\n+}\n+\n+// handleLocalForward handles a single local port forwarding connection\n+func (c *Client) handleLocalForward(localConn net.Conn, remoteAddr string) {\n+\tdefer func() {\n+\t\tif err := localConn.Close(); err != nil {\n+\t\t\tlog.Debugf(\"local connection close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tchannel, err := c.client.Dial(\"tcp\", remoteAddr)\n+\tif err != nil {\n+\t\tif strings.Contains(err.Error(), \"administratively prohibited\") {\n+\t\t\t_, _ = fmt.Fprintf(os.Stderr, \"channel open failed: administratively prohibited: port forwarding is disabled\\n\")\n+\t\t} else {\n+\t\t\tlog.Debugf(\"local port forwarding to %s failed: %v\", remoteAddr, err)\n+\t\t}\n+\t\treturn\n+\t}\n+\tdefer func() {\n+\t\tif err := channel.Close(); err != nil {\n+\t\t\tlog.Debugf(\"remote channel close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tgo func() {\n+\t\tif _, err := io.Copy(channel, localConn); err != nil {\n+\t\t\tlog.Debugf(\"local forward copy error (local->remote): %v\", err)\n+\t\t}\n+\t}()\n+\n+\tif _, err := io.Copy(localConn, channel); err != nil {\n+\t\tlog.Debugf(\"local forward copy error (remote->local): %v\", err)\n+\t}\n+}\n+\n+// RemotePortForward sets up remote port forwarding, binding on remote and forwarding to localAddr\n+func (c *Client) RemotePortForward(ctx context.Context, remoteAddr, localAddr string) error {\n+\thost, port, err := c.parseRemoteAddress(remoteAddr)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"parse remote address: %w\", err)\n+\t}\n+\n+\treq := c.buildTCPIPForwardRequest(host, port)\n+\tif err := c.sendTCPIPForwardRequest(req); err != nil {\n+\t\treturn fmt.Errorf(\"setup remote forward: %w\", err)\n+\t}\n+\n+\tgo c.handleRemoteForwardChannels(ctx, localAddr)\n+\n+\t<-ctx.Done()\n+\n+\tif err := c.cancelTCPIPForwardRequest(req); err != nil {\n+\t\treturn fmt.Errorf(\"cancel tcpip-forward: %w\", err)\n+\t}\n+\treturn ctx.Err()\n+}\n+\n+// parseRemoteAddress parses host and port from remote address string\n+func (c *Client) parseRemoteAddress(remoteAddr string) (string, uint32, error) {\n+\thost, portStr, err := net.SplitHostPort(remoteAddr)\n+\tif err != nil {\n+\t\treturn \"\", 0, fmt.Errorf(\"parse remote address %s: %w\", remoteAddr, err)\n+\t}\n+\n+\tport, err := strconv.Atoi(portStr)\n+\tif err != nil {\n+\t\treturn \"\", 0, fmt.Errorf(\"parse remote port %s: %w\", portStr, err)\n+\t}\n+\n+\treturn host, uint32(port), nil\n+}\n+\n+// buildTCPIPForwardRequest creates a tcpip-forward request message\n+func (c *Client) buildTCPIPForwardRequest(host string, port uint32) tcpipForwardMsg {\n+\treturn tcpipForwardMsg{\n+\t\tHost: host,\n+\t\tPort: port,\n+\t}\n+}\n+\n+// sendTCPIPForwardRequest sends the tcpip-forward request to establish remote port forwarding\n+func (c *Client) sendTCPIPForwardRequest(req tcpipForwardMsg) error {\n+\tok, _, err := c.client.SendRequest(\"tcpip-forward\", true, ssh.Marshal(&req))\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"send tcpip-forward request: %w\", err)\n+\t}\n+\tif !ok {\n+\t\treturn fmt.Errorf(\"remote port forwarding denied by server (check if --allow-ssh-remote-port-forwarding is enabled)\")\n+\t}\n+\treturn nil\n+}\n+\n+// cancelTCPIPForwardRequest cancels the tcpip-forward request\n+func (c *Client) cancelTCPIPForwardRequest(req tcpipForwardMsg) error {\n+\t_, _, err := c.client.SendRequest(\"cancel-tcpip-forward\", true, ssh.Marshal(&req))\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"send cancel-tcpip-forward request: %w\", err)\n+\t}\n+\treturn nil\n+}\n+\n+// handleRemoteForwardChannels handles incoming forwarded-tcpip channels\n+func (c *Client) handleRemoteForwardChannels(ctx context.Context, localAddr string) {\n+\t// Get the channel once - subsequent calls return nil!\n+\tchannelRequests := c.client.HandleChannelOpen(\"forwarded-tcpip\")\n+\tif channelRequests == nil {\n+\t\tlog.Debugf(\"forwarded-tcpip channel type already being handled\")\n+\t\treturn\n+\t}\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\t\treturn\n+\t\tcase newChan := <-channelRequests:\n+\t\t\tif newChan != nil {\n+\t\t\t\tgo c.handleRemoteForwardChannel(newChan, localAddr)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// handleRemoteForwardChannel handles a single forwarded-tcpip channel\n+func (c *Client) handleRemoteForwardChannel(newChan ssh.NewChannel, localAddr string) {\n+\tchannel, reqs, err := newChan.Accept()\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tdefer func() {\n+\t\tif err := channel.Close(); err != nil {\n+\t\t\tlog.Debugf(\"remote channel close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tgo ssh.DiscardRequests(reqs)\n+\n+\tlocalConn, err := net.Dial(\"tcp\", localAddr)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tdefer func() {\n+\t\tif err := localConn.Close(); err != nil {\n+\t\t\tlog.Debugf(\"local connection close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tgo func() {\n+\t\tif _, err := io.Copy(localConn, channel); err != nil {\n+\t\t\tlog.Debugf(\"remote forward copy error (remote->local): %v\", err)\n+\t\t}\n+\t}()\n+\n+\tif _, err := io.Copy(channel, localConn); err != nil {\n+\t\tlog.Debugf(\"remote forward copy error (local->remote): %v\", err)\n+\t}\n+}\n+\n+// tcpipForwardMsg represents the structure for tcpip-forward requests\n+type tcpipForwardMsg struct {\n+\tHost string\n+\tPort uint32\n+}\ndiff --git a/client/ssh/client/terminal_unix.go b/client/ssh/client/terminal_unix.go\nnew file mode 100644\nindex 00000000000..aaa3418f96e\n--- /dev/null\n+++ b/client/ssh/client/terminal_unix.go\n@@ -0,0 +1,127 @@\n+//go:build !windows\n+\n+package client\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"os/signal\"\n+\t\"syscall\"\n+\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"golang.org/x/crypto/ssh\"\n+\t\"golang.org/x/term\"\n+)\n+\n+func (c *Client) setupTerminalMode(ctx context.Context, session *ssh.Session) error {\n+\tstdinFd := int(os.Stdin.Fd())\n+\n+\tif !term.IsTerminal(stdinFd) {\n+\t\treturn c.setupNonTerminalMode(ctx, session)\n+\t}\n+\n+\tfd := int(os.Stdin.Fd())\n+\n+\tstate, err := term.MakeRaw(fd)\n+\tif err != nil {\n+\t\treturn c.setupNonTerminalMode(ctx, session)\n+\t}\n+\n+\tif err := c.setupTerminal(session, fd); err != nil {\n+\t\tif restoreErr := term.Restore(fd, state); restoreErr != nil {\n+\t\t\tlog.Debugf(\"restore terminal state: %v\", restoreErr)\n+\t\t}\n+\t\treturn err\n+\t}\n+\n+\tc.terminalState = state\n+\tc.terminalFd = fd\n+\n+\tsigChan := make(chan os.Signal, 1)\n+\tsignal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)\n+\n+\tgo func() {\n+\t\tdefer signal.Stop(sigChan)\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\t\tif err := term.Restore(fd, state); err != nil {\n+\t\t\t\tlog.Debugf(\"restore terminal state: %v\", err)\n+\t\t\t}\n+\t\tcase sig := <-sigChan:\n+\t\t\tif err := term.Restore(fd, state); err != nil {\n+\t\t\t\tlog.Debugf(\"restore terminal state: %v\", err)\n+\t\t\t}\n+\t\t\tsignal.Reset(sig)\n+\t\t\ts, ok := sig.(syscall.Signal)\n+\t\t\tif !ok {\n+\t\t\t\tlog.Debugf(\"signal %v is not a syscall.Signal: %T\", sig, sig)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif err := syscall.Kill(syscall.Getpid(), s); err != nil {\n+\t\t\t\tlog.Debugf(\"kill process with signal %v: %v\", s, err)\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n+\treturn nil\n+}\n+\n+func (c *Client) setupNonTerminalMode(_ context.Context, session *ssh.Session) error {\n+\treturn nil\n+}\n+\n+// restoreWindowsConsoleState is a no-op on Unix systems\n+func (c *Client) restoreWindowsConsoleState() error {\n+\treturn nil\n+}\n+\n+func (c *Client) setupTerminal(session *ssh.Session, fd int) error {\n+\tw, h, err := term.GetSize(fd)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"get terminal size: %w\", err)\n+\t}\n+\n+\tmodes := ssh.TerminalModes{\n+\t\tssh.ECHO:          1,\n+\t\tssh.TTY_OP_ISPEED: 14400,\n+\t\tssh.TTY_OP_OSPEED: 14400,\n+\t\t// Ctrl+C\n+\t\tssh.VINTR: 3,\n+\t\t// Ctrl+\\\n+\t\tssh.VQUIT: 28,\n+\t\t// Backspace\n+\t\tssh.VERASE: 127,\n+\t\t// Ctrl+U\n+\t\tssh.VKILL: 21,\n+\t\t// Ctrl+D\n+\t\tssh.VEOF:  4,\n+\t\tssh.VEOL:  0,\n+\t\tssh.VEOL2: 0,\n+\t\t// Ctrl+Q\n+\t\tssh.VSTART: 17,\n+\t\t// Ctrl+S\n+\t\tssh.VSTOP: 19,\n+\t\t// Ctrl+Z\n+\t\tssh.VSUSP: 26,\n+\t\t// Ctrl+O\n+\t\tssh.VDISCARD: 15,\n+\t\t// Ctrl+R\n+\t\tssh.VREPRINT: 18,\n+\t\t// Ctrl+W\n+\t\tssh.VWERASE: 23,\n+\t\t// Ctrl+V\n+\t\tssh.VLNEXT: 22,\n+\t}\n+\n+\tterminal := os.Getenv(\"TERM\")\n+\tif terminal == \"\" {\n+\t\tterminal = \"xterm-256color\"\n+\t}\n+\n+\tif err := session.RequestPty(terminal, h, w, modes); err != nil {\n+\t\treturn fmt.Errorf(\"request pty: %w\", err)\n+\t}\n+\n+\treturn nil\n+}\ndiff --git a/client/ssh/client/terminal_windows.go b/client/ssh/client/terminal_windows.go\nnew file mode 100644\nindex 00000000000..462438317e4\n--- /dev/null\n+++ b/client/ssh/client/terminal_windows.go\n@@ -0,0 +1,265 @@\n+package client\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"syscall\"\n+\t\"unsafe\"\n+\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"golang.org/x/crypto/ssh\"\n+)\n+\n+const (\n+\tenableProcessedInput            = 0x0001\n+\tenableLineInput                 = 0x0002\n+\tenableEchoInput                 = 0x0004 // Input mode: ENABLE_ECHO_INPUT\n+\tenableVirtualTerminalProcessing = 0x0004 // Output mode: ENABLE_VIRTUAL_TERMINAL_PROCESSING (same value, different mode)\n+\tenableVirtualTerminalInput      = 0x0200\n+)\n+\n+var (\n+\tkernel32                       = syscall.NewLazyDLL(\"kernel32.dll\")\n+\tprocGetConsoleMode             = kernel32.NewProc(\"GetConsoleMode\")\n+\tprocSetConsoleMode             = kernel32.NewProc(\"SetConsoleMode\")\n+\tprocGetConsoleScreenBufferInfo = kernel32.NewProc(\"GetConsoleScreenBufferInfo\")\n+)\n+\n+// ConsoleUnavailableError indicates that Windows console handles are not available\n+// (e.g., in CI environments where stdout/stdin are redirected)\n+type ConsoleUnavailableError struct {\n+\tOperation string\n+\tErr       error\n+}\n+\n+func (e *ConsoleUnavailableError) Error() string {\n+\treturn fmt.Sprintf(\"console unavailable for %s: %v\", e.Operation, e.Err)\n+}\n+\n+func (e *ConsoleUnavailableError) Unwrap() error {\n+\treturn e.Err\n+}\n+\n+type coord struct {\n+\tx, y int16\n+}\n+\n+type smallRect struct {\n+\tleft, top, right, bottom int16\n+}\n+\n+type consoleScreenBufferInfo struct {\n+\tsize              coord\n+\tcursorPosition    coord\n+\tattributes        uint16\n+\twindow            smallRect\n+\tmaximumWindowSize coord\n+}\n+\n+func (c *Client) setupTerminalMode(_ context.Context, session *ssh.Session) error {\n+\tif err := c.saveWindowsConsoleState(); err != nil {\n+\t\tvar consoleErr *ConsoleUnavailableError\n+\t\tif errors.As(err, &consoleErr) {\n+\t\t\tlog.Debugf(\"console unavailable, not requesting PTY: %v\", err)\n+\t\t\treturn nil\n+\t\t}\n+\t\treturn fmt.Errorf(\"save console state: %w\", err)\n+\t}\n+\n+\tif err := c.enableWindowsVirtualTerminal(); err != nil {\n+\t\tvar consoleErr *ConsoleUnavailableError\n+\t\tif errors.As(err, &consoleErr) {\n+\t\t\tlog.Debugf(\"virtual terminal unavailable: %v\", err)\n+\t\t} else {\n+\t\t\treturn fmt.Errorf(\"failed to enable virtual terminal: %w\", err)\n+\t\t}\n+\t}\n+\n+\tw, h := c.getWindowsConsoleSize()\n+\n+\tmodes := ssh.TerminalModes{\n+\t\tssh.ECHO:          1,\n+\t\tssh.TTY_OP_ISPEED: 14400,\n+\t\tssh.TTY_OP_OSPEED: 14400,\n+\t\tssh.ICRNL:         1,\n+\t\tssh.OPOST:         1,\n+\t\tssh.ONLCR:         1,\n+\t\tssh.ISIG:          1,\n+\t\tssh.ICANON:        1,\n+\t\tssh.VINTR:         3,   // Ctrl+C\n+\t\tssh.VQUIT:         28,  // Ctrl+\\\n+\t\tssh.VERASE:        127, // Backspace\n+\t\tssh.VKILL:         21,  // Ctrl+U\n+\t\tssh.VEOF:          4,   // Ctrl+D\n+\t\tssh.VEOL:          0,\n+\t\tssh.VEOL2:         0,\n+\t\tssh.VSTART:        17, // Ctrl+Q\n+\t\tssh.VSTOP:         19, // Ctrl+S\n+\t\tssh.VSUSP:         26, // Ctrl+Z\n+\t\tssh.VDISCARD:      15, // Ctrl+O\n+\t\tssh.VWERASE:       23, // Ctrl+W\n+\t\tssh.VLNEXT:        22, // Ctrl+V\n+\t\tssh.VREPRINT:      18, // Ctrl+R\n+\t}\n+\n+\tif err := session.RequestPty(\"xterm-256color\", h, w, modes); err != nil {\n+\t\tif restoreErr := c.restoreWindowsConsoleState(); restoreErr != nil {\n+\t\t\tlog.Debugf(\"restore Windows console state: %v\", restoreErr)\n+\t\t}\n+\t\treturn fmt.Errorf(\"request pty: %w\", err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+func (c *Client) saveWindowsConsoleState() error {\n+\tdefer func() {\n+\t\tif r := recover(); r != nil {\n+\t\t\tlog.Debugf(\"panic in saveWindowsConsoleState: %v\", r)\n+\t\t}\n+\t}()\n+\n+\tstdout := syscall.Handle(os.Stdout.Fd())\n+\tstdin := syscall.Handle(os.Stdin.Fd())\n+\n+\tvar stdoutMode, stdinMode uint32\n+\n+\tret, _, err := procGetConsoleMode.Call(uintptr(stdout), uintptr(unsafe.Pointer(&stdoutMode)))\n+\tif ret == 0 {\n+\t\tlog.Debugf(\"failed to get stdout console mode: %v\", err)\n+\t\treturn &ConsoleUnavailableError{\n+\t\t\tOperation: \"get stdout console mode\",\n+\t\t\tErr:       err,\n+\t\t}\n+\t}\n+\n+\tret, _, err = procGetConsoleMode.Call(uintptr(stdin), uintptr(unsafe.Pointer(&stdinMode)))\n+\tif ret == 0 {\n+\t\tlog.Debugf(\"failed to get stdin console mode: %v\", err)\n+\t\treturn &ConsoleUnavailableError{\n+\t\t\tOperation: \"get stdin console mode\",\n+\t\t\tErr:       err,\n+\t\t}\n+\t}\n+\n+\tc.terminalFd = 1\n+\tc.windowsStdoutMode = stdoutMode\n+\tc.windowsStdinMode = stdinMode\n+\n+\tlog.Debugf(\"saved Windows console state - stdout: 0x%04x, stdin: 0x%04x\", stdoutMode, stdinMode)\n+\treturn nil\n+}\n+\n+func (c *Client) enableWindowsVirtualTerminal() (err error) {\n+\tdefer func() {\n+\t\tif r := recover(); r != nil {\n+\t\t\terr = fmt.Errorf(\"panic in enableWindowsVirtualTerminal: %v\", r)\n+\t\t}\n+\t}()\n+\n+\tstdout := syscall.Handle(os.Stdout.Fd())\n+\tstdin := syscall.Handle(os.Stdin.Fd())\n+\tvar mode uint32\n+\n+\tret, _, winErr := procGetConsoleMode.Call(uintptr(stdout), uintptr(unsafe.Pointer(&mode)))\n+\tif ret == 0 {\n+\t\treturn &ConsoleUnavailableError{\n+\t\t\tOperation: \"get stdout console mode for VT\",\n+\t\t\tErr:       winErr,\n+\t\t}\n+\t}\n+\n+\tmode |= enableVirtualTerminalProcessing\n+\tret, _, winErr = procSetConsoleMode.Call(uintptr(stdout), uintptr(mode))\n+\tif ret == 0 {\n+\t\treturn &ConsoleUnavailableError{\n+\t\t\tOperation: \"enable virtual terminal processing\",\n+\t\t\tErr:       winErr,\n+\t\t}\n+\t}\n+\n+\tret, _, winErr = procGetConsoleMode.Call(uintptr(stdin), uintptr(unsafe.Pointer(&mode)))\n+\tif ret == 0 {\n+\t\treturn &ConsoleUnavailableError{\n+\t\t\tOperation: \"get stdin console mode for VT\",\n+\t\t\tErr:       winErr,\n+\t\t}\n+\t}\n+\n+\tmode &= ^uint32(enableLineInput | enableEchoInput | enableProcessedInput)\n+\tmode |= enableVirtualTerminalInput\n+\tret, _, winErr = procSetConsoleMode.Call(uintptr(stdin), uintptr(mode))\n+\tif ret == 0 {\n+\t\treturn &ConsoleUnavailableError{\n+\t\t\tOperation: \"set stdin raw mode\",\n+\t\t\tErr:       winErr,\n+\t\t}\n+\t}\n+\n+\tlog.Debugf(\"enabled Windows virtual terminal processing\")\n+\treturn nil\n+}\n+\n+func (c *Client) getWindowsConsoleSize() (int, int) {\n+\tdefer func() {\n+\t\tif r := recover(); r != nil {\n+\t\t\tlog.Debugf(\"panic in getWindowsConsoleSize: %v\", r)\n+\t\t}\n+\t}()\n+\n+\tstdout := syscall.Handle(os.Stdout.Fd())\n+\tvar csbi consoleScreenBufferInfo\n+\n+\tret, _, err := procGetConsoleScreenBufferInfo.Call(uintptr(stdout), uintptr(unsafe.Pointer(&csbi)))\n+\tif ret == 0 {\n+\t\tlog.Debugf(\"failed to get console buffer info, using defaults: %v\", err)\n+\t\treturn 80, 24\n+\t}\n+\n+\twidth := int(csbi.window.right - csbi.window.left + 1)\n+\theight := int(csbi.window.bottom - csbi.window.top + 1)\n+\n+\tlog.Debugf(\"Windows console size: %dx%d\", width, height)\n+\treturn width, height\n+}\n+\n+func (c *Client) restoreWindowsConsoleState() error {\n+\tvar err error\n+\tdefer func() {\n+\t\tif r := recover(); r != nil {\n+\t\t\terr = fmt.Errorf(\"panic in restoreWindowsConsoleState: %v\", r)\n+\t\t}\n+\t}()\n+\n+\tif c.terminalFd != 1 {\n+\t\treturn nil\n+\t}\n+\n+\tstdout := syscall.Handle(os.Stdout.Fd())\n+\tstdin := syscall.Handle(os.Stdin.Fd())\n+\n+\tret, _, winErr := procSetConsoleMode.Call(uintptr(stdout), uintptr(c.windowsStdoutMode))\n+\tif ret == 0 {\n+\t\tlog.Debugf(\"failed to restore stdout console mode: %v\", winErr)\n+\t\tif err == nil {\n+\t\t\terr = fmt.Errorf(\"restore stdout console mode: %w\", winErr)\n+\t\t}\n+\t}\n+\n+\tret, _, winErr = procSetConsoleMode.Call(uintptr(stdin), uintptr(c.windowsStdinMode))\n+\tif ret == 0 {\n+\t\tlog.Debugf(\"failed to restore stdin console mode: %v\", winErr)\n+\t\tif err == nil {\n+\t\t\terr = fmt.Errorf(\"restore stdin console mode: %w\", winErr)\n+\t\t}\n+\t}\n+\n+\tc.terminalFd = 0\n+\tc.windowsStdoutMode = 0\n+\tc.windowsStdinMode = 0\n+\n+\tlog.Debugf(\"restored Windows console state\")\n+\treturn err\n+}\ndiff --git a/client/ssh/common.go b/client/ssh/common.go\nnew file mode 100644\nindex 00000000000..3beb12806d9\n--- /dev/null\n+++ b/client/ssh/common.go\n@@ -0,0 +1,171 @@\n+package ssh\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net\"\n+\t\"time\"\n+\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"golang.org/x/crypto/ssh\"\n+\n+\t\"github.com/netbirdio/netbird/client/proto\"\n+)\n+\n+const (\n+\tNetBirdSSHConfigFile = \"99-netbird.conf\"\n+\n+\tUnixSSHConfigDir    = \"/etc/ssh/ssh_config.d\"\n+\tWindowsSSHConfigDir = \"ssh/ssh_config.d\"\n+)\n+\n+var (\n+\t// ErrPeerNotFound indicates the peer was not found in the network\n+\tErrPeerNotFound = errors.New(\"peer not found in network\")\n+\t// ErrNoStoredKey indicates the peer has no stored SSH host key\n+\tErrNoStoredKey = errors.New(\"peer has no stored SSH host key\")\n+)\n+\n+// HostKeyVerifier provides SSH host key verification\n+type HostKeyVerifier interface {\n+\tVerifySSHHostKey(peerAddress string, key []byte) error\n+}\n+\n+// DaemonHostKeyVerifier implements HostKeyVerifier using the NetBird daemon\n+type DaemonHostKeyVerifier struct {\n+\tclient proto.DaemonServiceClient\n+}\n+\n+// NewDaemonHostKeyVerifier creates a new daemon-based host key verifier\n+func NewDaemonHostKeyVerifier(client proto.DaemonServiceClient) *DaemonHostKeyVerifier {\n+\treturn &DaemonHostKeyVerifier{\n+\t\tclient: client,\n+\t}\n+}\n+\n+// VerifySSHHostKey verifies an SSH host key by querying the NetBird daemon\n+func (d *DaemonHostKeyVerifier) VerifySSHHostKey(peerAddress string, presentedKey []byte) error {\n+\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n+\tdefer cancel()\n+\n+\tresponse, err := d.client.GetPeerSSHHostKey(ctx, &proto.GetPeerSSHHostKeyRequest{\n+\t\tPeerAddress: peerAddress,\n+\t})\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif !response.GetFound() {\n+\t\treturn ErrPeerNotFound\n+\t}\n+\n+\tstoredKeyData := response.GetSshHostKey()\n+\n+\treturn VerifyHostKey(storedKeyData, presentedKey, peerAddress)\n+}\n+\n+// RequestJWTToken requests or retrieves a JWT token for SSH authentication\n+func RequestJWTToken(ctx context.Context, client proto.DaemonServiceClient, stdout, stderr io.Writer, useCache bool, hint string) (string, error) {\n+\treq := &proto.RequestJWTAuthRequest{}\n+\tif hint != \"\" {\n+\t\treq.Hint = &hint\n+\t}\n+\tauthResponse, err := client.RequestJWTAuth(ctx, req)\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"request JWT auth: %w\", err)\n+\t}\n+\n+\tif useCache && authResponse.CachedToken != \"\" {\n+\t\tlog.Debug(\"Using cached authentication token\")\n+\t\treturn authResponse.CachedToken, nil\n+\t}\n+\n+\tif stderr != nil {\n+\t\t_, _ = fmt.Fprintln(stderr, \"SSH authentication required.\")\n+\t\t_, _ = fmt.Fprintf(stderr, \"Please visit: %s\\n\", authResponse.VerificationURIComplete)\n+\t\tif authResponse.UserCode != \"\" {\n+\t\t\t_, _ = fmt.Fprintf(stderr, \"Or visit: %s and enter code: %s\\n\", authResponse.VerificationURI, authResponse.UserCode)\n+\t\t}\n+\t\t_, _ = fmt.Fprintln(stderr, \"Waiting for authentication...\")\n+\t}\n+\n+\ttokenResponse, err := client.WaitJWTToken(ctx, &proto.WaitJWTTokenRequest{\n+\t\tDeviceCode: authResponse.DeviceCode,\n+\t\tUserCode:   authResponse.UserCode,\n+\t})\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"wait for JWT token: %w\", err)\n+\t}\n+\n+\tif stdout != nil {\n+\t\t_, _ = fmt.Fprintln(stdout, \"Authentication successful!\")\n+\t}\n+\treturn tokenResponse.Token, nil\n+}\n+\n+// VerifyHostKey verifies an SSH host key against stored peer key data.\n+// Returns nil only if the presented key matches the stored key.\n+// Returns ErrNoStoredKey if storedKeyData is empty.\n+// Returns an error if the keys don't match or if parsing fails.\n+func VerifyHostKey(storedKeyData []byte, presentedKey []byte, peerAddress string) error {\n+\tif len(storedKeyData) == 0 {\n+\t\treturn ErrNoStoredKey\n+\t}\n+\n+\tstoredPubKey, _, _, _, err := ssh.ParseAuthorizedKey(storedKeyData)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"parse stored SSH key for %s: %w\", peerAddress, err)\n+\t}\n+\n+\tif !bytes.Equal(presentedKey, storedPubKey.Marshal()) {\n+\t\treturn fmt.Errorf(\"SSH host key mismatch for %s\", peerAddress)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// AddJWTAuth prepends JWT password authentication to existing auth methods.\n+// This ensures JWT auth is tried first while preserving any existing auth methods.\n+func AddJWTAuth(config *ssh.ClientConfig, jwtToken string) *ssh.ClientConfig {\n+\tconfigWithJWT := *config\n+\tconfigWithJWT.Auth = append([]ssh.AuthMethod{ssh.Password(jwtToken)}, config.Auth...)\n+\treturn &configWithJWT\n+}\n+\n+// CreateHostKeyCallback creates an SSH host key verification callback using the provided verifier.\n+// It tries multiple addresses (hostname, IP) for the peer before failing.\n+func CreateHostKeyCallback(verifier HostKeyVerifier) ssh.HostKeyCallback {\n+\treturn func(hostname string, remote net.Addr, key ssh.PublicKey) error {\n+\t\taddresses := buildAddressList(hostname, remote)\n+\t\tpresentedKey := key.Marshal()\n+\n+\t\tfor _, addr := range addresses {\n+\t\t\tif err := verifier.VerifySSHHostKey(addr, presentedKey); err != nil {\n+\t\t\t\tif errors.Is(err, ErrPeerNotFound) {\n+\t\t\t\t\t// Try other addresses for this peer\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\t// Verified\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\treturn fmt.Errorf(\"SSH host key verification failed: peer %s not found in network\", hostname)\n+\t}\n+}\n+\n+// buildAddressList creates a list of addresses to check for host key verification.\n+// It includes the original hostname and extracts the host part from the remote address if different.\n+func buildAddressList(hostname string, remote net.Addr) []string {\n+\taddresses := []string{hostname}\n+\tif host, _, err := net.SplitHostPort(remote.String()); err == nil {\n+\t\tif host != hostname {\n+\t\t\taddresses = append(addresses, host)\n+\t\t}\n+\t}\n+\treturn addresses\n+}\ndiff --git a/client/ssh/config/manager.go b/client/ssh/config/manager.go\nnew file mode 100644\nindex 00000000000..03a136de363\n--- /dev/null\n+++ b/client/ssh/config/manager.go\n@@ -0,0 +1,282 @@\n+package config\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\tlog \"github.com/sirupsen/logrus\"\n+\n+\tnbssh \"github.com/netbirdio/netbird/client/ssh\"\n+)\n+\n+const (\n+\tEnvDisableSSHConfig = \"NB_DISABLE_SSH_CONFIG\"\n+\n+\tEnvForceSSHConfig = \"NB_FORCE_SSH_CONFIG\"\n+\n+\tMaxPeersForSSHConfig = 200\n+\n+\tfileWriteTimeout = 2 * time.Second\n+)\n+\n+func isSSHConfigDisabled() bool {\n+\tvalue := os.Getenv(EnvDisableSSHConfig)\n+\tif value == \"\" {\n+\t\treturn false\n+\t}\n+\n+\tdisabled, err := strconv.ParseBool(value)\n+\tif err != nil {\n+\t\treturn true\n+\t}\n+\treturn disabled\n+}\n+\n+func isSSHConfigForced() bool {\n+\tvalue := os.Getenv(EnvForceSSHConfig)\n+\tif value == \"\" {\n+\t\treturn false\n+\t}\n+\n+\tforced, err := strconv.ParseBool(value)\n+\tif err != nil {\n+\t\treturn true\n+\t}\n+\treturn forced\n+}\n+\n+// shouldGenerateSSHConfig checks if SSH config should be generated based on peer count\n+func shouldGenerateSSHConfig(peerCount int) bool {\n+\tif isSSHConfigDisabled() {\n+\t\treturn false\n+\t}\n+\n+\tif isSSHConfigForced() {\n+\t\treturn true\n+\t}\n+\n+\treturn peerCount <= MaxPeersForSSHConfig\n+}\n+\n+// writeFileWithTimeout writes data to a file with a timeout\n+func writeFileWithTimeout(filename string, data []byte, perm os.FileMode) error {\n+\tctx, cancel := context.WithTimeout(context.Background(), fileWriteTimeout)\n+\tdefer cancel()\n+\n+\tdone := make(chan error, 1)\n+\tgo func() {\n+\t\tdone <- os.WriteFile(filename, data, perm)\n+\t}()\n+\n+\tselect {\n+\tcase err := <-done:\n+\t\treturn err\n+\tcase <-ctx.Done():\n+\t\treturn fmt.Errorf(\"file write timeout after %v: %s\", fileWriteTimeout, filename)\n+\t}\n+}\n+\n+// Manager handles SSH client configuration for NetBird peers\n+type Manager struct {\n+\tsshConfigDir  string\n+\tsshConfigFile string\n+}\n+\n+// PeerSSHInfo represents a peer's SSH configuration information\n+type PeerSSHInfo struct {\n+\tHostname string\n+\tIP       string\n+\tFQDN     string\n+}\n+\n+// New creates a new SSH config manager\n+func New() *Manager {\n+\tsshConfigDir := getSystemSSHConfigDir()\n+\treturn &Manager{\n+\t\tsshConfigDir:  sshConfigDir,\n+\t\tsshConfigFile: nbssh.NetBirdSSHConfigFile,\n+\t}\n+}\n+\n+// getSystemSSHConfigDir returns platform-specific SSH configuration directory\n+func getSystemSSHConfigDir() string {\n+\tif runtime.GOOS == \"windows\" {\n+\t\treturn getWindowsSSHConfigDir()\n+\t}\n+\treturn nbssh.UnixSSHConfigDir\n+}\n+\n+func getWindowsSSHConfigDir() string {\n+\tprogramData := os.Getenv(\"PROGRAMDATA\")\n+\tif programData == \"\" {\n+\t\tprogramData = `C:\\ProgramData`\n+\t}\n+\treturn filepath.Join(programData, nbssh.WindowsSSHConfigDir)\n+}\n+\n+// SetupSSHClientConfig creates SSH client configuration for NetBird peers\n+func (m *Manager) SetupSSHClientConfig(peers []PeerSSHInfo) error {\n+\tif !shouldGenerateSSHConfig(len(peers)) {\n+\t\tm.logSkipReason(len(peers))\n+\t\treturn nil\n+\t}\n+\n+\tsshConfig, err := m.buildSSHConfig(peers)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"build SSH config: %w\", err)\n+\t}\n+\treturn m.writeSSHConfig(sshConfig)\n+}\n+\n+func (m *Manager) logSkipReason(peerCount int) {\n+\tif isSSHConfigDisabled() {\n+\t\tlog.Debugf(\"SSH config management disabled via %s\", EnvDisableSSHConfig)\n+\t} else {\n+\t\tlog.Infof(\"SSH config generation skipped: too many peers (%d > %d). Use %s=true to force.\",\n+\t\t\tpeerCount, MaxPeersForSSHConfig, EnvForceSSHConfig)\n+\t}\n+}\n+\n+func (m *Manager) buildSSHConfig(peers []PeerSSHInfo) (string, error) {\n+\tsshConfig := m.buildConfigHeader()\n+\n+\tvar allHostPatterns []string\n+\tfor _, peer := range peers {\n+\t\thostPatterns := m.buildHostPatterns(peer)\n+\t\tallHostPatterns = append(allHostPatterns, hostPatterns...)\n+\t}\n+\n+\tif len(allHostPatterns) > 0 {\n+\t\tpeerConfig, err := m.buildPeerConfig(allHostPatterns)\n+\t\tif err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tsshConfig += peerConfig\n+\t}\n+\n+\treturn sshConfig, nil\n+}\n+\n+func (m *Manager) buildConfigHeader() string {\n+\treturn \"# NetBird SSH client configuration\\n\" +\n+\t\t\"# Generated automatically - do not edit manually\\n\" +\n+\t\t\"#\\n\" +\n+\t\t\"# To disable SSH config management, use:\\n\" +\n+\t\t\"#   netbird service reconfigure --service-env NB_DISABLE_SSH_CONFIG=true\\n\" +\n+\t\t\"#\\n\\n\"\n+}\n+\n+func (m *Manager) buildPeerConfig(allHostPatterns []string) (string, error) {\n+\tuniquePatterns := make(map[string]bool)\n+\tvar deduplicatedPatterns []string\n+\tfor _, pattern := range allHostPatterns {\n+\t\tif !uniquePatterns[pattern] {\n+\t\t\tuniquePatterns[pattern] = true\n+\t\t\tdeduplicatedPatterns = append(deduplicatedPatterns, pattern)\n+\t\t}\n+\t}\n+\n+\texecPath, err := m.getNetBirdExecutablePath()\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"get NetBird executable path: %w\", err)\n+\t}\n+\n+\thostLine := strings.Join(deduplicatedPatterns, \" \")\n+\tconfig := fmt.Sprintf(\"Host %s\\n\", hostLine)\n+\n+\tif runtime.GOOS == \"windows\" {\n+\t\tconfig += fmt.Sprintf(\"    Match exec \\\"%s ssh detect %%h %%p\\\"\\n\", execPath)\n+\t} else {\n+\t\tconfig += fmt.Sprintf(\"    Match exec \\\"%s ssh detect %%h %%p 2>/dev/null\\\"\\n\", execPath)\n+\t}\n+\tconfig += \"        PreferredAuthentications password,publickey,keyboard-interactive\\n\"\n+\tconfig += \"        PasswordAuthentication yes\\n\"\n+\tconfig += \"        PubkeyAuthentication yes\\n\"\n+\tconfig += \"        BatchMode no\\n\"\n+\tconfig += fmt.Sprintf(\"        ProxyCommand %s ssh proxy %%h %%p\\n\", execPath)\n+\tconfig += \"        StrictHostKeyChecking no\\n\"\n+\n+\tif runtime.GOOS == \"windows\" {\n+\t\tconfig += \"        UserKnownHostsFile NUL\\n\"\n+\t} else {\n+\t\tconfig += \"        UserKnownHostsFile /dev/null\\n\"\n+\t}\n+\n+\tconfig += \"        CheckHostIP no\\n\"\n+\tconfig += \"        LogLevel ERROR\\n\\n\"\n+\n+\treturn config, nil\n+}\n+\n+func (m *Manager) buildHostPatterns(peer PeerSSHInfo) []string {\n+\tvar hostPatterns []string\n+\tif peer.IP != \"\" {\n+\t\thostPatterns = append(hostPatterns, peer.IP)\n+\t}\n+\tif peer.FQDN != \"\" {\n+\t\thostPatterns = append(hostPatterns, peer.FQDN)\n+\t}\n+\tif peer.Hostname != \"\" && peer.Hostname != peer.FQDN {\n+\t\thostPatterns = append(hostPatterns, peer.Hostname)\n+\t}\n+\treturn hostPatterns\n+}\n+\n+func (m *Manager) writeSSHConfig(sshConfig string) error {\n+\tsshConfigPath := filepath.Join(m.sshConfigDir, m.sshConfigFile)\n+\n+\tif err := os.MkdirAll(m.sshConfigDir, 0755); err != nil {\n+\t\treturn fmt.Errorf(\"create SSH config directory %s: %w\", m.sshConfigDir, err)\n+\t}\n+\n+\tif err := writeFileWithTimeout(sshConfigPath, []byte(sshConfig), 0644); err != nil {\n+\t\treturn fmt.Errorf(\"write SSH config file %s: %w\", sshConfigPath, err)\n+\t}\n+\n+\tlog.Infof(\"Created NetBird SSH client config: %s\", sshConfigPath)\n+\treturn nil\n+}\n+\n+// RemoveSSHClientConfig removes NetBird SSH configuration\n+func (m *Manager) RemoveSSHClientConfig() error {\n+\tsshConfigPath := filepath.Join(m.sshConfigDir, m.sshConfigFile)\n+\terr := os.Remove(sshConfigPath)\n+\tif err != nil && !os.IsNotExist(err) {\n+\t\treturn fmt.Errorf(\"remove SSH config %s: %w\", sshConfigPath, err)\n+\t}\n+\tif err == nil {\n+\t\tlog.Infof(\"Removed NetBird SSH config: %s\", sshConfigPath)\n+\t}\n+\treturn nil\n+}\n+\n+func (m *Manager) getNetBirdExecutablePath() (string, error) {\n+\texecPath, err := os.Executable()\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"retrieve executable path: %w\", err)\n+\t}\n+\n+\trealPath, err := filepath.EvalSymlinks(execPath)\n+\tif err != nil {\n+\t\tlog.Debugf(\"symlink resolution failed: %v\", err)\n+\t\treturn execPath, nil\n+\t}\n+\n+\treturn realPath, nil\n+}\n+\n+// GetSSHConfigDir returns the SSH config directory path\n+func (m *Manager) GetSSHConfigDir() string {\n+\treturn m.sshConfigDir\n+}\n+\n+// GetSSHConfigFile returns the SSH config file name\n+func (m *Manager) GetSSHConfigFile() string {\n+\treturn m.sshConfigFile\n+}\ndiff --git a/client/ssh/config/shutdown_state.go b/client/ssh/config/shutdown_state.go\nnew file mode 100644\nindex 00000000000..22f0e06781a\n--- /dev/null\n+++ b/client/ssh/config/shutdown_state.go\n@@ -0,0 +1,22 @@\n+package config\n+\n+// ShutdownState represents SSH configuration state that needs to be cleaned up.\n+type ShutdownState struct {\n+\tSSHConfigDir  string\n+\tSSHConfigFile string\n+}\n+\n+// Name returns the state name for the state manager.\n+func (s *ShutdownState) Name() string {\n+\treturn \"ssh_config_state\"\n+}\n+\n+// Cleanup removes SSH client configuration files.\n+func (s *ShutdownState) Cleanup() error {\n+\tmanager := &Manager{\n+\t\tsshConfigDir:  s.SSHConfigDir,\n+\t\tsshConfigFile: s.SSHConfigFile,\n+\t}\n+\n+\treturn manager.RemoveSSHClientConfig()\n+}\ndiff --git a/client/ssh/detection/detection.go b/client/ssh/detection/detection.go\nnew file mode 100644\nindex 00000000000..487f4665a08\n--- /dev/null\n+++ b/client/ssh/detection/detection.go\n@@ -0,0 +1,99 @@\n+package detection\n+\n+import (\n+\t\"bufio\"\n+\t\"context\"\n+\t\"net\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\tlog \"github.com/sirupsen/logrus\"\n+)\n+\n+const (\n+\t// ServerIdentifier is the base response for NetBird SSH servers\n+\tServerIdentifier = \"NetBird-SSH-Server\"\n+\t// ProxyIdentifier is the base response for NetBird SSH proxy\n+\tProxyIdentifier = \"NetBird-SSH-Proxy\"\n+\t// JWTRequiredMarker is appended to responses when JWT is required\n+\tJWTRequiredMarker = \"NetBird-JWT-Required\"\n+\n+\t// Timeout is the timeout for SSH server detection\n+\tTimeout = 5 * time.Second\n+)\n+\n+type ServerType string\n+\n+const (\n+\tServerTypeNetBirdJWT   ServerType = \"netbird-jwt\"\n+\tServerTypeNetBirdNoJWT ServerType = \"netbird-no-jwt\"\n+\tServerTypeRegular      ServerType = \"regular\"\n+)\n+\n+// Dialer provides network connection capabilities\n+type Dialer interface {\n+\tDialContext(ctx context.Context, network, address string) (net.Conn, error)\n+}\n+\n+// RequiresJWT checks if the server type requires JWT authentication\n+func (s ServerType) RequiresJWT() bool {\n+\treturn s == ServerTypeNetBirdJWT\n+}\n+\n+// ExitCode returns the exit code for the detect command\n+func (s ServerType) ExitCode() int {\n+\tswitch s {\n+\tcase ServerTypeNetBirdJWT:\n+\t\treturn 0\n+\tcase ServerTypeNetBirdNoJWT:\n+\t\treturn 1\n+\tcase ServerTypeRegular:\n+\t\treturn 2\n+\tdefault:\n+\t\treturn 2\n+\t}\n+}\n+\n+// DetectSSHServerType detects SSH server type using the provided dialer\n+func DetectSSHServerType(ctx context.Context, dialer Dialer, host string, port int) (ServerType, error) {\n+\ttargetAddr := net.JoinHostPort(host, strconv.Itoa(port))\n+\n+\tconn, err := dialer.DialContext(ctx, \"tcp\", targetAddr)\n+\tif err != nil {\n+\t\tlog.Debugf(\"SSH connection failed for detection: %v\", err)\n+\t\treturn ServerTypeRegular, nil\n+\t}\n+\tdefer conn.Close()\n+\n+\tif err := conn.SetReadDeadline(time.Now().Add(Timeout)); err != nil {\n+\t\tlog.Debugf(\"set read deadline: %v\", err)\n+\t\treturn ServerTypeRegular, nil\n+\t}\n+\n+\treader := bufio.NewReader(conn)\n+\tserverBanner, err := reader.ReadString('\\n')\n+\tif err != nil {\n+\t\tlog.Debugf(\"read SSH banner: %v\", err)\n+\t\treturn ServerTypeRegular, nil\n+\t}\n+\n+\tserverBanner = strings.TrimSpace(serverBanner)\n+\tlog.Debugf(\"SSH server banner: %s\", serverBanner)\n+\n+\tif !strings.HasPrefix(serverBanner, \"SSH-\") {\n+\t\tlog.Debugf(\"Invalid SSH banner\")\n+\t\treturn ServerTypeRegular, nil\n+\t}\n+\n+\tif !strings.Contains(serverBanner, ServerIdentifier) {\n+\t\tlog.Debugf(\"Server banner does not contain identifier '%s'\", ServerIdentifier)\n+\t\treturn ServerTypeRegular, nil\n+\t}\n+\n+\tif strings.Contains(serverBanner, JWTRequiredMarker) {\n+\t\treturn ServerTypeNetBirdJWT, nil\n+\t}\n+\n+\treturn ServerTypeNetBirdNoJWT, nil\n+}\ndiff --git a/client/ssh/login.go b/client/ssh/login.go\ndeleted file mode 100644\nindex cb2615e5537..00000000000\n--- a/client/ssh/login.go\n+++ /dev/null\n@@ -1,53 +0,0 @@\n-//go:build !js\n-\n-package ssh\n-\n-import (\n-\t\"fmt\"\n-\t\"net\"\n-\t\"net/netip\"\n-\t\"os\"\n-\t\"os/exec\"\n-\t\"runtime\"\n-\n-\t\"github.com/netbirdio/netbird/util\"\n-)\n-\n-func isRoot() bool {\n-\treturn os.Geteuid() == 0\n-}\n-\n-func getLoginCmd(user string, remoteAddr net.Addr) (loginPath string, args []string, err error) {\n-\tif !isRoot() {\n-\t\tshell := getUserShell(user)\n-\t\tif shell == \"\" {\n-\t\t\tshell = \"/bin/sh\"\n-\t\t}\n-\n-\t\treturn shell, []string{\"-l\"}, nil\n-\t}\n-\n-\tloginPath, err = exec.LookPath(\"login\")\n-\tif err != nil {\n-\t\treturn \"\", nil, err\n-\t}\n-\n-\taddrPort, err := netip.ParseAddrPort(remoteAddr.String())\n-\tif err != nil {\n-\t\treturn \"\", nil, err\n-\t}\n-\n-\tswitch runtime.GOOS {\n-\tcase \"linux\":\n-\t\tif util.FileExists(\"/etc/arch-release\") && !util.FileExists(\"/etc/pam.d/remote\") {\n-\t\t\treturn loginPath, []string{\"-f\", user, \"-p\"}, nil\n-\t\t}\n-\t\treturn loginPath, []string{\"-f\", user, \"-h\", addrPort.Addr().String(), \"-p\"}, nil\n-\tcase \"darwin\":\n-\t\treturn loginPath, []string{\"-fp\", \"-h\", addrPort.Addr().String(), user}, nil\n-\tcase \"freebsd\":\n-\t\treturn loginPath, []string{\"-f\", user, \"-h\", addrPort.Addr().String(), \"-p\"}, nil\n-\tdefault:\n-\t\treturn \"\", nil, fmt.Errorf(\"unsupported platform: %s\", runtime.GOOS)\n-\t}\n-}\ndiff --git a/client/ssh/lookup.go b/client/ssh/lookup.go\ndeleted file mode 100644\nindex 9a7f6ff2eef..00000000000\n--- a/client/ssh/lookup.go\n+++ /dev/null\n@@ -1,14 +0,0 @@\n-//go:build !darwin\n-// +build !darwin\n-\n-package ssh\n-\n-import \"os/user\"\n-\n-func userNameLookup(username string) (*user.User, error) {\n-\tif username == \"\" || (username == \"root\" && !isRoot()) {\n-\t\treturn user.Current()\n-\t}\n-\n-\treturn user.Lookup(username)\n-}\ndiff --git a/client/ssh/lookup_darwin.go b/client/ssh/lookup_darwin.go\ndeleted file mode 100644\nindex 913d049dcce..00000000000\n--- a/client/ssh/lookup_darwin.go\n+++ /dev/null\n@@ -1,51 +0,0 @@\n-//go:build darwin\n-// +build darwin\n-\n-package ssh\n-\n-import (\n-\t\"bytes\"\n-\t\"fmt\"\n-\t\"os/exec\"\n-\t\"os/user\"\n-\t\"strings\"\n-)\n-\n-func userNameLookup(username string) (*user.User, error) {\n-\tif username == \"\" || (username == \"root\" && !isRoot()) {\n-\t\treturn user.Current()\n-\t}\n-\n-\tvar userObject *user.User\n-\tuserObject, err := user.Lookup(username)\n-\tif err != nil && err.Error() == user.UnknownUserError(username).Error() {\n-\t\treturn idUserNameLookup(username)\n-\t} else if err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\treturn userObject, nil\n-}\n-\n-func idUserNameLookup(username string) (*user.User, error) {\n-\tcmd := exec.Command(\"id\", \"-P\", username)\n-\tout, err := cmd.CombinedOutput()\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"error while retrieving user with id -P command, error: %v\", err)\n-\t}\n-\tcolon := \":\"\n-\n-\tif !bytes.Contains(out, []byte(username+colon)) {\n-\t\treturn nil, fmt.Errorf(\"unable to find user in returned string\")\n-\t}\n-\t// netbird:********:501:20::0:0:netbird:/Users/netbird:/bin/zsh\n-\tparts := strings.SplitN(string(out), colon, 10)\n-\tuserObject := &user.User{\n-\t\tUsername: parts[0],\n-\t\tUid:      parts[2],\n-\t\tGid:      parts[3],\n-\t\tName:     parts[7],\n-\t\tHomeDir:  parts[8],\n-\t}\n-\treturn userObject, nil\n-}\ndiff --git a/client/ssh/proxy/proxy.go b/client/ssh/proxy/proxy.go\nnew file mode 100644\nindex 00000000000..bc8a84b89b2\n--- /dev/null\n+++ b/client/ssh/proxy/proxy.go\n@@ -0,0 +1,392 @@\n+package proxy\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net\"\n+\t\"os\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\tcryptossh \"golang.org/x/crypto/ssh\"\n+\t\"google.golang.org/grpc\"\n+\t\"google.golang.org/grpc/credentials/insecure\"\n+\n+\t\"github.com/netbirdio/netbird/client/internal/profilemanager\"\n+\t\"github.com/netbirdio/netbird/client/proto\"\n+\tnbssh \"github.com/netbirdio/netbird/client/ssh\"\n+\t\"github.com/netbirdio/netbird/client/ssh/detection\"\n+\t\"github.com/netbirdio/netbird/version\"\n+)\n+\n+const (\n+\t// sshConnectionTimeout is the timeout for SSH TCP connection establishment\n+\tsshConnectionTimeout = 120 * time.Second\n+\t// sshHandshakeTimeout is the timeout for SSH handshake completion\n+\tsshHandshakeTimeout = 30 * time.Second\n+\n+\tjwtAuthErrorMsg = \"JWT authentication: %w\"\n+)\n+\n+type SSHProxy struct {\n+\tdaemonAddr   string\n+\ttargetHost   string\n+\ttargetPort   int\n+\tstderr       io.Writer\n+\tconn         *grpc.ClientConn\n+\tdaemonClient proto.DaemonServiceClient\n+}\n+\n+func New(daemonAddr, targetHost string, targetPort int, stderr io.Writer) (*SSHProxy, error) {\n+\tgrpcAddr := strings.TrimPrefix(daemonAddr, \"tcp://\")\n+\tgrpcConn, err := grpc.NewClient(grpcAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"connect to daemon: %w\", err)\n+\t}\n+\n+\treturn &SSHProxy{\n+\t\tdaemonAddr:   daemonAddr,\n+\t\ttargetHost:   targetHost,\n+\t\ttargetPort:   targetPort,\n+\t\tstderr:       stderr,\n+\t\tconn:         grpcConn,\n+\t\tdaemonClient: proto.NewDaemonServiceClient(grpcConn),\n+\t}, nil\n+}\n+\n+func (p *SSHProxy) Close() error {\n+\tif p.conn != nil {\n+\t\treturn p.conn.Close()\n+\t}\n+\treturn nil\n+}\n+\n+func (p *SSHProxy) Connect(ctx context.Context) error {\n+\thint := profilemanager.GetLoginHint()\n+\n+\tjwtToken, err := nbssh.RequestJWTToken(ctx, p.daemonClient, nil, p.stderr, true, hint)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(jwtAuthErrorMsg, err)\n+\t}\n+\n+\treturn p.runProxySSHServer(ctx, jwtToken)\n+}\n+\n+func (p *SSHProxy) runProxySSHServer(ctx context.Context, jwtToken string) error {\n+\tserverVersion := fmt.Sprintf(\"%s-%s\", detection.ProxyIdentifier, version.NetbirdVersion())\n+\n+\tsshServer := &ssh.Server{\n+\t\tHandler: func(s ssh.Session) {\n+\t\t\tp.handleSSHSession(ctx, s, jwtToken)\n+\t\t},\n+\t\tChannelHandlers: map[string]ssh.ChannelHandler{\n+\t\t\t\"session\":      ssh.DefaultSessionHandler,\n+\t\t\t\"direct-tcpip\": p.directTCPIPHandler,\n+\t\t},\n+\t\tSubsystemHandlers: map[string]ssh.SubsystemHandler{\n+\t\t\t\"sftp\": func(s ssh.Session) {\n+\t\t\t\tp.sftpSubsystemHandler(s, jwtToken)\n+\t\t\t},\n+\t\t},\n+\t\tRequestHandlers: map[string]ssh.RequestHandler{\n+\t\t\t\"tcpip-forward\":        p.tcpipForwardHandler,\n+\t\t\t\"cancel-tcpip-forward\": p.cancelTcpipForwardHandler,\n+\t\t},\n+\t\tVersion: serverVersion,\n+\t}\n+\n+\thostKey, err := generateHostKey()\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"generate host key: %w\", err)\n+\t}\n+\tsshServer.HostSigners = []ssh.Signer{hostKey}\n+\n+\tconn := &stdioConn{\n+\t\tstdin:  os.Stdin,\n+\t\tstdout: os.Stdout,\n+\t}\n+\n+\tsshServer.HandleConn(conn)\n+\n+\treturn nil\n+}\n+\n+func (p *SSHProxy) handleSSHSession(ctx context.Context, session ssh.Session, jwtToken string) {\n+\ttargetAddr := net.JoinHostPort(p.targetHost, strconv.Itoa(p.targetPort))\n+\n+\tsshClient, err := p.dialBackend(ctx, targetAddr, session.User(), jwtToken)\n+\tif err != nil {\n+\t\t_, _ = fmt.Fprintf(p.stderr, \"SSH connection to NetBird server failed: %v\\n\", err)\n+\t\treturn\n+\t}\n+\tdefer func() { _ = sshClient.Close() }()\n+\n+\tserverSession, err := sshClient.NewSession()\n+\tif err != nil {\n+\t\t_, _ = fmt.Fprintf(p.stderr, \"create server session: %v\\n\", err)\n+\t\treturn\n+\t}\n+\tdefer func() { _ = serverSession.Close() }()\n+\n+\tserverSession.Stdin = session\n+\tserverSession.Stdout = session\n+\tserverSession.Stderr = session.Stderr()\n+\n+\tptyReq, winCh, isPty := session.Pty()\n+\tif isPty {\n+\t\tif err := serverSession.RequestPty(ptyReq.Term, ptyReq.Window.Width, ptyReq.Window.Height, nil); err != nil {\n+\t\t\tlog.Debugf(\"PTY request to backend: %v\", err)\n+\t\t}\n+\n+\t\tgo func() {\n+\t\t\tfor win := range winCh {\n+\t\t\t\tif err := serverSession.WindowChange(win.Height, win.Width); err != nil {\n+\t\t\t\t\tlog.Debugf(\"window change: %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}()\n+\t}\n+\n+\tif len(session.Command()) > 0 {\n+\t\tif err := serverSession.Run(strings.Join(session.Command(), \" \")); err != nil {\n+\t\t\tlog.Debugf(\"run command: %v\", err)\n+\t\t\tp.handleProxyExitCode(session, err)\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tif err = serverSession.Shell(); err != nil {\n+\t\tlog.Debugf(\"start shell: %v\", err)\n+\t\treturn\n+\t}\n+\tif err := serverSession.Wait(); err != nil {\n+\t\tlog.Debugf(\"session wait: %v\", err)\n+\t\tp.handleProxyExitCode(session, err)\n+\t}\n+}\n+\n+func (p *SSHProxy) handleProxyExitCode(session ssh.Session, err error) {\n+\tvar exitErr *cryptossh.ExitError\n+\tif errors.As(err, &exitErr) {\n+\t\tif exitErr := session.Exit(exitErr.ExitStatus()); exitErr != nil {\n+\t\t\tlog.Debugf(\"set exit status: %v\", exitErr)\n+\t\t}\n+\t}\n+}\n+\n+func generateHostKey() (ssh.Signer, error) {\n+\tkeyPEM, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"generate ED25519 key: %w\", err)\n+\t}\n+\n+\tsigner, err := cryptossh.ParsePrivateKey(keyPEM)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"parse private key: %w\", err)\n+\t}\n+\n+\treturn signer, nil\n+}\n+\n+type stdioConn struct {\n+\tstdin  io.Reader\n+\tstdout io.Writer\n+\tclosed bool\n+\tmu     sync.Mutex\n+}\n+\n+func (c *stdioConn) Read(b []byte) (n int, err error) {\n+\tc.mu.Lock()\n+\tif c.closed {\n+\t\tc.mu.Unlock()\n+\t\treturn 0, io.EOF\n+\t}\n+\tc.mu.Unlock()\n+\treturn c.stdin.Read(b)\n+}\n+\n+func (c *stdioConn) Write(b []byte) (n int, err error) {\n+\tc.mu.Lock()\n+\tif c.closed {\n+\t\tc.mu.Unlock()\n+\t\treturn 0, io.ErrClosedPipe\n+\t}\n+\tc.mu.Unlock()\n+\treturn c.stdout.Write(b)\n+}\n+\n+func (c *stdioConn) Close() error {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\tc.closed = true\n+\treturn nil\n+}\n+\n+func (c *stdioConn) LocalAddr() net.Addr {\n+\treturn &net.UnixAddr{Name: \"stdio\", Net: \"unix\"}\n+}\n+\n+func (c *stdioConn) RemoteAddr() net.Addr {\n+\treturn &net.UnixAddr{Name: \"stdio\", Net: \"unix\"}\n+}\n+\n+func (c *stdioConn) SetDeadline(_ time.Time) error {\n+\treturn nil\n+}\n+\n+func (c *stdioConn) SetReadDeadline(_ time.Time) error {\n+\treturn nil\n+}\n+\n+func (c *stdioConn) SetWriteDeadline(_ time.Time) error {\n+\treturn nil\n+}\n+\n+func (p *SSHProxy) directTCPIPHandler(_ *ssh.Server, _ *cryptossh.ServerConn, newChan cryptossh.NewChannel, _ ssh.Context) {\n+\t_ = newChan.Reject(cryptossh.Prohibited, \"port forwarding not supported in proxy\")\n+}\n+\n+func (p *SSHProxy) sftpSubsystemHandler(s ssh.Session, jwtToken string) {\n+\tctx, cancel := context.WithCancel(s.Context())\n+\tdefer cancel()\n+\n+\ttargetAddr := net.JoinHostPort(p.targetHost, strconv.Itoa(p.targetPort))\n+\n+\tsshClient, err := p.dialBackend(ctx, targetAddr, s.User(), jwtToken)\n+\tif err != nil {\n+\t\t_, _ = fmt.Fprintf(s, \"SSH connection failed: %v\\n\", err)\n+\t\t_ = s.Exit(1)\n+\t\treturn\n+\t}\n+\tdefer func() {\n+\t\tif err := sshClient.Close(); err != nil {\n+\t\t\tlog.Debugf(\"close SSH client: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tserverSession, err := sshClient.NewSession()\n+\tif err != nil {\n+\t\t_, _ = fmt.Fprintf(s, \"create server session: %v\\n\", err)\n+\t\t_ = s.Exit(1)\n+\t\treturn\n+\t}\n+\tdefer func() {\n+\t\tif err := serverSession.Close(); err != nil {\n+\t\t\tlog.Debugf(\"close server session: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tstdin, stdout, err := p.setupSFTPPipes(serverSession)\n+\tif err != nil {\n+\t\tlog.Debugf(\"setup SFTP pipes: %v\", err)\n+\t\t_ = s.Exit(1)\n+\t\treturn\n+\t}\n+\n+\tif err := serverSession.RequestSubsystem(\"sftp\"); err != nil {\n+\t\t_, _ = fmt.Fprintf(s, \"SFTP subsystem request failed: %v\\n\", err)\n+\t\t_ = s.Exit(1)\n+\t\treturn\n+\t}\n+\n+\tp.runSFTPBridge(ctx, s, stdin, stdout, serverSession)\n+}\n+\n+func (p *SSHProxy) setupSFTPPipes(serverSession *cryptossh.Session) (io.WriteCloser, io.Reader, error) {\n+\tstdin, err := serverSession.StdinPipe()\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"get stdin pipe: %w\", err)\n+\t}\n+\n+\tstdout, err := serverSession.StdoutPipe()\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"get stdout pipe: %w\", err)\n+\t}\n+\n+\treturn stdin, stdout, nil\n+}\n+\n+func (p *SSHProxy) runSFTPBridge(ctx context.Context, s ssh.Session, stdin io.WriteCloser, stdout io.Reader, serverSession *cryptossh.Session) {\n+\tcopyErrCh := make(chan error, 2)\n+\n+\tgo func() {\n+\t\t_, err := io.Copy(stdin, s)\n+\t\tif err != nil {\n+\t\t\tlog.Debugf(\"SFTP client to server copy: %v\", err)\n+\t\t}\n+\t\tif err := stdin.Close(); err != nil {\n+\t\t\tlog.Debugf(\"close stdin: %v\", err)\n+\t\t}\n+\t\tcopyErrCh <- err\n+\t}()\n+\n+\tgo func() {\n+\t\t_, err := io.Copy(s, stdout)\n+\t\tif err != nil {\n+\t\t\tlog.Debugf(\"SFTP server to client copy: %v\", err)\n+\t\t}\n+\t\tcopyErrCh <- err\n+\t}()\n+\n+\tgo func() {\n+\t\t<-ctx.Done()\n+\t\tif err := serverSession.Close(); err != nil {\n+\t\t\tlog.Debugf(\"force close server session on context cancellation: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tfor i := 0; i < 2; i++ {\n+\t\tif err := <-copyErrCh; err != nil && !errors.Is(err, io.EOF) {\n+\t\t\tlog.Debugf(\"SFTP copy error: %v\", err)\n+\t\t}\n+\t}\n+\n+\tif err := serverSession.Wait(); err != nil {\n+\t\tlog.Debugf(\"SFTP session ended: %v\", err)\n+\t}\n+}\n+\n+func (p *SSHProxy) tcpipForwardHandler(_ ssh.Context, _ *ssh.Server, _ *cryptossh.Request) (bool, []byte) {\n+\treturn false, []byte(\"port forwarding not supported in proxy\")\n+}\n+\n+func (p *SSHProxy) cancelTcpipForwardHandler(_ ssh.Context, _ *ssh.Server, _ *cryptossh.Request) (bool, []byte) {\n+\treturn true, nil\n+}\n+\n+func (p *SSHProxy) dialBackend(ctx context.Context, addr, user, jwtToken string) (*cryptossh.Client, error) {\n+\tconfig := &cryptossh.ClientConfig{\n+\t\tUser:            user,\n+\t\tAuth:            []cryptossh.AuthMethod{cryptossh.Password(jwtToken)},\n+\t\tTimeout:         sshHandshakeTimeout,\n+\t\tHostKeyCallback: p.verifyHostKey,\n+\t}\n+\n+\tdialer := &net.Dialer{\n+\t\tTimeout: sshConnectionTimeout,\n+\t}\n+\tconn, err := dialer.DialContext(ctx, \"tcp\", addr)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"connect to server: %w\", err)\n+\t}\n+\n+\tclientConn, chans, reqs, err := cryptossh.NewClientConn(conn, addr, config)\n+\tif err != nil {\n+\t\t_ = conn.Close()\n+\t\treturn nil, fmt.Errorf(\"SSH handshake: %w\", err)\n+\t}\n+\n+\treturn cryptossh.NewClient(clientConn, chans, reqs), nil\n+}\n+\n+func (p *SSHProxy) verifyHostKey(hostname string, remote net.Addr, key cryptossh.PublicKey) error {\n+\tverifier := nbssh.NewDaemonHostKeyVerifier(p.daemonClient)\n+\tcallback := nbssh.CreateHostKeyCallback(verifier)\n+\treturn callback(hostname, remote, key)\n+}\ndiff --git a/client/ssh/server.go b/client/ssh/server.go\ndeleted file mode 100644\nindex 8c5db2547cd..00000000000\n--- a/client/ssh/server.go\n+++ /dev/null\n@@ -1,280 +0,0 @@\n-//go:build !js\n-\n-package ssh\n-\n-import (\n-\t\"fmt\"\n-\t\"io\"\n-\t\"net\"\n-\t\"os\"\n-\t\"os/exec\"\n-\t\"os/user\"\n-\t\"runtime\"\n-\t\"strings\"\n-\t\"sync\"\n-\t\"time\"\n-\n-\t\"github.com/creack/pty\"\n-\t\"github.com/gliderlabs/ssh\"\n-\tlog \"github.com/sirupsen/logrus\"\n-)\n-\n-// DefaultSSHPort is the default SSH port of the NetBird's embedded SSH server\n-const DefaultSSHPort = 44338\n-\n-// TerminalTimeout is the timeout for terminal session to be ready\n-const TerminalTimeout = 10 * time.Second\n-\n-// TerminalBackoffDelay is the delay between terminal session readiness checks\n-const TerminalBackoffDelay = 500 * time.Millisecond\n-\n-// DefaultSSHServer is a function that creates DefaultServer\n-func DefaultSSHServer(hostKeyPEM []byte, addr string) (Server, error) {\n-\treturn newDefaultServer(hostKeyPEM, addr)\n-}\n-\n-// Server is an interface of SSH server\n-type Server interface {\n-\t// Stop stops SSH server.\n-\tStop() error\n-\t// Start starts SSH server. Blocking\n-\tStart() error\n-\t// RemoveAuthorizedKey removes SSH key of a given peer from the authorized keys\n-\tRemoveAuthorizedKey(peer string)\n-\t// AddAuthorizedKey add a given peer key to server authorized keys\n-\tAddAuthorizedKey(peer, newKey string) error\n-}\n-\n-// DefaultServer is the embedded NetBird SSH server\n-type DefaultServer struct {\n-\tlistener net.Listener\n-\t// authorizedKeys is ssh pub key indexed by peer WireGuard public key\n-\tauthorizedKeys map[string]ssh.PublicKey\n-\tmu             sync.Mutex\n-\thostKeyPEM     []byte\n-\tsessions       []ssh.Session\n-}\n-\n-// newDefaultServer creates new server with provided host key\n-func newDefaultServer(hostKeyPEM []byte, addr string) (*DefaultServer, error) {\n-\tln, err := net.Listen(\"tcp\", addr)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tallowedKeys := make(map[string]ssh.PublicKey)\n-\treturn &DefaultServer{listener: ln, mu: sync.Mutex{}, hostKeyPEM: hostKeyPEM, authorizedKeys: allowedKeys, sessions: make([]ssh.Session, 0)}, nil\n-}\n-\n-// RemoveAuthorizedKey removes SSH key of a given peer from the authorized keys\n-func (srv *DefaultServer) RemoveAuthorizedKey(peer string) {\n-\tsrv.mu.Lock()\n-\tdefer srv.mu.Unlock()\n-\n-\tdelete(srv.authorizedKeys, peer)\n-}\n-\n-// AddAuthorizedKey add a given peer key to server authorized keys\n-func (srv *DefaultServer) AddAuthorizedKey(peer, newKey string) error {\n-\tsrv.mu.Lock()\n-\tdefer srv.mu.Unlock()\n-\n-\tparsedKey, _, _, _, err := ssh.ParseAuthorizedKey([]byte(newKey))\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\tsrv.authorizedKeys[peer] = parsedKey\n-\treturn nil\n-}\n-\n-// Stop stops SSH server.\n-func (srv *DefaultServer) Stop() error {\n-\tsrv.mu.Lock()\n-\tdefer srv.mu.Unlock()\n-\terr := srv.listener.Close()\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tfor _, session := range srv.sessions {\n-\t\terr := session.Close()\n-\t\tif err != nil {\n-\t\t\tlog.Warnf(\"failed closing SSH session from %v\", err)\n-\t\t}\n-\t}\n-\n-\treturn nil\n-}\n-\n-func (srv *DefaultServer) publicKeyHandler(ctx ssh.Context, key ssh.PublicKey) bool {\n-\tsrv.mu.Lock()\n-\tdefer srv.mu.Unlock()\n-\n-\tfor _, allowed := range srv.authorizedKeys {\n-\t\tif ssh.KeysEqual(allowed, key) {\n-\t\t\treturn true\n-\t\t}\n-\t}\n-\n-\treturn false\n-}\n-\n-func prepareUserEnv(user *user.User, shell string) []string {\n-\treturn []string{\n-\t\tfmt.Sprint(\"SHELL=\" + shell),\n-\t\tfmt.Sprint(\"USER=\" + user.Username),\n-\t\tfmt.Sprint(\"HOME=\" + user.HomeDir),\n-\t}\n-}\n-\n-func acceptEnv(s string) bool {\n-\tsplit := strings.Split(s, \"=\")\n-\tif len(split) != 2 {\n-\t\treturn false\n-\t}\n-\treturn split[0] == \"TERM\" || split[0] == \"LANG\" || strings.HasPrefix(split[0], \"LC_\")\n-}\n-\n-// sessionHandler handles SSH session post auth\n-func (srv *DefaultServer) sessionHandler(session ssh.Session) {\n-\tsrv.mu.Lock()\n-\tsrv.sessions = append(srv.sessions, session)\n-\tsrv.mu.Unlock()\n-\n-\tdefer func() {\n-\t\terr := session.Close()\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t}()\n-\n-\tlog.Infof(\"Establishing SSH session for %s from host %s\", session.User(), session.RemoteAddr().String())\n-\n-\tlocalUser, err := userNameLookup(session.User())\n-\tif err != nil {\n-\t\t_, err = fmt.Fprintf(session, \"remote SSH server couldn't find local user %s\\n\", session.User()) //nolint\n-\t\terr = session.Exit(1)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tlog.Warnf(\"failed SSH session from %v, user %s\", session.RemoteAddr(), session.User())\n-\t\treturn\n-\t}\n-\n-\tptyReq, winCh, isPty := session.Pty()\n-\tif isPty {\n-\t\tloginCmd, loginArgs, err := getLoginCmd(localUser.Username, session.RemoteAddr())\n-\t\tif err != nil {\n-\t\t\tlog.Warnf(\"failed logging-in user %s from remote IP %s\", localUser.Username, session.RemoteAddr().String())\n-\t\t\treturn\n-\t\t}\n-\t\tcmd := exec.Command(loginCmd, loginArgs...)\n-\t\tgo func() {\n-\t\t\t<-session.Context().Done()\n-\t\t\tif cmd.Process == nil {\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\terr := cmd.Process.Kill()\n-\t\t\tif err != nil {\n-\t\t\t\tlog.Debugf(\"failed killing SSH process %v\", err)\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t}()\n-\t\tcmd.Dir = localUser.HomeDir\n-\t\tcmd.Env = append(cmd.Env, fmt.Sprintf(\"TERM=%s\", ptyReq.Term))\n-\t\tcmd.Env = append(cmd.Env, prepareUserEnv(localUser, getUserShell(localUser.Uid))...)\n-\t\tfor _, v := range session.Environ() {\n-\t\t\tif acceptEnv(v) {\n-\t\t\t\tcmd.Env = append(cmd.Env, v)\n-\t\t\t}\n-\t\t}\n-\n-\t\tlog.Debugf(\"Login command: %s\", cmd.String())\n-\t\tfile, err := pty.Start(cmd)\n-\t\tif err != nil {\n-\t\t\tlog.Errorf(\"failed starting SSH server: %v\", err)\n-\t\t}\n-\n-\t\tgo func() {\n-\t\t\tfor win := range winCh {\n-\t\t\t\tsetWinSize(file, win.Width, win.Height)\n-\t\t\t}\n-\t\t}()\n-\n-\t\tsrv.stdInOut(file, session)\n-\n-\t\terr = cmd.Wait()\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t} else {\n-\t\t_, err := io.WriteString(session, \"only PTY is supported.\\n\")\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\terr = session.Exit(1)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t}\n-\tlog.Debugf(\"SSH session ended\")\n-}\n-\n-func (srv *DefaultServer) stdInOut(file *os.File, session ssh.Session) {\n-\tgo func() {\n-\t\t// stdin\n-\t\t_, err := io.Copy(file, session)\n-\t\tif err != nil {\n-\t\t\t_ = session.Exit(1)\n-\t\t\treturn\n-\t\t}\n-\t}()\n-\n-\t// AWS Linux 2 machines need some time to open the terminal so we need to wait for it\n-\ttimer := time.NewTimer(TerminalTimeout)\n-\tfor {\n-\t\tselect {\n-\t\tcase <-timer.C:\n-\t\t\t_, _ = session.Write([]byte(\"Reached timeout while opening connection\\n\"))\n-\t\t\t_ = session.Exit(1)\n-\t\t\treturn\n-\t\tdefault:\n-\t\t\t// stdout\n-\t\t\twrittenBytes, err := io.Copy(session, file)\n-\t\t\tif err != nil && writtenBytes != 0 {\n-\t\t\t\t_ = session.Exit(0)\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\ttime.Sleep(TerminalBackoffDelay)\n-\t\t}\n-\t}\n-}\n-\n-// Start starts SSH server. Blocking\n-func (srv *DefaultServer) Start() error {\n-\tlog.Infof(\"starting SSH server on addr: %s\", srv.listener.Addr().String())\n-\n-\tpublicKeyOption := ssh.PublicKeyAuth(srv.publicKeyHandler)\n-\thostKeyPEM := ssh.HostKeyPEM(srv.hostKeyPEM)\n-\terr := ssh.Serve(srv.listener, srv.sessionHandler, publicKeyOption, hostKeyPEM)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\treturn nil\n-}\n-\n-func getUserShell(userID string) string {\n-\tif runtime.GOOS == \"linux\" {\n-\t\toutput, _ := exec.Command(\"getent\", \"passwd\", userID).Output()\n-\t\tline := strings.SplitN(string(output), \":\", 10)\n-\t\tif len(line) > 6 {\n-\t\t\treturn strings.TrimSpace(line[6])\n-\t\t}\n-\t}\n-\n-\tshell := os.Getenv(\"SHELL\")\n-\tif shell == \"\" {\n-\t\tshell = \"/bin/sh\"\n-\t}\n-\treturn shell\n-}\ndiff --git a/client/ssh/server/command_execution.go b/client/ssh/server/command_execution.go\nnew file mode 100644\nindex 00000000000..7a01ce4f665\n--- /dev/null\n+++ b/client/ssh/server/command_execution.go\n@@ -0,0 +1,206 @@\n+package server\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"time\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+)\n+\n+// handleCommand executes an SSH command with privilege validation\n+func (s *Server) handleCommand(logger *log.Entry, session ssh.Session, privilegeResult PrivilegeCheckResult, winCh <-chan ssh.Window) {\n+\thasPty := winCh != nil\n+\n+\tcommandType := \"command\"\n+\tif hasPty {\n+\t\tcommandType = \"Pty command\"\n+\t}\n+\n+\tlogger.Infof(\"executing %s: %s\", commandType, safeLogCommand(session.Command()))\n+\n+\texecCmd, cleanup, err := s.createCommand(privilegeResult, session, hasPty)\n+\tif err != nil {\n+\t\tlogger.Errorf(\"%s creation failed: %v\", commandType, err)\n+\n+\t\terrorMsg := fmt.Sprintf(\"Cannot create %s - platform may not support user switching\", commandType)\n+\t\tif hasPty {\n+\t\t\terrorMsg += \" with Pty\"\n+\t\t}\n+\t\terrorMsg += \"\\n\"\n+\n+\t\tif _, writeErr := fmt.Fprint(session.Stderr(), errorMsg); writeErr != nil {\n+\t\t\tlogger.Debugf(errWriteSession, writeErr)\n+\t\t}\n+\t\tif err := session.Exit(1); err != nil {\n+\t\t\tlogSessionExitError(logger, err)\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tif !hasPty {\n+\t\tif s.executeCommand(logger, session, execCmd, cleanup) {\n+\t\t\tlogger.Debugf(\"%s execution completed\", commandType)\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tdefer cleanup()\n+\n+\tptyReq, _, _ := session.Pty()\n+\tif s.executeCommandWithPty(logger, session, execCmd, privilegeResult, ptyReq, winCh) {\n+\t\tlogger.Debugf(\"%s execution completed\", commandType)\n+\t}\n+}\n+\n+func (s *Server) createCommand(privilegeResult PrivilegeCheckResult, session ssh.Session, hasPty bool) (*exec.Cmd, func(), error) {\n+\tlocalUser := privilegeResult.User\n+\tif localUser == nil {\n+\t\treturn nil, nil, errors.New(\"no user in privilege result\")\n+\t}\n+\n+\t// If PTY requested but su doesn't support --pty, skip su and use executor\n+\t// This ensures PTY functionality is provided (executor runs within our allocated PTY)\n+\tif hasPty && !s.suSupportsPty {\n+\t\tlog.Debugf(\"PTY requested but su doesn't support --pty, using executor for PTY functionality\")\n+\t\tcmd, cleanup, err := s.createExecutorCommand(session, localUser, hasPty)\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"create command with privileges: %w\", err)\n+\t\t}\n+\t\tcmd.Env = s.prepareCommandEnv(localUser, session)\n+\t\treturn cmd, cleanup, nil\n+\t}\n+\n+\t// Try su first for system integration (PAM/audit) when privileged\n+\tcmd, err := s.createSuCommand(session, localUser, hasPty)\n+\tif err != nil || privilegeResult.UsedFallback {\n+\t\tlog.Debugf(\"su command failed, falling back to executor: %v\", err)\n+\t\tcmd, cleanup, err := s.createExecutorCommand(session, localUser, hasPty)\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"create command with privileges: %w\", err)\n+\t\t}\n+\t\tcmd.Env = s.prepareCommandEnv(localUser, session)\n+\t\treturn cmd, cleanup, nil\n+\t}\n+\n+\tcmd.Env = s.prepareCommandEnv(localUser, session)\n+\treturn cmd, func() {}, nil\n+}\n+\n+// executeCommand executes the command and handles I/O and exit codes\n+func (s *Server) executeCommand(logger *log.Entry, session ssh.Session, execCmd *exec.Cmd, cleanup func()) bool {\n+\tdefer cleanup()\n+\n+\ts.setupProcessGroup(execCmd)\n+\n+\tstdinPipe, err := execCmd.StdinPipe()\n+\tif err != nil {\n+\t\tlogger.Errorf(\"create stdin pipe: %v\", err)\n+\t\tif err := session.Exit(1); err != nil {\n+\t\t\tlogSessionExitError(logger, err)\n+\t\t}\n+\t\treturn false\n+\t}\n+\n+\texecCmd.Stdout = session\n+\texecCmd.Stderr = session.Stderr()\n+\n+\tif execCmd.Dir != \"\" {\n+\t\tif _, err := os.Stat(execCmd.Dir); err != nil {\n+\t\t\tlogger.Warnf(\"working directory does not exist: %s (%v)\", execCmd.Dir, err)\n+\t\t\texecCmd.Dir = \"/\"\n+\t\t}\n+\t}\n+\n+\tif err := execCmd.Start(); err != nil {\n+\t\tlogger.Errorf(\"command start failed: %v\", err)\n+\t\t// no user message for exec failure, just exit\n+\t\tif err := session.Exit(1); err != nil {\n+\t\t\tlogSessionExitError(logger, err)\n+\t\t}\n+\t\treturn false\n+\t}\n+\n+\tgo s.handleCommandIO(logger, stdinPipe, session)\n+\treturn s.waitForCommandCleanup(logger, session, execCmd)\n+}\n+\n+// handleCommandIO manages stdin/stdout copying in a goroutine\n+func (s *Server) handleCommandIO(logger *log.Entry, stdinPipe io.WriteCloser, session ssh.Session) {\n+\tdefer func() {\n+\t\tif err := stdinPipe.Close(); err != nil {\n+\t\t\tlogger.Debugf(\"stdin pipe close error: %v\", err)\n+\t\t}\n+\t}()\n+\tif _, err := io.Copy(stdinPipe, session); err != nil {\n+\t\tlogger.Debugf(\"stdin copy error: %v\", err)\n+\t}\n+}\n+\n+// waitForCommandCleanup waits for command completion with session disconnect handling\n+func (s *Server) waitForCommandCleanup(logger *log.Entry, session ssh.Session, execCmd *exec.Cmd) bool {\n+\tctx := session.Context()\n+\tdone := make(chan error, 1)\n+\tgo func() {\n+\t\tdone <- execCmd.Wait()\n+\t}()\n+\n+\tselect {\n+\tcase <-ctx.Done():\n+\t\tlogger.Debugf(\"session cancelled, terminating command\")\n+\t\ts.killProcessGroup(execCmd)\n+\n+\t\tselect {\n+\t\tcase err := <-done:\n+\t\t\tlogger.Tracef(\"command terminated after session cancellation: %v\", err)\n+\t\tcase <-time.After(5 * time.Second):\n+\t\t\tlogger.Warnf(\"command did not terminate within 5 seconds after session cancellation\")\n+\t\t}\n+\n+\t\tif err := session.Exit(130); err != nil {\n+\t\t\tlogSessionExitError(logger, err)\n+\t\t}\n+\t\treturn false\n+\n+\tcase err := <-done:\n+\t\treturn s.handleCommandCompletion(logger, session, err)\n+\t}\n+}\n+\n+// handleCommandCompletion handles command completion\n+func (s *Server) handleCommandCompletion(logger *log.Entry, session ssh.Session, err error) bool {\n+\tif err != nil {\n+\t\tlogger.Debugf(\"command execution failed: %v\", err)\n+\t\ts.handleSessionExit(session, err, logger)\n+\t\treturn false\n+\t}\n+\n+\ts.handleSessionExit(session, nil, logger)\n+\treturn true\n+}\n+\n+// handleSessionExit handles command errors and sets appropriate exit codes\n+func (s *Server) handleSessionExit(session ssh.Session, err error, logger *log.Entry) {\n+\tif err == nil {\n+\t\tif err := session.Exit(0); err != nil {\n+\t\t\tlogSessionExitError(logger, err)\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tvar exitError *exec.ExitError\n+\tif errors.As(err, &exitError) {\n+\t\tif err := session.Exit(exitError.ExitCode()); err != nil {\n+\t\t\tlogSessionExitError(logger, err)\n+\t\t}\n+\t} else {\n+\t\tlogger.Debugf(\"non-exit error in command execution: %v\", err)\n+\t\tif err := session.Exit(1); err != nil {\n+\t\t\tlogSessionExitError(logger, err)\n+\t\t}\n+\t}\n+}\ndiff --git a/client/ssh/server/command_execution_js.go b/client/ssh/server/command_execution_js.go\nnew file mode 100644\nindex 00000000000..6473f827354\n--- /dev/null\n+++ b/client/ssh/server/command_execution_js.go\n@@ -0,0 +1,52 @@\n+//go:build js\n+\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"os/exec\"\n+\t\"os/user\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+)\n+\n+var errNotSupported = errors.New(\"SSH server command execution not supported on WASM/JS platform\")\n+\n+// createSuCommand is not supported on JS/WASM\n+func (s *Server) createSuCommand(_ ssh.Session, _ *user.User, _ bool) (*exec.Cmd, error) {\n+\treturn nil, errNotSupported\n+}\n+\n+// createExecutorCommand is not supported on JS/WASM\n+func (s *Server) createExecutorCommand(_ ssh.Session, _ *user.User, _ bool) (*exec.Cmd, func(), error) {\n+\treturn nil, nil, errNotSupported\n+}\n+\n+// prepareCommandEnv is not supported on JS/WASM\n+func (s *Server) prepareCommandEnv(_ *user.User, _ ssh.Session) []string {\n+\treturn nil\n+}\n+\n+// setupProcessGroup is not supported on JS/WASM\n+func (s *Server) setupProcessGroup(_ *exec.Cmd) {\n+}\n+\n+// killProcessGroup is not supported on JS/WASM\n+func (s *Server) killProcessGroup(*exec.Cmd) {\n+}\n+\n+// detectSuPtySupport always returns false on JS/WASM\n+func (s *Server) detectSuPtySupport(context.Context) bool {\n+\treturn false\n+}\n+\n+// executeCommandWithPty is not supported on JS/WASM\n+func (s *Server) executeCommandWithPty(logger *log.Entry, session ssh.Session, execCmd *exec.Cmd, privilegeResult PrivilegeCheckResult, ptyReq ssh.Pty, winCh <-chan ssh.Window) bool {\n+\tlogger.Errorf(\"PTY command execution not supported on JS/WASM\")\n+\tif err := session.Exit(1); err != nil {\n+\t\tlogSessionExitError(logger, err)\n+\t}\n+\treturn false\n+}\ndiff --git a/client/ssh/server/command_execution_unix.go b/client/ssh/server/command_execution_unix.go\nnew file mode 100644\nindex 00000000000..da059fed9fc\n--- /dev/null\n+++ b/client/ssh/server/command_execution_unix.go\n@@ -0,0 +1,329 @@\n+//go:build unix\n+\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"os/user\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"syscall\"\n+\t\"time\"\n+\n+\t\"github.com/creack/pty\"\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+)\n+\n+// ptyManager manages Pty file operations with thread safety\n+type ptyManager struct {\n+\tfile     *os.File\n+\tmu       sync.RWMutex\n+\tclosed   bool\n+\tcloseErr error\n+\tonce     sync.Once\n+}\n+\n+func newPtyManager(file *os.File) *ptyManager {\n+\treturn &ptyManager{file: file}\n+}\n+\n+func (pm *ptyManager) Close() error {\n+\tpm.once.Do(func() {\n+\t\tpm.mu.Lock()\n+\t\tpm.closed = true\n+\t\tpm.closeErr = pm.file.Close()\n+\t\tpm.mu.Unlock()\n+\t})\n+\tpm.mu.RLock()\n+\tdefer pm.mu.RUnlock()\n+\treturn pm.closeErr\n+}\n+\n+func (pm *ptyManager) Setsize(ws *pty.Winsize) error {\n+\tpm.mu.RLock()\n+\tdefer pm.mu.RUnlock()\n+\tif pm.closed {\n+\t\treturn errors.New(\"pty is closed\")\n+\t}\n+\treturn pty.Setsize(pm.file, ws)\n+}\n+\n+func (pm *ptyManager) File() *os.File {\n+\treturn pm.file\n+}\n+\n+// detectSuPtySupport checks if su supports the --pty flag\n+func (s *Server) detectSuPtySupport(ctx context.Context) bool {\n+\tctx, cancel := context.WithTimeout(ctx, 500*time.Millisecond)\n+\tdefer cancel()\n+\n+\tcmd := exec.CommandContext(ctx, \"su\", \"--help\")\n+\toutput, err := cmd.CombinedOutput()\n+\tif err != nil {\n+\t\tlog.Debugf(\"su --help failed (may not support --help): %v\", err)\n+\t\treturn false\n+\t}\n+\n+\tsupported := strings.Contains(string(output), \"--pty\")\n+\tlog.Debugf(\"su --pty support detected: %v\", supported)\n+\treturn supported\n+}\n+\n+// createSuCommand creates a command using su -l -c for privilege switching\n+func (s *Server) createSuCommand(session ssh.Session, localUser *user.User, hasPty bool) (*exec.Cmd, error) {\n+\tsuPath, err := exec.LookPath(\"su\")\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"su command not available: %w\", err)\n+\t}\n+\n+\tcommand := session.RawCommand()\n+\tif command == \"\" {\n+\t\treturn nil, fmt.Errorf(\"no command specified for su execution\")\n+\t}\n+\n+\targs := []string{\"-l\"}\n+\tif hasPty && s.suSupportsPty {\n+\t\targs = append(args, \"--pty\")\n+\t}\n+\targs = append(args, localUser.Username, \"-c\", command)\n+\n+\tcmd := exec.CommandContext(session.Context(), suPath, args...)\n+\tcmd.Dir = localUser.HomeDir\n+\n+\treturn cmd, nil\n+}\n+\n+// getShellCommandArgs returns the shell command and arguments for executing a command string\n+func (s *Server) getShellCommandArgs(shell, cmdString string) []string {\n+\tif cmdString == \"\" {\n+\t\treturn []string{shell, \"-l\"}\n+\t}\n+\treturn []string{shell, \"-l\", \"-c\", cmdString}\n+}\n+\n+// prepareCommandEnv prepares environment variables for command execution on Unix\n+func (s *Server) prepareCommandEnv(localUser *user.User, session ssh.Session) []string {\n+\tenv := prepareUserEnv(localUser, getUserShell(localUser.Uid))\n+\tenv = append(env, prepareSSHEnv(session)...)\n+\tfor _, v := range session.Environ() {\n+\t\tif acceptEnv(v) {\n+\t\t\tenv = append(env, v)\n+\t\t}\n+\t}\n+\treturn env\n+}\n+\n+// executeCommandWithPty executes a command with PTY allocation\n+func (s *Server) executeCommandWithPty(logger *log.Entry, session ssh.Session, execCmd *exec.Cmd, privilegeResult PrivilegeCheckResult, ptyReq ssh.Pty, winCh <-chan ssh.Window) bool {\n+\ttermType := ptyReq.Term\n+\tif termType == \"\" {\n+\t\ttermType = \"xterm-256color\"\n+\t}\n+\texecCmd.Env = append(execCmd.Env, fmt.Sprintf(\"TERM=%s\", termType))\n+\n+\treturn s.runPtyCommand(logger, session, execCmd, ptyReq, winCh)\n+}\n+\n+func (s *Server) handlePty(logger *log.Entry, session ssh.Session, privilegeResult PrivilegeCheckResult, ptyReq ssh.Pty, winCh <-chan ssh.Window) bool {\n+\texecCmd, err := s.createPtyCommand(privilegeResult, ptyReq, session)\n+\tif err != nil {\n+\t\tlogger.Errorf(\"Pty command creation failed: %v\", err)\n+\t\terrorMsg := \"User switching failed - login command not available\\r\\n\"\n+\t\tif _, writeErr := fmt.Fprint(session.Stderr(), errorMsg); writeErr != nil {\n+\t\t\tlogger.Debugf(errWriteSession, writeErr)\n+\t\t}\n+\t\tif err := session.Exit(1); err != nil {\n+\t\t\tlogSessionExitError(logger, err)\n+\t\t}\n+\t\treturn false\n+\t}\n+\n+\tlogger.Infof(\"starting interactive shell: %s\", execCmd.Path)\n+\treturn s.runPtyCommand(logger, session, execCmd, ptyReq, winCh)\n+}\n+\n+// runPtyCommand runs a command with PTY management (common code for interactive and command execution)\n+func (s *Server) runPtyCommand(logger *log.Entry, session ssh.Session, execCmd *exec.Cmd, ptyReq ssh.Pty, winCh <-chan ssh.Window) bool {\n+\tptmx, err := s.startPtyCommandWithSize(execCmd, ptyReq)\n+\tif err != nil {\n+\t\tlogger.Errorf(\"Pty start failed: %v\", err)\n+\t\tif err := session.Exit(1); err != nil {\n+\t\t\tlogSessionExitError(logger, err)\n+\t\t}\n+\t\treturn false\n+\t}\n+\n+\tptyMgr := newPtyManager(ptmx)\n+\tdefer func() {\n+\t\tif err := ptyMgr.Close(); err != nil {\n+\t\t\tlogger.Debugf(\"Pty close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tgo s.handlePtyWindowResize(logger, session, ptyMgr, winCh)\n+\ts.handlePtyIO(logger, session, ptyMgr)\n+\ts.waitForPtyCompletion(logger, session, execCmd, ptyMgr)\n+\treturn true\n+}\n+\n+func (s *Server) startPtyCommandWithSize(execCmd *exec.Cmd, ptyReq ssh.Pty) (*os.File, error) {\n+\twinSize := &pty.Winsize{\n+\t\tCols: uint16(ptyReq.Window.Width),\n+\t\tRows: uint16(ptyReq.Window.Height),\n+\t}\n+\tif winSize.Cols == 0 {\n+\t\twinSize.Cols = 80\n+\t}\n+\tif winSize.Rows == 0 {\n+\t\twinSize.Rows = 24\n+\t}\n+\n+\tptmx, err := pty.StartWithSize(execCmd, winSize)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"start Pty: %w\", err)\n+\t}\n+\n+\treturn ptmx, nil\n+}\n+\n+func (s *Server) handlePtyWindowResize(logger *log.Entry, session ssh.Session, ptyMgr *ptyManager, winCh <-chan ssh.Window) {\n+\tfor {\n+\t\tselect {\n+\t\tcase <-session.Context().Done():\n+\t\t\treturn\n+\t\tcase win, ok := <-winCh:\n+\t\t\tif !ok {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif err := ptyMgr.Setsize(&pty.Winsize{Rows: uint16(win.Height), Cols: uint16(win.Width)}); err != nil {\n+\t\t\t\tlogger.Debugf(\"Pty resize to %dx%d: %v\", win.Width, win.Height, err)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func (s *Server) handlePtyIO(logger *log.Entry, session ssh.Session, ptyMgr *ptyManager) {\n+\tptmx := ptyMgr.File()\n+\n+\tgo func() {\n+\t\tif _, err := io.Copy(ptmx, session); err != nil {\n+\t\t\tif !errors.Is(err, io.EOF) && !errors.Is(err, syscall.EIO) {\n+\t\t\t\tlogger.Warnf(\"Pty input copy error: %v\", err)\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n+\tgo func() {\n+\t\tdefer func() {\n+\t\t\tif err := session.Close(); err != nil && !errors.Is(err, io.EOF) {\n+\t\t\t\tlogger.Debugf(\"session close error: %v\", err)\n+\t\t\t}\n+\t\t}()\n+\t\tif _, err := io.Copy(session, ptmx); err != nil {\n+\t\t\tif !errors.Is(err, io.EOF) && !errors.Is(err, syscall.EIO) {\n+\t\t\t\tlogger.Warnf(\"Pty output copy error: %v\", err)\n+\t\t\t}\n+\t\t}\n+\t}()\n+}\n+\n+func (s *Server) waitForPtyCompletion(logger *log.Entry, session ssh.Session, execCmd *exec.Cmd, ptyMgr *ptyManager) {\n+\tctx := session.Context()\n+\tdone := make(chan error, 1)\n+\tgo func() {\n+\t\tdone <- execCmd.Wait()\n+\t}()\n+\n+\tselect {\n+\tcase <-ctx.Done():\n+\t\ts.handlePtySessionCancellation(logger, session, execCmd, ptyMgr, done)\n+\tcase err := <-done:\n+\t\ts.handlePtyCommandCompletion(logger, session, err)\n+\t}\n+}\n+\n+func (s *Server) handlePtySessionCancellation(logger *log.Entry, session ssh.Session, execCmd *exec.Cmd, ptyMgr *ptyManager, done <-chan error) {\n+\tlogger.Debugf(\"Pty session cancelled, terminating command\")\n+\tif err := ptyMgr.Close(); err != nil {\n+\t\tlogger.Debugf(\"Pty close during session cancellation: %v\", err)\n+\t}\n+\n+\ts.killProcessGroup(execCmd)\n+\n+\tselect {\n+\tcase err := <-done:\n+\t\tif err != nil {\n+\t\t\tlogger.Debugf(\"Pty command terminated after session cancellation with error: %v\", err)\n+\t\t} else {\n+\t\t\tlogger.Debugf(\"Pty command terminated after session cancellation\")\n+\t\t}\n+\tcase <-time.After(5 * time.Second):\n+\t\tlogger.Warnf(\"Pty command did not terminate within 5 seconds after session cancellation\")\n+\t}\n+\n+\tif err := session.Exit(130); err != nil {\n+\t\tlogSessionExitError(logger, err)\n+\t}\n+}\n+\n+func (s *Server) handlePtyCommandCompletion(logger *log.Entry, session ssh.Session, err error) {\n+\tif err != nil {\n+\t\tlogger.Debugf(\"Pty command execution failed: %v\", err)\n+\t\ts.handleSessionExit(session, err, logger)\n+\t\treturn\n+\t}\n+\n+\t// Normal completion\n+\tlogger.Debugf(\"Pty command completed successfully\")\n+\tif err := session.Exit(0); err != nil {\n+\t\tlogSessionExitError(logger, err)\n+\t}\n+}\n+\n+func (s *Server) setupProcessGroup(cmd *exec.Cmd) {\n+\tcmd.SysProcAttr = &syscall.SysProcAttr{\n+\t\tSetpgid: true,\n+\t}\n+}\n+\n+func (s *Server) killProcessGroup(cmd *exec.Cmd) {\n+\tif cmd.Process == nil {\n+\t\treturn\n+\t}\n+\n+\tlogger := log.WithField(\"pid\", cmd.Process.Pid)\n+\tpgid := cmd.Process.Pid\n+\n+\tif err := syscall.Kill(-pgid, syscall.SIGTERM); err != nil {\n+\t\tlogger.Debugf(\"kill process group SIGTERM: %v\", err)\n+\t\treturn\n+\t}\n+\n+\tconst gracePeriod = 500 * time.Millisecond\n+\tconst checkInterval = 50 * time.Millisecond\n+\n+\tticker := time.NewTicker(checkInterval)\n+\tdefer ticker.Stop()\n+\n+\ttimeout := time.After(gracePeriod)\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase <-timeout:\n+\t\t\tif err := syscall.Kill(-pgid, syscall.SIGKILL); err != nil {\n+\t\t\t\tlogger.Debugf(\"kill process group SIGKILL: %v\", err)\n+\t\t\t}\n+\t\t\treturn\n+\t\tcase <-ticker.C:\n+\t\t\tif err := syscall.Kill(-pgid, 0); err != nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+}\ndiff --git a/client/ssh/server/command_execution_windows.go b/client/ssh/server/command_execution_windows.go\nnew file mode 100644\nindex 00000000000..37b3ae0eefe\n--- /dev/null\n+++ b/client/ssh/server/command_execution_windows.go\n@@ -0,0 +1,430 @@\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"os/user\"\n+\t\"path/filepath\"\n+\t\"strings\"\n+\t\"unsafe\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"golang.org/x/sys/windows\"\n+\t\"golang.org/x/sys/windows/registry\"\n+\n+\t\"github.com/netbirdio/netbird/client/ssh/server/winpty\"\n+)\n+\n+// getUserEnvironment retrieves the Windows environment for the target user.\n+// Follows OpenSSH's resilient approach with graceful degradation on failures.\n+func (s *Server) getUserEnvironment(username, domain string) ([]string, error) {\n+\tuserToken, err := s.getUserToken(username, domain)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"get user token: %w\", err)\n+\t}\n+\tdefer func() {\n+\t\tif err := windows.CloseHandle(userToken); err != nil {\n+\t\t\tlog.Debugf(\"close user token: %v\", err)\n+\t\t}\n+\t}()\n+\n+\treturn s.getUserEnvironmentWithToken(userToken, username, domain)\n+}\n+\n+// getUserEnvironmentWithToken retrieves the Windows environment using an existing token.\n+func (s *Server) getUserEnvironmentWithToken(userToken windows.Handle, username, domain string) ([]string, error) {\n+\tuserProfile, err := s.loadUserProfile(userToken, username, domain)\n+\tif err != nil {\n+\t\tlog.Debugf(\"failed to load user profile for %s\\\\%s: %v\", domain, username, err)\n+\t\tuserProfile = fmt.Sprintf(\"C:\\\\Users\\\\%s\", username)\n+\t}\n+\n+\tenvMap := make(map[string]string)\n+\n+\tif err := s.loadSystemEnvironment(envMap); err != nil {\n+\t\tlog.Debugf(\"failed to load system environment from registry: %v\", err)\n+\t}\n+\n+\ts.setUserEnvironmentVariables(envMap, userProfile, username, domain)\n+\n+\tvar env []string\n+\tfor key, value := range envMap {\n+\t\tenv = append(env, key+\"=\"+value)\n+\t}\n+\n+\treturn env, nil\n+}\n+\n+// getUserToken creates a user token for the specified user.\n+func (s *Server) getUserToken(username, domain string) (windows.Handle, error) {\n+\tprivilegeDropper := NewPrivilegeDropper()\n+\ttoken, err := privilegeDropper.createToken(username, domain)\n+\tif err != nil {\n+\t\treturn 0, fmt.Errorf(\"generate S4U user token: %w\", err)\n+\t}\n+\treturn token, nil\n+}\n+\n+// loadUserProfile loads the Windows user profile and returns the profile path.\n+func (s *Server) loadUserProfile(userToken windows.Handle, username, domain string) (string, error) {\n+\tusernamePtr, err := windows.UTF16PtrFromString(username)\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"convert username to UTF-16: %w\", err)\n+\t}\n+\n+\tvar domainUTF16 *uint16\n+\tif domain != \"\" && domain != \".\" {\n+\t\tdomainUTF16, err = windows.UTF16PtrFromString(domain)\n+\t\tif err != nil {\n+\t\t\treturn \"\", fmt.Errorf(\"convert domain to UTF-16: %w\", err)\n+\t\t}\n+\t}\n+\n+\ttype profileInfo struct {\n+\t\tdwSize        uint32\n+\t\tdwFlags       uint32\n+\t\tlpUserName    *uint16\n+\t\tlpProfilePath *uint16\n+\t\tlpDefaultPath *uint16\n+\t\tlpServerName  *uint16\n+\t\tlpPolicyPath  *uint16\n+\t\thProfile      windows.Handle\n+\t}\n+\n+\tconst PI_NOUI = 0x00000001\n+\n+\tprofile := profileInfo{\n+\t\tdwSize:       uint32(unsafe.Sizeof(profileInfo{})),\n+\t\tdwFlags:      PI_NOUI,\n+\t\tlpUserName:   usernamePtr,\n+\t\tlpServerName: domainUTF16,\n+\t}\n+\n+\tuserenv := windows.NewLazySystemDLL(\"userenv.dll\")\n+\tloadUserProfileW := userenv.NewProc(\"LoadUserProfileW\")\n+\n+\tret, _, err := loadUserProfileW.Call(\n+\t\tuintptr(userToken),\n+\t\tuintptr(unsafe.Pointer(&profile)),\n+\t)\n+\n+\tif ret == 0 {\n+\t\treturn \"\", fmt.Errorf(\"LoadUserProfileW: %w\", err)\n+\t}\n+\n+\tif profile.lpProfilePath == nil {\n+\t\treturn \"\", fmt.Errorf(\"LoadUserProfileW returned null profile path\")\n+\t}\n+\n+\tprofilePath := windows.UTF16PtrToString(profile.lpProfilePath)\n+\treturn profilePath, nil\n+}\n+\n+// loadSystemEnvironment loads system-wide environment variables from registry.\n+func (s *Server) loadSystemEnvironment(envMap map[string]string) error {\n+\tkey, err := registry.OpenKey(registry.LOCAL_MACHINE,\n+\t\t`SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment`,\n+\t\tregistry.QUERY_VALUE)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"open system environment registry key: %w\", err)\n+\t}\n+\tdefer func() {\n+\t\tif err := key.Close(); err != nil {\n+\t\t\tlog.Debugf(\"close registry key: %v\", err)\n+\t\t}\n+\t}()\n+\n+\treturn s.readRegistryEnvironment(key, envMap)\n+}\n+\n+// readRegistryEnvironment reads environment variables from a registry key.\n+func (s *Server) readRegistryEnvironment(key registry.Key, envMap map[string]string) error {\n+\tnames, err := key.ReadValueNames(0)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"read registry value names: %w\", err)\n+\t}\n+\n+\tfor _, name := range names {\n+\t\tvalue, valueType, err := key.GetStringValue(name)\n+\t\tif err != nil {\n+\t\t\tlog.Debugf(\"failed to read registry value %s: %v\", name, err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tfinalValue := s.expandRegistryValue(value, valueType, name)\n+\t\ts.setEnvironmentVariable(envMap, name, finalValue)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// expandRegistryValue expands registry values if they contain environment variables.\n+func (s *Server) expandRegistryValue(value string, valueType uint32, name string) string {\n+\tif valueType != registry.EXPAND_SZ {\n+\t\treturn value\n+\t}\n+\n+\tsourcePtr := windows.StringToUTF16Ptr(value)\n+\texpandedBuffer := make([]uint16, 1024)\n+\texpandedLen, err := windows.ExpandEnvironmentStrings(sourcePtr, &expandedBuffer[0], uint32(len(expandedBuffer)))\n+\tif err != nil {\n+\t\tlog.Debugf(\"failed to expand environment string for %s: %v\", name, err)\n+\t\treturn value\n+\t}\n+\n+\t// If buffer was too small, retry with larger buffer\n+\tif expandedLen > uint32(len(expandedBuffer)) {\n+\t\texpandedBuffer = make([]uint16, expandedLen)\n+\t\texpandedLen, err = windows.ExpandEnvironmentStrings(sourcePtr, &expandedBuffer[0], uint32(len(expandedBuffer)))\n+\t\tif err != nil {\n+\t\t\tlog.Debugf(\"failed to expand environment string for %s on retry: %v\", name, err)\n+\t\t\treturn value\n+\t\t}\n+\t}\n+\n+\tif expandedLen > 0 && expandedLen <= uint32(len(expandedBuffer)) {\n+\t\treturn windows.UTF16ToString(expandedBuffer[:expandedLen-1])\n+\t}\n+\treturn value\n+}\n+\n+// setEnvironmentVariable sets an environment variable with special handling for PATH.\n+func (s *Server) setEnvironmentVariable(envMap map[string]string, name, value string) {\n+\tupperName := strings.ToUpper(name)\n+\n+\tif upperName == \"PATH\" {\n+\t\tif existing, exists := envMap[\"PATH\"]; exists && existing != value {\n+\t\t\tenvMap[\"PATH\"] = existing + \";\" + value\n+\t\t} else {\n+\t\t\tenvMap[\"PATH\"] = value\n+\t\t}\n+\t} else {\n+\t\tenvMap[upperName] = value\n+\t}\n+}\n+\n+// setUserEnvironmentVariables sets critical user-specific environment variables.\n+func (s *Server) setUserEnvironmentVariables(envMap map[string]string, userProfile, username, domain string) {\n+\tenvMap[\"USERPROFILE\"] = userProfile\n+\n+\tif len(userProfile) >= 2 && userProfile[1] == ':' {\n+\t\tenvMap[\"HOMEDRIVE\"] = userProfile[:2]\n+\t\tenvMap[\"HOMEPATH\"] = userProfile[2:]\n+\t}\n+\n+\tenvMap[\"APPDATA\"] = filepath.Join(userProfile, \"AppData\", \"Roaming\")\n+\tenvMap[\"LOCALAPPDATA\"] = filepath.Join(userProfile, \"AppData\", \"Local\")\n+\n+\ttempDir := filepath.Join(userProfile, \"AppData\", \"Local\", \"Temp\")\n+\tenvMap[\"TEMP\"] = tempDir\n+\tenvMap[\"TMP\"] = tempDir\n+\n+\tenvMap[\"USERNAME\"] = username\n+\tif domain != \"\" && domain != \".\" {\n+\t\tenvMap[\"USERDOMAIN\"] = domain\n+\t\tenvMap[\"USERDNSDOMAIN\"] = domain\n+\t}\n+\n+\tsystemVars := []string{\n+\t\t\"PROCESSOR_ARCHITECTURE\", \"PROCESSOR_IDENTIFIER\", \"PROCESSOR_LEVEL\", \"PROCESSOR_REVISION\",\n+\t\t\"SYSTEMDRIVE\", \"SYSTEMROOT\", \"WINDIR\", \"COMPUTERNAME\", \"OS\", \"PATHEXT\",\n+\t\t\"PROGRAMFILES\", \"PROGRAMDATA\", \"ALLUSERSPROFILE\", \"COMSPEC\",\n+\t}\n+\n+\tfor _, sysVar := range systemVars {\n+\t\tif sysValue := os.Getenv(sysVar); sysValue != \"\" {\n+\t\t\tenvMap[sysVar] = sysValue\n+\t\t}\n+\t}\n+}\n+\n+// prepareCommandEnv prepares environment variables for command execution on Windows\n+func (s *Server) prepareCommandEnv(localUser *user.User, session ssh.Session) []string {\n+\tusername, domain := s.parseUsername(localUser.Username)\n+\tuserEnv, err := s.getUserEnvironment(username, domain)\n+\tif err != nil {\n+\t\tlog.Debugf(\"failed to get user environment for %s\\\\%s, using fallback: %v\", domain, username, err)\n+\t\tenv := prepareUserEnv(localUser, getUserShell(localUser.Uid))\n+\t\tenv = append(env, prepareSSHEnv(session)...)\n+\t\tfor _, v := range session.Environ() {\n+\t\t\tif acceptEnv(v) {\n+\t\t\t\tenv = append(env, v)\n+\t\t\t}\n+\t\t}\n+\t\treturn env\n+\t}\n+\n+\tenv := userEnv\n+\tenv = append(env, prepareSSHEnv(session)...)\n+\tfor _, v := range session.Environ() {\n+\t\tif acceptEnv(v) {\n+\t\t\tenv = append(env, v)\n+\t\t}\n+\t}\n+\treturn env\n+}\n+\n+func (s *Server) handlePty(logger *log.Entry, session ssh.Session, privilegeResult PrivilegeCheckResult, ptyReq ssh.Pty, winCh <-chan ssh.Window) bool {\n+\tif privilegeResult.User == nil {\n+\t\tlogger.Errorf(\"no user in privilege result\")\n+\t\treturn false\n+\t}\n+\n+\tcmd := session.Command()\n+\tshell := getUserShell(privilegeResult.User.Uid)\n+\n+\tif len(cmd) == 0 {\n+\t\tlogger.Infof(\"starting interactive shell: %s\", shell)\n+\t} else {\n+\t\tlogger.Infof(\"executing command: %s\", safeLogCommand(cmd))\n+\t}\n+\n+\ts.handlePtyWithUserSwitching(logger, session, privilegeResult, ptyReq, winCh, cmd)\n+\treturn true\n+}\n+\n+// getShellCommandArgs returns the shell command and arguments for executing a command string\n+func (s *Server) getShellCommandArgs(shell, cmdString string) []string {\n+\tif cmdString == \"\" {\n+\t\treturn []string{shell, \"-NoLogo\"}\n+\t}\n+\treturn []string{shell, \"-Command\", cmdString}\n+}\n+\n+func (s *Server) handlePtyWithUserSwitching(logger *log.Entry, session ssh.Session, privilegeResult PrivilegeCheckResult, ptyReq ssh.Pty, _ <-chan ssh.Window, _ []string) {\n+\tlogger.Info(\"starting interactive shell\")\n+\ts.executeConPtyCommand(logger, session, privilegeResult, ptyReq, session.RawCommand())\n+}\n+\n+type PtyExecutionRequest struct {\n+\tShell    string\n+\tCommand  string\n+\tWidth    int\n+\tHeight   int\n+\tUsername string\n+\tDomain   string\n+}\n+\n+func executePtyCommandWithUserToken(ctx context.Context, session ssh.Session, req PtyExecutionRequest) error {\n+\tlog.Tracef(\"executing Windows ConPty command with user switching: shell=%s, command=%s, user=%s\\\\%s, size=%dx%d\",\n+\t\treq.Shell, req.Command, req.Domain, req.Username, req.Width, req.Height)\n+\n+\tprivilegeDropper := NewPrivilegeDropper()\n+\tuserToken, err := privilegeDropper.createToken(req.Username, req.Domain)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"create user token: %w\", err)\n+\t}\n+\tdefer func() {\n+\t\tif err := windows.CloseHandle(userToken); err != nil {\n+\t\t\tlog.Debugf(\"close user token: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tserver := &Server{}\n+\tuserEnv, err := server.getUserEnvironmentWithToken(userToken, req.Username, req.Domain)\n+\tif err != nil {\n+\t\tlog.Debugf(\"failed to get user environment for %s\\\\%s, using system environment: %v\", req.Domain, req.Username, err)\n+\t\tuserEnv = os.Environ()\n+\t}\n+\n+\tworkingDir := getUserHomeFromEnv(userEnv)\n+\tif workingDir == \"\" {\n+\t\tworkingDir = fmt.Sprintf(`C:\\Users\\%s`, req.Username)\n+\t}\n+\n+\tptyConfig := winpty.PtyConfig{\n+\t\tShell:      req.Shell,\n+\t\tCommand:    req.Command,\n+\t\tWidth:      req.Width,\n+\t\tHeight:     req.Height,\n+\t\tWorkingDir: workingDir,\n+\t}\n+\n+\tuserConfig := winpty.UserConfig{\n+\t\tToken:       userToken,\n+\t\tEnvironment: userEnv,\n+\t}\n+\n+\tlog.Debugf(\"executePtyCommandWithUserToken: calling winpty execution with working dir: %s\", workingDir)\n+\treturn winpty.ExecutePtyWithUserToken(ctx, session, ptyConfig, userConfig)\n+}\n+\n+func getUserHomeFromEnv(env []string) string {\n+\tfor _, envVar := range env {\n+\t\tif len(envVar) > 12 && envVar[:12] == \"USERPROFILE=\" {\n+\t\t\treturn envVar[12:]\n+\t\t}\n+\t}\n+\treturn \"\"\n+}\n+\n+func (s *Server) setupProcessGroup(_ *exec.Cmd) {\n+\t// Windows doesn't support process groups in the same way as Unix\n+\t// Process creation groups are handled differently\n+}\n+\n+func (s *Server) killProcessGroup(cmd *exec.Cmd) {\n+\tif cmd.Process == nil {\n+\t\treturn\n+\t}\n+\n+\tlogger := log.WithField(\"pid\", cmd.Process.Pid)\n+\n+\tif err := cmd.Process.Kill(); err != nil {\n+\t\tlogger.Debugf(\"kill process failed: %v\", err)\n+\t}\n+}\n+\n+// detectSuPtySupport always returns false on Windows as su is not available\n+func (s *Server) detectSuPtySupport(context.Context) bool {\n+\treturn false\n+}\n+\n+// executeCommandWithPty executes a command with PTY allocation on Windows using ConPty\n+func (s *Server) executeCommandWithPty(logger *log.Entry, session ssh.Session, execCmd *exec.Cmd, privilegeResult PrivilegeCheckResult, ptyReq ssh.Pty, winCh <-chan ssh.Window) bool {\n+\tcommand := session.RawCommand()\n+\tif command == \"\" {\n+\t\tlogger.Error(\"no command specified for PTY execution\")\n+\t\tif err := session.Exit(1); err != nil {\n+\t\t\tlogSessionExitError(logger, err)\n+\t\t}\n+\t\treturn false\n+\t}\n+\n+\treturn s.executeConPtyCommand(logger, session, privilegeResult, ptyReq, command)\n+}\n+\n+// executeConPtyCommand executes a command using ConPty (common for interactive and command execution)\n+func (s *Server) executeConPtyCommand(logger *log.Entry, session ssh.Session, privilegeResult PrivilegeCheckResult, ptyReq ssh.Pty, command string) bool {\n+\tlocalUser := privilegeResult.User\n+\tif localUser == nil {\n+\t\tlogger.Errorf(\"no user in privilege result\")\n+\t\treturn false\n+\t}\n+\n+\tusername, domain := s.parseUsername(localUser.Username)\n+\tshell := getUserShell(localUser.Uid)\n+\n+\treq := PtyExecutionRequest{\n+\t\tShell:    shell,\n+\t\tCommand:  command,\n+\t\tWidth:    ptyReq.Window.Width,\n+\t\tHeight:   ptyReq.Window.Height,\n+\t\tUsername: username,\n+\t\tDomain:   domain,\n+\t}\n+\n+\tif err := executePtyCommandWithUserToken(session.Context(), session, req); err != nil {\n+\t\tlogger.Errorf(\"ConPty execution failed: %v\", err)\n+\t\tif err := session.Exit(1); err != nil {\n+\t\t\tlogSessionExitError(logger, err)\n+\t\t}\n+\t\treturn false\n+\t}\n+\n+\tlogger.Debug(\"ConPty execution completed\")\n+\treturn true\n+}\ndiff --git a/client/ssh/server/executor_unix.go b/client/ssh/server/executor_unix.go\nnew file mode 100644\nindex 00000000000..8adc824effe\n--- /dev/null\n+++ b/client/ssh/server/executor_unix.go\n@@ -0,0 +1,253 @@\n+//go:build unix\n+\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"syscall\"\n+\n+\tlog \"github.com/sirupsen/logrus\"\n+)\n+\n+// Exit codes for executor process communication\n+const (\n+\tExitCodeSuccess           = 0\n+\tExitCodePrivilegeDropFail = 10\n+\tExitCodeShellExecFail     = 11\n+\tExitCodeValidationFail    = 12\n+)\n+\n+// ExecutorConfig holds configuration for the executor process\n+type ExecutorConfig struct {\n+\tUID        uint32\n+\tGID        uint32\n+\tGroups     []uint32\n+\tWorkingDir string\n+\tShell      string\n+\tCommand    string\n+\tPTY        bool\n+}\n+\n+// PrivilegeDropper handles secure privilege dropping in child processes\n+type PrivilegeDropper struct{}\n+\n+// NewPrivilegeDropper creates a new privilege dropper\n+func NewPrivilegeDropper() *PrivilegeDropper {\n+\treturn &PrivilegeDropper{}\n+}\n+\n+// CreateExecutorCommand creates a command that spawns netbird ssh exec for privilege dropping\n+func (pd *PrivilegeDropper) CreateExecutorCommand(ctx context.Context, config ExecutorConfig) (*exec.Cmd, error) {\n+\tnetbirdPath, err := os.Executable()\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"get netbird executable path: %w\", err)\n+\t}\n+\n+\tif err := pd.validatePrivileges(config.UID, config.GID); err != nil {\n+\t\treturn nil, fmt.Errorf(\"invalid privileges: %w\", err)\n+\t}\n+\n+\targs := []string{\n+\t\t\"ssh\", \"exec\",\n+\t\t\"--uid\", fmt.Sprintf(\"%d\", config.UID),\n+\t\t\"--gid\", fmt.Sprintf(\"%d\", config.GID),\n+\t\t\"--working-dir\", config.WorkingDir,\n+\t\t\"--shell\", config.Shell,\n+\t}\n+\n+\tfor _, group := range config.Groups {\n+\t\targs = append(args, \"--groups\", fmt.Sprintf(\"%d\", group))\n+\t}\n+\n+\tif config.PTY {\n+\t\targs = append(args, \"--pty\")\n+\t}\n+\n+\tif config.Command != \"\" {\n+\t\targs = append(args, \"--cmd\", config.Command)\n+\t}\n+\n+\t// Log executor args safely - show all args except hide the command value\n+\tsafeArgs := make([]string, len(args))\n+\tcopy(safeArgs, args)\n+\tfor i := 0; i < len(safeArgs)-1; i++ {\n+\t\tif safeArgs[i] == \"--cmd\" {\n+\t\t\tcmdParts := strings.Fields(safeArgs[i+1])\n+\t\t\tsafeArgs[i+1] = safeLogCommand(cmdParts)\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tlog.Tracef(\"creating executor command: %s %v\", netbirdPath, safeArgs)\n+\treturn exec.CommandContext(ctx, netbirdPath, args...), nil\n+}\n+\n+// DropPrivileges performs privilege dropping with thread locking for security\n+func (pd *PrivilegeDropper) DropPrivileges(targetUID, targetGID uint32, supplementaryGroups []uint32) error {\n+\tif err := pd.validatePrivileges(targetUID, targetGID); err != nil {\n+\t\treturn fmt.Errorf(\"invalid privileges: %w\", err)\n+\t}\n+\n+\truntime.LockOSThread()\n+\tdefer runtime.UnlockOSThread()\n+\n+\toriginalUID := os.Geteuid()\n+\toriginalGID := os.Getegid()\n+\n+\tif originalUID != int(targetUID) || originalGID != int(targetGID) {\n+\t\tif err := pd.setGroupsAndIDs(targetUID, targetGID, supplementaryGroups); err != nil {\n+\t\t\treturn fmt.Errorf(\"set groups and IDs: %w\", err)\n+\t\t}\n+\t}\n+\n+\tif err := pd.validatePrivilegeDropSuccess(targetUID, targetGID, originalUID, originalGID); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tlog.Tracef(\"successfully dropped privileges to UID=%d, GID=%d\", targetUID, targetGID)\n+\treturn nil\n+}\n+\n+// setGroupsAndIDs sets the supplementary groups, GID, and UID\n+func (pd *PrivilegeDropper) setGroupsAndIDs(targetUID, targetGID uint32, supplementaryGroups []uint32) error {\n+\tgroups := make([]int, len(supplementaryGroups))\n+\tfor i, g := range supplementaryGroups {\n+\t\tgroups[i] = int(g)\n+\t}\n+\n+\tif runtime.GOOS == \"darwin\" || runtime.GOOS == \"freebsd\" {\n+\t\tif len(groups) == 0 || groups[0] != int(targetGID) {\n+\t\t\tgroups = append([]int{int(targetGID)}, groups...)\n+\t\t}\n+\t}\n+\n+\tif err := syscall.Setgroups(groups); err != nil {\n+\t\treturn fmt.Errorf(\"setgroups to %v: %w\", groups, err)\n+\t}\n+\n+\tif err := syscall.Setgid(int(targetGID)); err != nil {\n+\t\treturn fmt.Errorf(\"setgid to %d: %w\", targetGID, err)\n+\t}\n+\n+\tif err := syscall.Setuid(int(targetUID)); err != nil {\n+\t\treturn fmt.Errorf(\"setuid to %d: %w\", targetUID, err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// validatePrivilegeDropSuccess validates that privilege dropping was successful\n+func (pd *PrivilegeDropper) validatePrivilegeDropSuccess(targetUID, targetGID uint32, originalUID, originalGID int) error {\n+\tif err := pd.validatePrivilegeDropReversibility(targetUID, targetGID, originalUID, originalGID); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif err := pd.validateCurrentPrivileges(targetUID, targetGID); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn nil\n+}\n+\n+// validatePrivilegeDropReversibility ensures privileges cannot be restored\n+func (pd *PrivilegeDropper) validatePrivilegeDropReversibility(targetUID, targetGID uint32, originalUID, originalGID int) error {\n+\tif originalGID != int(targetGID) {\n+\t\tif err := syscall.Setegid(originalGID); err == nil {\n+\t\t\treturn fmt.Errorf(\"privilege drop validation failed: able to restore original GID %d\", originalGID)\n+\t\t}\n+\t}\n+\tif originalUID != int(targetUID) {\n+\t\tif err := syscall.Seteuid(originalUID); err == nil {\n+\t\t\treturn fmt.Errorf(\"privilege drop validation failed: able to restore original UID %d\", originalUID)\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// validateCurrentPrivileges validates the current UID and GID match the target\n+func (pd *PrivilegeDropper) validateCurrentPrivileges(targetUID, targetGID uint32) error {\n+\tcurrentUID := os.Geteuid()\n+\tif currentUID != int(targetUID) {\n+\t\treturn fmt.Errorf(\"privilege drop validation failed: current UID %d, expected %d\", currentUID, targetUID)\n+\t}\n+\n+\tcurrentGID := os.Getegid()\n+\tif currentGID != int(targetGID) {\n+\t\treturn fmt.Errorf(\"privilege drop validation failed: current GID %d, expected %d\", currentGID, targetGID)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// ExecuteWithPrivilegeDrop executes a command with privilege dropping, using exit codes to signal specific failures\n+func (pd *PrivilegeDropper) ExecuteWithPrivilegeDrop(ctx context.Context, config ExecutorConfig) {\n+\tlog.Tracef(\"dropping privileges to UID=%d, GID=%d, groups=%v\", config.UID, config.GID, config.Groups)\n+\n+\t// TODO: Implement Pty support for executor path\n+\tif config.PTY {\n+\t\tconfig.PTY = false\n+\t}\n+\n+\tif err := pd.DropPrivileges(config.UID, config.GID, config.Groups); err != nil {\n+\t\t_, _ = fmt.Fprintf(os.Stderr, \"privilege drop failed: %v\\n\", err)\n+\t\tos.Exit(ExitCodePrivilegeDropFail)\n+\t}\n+\n+\tif config.WorkingDir != \"\" {\n+\t\tif err := os.Chdir(config.WorkingDir); err != nil {\n+\t\t\tlog.Debugf(\"failed to change to working directory %s, continuing with current directory: %v\", config.WorkingDir, err)\n+\t\t}\n+\t}\n+\n+\tvar execCmd *exec.Cmd\n+\tif config.Command == \"\" {\n+\t\tos.Exit(ExitCodeSuccess)\n+\t}\n+\n+\texecCmd = exec.CommandContext(ctx, config.Shell, \"-c\", config.Command)\n+\texecCmd.Stdin = os.Stdin\n+\texecCmd.Stdout = os.Stdout\n+\texecCmd.Stderr = os.Stderr\n+\n+\tcmdParts := strings.Fields(config.Command)\n+\tsafeCmd := safeLogCommand(cmdParts)\n+\tlog.Tracef(\"executing %s -c %s\", execCmd.Path, safeCmd)\n+\tif err := execCmd.Run(); err != nil {\n+\t\tvar exitError *exec.ExitError\n+\t\tif errors.As(err, &exitError) {\n+\t\t\t// Normal command exit with non-zero code - not an SSH execution error\n+\t\t\tlog.Tracef(\"command exited with code %d\", exitError.ExitCode())\n+\t\t\tos.Exit(exitError.ExitCode())\n+\t\t}\n+\n+\t\t// Actual execution failure (command not found, permission denied, etc.)\n+\t\tlog.Debugf(\"command execution failed: %v\", err)\n+\t\tos.Exit(ExitCodeShellExecFail)\n+\t}\n+\n+\tos.Exit(ExitCodeSuccess)\n+}\n+\n+// validatePrivileges validates that privilege dropping to the target UID/GID is allowed\n+func (pd *PrivilegeDropper) validatePrivileges(uid, gid uint32) error {\n+\tcurrentUID := uint32(os.Geteuid())\n+\tcurrentGID := uint32(os.Getegid())\n+\n+\t// Allow same-user operations (no privilege dropping needed)\n+\tif uid == currentUID && gid == currentGID {\n+\t\treturn nil\n+\t}\n+\n+\t// Only root can drop privileges to other users\n+\tif currentUID != 0 {\n+\t\treturn fmt.Errorf(\"cannot drop privileges from non-root user (UID %d) to UID %d\", currentUID, uid)\n+\t}\n+\n+\t// Root can drop to any user (including root itself)\n+\treturn nil\n+}\ndiff --git a/client/ssh/server/executor_windows.go b/client/ssh/server/executor_windows.go\nnew file mode 100644\nindex 00000000000..d3504e05682\n--- /dev/null\n+++ b/client/ssh/server/executor_windows.go\n@@ -0,0 +1,570 @@\n+//go:build windows\n+\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"os/user\"\n+\t\"strings\"\n+\t\"syscall\"\n+\t\"unsafe\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"golang.org/x/sys/windows\"\n+)\n+\n+const (\n+\tExitCodeSuccess           = 0\n+\tExitCodeLogonFail         = 10\n+\tExitCodeCreateProcessFail = 11\n+\tExitCodeWorkingDirFail    = 12\n+\tExitCodeShellExecFail     = 13\n+\tExitCodeValidationFail    = 14\n+)\n+\n+type WindowsExecutorConfig struct {\n+\tUsername    string\n+\tDomain      string\n+\tWorkingDir  string\n+\tShell       string\n+\tCommand     string\n+\tArgs        []string\n+\tInteractive bool\n+\tPty         bool\n+\tPtyWidth    int\n+\tPtyHeight   int\n+}\n+\n+type PrivilegeDropper struct{}\n+\n+func NewPrivilegeDropper() *PrivilegeDropper {\n+\treturn &PrivilegeDropper{}\n+}\n+\n+var (\n+\tadvapi32                    = windows.NewLazyDLL(\"advapi32.dll\")\n+\tprocAllocateLocallyUniqueId = advapi32.NewProc(\"AllocateLocallyUniqueId\")\n+)\n+\n+const (\n+\tlogon32LogonNetwork = 3 // Network logon - no password required for authenticated users\n+\n+\t// Common error messages\n+\tcommandFlag          = \"-Command\"\n+\tcloseTokenErrorMsg   = \"close token error: %v\" // #nosec G101 -- This is an error message template, not credentials\n+\tconvertUsernameError = \"convert username to UTF16: %w\"\n+\tconvertDomainError   = \"convert domain to UTF16: %w\"\n+)\n+\n+// CreateWindowsExecutorCommand creates a Windows command with privilege dropping.\n+// The caller must close the returned token handle after starting the process.\n+func (pd *PrivilegeDropper) CreateWindowsExecutorCommand(ctx context.Context, config WindowsExecutorConfig) (*exec.Cmd, windows.Token, error) {\n+\tif config.Username == \"\" {\n+\t\treturn nil, 0, errors.New(\"username cannot be empty\")\n+\t}\n+\tif config.Shell == \"\" {\n+\t\treturn nil, 0, errors.New(\"shell cannot be empty\")\n+\t}\n+\n+\tshell := config.Shell\n+\n+\tvar shellArgs []string\n+\tif config.Command != \"\" {\n+\t\tshellArgs = []string{shell, commandFlag, config.Command}\n+\t} else {\n+\t\tshellArgs = []string{shell}\n+\t}\n+\n+\tlog.Tracef(\"creating Windows direct shell command: %s %v\", shellArgs[0], shellArgs)\n+\n+\tcmd, token, err := pd.CreateWindowsProcessAsUser(\n+\t\tctx, shellArgs[0], shellArgs, config.Username, config.Domain, config.WorkingDir)\n+\tif err != nil {\n+\t\treturn nil, 0, fmt.Errorf(\"create Windows process as user: %w\", err)\n+\t}\n+\n+\treturn cmd, token, nil\n+}\n+\n+const (\n+\t// StatusSuccess represents successful LSA operation\n+\tStatusSuccess = 0\n+\n+\t// KerbS4ULogonType message type for domain users with Kerberos\n+\tKerbS4ULogonType = 12\n+\t// Msv10s4ulogontype message type for local users with MSV1_0\n+\tMsv10s4ulogontype = 12\n+\n+\t// MicrosoftKerberosNameA is the authentication package name for Kerberos\n+\tMicrosoftKerberosNameA = \"Kerberos\"\n+\t// Msv10packagename is the authentication package name for MSV1_0\n+\tMsv10packagename = \"MICROSOFT_AUTHENTICATION_PACKAGE_V1_0\"\n+\n+\tNameSamCompatible = 2\n+\tNameUserPrincipal = 8\n+\tNameCanonical     = 7\n+\n+\tmaxUPNLen = 1024\n+)\n+\n+// kerbS4ULogon structure for S4U authentication (domain users)\n+type kerbS4ULogon struct {\n+\tMessageType uint32\n+\tFlags       uint32\n+\tClientUpn   unicodeString\n+\tClientRealm unicodeString\n+}\n+\n+// msv10s4ulogon structure for S4U authentication (local users)\n+type msv10s4ulogon struct {\n+\tMessageType       uint32\n+\tFlags             uint32\n+\tUserPrincipalName unicodeString\n+\tDomainName        unicodeString\n+}\n+\n+// unicodeString structure\n+type unicodeString struct {\n+\tLength        uint16\n+\tMaximumLength uint16\n+\tBuffer        *uint16\n+}\n+\n+// lsaString structure\n+type lsaString struct {\n+\tLength        uint16\n+\tMaximumLength uint16\n+\tBuffer        *byte\n+}\n+\n+// tokenSource structure\n+type tokenSource struct {\n+\tSourceName       [8]byte\n+\tSourceIdentifier windows.LUID\n+}\n+\n+// quotaLimits structure\n+type quotaLimits struct {\n+\tPagedPoolLimit        uint32\n+\tNonPagedPoolLimit     uint32\n+\tMinimumWorkingSetSize uint32\n+\tMaximumWorkingSetSize uint32\n+\tPagefileLimit         uint32\n+\tTimeLimit             int64\n+}\n+\n+var (\n+\tsecur32                            = windows.NewLazyDLL(\"secur32.dll\")\n+\tprocLsaRegisterLogonProcess        = secur32.NewProc(\"LsaRegisterLogonProcess\")\n+\tprocLsaLookupAuthenticationPackage = secur32.NewProc(\"LsaLookupAuthenticationPackage\")\n+\tprocLsaLogonUser                   = secur32.NewProc(\"LsaLogonUser\")\n+\tprocLsaFreeReturnBuffer            = secur32.NewProc(\"LsaFreeReturnBuffer\")\n+\tprocLsaDeregisterLogonProcess      = secur32.NewProc(\"LsaDeregisterLogonProcess\")\n+\tprocTranslateNameW                 = secur32.NewProc(\"TranslateNameW\")\n+)\n+\n+// newLsaString creates an LsaString from a Go string\n+func newLsaString(s string) lsaString {\n+\tb := append([]byte(s), 0)\n+\treturn lsaString{\n+\t\tLength:        uint16(len(s)),\n+\t\tMaximumLength: uint16(len(b)),\n+\t\tBuffer:        &b[0],\n+\t}\n+}\n+\n+// generateS4UUserToken creates a Windows token using S4U authentication\n+// This is the exact approach OpenSSH for Windows uses for public key authentication\n+func generateS4UUserToken(username, domain string) (windows.Handle, error) {\n+\tuserCpn := buildUserCpn(username, domain)\n+\n+\tpd := NewPrivilegeDropper()\n+\tisDomainUser := !pd.isLocalUser(domain)\n+\n+\tlsaHandle, err := initializeLsaConnection()\n+\tif err != nil {\n+\t\treturn 0, err\n+\t}\n+\tdefer cleanupLsaConnection(lsaHandle)\n+\n+\tauthPackageId, err := lookupAuthenticationPackage(lsaHandle, isDomainUser)\n+\tif err != nil {\n+\t\treturn 0, err\n+\t}\n+\n+\tlogonInfo, logonInfoSize, err := prepareS4ULogonStructure(username, domain, isDomainUser)\n+\tif err != nil {\n+\t\treturn 0, err\n+\t}\n+\n+\treturn performS4ULogon(lsaHandle, authPackageId, logonInfo, logonInfoSize, userCpn, isDomainUser)\n+}\n+\n+// buildUserCpn constructs the user principal name\n+func buildUserCpn(username, domain string) string {\n+\tif domain != \"\" && domain != \".\" {\n+\t\treturn fmt.Sprintf(`%s\\%s`, domain, username)\n+\t}\n+\treturn username\n+}\n+\n+// initializeLsaConnection establishes connection to LSA\n+func initializeLsaConnection() (windows.Handle, error) {\n+\n+\tprocessName := newLsaString(\"NetBird\")\n+\tvar mode uint32\n+\tvar lsaHandle windows.Handle\n+\tret, _, _ := procLsaRegisterLogonProcess.Call(\n+\t\tuintptr(unsafe.Pointer(&processName)),\n+\t\tuintptr(unsafe.Pointer(&lsaHandle)),\n+\t\tuintptr(unsafe.Pointer(&mode)),\n+\t)\n+\tif ret != StatusSuccess {\n+\t\treturn 0, fmt.Errorf(\"LsaRegisterLogonProcess: 0x%x\", ret)\n+\t}\n+\n+\treturn lsaHandle, nil\n+}\n+\n+// cleanupLsaConnection closes the LSA connection\n+func cleanupLsaConnection(lsaHandle windows.Handle) {\n+\tif ret, _, _ := procLsaDeregisterLogonProcess.Call(uintptr(lsaHandle)); ret != StatusSuccess {\n+\t\tlog.Debugf(\"LsaDeregisterLogonProcess failed: 0x%x\", ret)\n+\t}\n+}\n+\n+// lookupAuthenticationPackage finds the correct authentication package\n+func lookupAuthenticationPackage(lsaHandle windows.Handle, isDomainUser bool) (uint32, error) {\n+\tvar authPackageName lsaString\n+\tif isDomainUser {\n+\t\tauthPackageName = newLsaString(MicrosoftKerberosNameA)\n+\t} else {\n+\t\tauthPackageName = newLsaString(Msv10packagename)\n+\t}\n+\n+\tvar authPackageId uint32\n+\tret, _, _ := procLsaLookupAuthenticationPackage.Call(\n+\t\tuintptr(lsaHandle),\n+\t\tuintptr(unsafe.Pointer(&authPackageName)),\n+\t\tuintptr(unsafe.Pointer(&authPackageId)),\n+\t)\n+\tif ret != StatusSuccess {\n+\t\treturn 0, fmt.Errorf(\"LsaLookupAuthenticationPackage: 0x%x\", ret)\n+\t}\n+\n+\treturn authPackageId, nil\n+}\n+\n+// lookupPrincipalName converts DOMAIN\\username to username@domain.fqdn (UPN format)\n+func lookupPrincipalName(username, domain string) (string, error) {\n+\tsamAccountName := fmt.Sprintf(`%s\\%s`, domain, username)\n+\tsamAccountNameUtf16, err := windows.UTF16PtrFromString(samAccountName)\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"convert SAM account name to UTF-16: %w\", err)\n+\t}\n+\n+\tupnBuf := make([]uint16, maxUPNLen+1)\n+\tupnSize := uint32(len(upnBuf))\n+\n+\tret, _, _ := procTranslateNameW.Call(\n+\t\tuintptr(unsafe.Pointer(samAccountNameUtf16)),\n+\t\tuintptr(NameSamCompatible),\n+\t\tuintptr(NameUserPrincipal),\n+\t\tuintptr(unsafe.Pointer(&upnBuf[0])),\n+\t\tuintptr(unsafe.Pointer(&upnSize)),\n+\t)\n+\n+\tif ret != 0 {\n+\t\tupn := windows.UTF16ToString(upnBuf[:upnSize])\n+\t\tlog.Debugf(\"Translated %s to explicit UPN: %s\", samAccountName, upn)\n+\t\treturn upn, nil\n+\t}\n+\n+\tupnSize = uint32(len(upnBuf))\n+\tret, _, _ = procTranslateNameW.Call(\n+\t\tuintptr(unsafe.Pointer(samAccountNameUtf16)),\n+\t\tuintptr(NameSamCompatible),\n+\t\tuintptr(NameCanonical),\n+\t\tuintptr(unsafe.Pointer(&upnBuf[0])),\n+\t\tuintptr(unsafe.Pointer(&upnSize)),\n+\t)\n+\n+\tif ret != 0 {\n+\t\tcanonical := windows.UTF16ToString(upnBuf[:upnSize])\n+\t\tslashIdx := strings.IndexByte(canonical, '/')\n+\t\tif slashIdx > 0 {\n+\t\t\tfqdn := canonical[:slashIdx]\n+\t\t\tupn := fmt.Sprintf(\"%s@%s\", username, fqdn)\n+\t\t\tlog.Debugf(\"Translated %s to implicit UPN: %s (from canonical: %s)\", samAccountName, upn, canonical)\n+\t\t\treturn upn, nil\n+\t\t}\n+\t}\n+\n+\tlog.Debugf(\"Could not translate %s to UPN, using SAM format\", samAccountName)\n+\treturn samAccountName, nil\n+}\n+\n+// prepareS4ULogonStructure creates the appropriate S4U logon structure\n+func prepareS4ULogonStructure(username, domain string, isDomainUser bool) (unsafe.Pointer, uintptr, error) {\n+\tif isDomainUser {\n+\t\treturn prepareDomainS4ULogon(username, domain)\n+\t}\n+\treturn prepareLocalS4ULogon(username)\n+}\n+\n+// prepareDomainS4ULogon creates S4U logon structure for domain users\n+func prepareDomainS4ULogon(username, domain string) (unsafe.Pointer, uintptr, error) {\n+\tupn, err := lookupPrincipalName(username, domain)\n+\tif err != nil {\n+\t\treturn nil, 0, fmt.Errorf(\"lookup principal name: %w\", err)\n+\t}\n+\n+\tlog.Debugf(\"using KerbS4ULogon for domain user with UPN: %s\", upn)\n+\n+\tupnUtf16, err := windows.UTF16FromString(upn)\n+\tif err != nil {\n+\t\treturn nil, 0, fmt.Errorf(convertUsernameError, err)\n+\t}\n+\n+\tstructSize := unsafe.Sizeof(kerbS4ULogon{})\n+\tupnByteSize := len(upnUtf16) * 2\n+\tlogonInfoSize := structSize + uintptr(upnByteSize)\n+\n+\tbuffer := make([]byte, logonInfoSize)\n+\tlogonInfo := unsafe.Pointer(&buffer[0])\n+\n+\ts4uLogon := (*kerbS4ULogon)(logonInfo)\n+\ts4uLogon.MessageType = KerbS4ULogonType\n+\ts4uLogon.Flags = 0\n+\n+\tupnOffset := structSize\n+\tupnBuffer := (*uint16)(unsafe.Pointer(uintptr(logonInfo) + upnOffset))\n+\tcopy((*[1025]uint16)(unsafe.Pointer(upnBuffer))[:len(upnUtf16)], upnUtf16)\n+\n+\ts4uLogon.ClientUpn = unicodeString{\n+\t\tLength:        uint16((len(upnUtf16) - 1) * 2),\n+\t\tMaximumLength: uint16(len(upnUtf16) * 2),\n+\t\tBuffer:        upnBuffer,\n+\t}\n+\ts4uLogon.ClientRealm = unicodeString{}\n+\n+\treturn logonInfo, logonInfoSize, nil\n+}\n+\n+// prepareLocalS4ULogon creates S4U logon structure for local users\n+func prepareLocalS4ULogon(username string) (unsafe.Pointer, uintptr, error) {\n+\tlog.Debugf(\"using Msv1_0S4ULogon for local user: %s\", username)\n+\n+\tusernameUtf16, err := windows.UTF16FromString(username)\n+\tif err != nil {\n+\t\treturn nil, 0, fmt.Errorf(convertUsernameError, err)\n+\t}\n+\n+\tdomainUtf16, err := windows.UTF16FromString(\".\")\n+\tif err != nil {\n+\t\treturn nil, 0, fmt.Errorf(convertDomainError, err)\n+\t}\n+\n+\tstructSize := unsafe.Sizeof(msv10s4ulogon{})\n+\tusernameByteSize := len(usernameUtf16) * 2\n+\tdomainByteSize := len(domainUtf16) * 2\n+\tlogonInfoSize := structSize + uintptr(usernameByteSize) + uintptr(domainByteSize)\n+\n+\tbuffer := make([]byte, logonInfoSize)\n+\tlogonInfo := unsafe.Pointer(&buffer[0])\n+\n+\ts4uLogon := (*msv10s4ulogon)(logonInfo)\n+\ts4uLogon.MessageType = Msv10s4ulogontype\n+\ts4uLogon.Flags = 0x0\n+\n+\tusernameOffset := structSize\n+\tusernameBuffer := (*uint16)(unsafe.Pointer(uintptr(logonInfo) + usernameOffset))\n+\tcopy((*[256]uint16)(unsafe.Pointer(usernameBuffer))[:len(usernameUtf16)], usernameUtf16)\n+\n+\ts4uLogon.UserPrincipalName = unicodeString{\n+\t\tLength:        uint16((len(usernameUtf16) - 1) * 2),\n+\t\tMaximumLength: uint16(len(usernameUtf16) * 2),\n+\t\tBuffer:        usernameBuffer,\n+\t}\n+\n+\tdomainOffset := usernameOffset + uintptr(usernameByteSize)\n+\tdomainBuffer := (*uint16)(unsafe.Pointer(uintptr(logonInfo) + domainOffset))\n+\tcopy((*[16]uint16)(unsafe.Pointer(domainBuffer))[:len(domainUtf16)], domainUtf16)\n+\n+\ts4uLogon.DomainName = unicodeString{\n+\t\tLength:        uint16((len(domainUtf16) - 1) * 2),\n+\t\tMaximumLength: uint16(len(domainUtf16) * 2),\n+\t\tBuffer:        domainBuffer,\n+\t}\n+\n+\treturn logonInfo, logonInfoSize, nil\n+}\n+\n+// performS4ULogon executes the S4U logon operation\n+func performS4ULogon(lsaHandle windows.Handle, authPackageId uint32, logonInfo unsafe.Pointer, logonInfoSize uintptr, userCpn string, isDomainUser bool) (windows.Handle, error) {\n+\tvar tokenSource tokenSource\n+\tcopy(tokenSource.SourceName[:], \"netbird\")\n+\tif ret, _, _ := procAllocateLocallyUniqueId.Call(uintptr(unsafe.Pointer(&tokenSource.SourceIdentifier))); ret == 0 {\n+\t\tlog.Debugf(\"AllocateLocallyUniqueId failed\")\n+\t}\n+\n+\toriginName := newLsaString(\"netbird\")\n+\n+\tvar profile uintptr\n+\tvar profileSize uint32\n+\tvar logonId windows.LUID\n+\tvar token windows.Handle\n+\tvar quotas quotaLimits\n+\tvar subStatus int32\n+\n+\tret, _, _ := procLsaLogonUser.Call(\n+\t\tuintptr(lsaHandle),\n+\t\tuintptr(unsafe.Pointer(&originName)),\n+\t\tlogon32LogonNetwork,\n+\t\tuintptr(authPackageId),\n+\t\tuintptr(logonInfo),\n+\t\tlogonInfoSize,\n+\t\t0,\n+\t\tuintptr(unsafe.Pointer(&tokenSource)),\n+\t\tuintptr(unsafe.Pointer(&profile)),\n+\t\tuintptr(unsafe.Pointer(&profileSize)),\n+\t\tuintptr(unsafe.Pointer(&logonId)),\n+\t\tuintptr(unsafe.Pointer(&token)),\n+\t\tuintptr(unsafe.Pointer(&quotas)),\n+\t\tuintptr(unsafe.Pointer(&subStatus)),\n+\t)\n+\n+\tif profile != 0 {\n+\t\tif ret, _, _ := procLsaFreeReturnBuffer.Call(profile); ret != StatusSuccess {\n+\t\t\tlog.Debugf(\"LsaFreeReturnBuffer failed: 0x%x\", ret)\n+\t\t}\n+\t}\n+\n+\tif ret != StatusSuccess {\n+\t\treturn 0, fmt.Errorf(\"LsaLogonUser S4U for %s: NTSTATUS=0x%x, SubStatus=0x%x\", userCpn, ret, subStatus)\n+\t}\n+\n+\tlog.Debugf(\"created S4U %s token for user %s\",\n+\t\tmap[bool]string{true: \"domain\", false: \"local\"}[isDomainUser], userCpn)\n+\treturn token, nil\n+}\n+\n+// createToken implements NetBird trust-based authentication using S4U\n+func (pd *PrivilegeDropper) createToken(username, domain string) (windows.Handle, error) {\n+\tfullUsername := buildUserCpn(username, domain)\n+\n+\tif err := userExists(fullUsername, username, domain); err != nil {\n+\t\treturn 0, err\n+\t}\n+\n+\tisLocalUser := pd.isLocalUser(domain)\n+\n+\tif isLocalUser {\n+\t\treturn pd.authenticateLocalUser(username, fullUsername)\n+\t}\n+\treturn pd.authenticateDomainUser(username, domain, fullUsername)\n+}\n+\n+// userExists checks if the target useVerifier exists on the system\n+func userExists(fullUsername, username, domain string) error {\n+\tif _, err := lookupUser(fullUsername); err != nil {\n+\t\tlog.Debugf(\"User %s not found: %v\", fullUsername, err)\n+\t\tif domain != \"\" && domain != \".\" {\n+\t\t\t_, err = lookupUser(username)\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"target user %s not found: %w\", fullUsername, err)\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// isLocalUser determines if this is a local user vs domain user\n+func (pd *PrivilegeDropper) isLocalUser(domain string) bool {\n+\thostname, err := os.Hostname()\n+\tif err != nil {\n+\t\thostname = \"localhost\"\n+\t}\n+\n+\treturn domain == \"\" || domain == \".\" ||\n+\t\tstrings.EqualFold(domain, hostname)\n+}\n+\n+// authenticateLocalUser handles authentication for local users\n+func (pd *PrivilegeDropper) authenticateLocalUser(username, fullUsername string) (windows.Handle, error) {\n+\tlog.Debugf(\"using S4U authentication for local user %s\", fullUsername)\n+\ttoken, err := generateS4UUserToken(username, \".\")\n+\tif err != nil {\n+\t\treturn 0, fmt.Errorf(\"S4U authentication for local user %s: %w\", fullUsername, err)\n+\t}\n+\treturn token, nil\n+}\n+\n+// authenticateDomainUser handles authentication for domain users\n+func (pd *PrivilegeDropper) authenticateDomainUser(username, domain, fullUsername string) (windows.Handle, error) {\n+\tlog.Debugf(\"using S4U authentication for domain user %s\", fullUsername)\n+\ttoken, err := generateS4UUserToken(username, domain)\n+\tif err != nil {\n+\t\treturn 0, fmt.Errorf(\"S4U authentication for domain user %s: %w\", fullUsername, err)\n+\t}\n+\tlog.Debugf(\"Successfully created S4U token for domain user %s\", fullUsername)\n+\treturn token, nil\n+}\n+\n+// CreateWindowsProcessAsUser creates a process as user with safe argument passing (for SFTP and executables).\n+// The caller must close the returned token handle after starting the process.\n+func (pd *PrivilegeDropper) CreateWindowsProcessAsUser(ctx context.Context, executablePath string, args []string, username, domain, workingDir string) (*exec.Cmd, windows.Token, error) {\n+\ttoken, err := pd.createToken(username, domain)\n+\tif err != nil {\n+\t\treturn nil, 0, fmt.Errorf(\"user authentication: %w\", err)\n+\t}\n+\n+\tdefer func() {\n+\t\tif err := windows.CloseHandle(token); err != nil {\n+\t\t\tlog.Debugf(\"close impersonation token: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tcmd, primaryToken, err := pd.createProcessWithToken(ctx, windows.Token(token), executablePath, args, workingDir)\n+\tif err != nil {\n+\t\treturn nil, 0, err\n+\t}\n+\n+\treturn cmd, primaryToken, nil\n+}\n+\n+// createProcessWithToken creates process with the specified token and executable path.\n+// The caller must close the returned token handle after starting the process.\n+func (pd *PrivilegeDropper) createProcessWithToken(ctx context.Context, sourceToken windows.Token, executablePath string, args []string, workingDir string) (*exec.Cmd, windows.Token, error) {\n+\tcmd := exec.CommandContext(ctx, executablePath, args[1:]...)\n+\tcmd.Dir = workingDir\n+\n+\tvar primaryToken windows.Token\n+\terr := windows.DuplicateTokenEx(\n+\t\tsourceToken,\n+\t\twindows.TOKEN_ALL_ACCESS,\n+\t\tnil,\n+\t\twindows.SecurityIdentification,\n+\t\twindows.TokenPrimary,\n+\t\t&primaryToken,\n+\t)\n+\tif err != nil {\n+\t\treturn nil, 0, fmt.Errorf(\"duplicate token to primary token: %w\", err)\n+\t}\n+\n+\tcmd.SysProcAttr = &syscall.SysProcAttr{\n+\t\tToken: syscall.Token(primaryToken),\n+\t}\n+\n+\treturn cmd, primaryToken, nil\n+}\n+\n+// createSuCommand creates a command using su -l -c for privilege switching (Windows stub)\n+func (s *Server) createSuCommand(ssh.Session, *user.User, bool) (*exec.Cmd, error) {\n+\treturn nil, fmt.Errorf(\"su command not available on Windows\")\n+}\ndiff --git a/client/ssh/server/port_forwarding.go b/client/ssh/server/port_forwarding.go\nnew file mode 100644\nindex 00000000000..6138f9296f7\n--- /dev/null\n+++ b/client/ssh/server/port_forwarding.go\n@@ -0,0 +1,386 @@\n+package server\n+\n+import (\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net\"\n+\t\"strconv\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\tcryptossh \"golang.org/x/crypto/ssh\"\n+)\n+\n+// SessionKey uniquely identifies an SSH session\n+type SessionKey string\n+\n+// ConnectionKey uniquely identifies a port forwarding connection within a session\n+type ConnectionKey string\n+\n+// ForwardKey uniquely identifies a port forwarding listener\n+type ForwardKey string\n+\n+// tcpipForwardMsg represents the structure for tcpip-forward SSH requests\n+type tcpipForwardMsg struct {\n+\tHost string\n+\tPort uint32\n+}\n+\n+// SetAllowLocalPortForwarding configures local port forwarding\n+func (s *Server) SetAllowLocalPortForwarding(allow bool) {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\ts.allowLocalPortForwarding = allow\n+}\n+\n+// SetAllowRemotePortForwarding configures remote port forwarding\n+func (s *Server) SetAllowRemotePortForwarding(allow bool) {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\ts.allowRemotePortForwarding = allow\n+}\n+\n+// configurePortForwarding sets up port forwarding callbacks\n+func (s *Server) configurePortForwarding(server *ssh.Server) {\n+\tallowLocal := s.allowLocalPortForwarding\n+\tallowRemote := s.allowRemotePortForwarding\n+\n+\tserver.LocalPortForwardingCallback = func(ctx ssh.Context, dstHost string, dstPort uint32) bool {\n+\t\tif !allowLocal {\n+\t\t\tlog.Warnf(\"local port forwarding denied for %s from %s: disabled by configuration\",\n+\t\t\t\tnet.JoinHostPort(dstHost, fmt.Sprintf(\"%d\", dstPort)), ctx.RemoteAddr())\n+\t\t\treturn false\n+\t\t}\n+\n+\t\tif err := s.checkPortForwardingPrivileges(ctx, \"local\", dstPort); err != nil {\n+\t\t\tlog.Warnf(\"local port forwarding denied for %s:%d from %s: %v\", dstHost, dstPort, ctx.RemoteAddr(), err)\n+\t\t\treturn false\n+\t\t}\n+\n+\t\tlog.Debugf(\"local port forwarding allowed: %s:%d\", dstHost, dstPort)\n+\t\treturn true\n+\t}\n+\n+\tserver.ReversePortForwardingCallback = func(ctx ssh.Context, bindHost string, bindPort uint32) bool {\n+\t\tif !allowRemote {\n+\t\t\tlog.Warnf(\"remote port forwarding denied for %s from %s: disabled by configuration\",\n+\t\t\t\tnet.JoinHostPort(bindHost, fmt.Sprintf(\"%d\", bindPort)), ctx.RemoteAddr())\n+\t\t\treturn false\n+\t\t}\n+\n+\t\tif err := s.checkPortForwardingPrivileges(ctx, \"remote\", bindPort); err != nil {\n+\t\t\tlog.Warnf(\"remote port forwarding denied for %s:%d from %s: %v\", bindHost, bindPort, ctx.RemoteAddr(), err)\n+\t\t\treturn false\n+\t\t}\n+\n+\t\tlog.Debugf(\"remote port forwarding allowed: %s:%d\", bindHost, bindPort)\n+\t\treturn true\n+\t}\n+\n+\tlog.Debugf(\"SSH server configured with local_forwarding=%v, remote_forwarding=%v\", allowLocal, allowRemote)\n+}\n+\n+// checkPortForwardingPrivileges validates privilege requirements for port forwarding operations.\n+// Returns nil if allowed, error if denied.\n+func (s *Server) checkPortForwardingPrivileges(ctx ssh.Context, forwardType string, port uint32) error {\n+\tif ctx == nil {\n+\t\treturn fmt.Errorf(\"%s port forwarding denied: no context\", forwardType)\n+\t}\n+\n+\tusername := ctx.User()\n+\tremoteAddr := \"unknown\"\n+\tif ctx.RemoteAddr() != nil {\n+\t\tremoteAddr = ctx.RemoteAddr().String()\n+\t}\n+\n+\tlogger := log.WithFields(log.Fields{\"user\": username, \"remote\": remoteAddr, \"port\": port})\n+\n+\tresult := s.CheckPrivileges(PrivilegeCheckRequest{\n+\t\tRequestedUsername:         username,\n+\t\tFeatureSupportsUserSwitch: false,\n+\t\tFeatureName:               forwardType + \" port forwarding\",\n+\t})\n+\n+\tif !result.Allowed {\n+\t\treturn result.Error\n+\t}\n+\n+\tlogger.Debugf(\"%s port forwarding allowed: user %s validated (port %d)\",\n+\t\tforwardType, result.User.Username, port)\n+\n+\treturn nil\n+}\n+\n+// tcpipForwardHandler handles tcpip-forward requests for remote port forwarding.\n+func (s *Server) tcpipForwardHandler(ctx ssh.Context, _ *ssh.Server, req *cryptossh.Request) (bool, []byte) {\n+\tlogger := s.getRequestLogger(ctx)\n+\n+\tif !s.isRemotePortForwardingAllowed() {\n+\t\tlogger.Warnf(\"tcpip-forward request denied: remote port forwarding disabled\")\n+\t\treturn false, nil\n+\t}\n+\n+\tpayload, err := s.parseTcpipForwardRequest(req)\n+\tif err != nil {\n+\t\tlogger.Errorf(\"tcpip-forward unmarshal error: %v\", err)\n+\t\treturn false, nil\n+\t}\n+\n+\tif err := s.checkPortForwardingPrivileges(ctx, \"tcpip-forward\", payload.Port); err != nil {\n+\t\tlogger.Warnf(\"tcpip-forward denied: %v\", err)\n+\t\treturn false, nil\n+\t}\n+\n+\tlogger.Debugf(\"tcpip-forward request: %s:%d\", payload.Host, payload.Port)\n+\n+\tsshConn, err := s.getSSHConnection(ctx)\n+\tif err != nil {\n+\t\tlogger.Warnf(\"tcpip-forward request denied: %v\", err)\n+\t\treturn false, nil\n+\t}\n+\n+\treturn s.setupDirectForward(ctx, logger, sshConn, payload)\n+}\n+\n+// cancelTcpipForwardHandler handles cancel-tcpip-forward requests.\n+func (s *Server) cancelTcpipForwardHandler(ctx ssh.Context, _ *ssh.Server, req *cryptossh.Request) (bool, []byte) {\n+\tlogger := s.getRequestLogger(ctx)\n+\n+\tvar payload tcpipForwardMsg\n+\tif err := cryptossh.Unmarshal(req.Payload, &payload); err != nil {\n+\t\tlogger.Errorf(\"cancel-tcpip-forward unmarshal error: %v\", err)\n+\t\treturn false, nil\n+\t}\n+\n+\tkey := ForwardKey(fmt.Sprintf(\"%s:%d\", payload.Host, payload.Port))\n+\tif s.removeRemoteForwardListener(key) {\n+\t\tlogger.Infof(\"remote port forwarding cancelled: %s:%d\", payload.Host, payload.Port)\n+\t\treturn true, nil\n+\t}\n+\n+\tlogger.Warnf(\"cancel-tcpip-forward failed: no listener found for %s:%d\", payload.Host, payload.Port)\n+\treturn false, nil\n+}\n+\n+// handleRemoteForwardListener handles incoming connections for remote port forwarding.\n+func (s *Server) handleRemoteForwardListener(ctx ssh.Context, ln net.Listener, host string, port uint32) {\n+\tlog.Debugf(\"starting remote forward listener handler for %s:%d\", host, port)\n+\n+\tdefer func() {\n+\t\tlog.Debugf(\"cleaning up remote forward listener for %s:%d\", host, port)\n+\t\tif err := ln.Close(); err != nil {\n+\t\t\tlog.Debugf(\"remote forward listener close error: %v\", err)\n+\t\t} else {\n+\t\t\tlog.Debugf(\"remote forward listener closed successfully for %s:%d\", host, port)\n+\t\t}\n+\t}()\n+\n+\tacceptChan := make(chan acceptResult, 1)\n+\n+\tgo func() {\n+\t\tfor {\n+\t\t\tconn, err := ln.Accept()\n+\t\t\tselect {\n+\t\t\tcase acceptChan <- acceptResult{conn: conn, err: err}:\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\tcase <-ctx.Done():\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase result := <-acceptChan:\n+\t\t\tif result.err != nil {\n+\t\t\t\tlog.Debugf(\"remote forward accept error: %v\", result.err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tgo s.handleRemoteForwardConnection(ctx, result.conn, host, port)\n+\t\tcase <-ctx.Done():\n+\t\t\tlog.Debugf(\"remote forward listener shutting down due to context cancellation for %s:%d\", host, port)\n+\t\t\treturn\n+\t\t}\n+\t}\n+}\n+\n+// getRequestLogger creates a logger with user and remote address context\n+func (s *Server) getRequestLogger(ctx ssh.Context) *log.Entry {\n+\tremoteAddr := \"unknown\"\n+\tusername := \"unknown\"\n+\tif ctx != nil {\n+\t\tif ctx.RemoteAddr() != nil {\n+\t\t\tremoteAddr = ctx.RemoteAddr().String()\n+\t\t}\n+\t\tusername = ctx.User()\n+\t}\n+\treturn log.WithFields(log.Fields{\"user\": username, \"remote\": remoteAddr})\n+}\n+\n+// isRemotePortForwardingAllowed checks if remote port forwarding is enabled\n+func (s *Server) isRemotePortForwardingAllowed() bool {\n+\ts.mu.RLock()\n+\tdefer s.mu.RUnlock()\n+\treturn s.allowRemotePortForwarding\n+}\n+\n+// parseTcpipForwardRequest parses the SSH request payload\n+func (s *Server) parseTcpipForwardRequest(req *cryptossh.Request) (*tcpipForwardMsg, error) {\n+\tvar payload tcpipForwardMsg\n+\terr := cryptossh.Unmarshal(req.Payload, &payload)\n+\treturn &payload, err\n+}\n+\n+// getSSHConnection extracts SSH connection from context\n+func (s *Server) getSSHConnection(ctx ssh.Context) (*cryptossh.ServerConn, error) {\n+\tif ctx == nil {\n+\t\treturn nil, fmt.Errorf(\"no context\")\n+\t}\n+\tsshConnValue := ctx.Value(ssh.ContextKeyConn)\n+\tif sshConnValue == nil {\n+\t\treturn nil, fmt.Errorf(\"no SSH connection in context\")\n+\t}\n+\tsshConn, ok := sshConnValue.(*cryptossh.ServerConn)\n+\tif !ok || sshConn == nil {\n+\t\treturn nil, fmt.Errorf(\"invalid SSH connection in context\")\n+\t}\n+\treturn sshConn, nil\n+}\n+\n+// setupDirectForward sets up a direct port forward\n+func (s *Server) setupDirectForward(ctx ssh.Context, logger *log.Entry, sshConn *cryptossh.ServerConn, payload *tcpipForwardMsg) (bool, []byte) {\n+\tbindAddr := net.JoinHostPort(payload.Host, strconv.FormatUint(uint64(payload.Port), 10))\n+\n+\tln, err := net.Listen(\"tcp\", bindAddr)\n+\tif err != nil {\n+\t\tlogger.Errorf(\"tcpip-forward listen failed on %s: %v\", bindAddr, err)\n+\t\treturn false, nil\n+\t}\n+\n+\tactualPort := payload.Port\n+\tif payload.Port == 0 {\n+\t\ttcpAddr := ln.Addr().(*net.TCPAddr)\n+\t\tactualPort = uint32(tcpAddr.Port)\n+\t\tlogger.Debugf(\"tcpip-forward allocated port %d for %s\", actualPort, payload.Host)\n+\t}\n+\n+\tkey := ForwardKey(fmt.Sprintf(\"%s:%d\", payload.Host, payload.Port))\n+\ts.storeRemoteForwardListener(key, ln)\n+\n+\ts.markConnectionActivePortForward(sshConn, ctx.User(), ctx.RemoteAddr().String())\n+\tgo s.handleRemoteForwardListener(ctx, ln, payload.Host, actualPort)\n+\n+\tresponse := make([]byte, 4)\n+\tbinary.BigEndian.PutUint32(response, actualPort)\n+\n+\tlogger.Infof(\"remote port forwarding established: %s:%d\", payload.Host, actualPort)\n+\treturn true, response\n+}\n+\n+// acceptResult holds the result of a listener Accept() call\n+type acceptResult struct {\n+\tconn net.Conn\n+\terr  error\n+}\n+\n+// handleRemoteForwardConnection handles a single remote port forwarding connection\n+func (s *Server) handleRemoteForwardConnection(ctx ssh.Context, conn net.Conn, host string, port uint32) {\n+\tsessionKey := s.findSessionKeyByContext(ctx)\n+\tconnID := fmt.Sprintf(\"pf-%s->%s:%d\", conn.RemoteAddr(), host, port)\n+\tlogger := log.WithFields(log.Fields{\n+\t\t\"session\": sessionKey,\n+\t\t\"conn\":    connID,\n+\t})\n+\n+\tdefer func() {\n+\t\tif err := conn.Close(); err != nil {\n+\t\t\tlogger.Debugf(\"connection close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tsshConn := ctx.Value(ssh.ContextKeyConn).(*cryptossh.ServerConn)\n+\tif sshConn == nil {\n+\t\tlogger.Debugf(\"remote forward: no SSH connection in context\")\n+\t\treturn\n+\t}\n+\n+\tremoteAddr, ok := conn.RemoteAddr().(*net.TCPAddr)\n+\tif !ok {\n+\t\tlogger.Warnf(\"remote forward: non-TCP connection type: %T\", conn.RemoteAddr())\n+\t\treturn\n+\t}\n+\n+\tchannel, err := s.openForwardChannel(sshConn, host, port, remoteAddr, logger)\n+\tif err != nil {\n+\t\tlogger.Debugf(\"open forward channel: %v\", err)\n+\t\treturn\n+\t}\n+\n+\ts.proxyForwardConnection(ctx, logger, conn, channel)\n+}\n+\n+// openForwardChannel creates an SSH forwarded-tcpip channel\n+func (s *Server) openForwardChannel(sshConn *cryptossh.ServerConn, host string, port uint32, remoteAddr *net.TCPAddr, logger *log.Entry) (cryptossh.Channel, error) {\n+\tlogger.Tracef(\"opening forwarded-tcpip channel for %s:%d\", host, port)\n+\n+\tpayload := struct {\n+\t\tConnectedAddress  string\n+\t\tConnectedPort     uint32\n+\t\tOriginatorAddress string\n+\t\tOriginatorPort    uint32\n+\t}{\n+\t\tConnectedAddress:  host,\n+\t\tConnectedPort:     port,\n+\t\tOriginatorAddress: remoteAddr.IP.String(),\n+\t\tOriginatorPort:    uint32(remoteAddr.Port),\n+\t}\n+\n+\tchannel, reqs, err := sshConn.OpenChannel(\"forwarded-tcpip\", cryptossh.Marshal(&payload))\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"open SSH channel: %w\", err)\n+\t}\n+\n+\tgo cryptossh.DiscardRequests(reqs)\n+\treturn channel, nil\n+}\n+\n+// proxyForwardConnection handles bidirectional data transfer between connection and SSH channel\n+func (s *Server) proxyForwardConnection(ctx ssh.Context, logger *log.Entry, conn net.Conn, channel cryptossh.Channel) {\n+\tdone := make(chan struct{}, 2)\n+\n+\tgo func() {\n+\t\tif _, err := io.Copy(channel, conn); err != nil {\n+\t\t\tlogger.Debugf(\"copy error (conn->channel): %v\", err)\n+\t\t}\n+\t\tdone <- struct{}{}\n+\t}()\n+\n+\tgo func() {\n+\t\tif _, err := io.Copy(conn, channel); err != nil {\n+\t\t\tlogger.Debugf(\"copy error (channel->conn): %v\", err)\n+\t\t}\n+\t\tdone <- struct{}{}\n+\t}()\n+\n+\tselect {\n+\tcase <-ctx.Done():\n+\t\tlogger.Debugf(\"session ended, closing connections\")\n+\tcase <-done:\n+\t\t// First copy finished, wait for second copy or context cancellation\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\t\tlogger.Debugf(\"session ended, closing connections\")\n+\t\tcase <-done:\n+\t\t}\n+\t}\n+\n+\tif err := channel.Close(); err != nil {\n+\t\tlogger.Debugf(\"channel close error: %v\", err)\n+\t}\n+\tif err := conn.Close(); err != nil {\n+\t\tlogger.Debugf(\"connection close error: %v\", err)\n+\t}\n+}\ndiff --git a/client/ssh/server/server.go b/client/ssh/server/server.go\nnew file mode 100644\nindex 00000000000..44612532b8d\n--- /dev/null\n+++ b/client/ssh/server/server.go\n@@ -0,0 +1,712 @@\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"encoding/base64\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net\"\n+\t\"net/netip\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tgojwt \"github.com/golang-jwt/jwt/v5\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\tcryptossh \"golang.org/x/crypto/ssh\"\n+\t\"golang.org/x/exp/maps\"\n+\t\"golang.zx2c4.com/wireguard/tun/netstack\"\n+\n+\t\"github.com/netbirdio/netbird/client/iface/wgaddr\"\n+\t\"github.com/netbirdio/netbird/client/ssh/detection\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n+\t\"github.com/netbirdio/netbird/shared/auth/jwt\"\n+\t\"github.com/netbirdio/netbird/version\"\n+)\n+\n+// DefaultSSHPort is the default SSH port of the NetBird's embedded SSH server\n+const DefaultSSHPort = 22\n+\n+// InternalSSHPort is the port SSH server listens on and is redirected to\n+const InternalSSHPort = 22022\n+\n+const (\n+\terrWriteSession = \"write session error: %v\"\n+\terrExitSession  = \"exit session error: %v\"\n+\n+\tmsgPrivilegedUserDisabled = \"privileged user login is disabled\"\n+\n+\t// DefaultJWTMaxTokenAge is the default maximum age for JWT tokens accepted by the SSH server\n+\tDefaultJWTMaxTokenAge = 5 * 60\n+)\n+\n+var (\n+\tErrPrivilegedUserDisabled = errors.New(msgPrivilegedUserDisabled)\n+\tErrUserNotFound           = errors.New(\"user not found\")\n+)\n+\n+// PrivilegedUserError represents an error when privileged user login is disabled\n+type PrivilegedUserError struct {\n+\tUsername string\n+}\n+\n+func (e *PrivilegedUserError) Error() string {\n+\treturn fmt.Sprintf(\"%s for user: %s\", msgPrivilegedUserDisabled, e.Username)\n+}\n+\n+func (e *PrivilegedUserError) Is(target error) bool {\n+\treturn target == ErrPrivilegedUserDisabled\n+}\n+\n+// UserNotFoundError represents an error when a user cannot be found\n+type UserNotFoundError struct {\n+\tUsername string\n+\tCause    error\n+}\n+\n+func (e *UserNotFoundError) Error() string {\n+\tif e.Cause != nil {\n+\t\treturn fmt.Sprintf(\"user %s not found: %v\", e.Username, e.Cause)\n+\t}\n+\treturn fmt.Sprintf(\"user %s not found\", e.Username)\n+}\n+\n+func (e *UserNotFoundError) Is(target error) bool {\n+\treturn target == ErrUserNotFound\n+}\n+\n+func (e *UserNotFoundError) Unwrap() error {\n+\treturn e.Cause\n+}\n+\n+// logSessionExitError logs session exit errors, ignoring EOF (normal close) errors\n+func logSessionExitError(logger *log.Entry, err error) {\n+\tif err != nil && !errors.Is(err, io.EOF) {\n+\t\tlogger.Warnf(errExitSession, err)\n+\t}\n+}\n+\n+// safeLogCommand returns a safe representation of the command for logging\n+func safeLogCommand(cmd []string) string {\n+\tif len(cmd) == 0 {\n+\t\treturn \"<interactive shell>\"\n+\t}\n+\tif len(cmd) == 1 {\n+\t\treturn cmd[0]\n+\t}\n+\treturn fmt.Sprintf(\"%s [%d args]\", cmd[0], len(cmd)-1)\n+}\n+\n+type sshConnectionState struct {\n+\thasActivePortForward bool\n+\tusername             string\n+\tremoteAddr           string\n+}\n+\n+type authKey string\n+\n+func newAuthKey(username string, remoteAddr net.Addr) authKey {\n+\treturn authKey(fmt.Sprintf(\"%s@%s\", username, remoteAddr.String()))\n+}\n+\n+type Server struct {\n+\tsshServer       *ssh.Server\n+\tmu              sync.RWMutex\n+\thostKeyPEM      []byte\n+\tsessions        map[SessionKey]ssh.Session\n+\tsessionCancels  map[ConnectionKey]context.CancelFunc\n+\tsessionJWTUsers map[SessionKey]string\n+\tpendingAuthJWT  map[authKey]string\n+\n+\tallowLocalPortForwarding  bool\n+\tallowRemotePortForwarding bool\n+\tallowRootLogin            bool\n+\tallowSFTP                 bool\n+\tjwtEnabled                bool\n+\n+\tnetstackNet *netstack.Net\n+\n+\twgAddress wgaddr.Address\n+\n+\tremoteForwardListeners map[ForwardKey]net.Listener\n+\tsshConnections         map[*cryptossh.ServerConn]*sshConnectionState\n+\n+\tjwtValidator *jwt.Validator\n+\tjwtExtractor *jwt.ClaimsExtractor\n+\tjwtConfig    *JWTConfig\n+\n+\tsuSupportsPty bool\n+}\n+\n+type JWTConfig struct {\n+\tIssuer       string\n+\tAudience     string\n+\tKeysLocation string\n+\tMaxTokenAge  int64\n+}\n+\n+// Config contains all SSH server configuration options\n+type Config struct {\n+\t// JWT authentication configuration. If nil, JWT authentication is disabled\n+\tJWT *JWTConfig\n+\n+\t// HostKey is the SSH server host key in PEM format\n+\tHostKeyPEM []byte\n+}\n+\n+// SessionInfo contains information about an active SSH session\n+type SessionInfo struct {\n+\tUsername      string\n+\tRemoteAddress string\n+\tCommand       string\n+\tJWTUsername   string\n+}\n+\n+// New creates an SSH server instance with the provided host key and optional JWT configuration\n+// If jwtConfig is nil, JWT authentication is disabled\n+func New(config *Config) *Server {\n+\ts := &Server{\n+\t\tmu:                     sync.RWMutex{},\n+\t\thostKeyPEM:             config.HostKeyPEM,\n+\t\tsessions:               make(map[SessionKey]ssh.Session),\n+\t\tsessionJWTUsers:        make(map[SessionKey]string),\n+\t\tpendingAuthJWT:         make(map[authKey]string),\n+\t\tremoteForwardListeners: make(map[ForwardKey]net.Listener),\n+\t\tsshConnections:         make(map[*cryptossh.ServerConn]*sshConnectionState),\n+\t\tjwtEnabled:             config.JWT != nil,\n+\t\tjwtConfig:              config.JWT,\n+\t}\n+\n+\treturn s\n+}\n+\n+// Start runs the SSH server\n+func (s *Server) Start(ctx context.Context, addr netip.AddrPort) error {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n+\tif s.sshServer != nil {\n+\t\treturn errors.New(\"SSH server is already running\")\n+\t}\n+\n+\ts.suSupportsPty = s.detectSuPtySupport(ctx)\n+\n+\tln, addrDesc, err := s.createListener(ctx, addr)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"create listener: %w\", err)\n+\t}\n+\n+\tsshServer, err := s.createSSHServer(ln.Addr())\n+\tif err != nil {\n+\t\ts.closeListener(ln)\n+\t\treturn fmt.Errorf(\"create SSH server: %w\", err)\n+\t}\n+\n+\ts.sshServer = sshServer\n+\tlog.Infof(\"SSH server started on %s\", addrDesc)\n+\n+\tgo func() {\n+\t\tif err := sshServer.Serve(ln); err != nil && !errors.Is(err, ssh.ErrServerClosed) {\n+\t\t\tlog.Errorf(\"SSH server error: %v\", err)\n+\t\t}\n+\t}()\n+\treturn nil\n+}\n+\n+func (s *Server) createListener(ctx context.Context, addr netip.AddrPort) (net.Listener, string, error) {\n+\tif s.netstackNet != nil {\n+\t\tln, err := s.netstackNet.ListenTCPAddrPort(addr)\n+\t\tif err != nil {\n+\t\t\treturn nil, \"\", fmt.Errorf(\"listen on netstack: %w\", err)\n+\t\t}\n+\t\treturn ln, fmt.Sprintf(\"netstack %s\", addr), nil\n+\t}\n+\n+\ttcpAddr := net.TCPAddrFromAddrPort(addr)\n+\tlc := net.ListenConfig{}\n+\tln, err := lc.Listen(ctx, \"tcp\", tcpAddr.String())\n+\tif err != nil {\n+\t\treturn nil, \"\", fmt.Errorf(\"listen: %w\", err)\n+\t}\n+\treturn ln, addr.String(), nil\n+}\n+\n+func (s *Server) closeListener(ln net.Listener) {\n+\tif ln == nil {\n+\t\treturn\n+\t}\n+\tif err := ln.Close(); err != nil {\n+\t\tlog.Debugf(\"listener close error: %v\", err)\n+\t}\n+}\n+\n+// Stop closes the SSH server\n+func (s *Server) Stop() error {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n+\tif s.sshServer == nil {\n+\t\treturn nil\n+\t}\n+\n+\tif err := s.sshServer.Close(); err != nil {\n+\t\tlog.Debugf(\"close SSH server: %v\", err)\n+\t}\n+\n+\ts.sshServer = nil\n+\n+\tmaps.Clear(s.sessions)\n+\tmaps.Clear(s.sessionJWTUsers)\n+\tmaps.Clear(s.pendingAuthJWT)\n+\tmaps.Clear(s.sshConnections)\n+\n+\tfor _, cancelFunc := range s.sessionCancels {\n+\t\tcancelFunc()\n+\t}\n+\tmaps.Clear(s.sessionCancels)\n+\n+\tfor _, listener := range s.remoteForwardListeners {\n+\t\tif err := listener.Close(); err != nil {\n+\t\t\tlog.Debugf(\"close remote forward listener: %v\", err)\n+\t\t}\n+\t}\n+\tmaps.Clear(s.remoteForwardListeners)\n+\n+\treturn nil\n+}\n+\n+// GetStatus returns the current status of the SSH server and active sessions\n+func (s *Server) GetStatus() (enabled bool, sessions []SessionInfo) {\n+\ts.mu.RLock()\n+\tdefer s.mu.RUnlock()\n+\n+\tenabled = s.sshServer != nil\n+\n+\tfor sessionKey, session := range s.sessions {\n+\t\tcmd := \"<interactive shell>\"\n+\t\tif len(session.Command()) > 0 {\n+\t\t\tcmd = safeLogCommand(session.Command())\n+\t\t}\n+\n+\t\tjwtUsername := s.sessionJWTUsers[sessionKey]\n+\n+\t\tsessions = append(sessions, SessionInfo{\n+\t\t\tUsername:      session.User(),\n+\t\t\tRemoteAddress: session.RemoteAddr().String(),\n+\t\t\tCommand:       cmd,\n+\t\t\tJWTUsername:   jwtUsername,\n+\t\t})\n+\t}\n+\n+\treturn enabled, sessions\n+}\n+\n+// SetNetstackNet sets the netstack network for userspace networking\n+func (s *Server) SetNetstackNet(net *netstack.Net) {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\ts.netstackNet = net\n+}\n+\n+// SetNetworkValidation configures network-based connection filtering\n+func (s *Server) SetNetworkValidation(addr wgaddr.Address) {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\ts.wgAddress = addr\n+}\n+\n+// ensureJWTValidator initializes the JWT validator and extractor if not already initialized\n+func (s *Server) ensureJWTValidator() error {\n+\ts.mu.RLock()\n+\tif s.jwtValidator != nil && s.jwtExtractor != nil {\n+\t\ts.mu.RUnlock()\n+\t\treturn nil\n+\t}\n+\tconfig := s.jwtConfig\n+\ts.mu.RUnlock()\n+\n+\tif config == nil {\n+\t\treturn fmt.Errorf(\"JWT config not set\")\n+\t}\n+\n+\tlog.Debugf(\"Initializing JWT validator (issuer: %s, audience: %s)\", config.Issuer, config.Audience)\n+\n+\tvalidator := jwt.NewValidator(\n+\t\tconfig.Issuer,\n+\t\t[]string{config.Audience},\n+\t\tconfig.KeysLocation,\n+\t\ttrue,\n+\t)\n+\n+\textractor := jwt.NewClaimsExtractor(\n+\t\tjwt.WithAudience(config.Audience),\n+\t)\n+\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n+\tif s.jwtValidator != nil && s.jwtExtractor != nil {\n+\t\treturn nil\n+\t}\n+\n+\ts.jwtValidator = validator\n+\ts.jwtExtractor = extractor\n+\n+\tlog.Infof(\"JWT validator initialized successfully\")\n+\treturn nil\n+}\n+\n+func (s *Server) validateJWTToken(tokenString string) (*gojwt.Token, error) {\n+\ts.mu.RLock()\n+\tjwtValidator := s.jwtValidator\n+\tjwtConfig := s.jwtConfig\n+\ts.mu.RUnlock()\n+\n+\tif jwtValidator == nil {\n+\t\treturn nil, fmt.Errorf(\"JWT validator not initialized\")\n+\t}\n+\n+\ttoken, err := jwtValidator.ValidateAndParse(context.Background(), tokenString)\n+\tif err != nil {\n+\t\tif jwtConfig != nil {\n+\t\t\tif claims, parseErr := s.parseTokenWithoutValidation(tokenString); parseErr == nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"validate token (expected issuer=%s, audience=%s, actual issuer=%v, audience=%v): %w\",\n+\t\t\t\t\tjwtConfig.Issuer, jwtConfig.Audience, claims[\"iss\"], claims[\"aud\"], err)\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"validate token: %w\", err)\n+\t}\n+\n+\tif err := s.checkTokenAge(token, jwtConfig); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn token, nil\n+}\n+\n+func (s *Server) checkTokenAge(token *gojwt.Token, jwtConfig *JWTConfig) error {\n+\tif jwtConfig == nil {\n+\t\treturn nil\n+\t}\n+\n+\tmaxTokenAge := jwtConfig.MaxTokenAge\n+\tif maxTokenAge <= 0 {\n+\t\tmaxTokenAge = DefaultJWTMaxTokenAge\n+\t}\n+\n+\tclaims, ok := token.Claims.(gojwt.MapClaims)\n+\tif !ok {\n+\t\tuserID := extractUserID(token)\n+\t\treturn fmt.Errorf(\"token has invalid claims format (user=%s)\", userID)\n+\t}\n+\n+\tiat, ok := claims[\"iat\"].(float64)\n+\tif !ok {\n+\t\tuserID := extractUserID(token)\n+\t\treturn fmt.Errorf(\"token missing iat claim (user=%s)\", userID)\n+\t}\n+\n+\tissuedAt := time.Unix(int64(iat), 0)\n+\ttokenAge := time.Since(issuedAt)\n+\tmaxAge := time.Duration(maxTokenAge) * time.Second\n+\tif tokenAge > maxAge {\n+\t\tuserID := getUserIDFromClaims(claims)\n+\t\treturn fmt.Errorf(\"token expired for user=%s: age=%v, max=%v\", userID, tokenAge, maxAge)\n+\t}\n+\n+\treturn nil\n+}\n+\n+func (s *Server) extractAndValidateUser(token *gojwt.Token) (*auth.UserAuth, error) {\n+\ts.mu.RLock()\n+\tjwtExtractor := s.jwtExtractor\n+\ts.mu.RUnlock()\n+\n+\tif jwtExtractor == nil {\n+\t\tuserID := extractUserID(token)\n+\t\treturn nil, fmt.Errorf(\"JWT extractor not initialized (user=%s)\", userID)\n+\t}\n+\n+\tuserAuth, err := jwtExtractor.ToUserAuth(token)\n+\tif err != nil {\n+\t\tuserID := extractUserID(token)\n+\t\treturn nil, fmt.Errorf(\"extract user from token (user=%s): %w\", userID, err)\n+\t}\n+\n+\tif !s.hasSSHAccess(&userAuth) {\n+\t\treturn nil, fmt.Errorf(\"user %s does not have SSH access permissions\", userAuth.UserId)\n+\t}\n+\n+\treturn &userAuth, nil\n+}\n+\n+func (s *Server) hasSSHAccess(userAuth *auth.UserAuth) bool {\n+\treturn userAuth.UserId != \"\"\n+}\n+\n+func extractUserID(token *gojwt.Token) string {\n+\tif token == nil {\n+\t\treturn \"unknown\"\n+\t}\n+\tclaims, ok := token.Claims.(gojwt.MapClaims)\n+\tif !ok {\n+\t\treturn \"unknown\"\n+\t}\n+\treturn getUserIDFromClaims(claims)\n+}\n+\n+func getUserIDFromClaims(claims gojwt.MapClaims) string {\n+\tif sub, ok := claims[\"sub\"].(string); ok && sub != \"\" {\n+\t\treturn sub\n+\t}\n+\tif userID, ok := claims[\"user_id\"].(string); ok && userID != \"\" {\n+\t\treturn userID\n+\t}\n+\tif email, ok := claims[\"email\"].(string); ok && email != \"\" {\n+\t\treturn email\n+\t}\n+\treturn \"unknown\"\n+}\n+\n+func (s *Server) parseTokenWithoutValidation(tokenString string) (map[string]interface{}, error) {\n+\tparts := strings.Split(tokenString, \".\")\n+\tif len(parts) != 3 {\n+\t\treturn nil, fmt.Errorf(\"invalid token format\")\n+\t}\n+\n+\tpayload, err := base64.RawURLEncoding.DecodeString(parts[1])\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"decode payload: %w\", err)\n+\t}\n+\n+\tvar claims map[string]interface{}\n+\tif err := json.Unmarshal(payload, &claims); err != nil {\n+\t\treturn nil, fmt.Errorf(\"parse claims: %w\", err)\n+\t}\n+\n+\treturn claims, nil\n+}\n+\n+func (s *Server) passwordHandler(ctx ssh.Context, password string) bool {\n+\tif err := s.ensureJWTValidator(); err != nil {\n+\t\tlog.Errorf(\"JWT validator initialization failed for user %s from %s: %v\", ctx.User(), ctx.RemoteAddr(), err)\n+\t\treturn false\n+\t}\n+\n+\ttoken, err := s.validateJWTToken(password)\n+\tif err != nil {\n+\t\tlog.Warnf(\"JWT authentication failed for user %s from %s: %v\", ctx.User(), ctx.RemoteAddr(), err)\n+\t\treturn false\n+\t}\n+\n+\tuserAuth, err := s.extractAndValidateUser(token)\n+\tif err != nil {\n+\t\tlog.Warnf(\"User validation failed for user %s from %s: %v\", ctx.User(), ctx.RemoteAddr(), err)\n+\t\treturn false\n+\t}\n+\n+\tkey := newAuthKey(ctx.User(), ctx.RemoteAddr())\n+\ts.mu.Lock()\n+\ts.pendingAuthJWT[key] = userAuth.UserId\n+\ts.mu.Unlock()\n+\n+\tlog.Infof(\"JWT authentication successful for user %s (JWT user ID: %s) from %s\", ctx.User(), userAuth.UserId, ctx.RemoteAddr())\n+\treturn true\n+}\n+\n+func (s *Server) markConnectionActivePortForward(sshConn *cryptossh.ServerConn, username, remoteAddr string) {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n+\tif state, exists := s.sshConnections[sshConn]; exists {\n+\t\tstate.hasActivePortForward = true\n+\t} else {\n+\t\ts.sshConnections[sshConn] = &sshConnectionState{\n+\t\t\thasActivePortForward: true,\n+\t\t\tusername:             username,\n+\t\t\tremoteAddr:           remoteAddr,\n+\t\t}\n+\t}\n+}\n+\n+func (s *Server) connectionCloseHandler(conn net.Conn, err error) {\n+\t// We can't extract the SSH connection from net.Conn directly\n+\t// Connection cleanup will happen during session cleanup or via timeout\n+\tlog.Debugf(\"SSH connection failed for %s: %v\", conn.RemoteAddr(), err)\n+}\n+\n+func (s *Server) findSessionKeyByContext(ctx ssh.Context) SessionKey {\n+\tif ctx == nil {\n+\t\treturn \"unknown\"\n+\t}\n+\n+\t// Try to match by SSH connection\n+\tsshConn := ctx.Value(ssh.ContextKeyConn)\n+\tif sshConn == nil {\n+\t\treturn \"unknown\"\n+\t}\n+\n+\ts.mu.RLock()\n+\tdefer s.mu.RUnlock()\n+\n+\t// Look through sessions to find one with matching connection\n+\tfor sessionKey, session := range s.sessions {\n+\t\tif session.Context().Value(ssh.ContextKeyConn) == sshConn {\n+\t\t\treturn sessionKey\n+\t\t}\n+\t}\n+\n+\t// If no session found, this might be during early connection setup\n+\t// Return a temporary key that we'll fix up later\n+\tif ctx.User() != \"\" && ctx.RemoteAddr() != nil {\n+\t\ttempKey := SessionKey(fmt.Sprintf(\"%s@%s\", ctx.User(), ctx.RemoteAddr().String()))\n+\t\tlog.Debugf(\"Using temporary session key for early port forward tracking: %s (will be updated when session established)\", tempKey)\n+\t\treturn tempKey\n+\t}\n+\n+\treturn \"unknown\"\n+}\n+\n+func (s *Server) connectionValidator(_ ssh.Context, conn net.Conn) net.Conn {\n+\ts.mu.RLock()\n+\tnetbirdNetwork := s.wgAddress.Network\n+\tlocalIP := s.wgAddress.IP\n+\ts.mu.RUnlock()\n+\n+\tif !netbirdNetwork.IsValid() || !localIP.IsValid() {\n+\t\treturn conn\n+\t}\n+\n+\tremoteAddr := conn.RemoteAddr()\n+\ttcpAddr, ok := remoteAddr.(*net.TCPAddr)\n+\tif !ok {\n+\t\tlog.Warnf(\"SSH connection rejected: non-TCP address %s\", remoteAddr)\n+\t\treturn nil\n+\t}\n+\n+\tremoteIP, ok := netip.AddrFromSlice(tcpAddr.IP)\n+\tif !ok {\n+\t\tlog.Warnf(\"SSH connection rejected: invalid remote IP %s\", tcpAddr.IP)\n+\t\treturn nil\n+\t}\n+\n+\t// Block connections from our own IP (prevent local apps from connecting to ourselves)\n+\tif remoteIP == localIP {\n+\t\tlog.Warnf(\"SSH connection rejected from own IP %s\", remoteIP)\n+\t\treturn nil\n+\t}\n+\n+\tif !netbirdNetwork.Contains(remoteIP) {\n+\t\tlog.Warnf(\"SSH connection rejected from non-NetBird IP %s\", remoteIP)\n+\t\treturn nil\n+\t}\n+\n+\tlog.Infof(\"SSH connection from NetBird peer %s allowed\", tcpAddr)\n+\treturn conn\n+}\n+\n+func (s *Server) createSSHServer(addr net.Addr) (*ssh.Server, error) {\n+\tif err := enableUserSwitching(); err != nil {\n+\t\tlog.Warnf(\"failed to enable user switching: %v\", err)\n+\t}\n+\n+\tserverVersion := fmt.Sprintf(\"%s-%s\", detection.ServerIdentifier, version.NetbirdVersion())\n+\tif s.jwtEnabled {\n+\t\tserverVersion += \" \" + detection.JWTRequiredMarker\n+\t}\n+\n+\tserver := &ssh.Server{\n+\t\tAddr:    addr.String(),\n+\t\tHandler: s.sessionHandler,\n+\t\tSubsystemHandlers: map[string]ssh.SubsystemHandler{\n+\t\t\t\"sftp\": s.sftpSubsystemHandler,\n+\t\t},\n+\t\tHostSigners: []ssh.Signer{},\n+\t\tChannelHandlers: map[string]ssh.ChannelHandler{\n+\t\t\t\"session\":      ssh.DefaultSessionHandler,\n+\t\t\t\"direct-tcpip\": s.directTCPIPHandler,\n+\t\t},\n+\t\tRequestHandlers: map[string]ssh.RequestHandler{\n+\t\t\t\"tcpip-forward\":        s.tcpipForwardHandler,\n+\t\t\t\"cancel-tcpip-forward\": s.cancelTcpipForwardHandler,\n+\t\t},\n+\t\tConnCallback:             s.connectionValidator,\n+\t\tConnectionFailedCallback: s.connectionCloseHandler,\n+\t\tVersion:                  serverVersion,\n+\t}\n+\n+\tif s.jwtEnabled {\n+\t\tserver.PasswordHandler = s.passwordHandler\n+\t}\n+\n+\thostKeyPEM := ssh.HostKeyPEM(s.hostKeyPEM)\n+\tif err := server.SetOption(hostKeyPEM); err != nil {\n+\t\treturn nil, fmt.Errorf(\"set host key: %w\", err)\n+\t}\n+\n+\ts.configurePortForwarding(server)\n+\treturn server, nil\n+}\n+\n+func (s *Server) storeRemoteForwardListener(key ForwardKey, ln net.Listener) {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\ts.remoteForwardListeners[key] = ln\n+}\n+\n+func (s *Server) removeRemoteForwardListener(key ForwardKey) bool {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n+\tln, exists := s.remoteForwardListeners[key]\n+\tif !exists {\n+\t\treturn false\n+\t}\n+\n+\tdelete(s.remoteForwardListeners, key)\n+\tif err := ln.Close(); err != nil {\n+\t\tlog.Debugf(\"remote forward listener close error: %v\", err)\n+\t}\n+\n+\treturn true\n+}\n+\n+func (s *Server) directTCPIPHandler(srv *ssh.Server, conn *cryptossh.ServerConn, newChan cryptossh.NewChannel, ctx ssh.Context) {\n+\tvar payload struct {\n+\t\tHost           string\n+\t\tPort           uint32\n+\t\tOriginatorAddr string\n+\t\tOriginatorPort uint32\n+\t}\n+\n+\tif err := cryptossh.Unmarshal(newChan.ExtraData(), &payload); err != nil {\n+\t\tif err := newChan.Reject(cryptossh.ConnectionFailed, \"parse payload\"); err != nil {\n+\t\t\tlog.Debugf(\"channel reject error: %v\", err)\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\ts.mu.RLock()\n+\tallowLocal := s.allowLocalPortForwarding\n+\ts.mu.RUnlock()\n+\n+\tif !allowLocal {\n+\t\tlog.Warnf(\"local port forwarding denied for %s:%d: disabled by configuration\", payload.Host, payload.Port)\n+\t\t_ = newChan.Reject(cryptossh.Prohibited, \"local port forwarding disabled\")\n+\t\treturn\n+\t}\n+\n+\t// Check privilege requirements for the destination port\n+\tif err := s.checkPortForwardingPrivileges(ctx, \"local\", payload.Port); err != nil {\n+\t\tlog.Warnf(\"local port forwarding denied for %s:%d: %v\", payload.Host, payload.Port, err)\n+\t\t_ = newChan.Reject(cryptossh.Prohibited, \"insufficient privileges\")\n+\t\treturn\n+\t}\n+\n+\tlog.Infof(\"local port forwarding: %s:%d\", payload.Host, payload.Port)\n+\n+\tssh.DirectTCPIPHandler(srv, conn, newChan, ctx)\n+}\ndiff --git a/client/ssh/server/session_handlers.go b/client/ssh/server/session_handlers.go\nnew file mode 100644\nindex 00000000000..4e6d720980e\n--- /dev/null\n+++ b/client/ssh/server/session_handlers.go\n@@ -0,0 +1,168 @@\n+package server\n+\n+import (\n+\t\"crypto/sha256\"\n+\t\"encoding/hex\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\tcryptossh \"golang.org/x/crypto/ssh\"\n+)\n+\n+// sessionHandler handles SSH sessions\n+func (s *Server) sessionHandler(session ssh.Session) {\n+\tsessionKey := s.registerSession(session)\n+\n+\tkey := newAuthKey(session.User(), session.RemoteAddr())\n+\ts.mu.Lock()\n+\tjwtUsername := s.pendingAuthJWT[key]\n+\tif jwtUsername != \"\" {\n+\t\ts.sessionJWTUsers[sessionKey] = jwtUsername\n+\t\tdelete(s.pendingAuthJWT, key)\n+\t}\n+\ts.mu.Unlock()\n+\n+\tlogger := log.WithField(\"session\", sessionKey)\n+\tif jwtUsername != \"\" {\n+\t\tlogger = logger.WithField(\"jwt_user\", jwtUsername)\n+\t\tlogger.Infof(\"SSH session started (JWT user: %s)\", jwtUsername)\n+\t} else {\n+\t\tlogger.Infof(\"SSH session started\")\n+\t}\n+\tsessionStart := time.Now()\n+\n+\tdefer s.unregisterSession(sessionKey, session)\n+\tdefer func() {\n+\t\tduration := time.Since(sessionStart).Round(time.Millisecond)\n+\t\tif err := session.Close(); err != nil && !errors.Is(err, io.EOF) {\n+\t\t\tlogger.Warnf(\"close session after %v: %v\", duration, err)\n+\t\t}\n+\t\tlogger.Infof(\"SSH session closed after %v\", duration)\n+\t}()\n+\n+\tprivilegeResult, err := s.userPrivilegeCheck(session.User())\n+\tif err != nil {\n+\t\ts.handlePrivError(logger, session, err)\n+\t\treturn\n+\t}\n+\n+\tptyReq, winCh, isPty := session.Pty()\n+\thasCommand := len(session.Command()) > 0\n+\n+\tswitch {\n+\tcase isPty && hasCommand:\n+\t\t// ssh -t <host> <cmd> - Pty command execution\n+\t\ts.handleCommand(logger, session, privilegeResult, winCh)\n+\tcase isPty:\n+\t\t// ssh <host> - Pty interactive session (login)\n+\t\ts.handlePty(logger, session, privilegeResult, ptyReq, winCh)\n+\tcase hasCommand:\n+\t\t// ssh <host> <cmd> - non-Pty command execution\n+\t\ts.handleCommand(logger, session, privilegeResult, nil)\n+\tdefault:\n+\t\ts.rejectInvalidSession(logger, session)\n+\t}\n+}\n+\n+func (s *Server) rejectInvalidSession(logger *log.Entry, session ssh.Session) {\n+\tif _, err := io.WriteString(session, \"no command specified and Pty not requested\\n\"); err != nil {\n+\t\tlogger.Debugf(errWriteSession, err)\n+\t}\n+\tif err := session.Exit(1); err != nil {\n+\t\tlogSessionExitError(logger, err)\n+\t}\n+\tlogger.Infof(\"rejected non-Pty session without command from %s\", session.RemoteAddr())\n+}\n+\n+func (s *Server) registerSession(session ssh.Session) SessionKey {\n+\tsessionID := session.Context().Value(ssh.ContextKeySessionID)\n+\tif sessionID == nil {\n+\t\tsessionID = fmt.Sprintf(\"%p\", session)\n+\t}\n+\n+\t// Create a short 4-byte identifier from the full session ID\n+\thasher := sha256.New()\n+\thasher.Write([]byte(fmt.Sprintf(\"%v\", sessionID)))\n+\thash := hasher.Sum(nil)\n+\tshortID := hex.EncodeToString(hash[:4])\n+\n+\tremoteAddr := session.RemoteAddr().String()\n+\tusername := session.User()\n+\tsessionKey := SessionKey(fmt.Sprintf(\"%s@%s-%s\", username, remoteAddr, shortID))\n+\n+\ts.mu.Lock()\n+\ts.sessions[sessionKey] = session\n+\ts.mu.Unlock()\n+\n+\treturn sessionKey\n+}\n+\n+func (s *Server) unregisterSession(sessionKey SessionKey, session ssh.Session) {\n+\ts.mu.Lock()\n+\tdelete(s.sessions, sessionKey)\n+\tdelete(s.sessionJWTUsers, sessionKey)\n+\n+\t// Cancel all port forwarding connections for this session\n+\tvar connectionsToCancel []ConnectionKey\n+\tfor key := range s.sessionCancels {\n+\t\tif strings.HasPrefix(string(key), string(sessionKey)+\"-\") {\n+\t\t\tconnectionsToCancel = append(connectionsToCancel, key)\n+\t\t}\n+\t}\n+\n+\tfor _, key := range connectionsToCancel {\n+\t\tif cancelFunc, exists := s.sessionCancels[key]; exists {\n+\t\t\tlog.WithField(\"session\", sessionKey).Debugf(\"cancelling port forwarding context: %s\", key)\n+\t\t\tcancelFunc()\n+\t\t\tdelete(s.sessionCancels, key)\n+\t\t}\n+\t}\n+\n+\tif sshConnValue := session.Context().Value(ssh.ContextKeyConn); sshConnValue != nil {\n+\t\tif sshConn, ok := sshConnValue.(*cryptossh.ServerConn); ok {\n+\t\t\tdelete(s.sshConnections, sshConn)\n+\t\t}\n+\t}\n+\n+\ts.mu.Unlock()\n+}\n+\n+func (s *Server) handlePrivError(logger *log.Entry, session ssh.Session, err error) {\n+\tlogger.Warnf(\"user privilege check failed: %v\", err)\n+\n+\terrorMsg := s.buildUserLookupErrorMessage(err)\n+\n+\tif _, writeErr := fmt.Fprint(session, errorMsg); writeErr != nil {\n+\t\tlogger.Debugf(errWriteSession, writeErr)\n+\t}\n+\tif exitErr := session.Exit(1); exitErr != nil {\n+\t\tlogSessionExitError(logger, exitErr)\n+\t}\n+}\n+\n+// buildUserLookupErrorMessage creates appropriate user-facing error messages based on error type\n+func (s *Server) buildUserLookupErrorMessage(err error) string {\n+\tvar privilegedErr *PrivilegedUserError\n+\n+\tswitch {\n+\tcase errors.As(err, &privilegedErr):\n+\t\tif privilegedErr.Username == \"root\" {\n+\t\t\treturn \"root login is disabled on this SSH server\\n\"\n+\t\t}\n+\t\treturn \"privileged user access is disabled on this SSH server\\n\"\n+\n+\tcase errors.Is(err, ErrPrivilegeRequired):\n+\t\treturn \"Windows user switching failed - NetBird must run with elevated privileges for user switching\\n\"\n+\n+\tcase errors.Is(err, ErrPrivilegedUserSwitch):\n+\t\treturn \"Cannot switch to privileged user - current user lacks required privileges\\n\"\n+\n+\tdefault:\n+\t\treturn \"User authentication failed\\n\"\n+\t}\n+}\ndiff --git a/client/ssh/server/session_handlers_js.go b/client/ssh/server/session_handlers_js.go\nnew file mode 100644\nindex 00000000000..c35e4da0b6e\n--- /dev/null\n+++ b/client/ssh/server/session_handlers_js.go\n@@ -0,0 +1,22 @@\n+//go:build js\n+\n+package server\n+\n+import (\n+\t\"fmt\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+)\n+\n+// handlePty is not supported on JS/WASM\n+func (s *Server) handlePty(logger *log.Entry, session ssh.Session, _ PrivilegeCheckResult, _ ssh.Pty, _ <-chan ssh.Window) bool {\n+\terrorMsg := \"PTY sessions are not supported on WASM/JS platform\\n\"\n+\tif _, err := fmt.Fprint(session.Stderr(), errorMsg); err != nil {\n+\t\tlogger.Debugf(errWriteSession, err)\n+\t}\n+\tif err := session.Exit(1); err != nil {\n+\t\tlogSessionExitError(logger, err)\n+\t}\n+\treturn false\n+}\ndiff --git a/client/ssh/server/sftp.go b/client/ssh/server/sftp.go\nnew file mode 100644\nindex 00000000000..c2b9f552bf2\n--- /dev/null\n+++ b/client/ssh/server/sftp.go\n@@ -0,0 +1,81 @@\n+package server\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\t\"github.com/pkg/sftp\"\n+\tlog \"github.com/sirupsen/logrus\"\n+)\n+\n+// SetAllowSFTP enables or disables SFTP support\n+func (s *Server) SetAllowSFTP(allow bool) {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\ts.allowSFTP = allow\n+}\n+\n+// sftpSubsystemHandler handles SFTP subsystem requests\n+func (s *Server) sftpSubsystemHandler(sess ssh.Session) {\n+\ts.mu.RLock()\n+\tallowSFTP := s.allowSFTP\n+\ts.mu.RUnlock()\n+\n+\tif !allowSFTP {\n+\t\tlog.Debugf(\"SFTP subsystem request denied: SFTP disabled\")\n+\t\tif err := sess.Exit(1); err != nil {\n+\t\t\tlog.Debugf(\"SFTP session exit failed: %v\", err)\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tresult := s.CheckPrivileges(PrivilegeCheckRequest{\n+\t\tRequestedUsername:         sess.User(),\n+\t\tFeatureSupportsUserSwitch: true,\n+\t\tFeatureName:               FeatureSFTP,\n+\t})\n+\n+\tif !result.Allowed {\n+\t\tlog.Warnf(\"SFTP access denied for user %s from %s: %v\", sess.User(), sess.RemoteAddr(), result.Error)\n+\t\tif err := sess.Exit(1); err != nil {\n+\t\t\tlog.Debugf(\"exit SFTP session: %v\", err)\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tlog.Debugf(\"SFTP subsystem request from user %s (effective user %s)\", sess.User(), result.User.Username)\n+\n+\tif !result.RequiresUserSwitching {\n+\t\tif err := s.executeSftpDirect(sess); err != nil {\n+\t\t\tlog.Errorf(\"SFTP direct execution: %v\", err)\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tif err := s.executeSftpWithPrivilegeDrop(sess, result.User); err != nil {\n+\t\tlog.Errorf(\"SFTP privilege drop execution: %v\", err)\n+\t}\n+}\n+\n+// executeSftpDirect executes SFTP directly without privilege dropping\n+func (s *Server) executeSftpDirect(sess ssh.Session) error {\n+\tlog.Debugf(\"starting SFTP session for user %s (no privilege dropping)\", sess.User())\n+\n+\tsftpServer, err := sftp.NewServer(sess)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"SFTP server creation: %w\", err)\n+\t}\n+\n+\tdefer func() {\n+\t\tif err := sftpServer.Close(); err != nil {\n+\t\t\tlog.Debugf(\"failed to close sftp server: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tif err := sftpServer.Serve(); err != nil && err != io.EOF {\n+\t\treturn fmt.Errorf(\"serve: %w\", err)\n+\t}\n+\n+\treturn nil\n+}\ndiff --git a/client/ssh/server/sftp_js.go b/client/ssh/server/sftp_js.go\nnew file mode 100644\nindex 00000000000..3b27aeff4c1\n--- /dev/null\n+++ b/client/ssh/server/sftp_js.go\n@@ -0,0 +1,12 @@\n+//go:build js\n+\n+package server\n+\n+import (\n+\t\"os/user\"\n+)\n+\n+// parseUserCredentials is not supported on JS/WASM\n+func (s *Server) parseUserCredentials(_ *user.User) (uint32, uint32, []uint32, error) {\n+\treturn 0, 0, nil, errNotSupported\n+}\ndiff --git a/client/ssh/server/sftp_unix.go b/client/ssh/server/sftp_unix.go\nnew file mode 100644\nindex 00000000000..44202bead8f\n--- /dev/null\n+++ b/client/ssh/server/sftp_unix.go\n@@ -0,0 +1,71 @@\n+//go:build !windows\n+\n+package server\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"os/user\"\n+\t\"strconv\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+)\n+\n+// executeSftpWithPrivilegeDrop executes SFTP using Unix privilege dropping\n+func (s *Server) executeSftpWithPrivilegeDrop(sess ssh.Session, targetUser *user.User) error {\n+\tuid, gid, groups, err := s.parseUserCredentials(targetUser)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"parse user credentials: %w\", err)\n+\t}\n+\n+\tsftpCmd, err := s.createSftpExecutorCommand(sess, uid, gid, groups, targetUser.HomeDir)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"create executor: %w\", err)\n+\t}\n+\n+\tsftpCmd.Stdin = sess\n+\tsftpCmd.Stdout = sess\n+\tsftpCmd.Stderr = sess.Stderr()\n+\n+\tlog.Tracef(\"starting SFTP with privilege dropping to user %s (UID=%d, GID=%d)\", targetUser.Username, uid, gid)\n+\n+\tif err := sftpCmd.Start(); err != nil {\n+\t\treturn fmt.Errorf(\"starting SFTP executor: %w\", err)\n+\t}\n+\n+\tif err := sftpCmd.Wait(); err != nil {\n+\t\tvar exitError *exec.ExitError\n+\t\tif errors.As(err, &exitError) {\n+\t\t\tlog.Tracef(\"SFTP process exited with code %d\", exitError.ExitCode())\n+\t\t\treturn nil\n+\t\t}\n+\t\treturn fmt.Errorf(\"exec: %w\", err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// createSftpExecutorCommand creates a command that spawns netbird ssh sftp for privilege dropping\n+func (s *Server) createSftpExecutorCommand(sess ssh.Session, uid, gid uint32, groups []uint32, workingDir string) (*exec.Cmd, error) {\n+\tnetbirdPath, err := os.Executable()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\targs := []string{\n+\t\t\"ssh\", \"sftp\",\n+\t\t\"--uid\", strconv.FormatUint(uint64(uid), 10),\n+\t\t\"--gid\", strconv.FormatUint(uint64(gid), 10),\n+\t\t\"--working-dir\", workingDir,\n+\t}\n+\n+\tfor _, group := range groups {\n+\t\targs = append(args, \"--groups\", strconv.FormatUint(uint64(group), 10))\n+\t}\n+\n+\tlog.Tracef(\"creating SFTP executor command: %s %v\", netbirdPath, args)\n+\treturn exec.CommandContext(sess.Context(), netbirdPath, args...), nil\n+}\ndiff --git a/client/ssh/server/sftp_windows.go b/client/ssh/server/sftp_windows.go\nnew file mode 100644\nindex 00000000000..dc532b9e766\n--- /dev/null\n+++ b/client/ssh/server/sftp_windows.go\n@@ -0,0 +1,91 @@\n+//go:build windows\n+\n+package server\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"os/user\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"golang.org/x/sys/windows\"\n+)\n+\n+// createSftpCommand creates a Windows SFTP command with user switching.\n+// The caller must close the returned token handle after starting the process.\n+func (s *Server) createSftpCommand(targetUser *user.User, sess ssh.Session) (*exec.Cmd, windows.Token, error) {\n+\tusername, domain := s.parseUsername(targetUser.Username)\n+\n+\tnetbirdPath, err := os.Executable()\n+\tif err != nil {\n+\t\treturn nil, 0, fmt.Errorf(\"get netbird executable path: %w\", err)\n+\t}\n+\n+\targs := []string{\n+\t\t\"ssh\", \"sftp\",\n+\t\t\"--working-dir\", targetUser.HomeDir,\n+\t\t\"--windows-username\", username,\n+\t\t\"--windows-domain\", domain,\n+\t}\n+\n+\tpd := NewPrivilegeDropper()\n+\ttoken, err := pd.createToken(username, domain)\n+\tif err != nil {\n+\t\treturn nil, 0, fmt.Errorf(\"create token: %w\", err)\n+\t}\n+\n+\tdefer func() {\n+\t\tif err := windows.CloseHandle(token); err != nil {\n+\t\t\tlog.Warnf(\"failed to close impersonation token: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tcmd, primaryToken, err := pd.createProcessWithToken(sess.Context(), windows.Token(token), netbirdPath, append([]string{netbirdPath}, args...), targetUser.HomeDir)\n+\tif err != nil {\n+\t\treturn nil, 0, fmt.Errorf(\"create SFTP command: %w\", err)\n+\t}\n+\n+\tlog.Debugf(\"Created Windows SFTP command with user switching for %s\", targetUser.Username)\n+\treturn cmd, primaryToken, nil\n+}\n+\n+// executeSftpCommand executes a Windows SFTP command with proper I/O handling\n+func (s *Server) executeSftpCommand(sess ssh.Session, sftpCmd *exec.Cmd, token windows.Token) error {\n+\tdefer func() {\n+\t\tif err := windows.CloseHandle(windows.Handle(token)); err != nil {\n+\t\t\tlog.Debugf(\"close primary token: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tsftpCmd.Stdin = sess\n+\tsftpCmd.Stdout = sess\n+\tsftpCmd.Stderr = sess.Stderr()\n+\n+\tif err := sftpCmd.Start(); err != nil {\n+\t\treturn fmt.Errorf(\"starting sftp executor: %w\", err)\n+\t}\n+\n+\tif err := sftpCmd.Wait(); err != nil {\n+\t\tvar exitError *exec.ExitError\n+\t\tif errors.As(err, &exitError) {\n+\t\t\tlog.Tracef(\"sftp process exited with code %d\", exitError.ExitCode())\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\treturn fmt.Errorf(\"exec sftp: %w\", err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// executeSftpWithPrivilegeDrop executes SFTP using Windows privilege dropping\n+func (s *Server) executeSftpWithPrivilegeDrop(sess ssh.Session, targetUser *user.User) error {\n+\tsftpCmd, token, err := s.createSftpCommand(targetUser, sess)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"create sftp: %w\", err)\n+\t}\n+\treturn s.executeSftpCommand(sess, sftpCmd, token)\n+}\ndiff --git a/client/ssh/server/shell.go b/client/ssh/server/shell.go\nnew file mode 100644\nindex 00000000000..fea9d291097\n--- /dev/null\n+++ b/client/ssh/server/shell.go\n@@ -0,0 +1,180 @@\n+package server\n+\n+import (\n+\t\"bufio\"\n+\t\"fmt\"\n+\t\"net\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"os/user\"\n+\t\"runtime\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+)\n+\n+const (\n+\tdefaultUnixShell = \"/bin/sh\"\n+\n+\tpwshExe       = \"pwsh.exe\" // #nosec G101 - This is not a credential, just executable name\n+\tpowershellExe = \"powershell.exe\"\n+)\n+\n+// getUserShell returns the appropriate shell for the given user ID\n+// Handles all platform-specific logic and fallbacks consistently\n+func getUserShell(userID string) string {\n+\tswitch runtime.GOOS {\n+\tcase \"windows\":\n+\t\treturn getWindowsUserShell()\n+\tdefault:\n+\t\treturn getUnixUserShell(userID)\n+\t}\n+}\n+\n+// getWindowsUserShell returns the best shell for Windows users.\n+// We intentionally do not support cmd.exe or COMSPEC fallbacks to avoid command injection\n+// vulnerabilities that arise from cmd.exe's complex command line parsing and special characters.\n+// PowerShell provides safer argument handling and is available on all modern Windows systems.\n+// Order: pwsh.exe -> powershell.exe\n+func getWindowsUserShell() string {\n+\tif path, err := exec.LookPath(pwshExe); err == nil {\n+\t\treturn path\n+\t}\n+\tif path, err := exec.LookPath(powershellExe); err == nil {\n+\t\treturn path\n+\t}\n+\n+\treturn `C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe`\n+}\n+\n+// getUnixUserShell returns the shell for Unix-like systems\n+func getUnixUserShell(userID string) string {\n+\tshell := getShellFromPasswd(userID)\n+\tif shell != \"\" {\n+\t\treturn shell\n+\t}\n+\n+\tif shell := os.Getenv(\"SHELL\"); shell != \"\" {\n+\t\treturn shell\n+\t}\n+\n+\treturn defaultUnixShell\n+}\n+\n+// getShellFromPasswd reads the shell from /etc/passwd for the given user ID\n+func getShellFromPasswd(userID string) string {\n+\tfile, err := os.Open(\"/etc/passwd\")\n+\tif err != nil {\n+\t\treturn \"\"\n+\t}\n+\tdefer func() {\n+\t\tif err := file.Close(); err != nil {\n+\t\t\tlog.Warnf(\"close /etc/passwd file: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tscanner := bufio.NewScanner(file)\n+\tfor scanner.Scan() {\n+\t\tline := scanner.Text()\n+\t\tfields := strings.Split(line, \":\")\n+\t\tif len(fields) < 7 {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// field 2 is UID\n+\t\tif fields[2] == userID {\n+\t\t\tshell := strings.TrimSpace(fields[6])\n+\t\t\treturn shell\n+\t\t}\n+\t}\n+\n+\tif err := scanner.Err(); err != nil {\n+\t\tlog.Warnf(\"error reading /etc/passwd: %v\", err)\n+\t}\n+\n+\treturn \"\"\n+}\n+\n+// prepareUserEnv prepares environment variables for user execution\n+func prepareUserEnv(user *user.User, shell string) []string {\n+\tpathValue := \"/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games\"\n+\tif runtime.GOOS == \"windows\" {\n+\t\tpathValue = `C:\\Windows\\System32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0`\n+\t}\n+\n+\treturn []string{\n+\t\tfmt.Sprint(\"SHELL=\" + shell),\n+\t\tfmt.Sprint(\"USER=\" + user.Username),\n+\t\tfmt.Sprint(\"LOGNAME=\" + user.Username),\n+\t\tfmt.Sprint(\"HOME=\" + user.HomeDir),\n+\t\t\"PATH=\" + pathValue,\n+\t}\n+}\n+\n+// acceptEnv checks if environment variable from SSH client should be accepted\n+// This is a whitelist of variables that SSH clients can send to the server\n+func acceptEnv(envVar string) bool {\n+\tvarName := envVar\n+\tif idx := strings.Index(envVar, \"=\"); idx != -1 {\n+\t\tvarName = envVar[:idx]\n+\t}\n+\n+\texactMatches := []string{\n+\t\t\"LANG\",\n+\t\t\"LANGUAGE\",\n+\t\t\"TERM\",\n+\t\t\"COLORTERM\",\n+\t\t\"EDITOR\",\n+\t\t\"VISUAL\",\n+\t\t\"PAGER\",\n+\t\t\"LESS\",\n+\t\t\"LESSCHARSET\",\n+\t\t\"TZ\",\n+\t}\n+\n+\tprefixMatches := []string{\n+\t\t\"LC_\",\n+\t}\n+\n+\tfor _, exact := range exactMatches {\n+\t\tif varName == exact {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\tfor _, prefix := range prefixMatches {\n+\t\tif strings.HasPrefix(varName, prefix) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\treturn false\n+}\n+\n+// prepareSSHEnv prepares SSH protocol-specific environment variables\n+// These variables provide information about the SSH connection itself\n+func prepareSSHEnv(session ssh.Session) []string {\n+\tremoteAddr := session.RemoteAddr()\n+\tlocalAddr := session.LocalAddr()\n+\n+\tremoteHost, remotePort, err := net.SplitHostPort(remoteAddr.String())\n+\tif err != nil {\n+\t\tremoteHost = remoteAddr.String()\n+\t\tremotePort = \"0\"\n+\t}\n+\n+\tlocalHost, localPort, err := net.SplitHostPort(localAddr.String())\n+\tif err != nil {\n+\t\tlocalHost = localAddr.String()\n+\t\tlocalPort = strconv.Itoa(InternalSSHPort)\n+\t}\n+\n+\treturn []string{\n+\t\t// SSH_CLIENT format: \"client_ip client_port server_port\"\n+\t\tfmt.Sprintf(\"SSH_CLIENT=%s %s %s\", remoteHost, remotePort, localPort),\n+\t\t// SSH_CONNECTION format: \"client_ip client_port server_ip server_port\"\n+\t\tfmt.Sprintf(\"SSH_CONNECTION=%s %s %s %s\", remoteHost, remotePort, localHost, localPort),\n+\t}\n+}\ndiff --git a/client/ssh/server/user_utils.go b/client/ssh/server/user_utils.go\nnew file mode 100644\nindex 00000000000..799882cbb51\n--- /dev/null\n+++ b/client/ssh/server/user_utils.go\n@@ -0,0 +1,411 @@\n+package server\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"os/user\"\n+\t\"runtime\"\n+\t\"strings\"\n+\n+\tlog \"github.com/sirupsen/logrus\"\n+)\n+\n+var (\n+\tErrPrivilegeRequired    = errors.New(\"SeAssignPrimaryTokenPrivilege required for user switching - NetBird must run with elevated privileges\")\n+\tErrPrivilegedUserSwitch = errors.New(\"cannot switch to privileged user - current user lacks required privileges\")\n+)\n+\n+// isPlatformUnix returns true for Unix-like platforms (Linux, macOS, etc.)\n+func isPlatformUnix() bool {\n+\treturn getCurrentOS() != \"windows\"\n+}\n+\n+// Dependency injection variables for testing - allows mocking dynamic runtime checks\n+var (\n+\tgetCurrentUser         = user.Current\n+\tlookupUser             = user.Lookup\n+\tgetCurrentOS           = func() string { return runtime.GOOS }\n+\tgetIsProcessPrivileged = isCurrentProcessPrivileged\n+\n+\tgetEuid = os.Geteuid\n+)\n+\n+const (\n+\t// FeatureSSHLogin represents SSH login operations for privilege checking\n+\tFeatureSSHLogin = \"SSH login\"\n+\t// FeatureSFTP represents SFTP operations for privilege checking\n+\tFeatureSFTP = \"SFTP\"\n+)\n+\n+// PrivilegeCheckRequest represents a privilege check request\n+type PrivilegeCheckRequest struct {\n+\t// Username being requested (empty = current user)\n+\tRequestedUsername         string\n+\tFeatureSupportsUserSwitch bool // Does this feature/operation support user switching?\n+\tFeatureName               string\n+}\n+\n+// PrivilegeCheckResult represents the result of a privilege check\n+type PrivilegeCheckResult struct {\n+\t// Allowed indicates whether the privilege check passed\n+\tAllowed bool\n+\t// User is the effective user to use for the operation (nil if not allowed)\n+\tUser *user.User\n+\t// Error contains the reason for denial (nil if allowed)\n+\tError error\n+\t// UsedFallback indicates we fell back to current user instead of requested user.\n+\t// This happens on Unix when running as an unprivileged user (e.g., in containers)\n+\t// where there's no point in user switching since we lack privileges anyway.\n+\t// When true, all privilege checks have already been performed and no additional\n+\t// privilege dropping or root checks are needed - the current user is the target.\n+\tUsedFallback bool\n+\t// RequiresUserSwitching indicates whether user switching will actually occur\n+\t// (false for fallback cases where no actual switching happens)\n+\tRequiresUserSwitching bool\n+}\n+\n+// CheckPrivileges performs comprehensive privilege checking for all SSH features.\n+// This is the single source of truth for privilege decisions across the SSH server.\n+func (s *Server) CheckPrivileges(req PrivilegeCheckRequest) PrivilegeCheckResult {\n+\tcontext, err := s.buildPrivilegeCheckContext(req.FeatureName)\n+\tif err != nil {\n+\t\treturn PrivilegeCheckResult{Allowed: false, Error: err}\n+\t}\n+\n+\t// Handle empty username case - but still check root access controls\n+\tif req.RequestedUsername == \"\" {\n+\t\tif isPrivilegedUsername(context.currentUser.Username) && !context.allowRoot {\n+\t\t\treturn PrivilegeCheckResult{\n+\t\t\t\tAllowed: false,\n+\t\t\t\tError:   &PrivilegedUserError{Username: context.currentUser.Username},\n+\t\t\t}\n+\t\t}\n+\t\treturn PrivilegeCheckResult{\n+\t\t\tAllowed:               true,\n+\t\t\tUser:                  context.currentUser,\n+\t\t\tRequiresUserSwitching: false,\n+\t\t}\n+\t}\n+\n+\treturn s.checkUserRequest(context, req)\n+}\n+\n+// buildPrivilegeCheckContext gathers all the context needed for privilege checking\n+func (s *Server) buildPrivilegeCheckContext(featureName string) (*privilegeCheckContext, error) {\n+\tcurrentUser, err := getCurrentUser()\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"get current user for %s: %w\", featureName, err)\n+\t}\n+\n+\ts.mu.RLock()\n+\tallowRoot := s.allowRootLogin\n+\ts.mu.RUnlock()\n+\n+\treturn &privilegeCheckContext{\n+\t\tcurrentUser:           currentUser,\n+\t\tcurrentUserPrivileged: getIsProcessPrivileged(),\n+\t\tallowRoot:             allowRoot,\n+\t}, nil\n+}\n+\n+// checkUserRequest handles normal privilege checking flow for specific usernames\n+func (s *Server) checkUserRequest(ctx *privilegeCheckContext, req PrivilegeCheckRequest) PrivilegeCheckResult {\n+\tif !ctx.currentUserPrivileged && isPlatformUnix() {\n+\t\tlog.Debugf(\"Unix non-privileged shortcut: falling back to current user %s for %s (requested: %s)\",\n+\t\t\tctx.currentUser.Username, req.FeatureName, req.RequestedUsername)\n+\t\treturn PrivilegeCheckResult{\n+\t\t\tAllowed:               true,\n+\t\t\tUser:                  ctx.currentUser,\n+\t\t\tUsedFallback:          true,\n+\t\t\tRequiresUserSwitching: false,\n+\t\t}\n+\t}\n+\n+\tresolvedUser, err := s.resolveRequestedUser(req.RequestedUsername)\n+\tif err != nil {\n+\t\t// Calculate if user switching would be required even if lookup failed\n+\t\tneedsUserSwitching := !isSameUser(req.RequestedUsername, ctx.currentUser.Username)\n+\t\treturn PrivilegeCheckResult{\n+\t\t\tAllowed:               false,\n+\t\t\tError:                 err,\n+\t\t\tRequiresUserSwitching: needsUserSwitching,\n+\t\t}\n+\t}\n+\n+\tneedsUserSwitching := !isSameResolvedUser(resolvedUser, ctx.currentUser)\n+\n+\tif isPrivilegedUsername(resolvedUser.Username) && !ctx.allowRoot {\n+\t\treturn PrivilegeCheckResult{\n+\t\t\tAllowed:               false,\n+\t\t\tError:                 &PrivilegedUserError{Username: resolvedUser.Username},\n+\t\t\tRequiresUserSwitching: needsUserSwitching,\n+\t\t}\n+\t}\n+\n+\tif needsUserSwitching && !req.FeatureSupportsUserSwitch {\n+\t\treturn PrivilegeCheckResult{\n+\t\t\tAllowed:               false,\n+\t\t\tError:                 fmt.Errorf(\"%s: user switching not supported by this feature\", req.FeatureName),\n+\t\t\tRequiresUserSwitching: needsUserSwitching,\n+\t\t}\n+\t}\n+\n+\treturn PrivilegeCheckResult{\n+\t\tAllowed:               true,\n+\t\tUser:                  resolvedUser,\n+\t\tRequiresUserSwitching: needsUserSwitching,\n+\t}\n+}\n+\n+// resolveRequestedUser resolves a username to its canonical user identity\n+func (s *Server) resolveRequestedUser(requestedUsername string) (*user.User, error) {\n+\tif requestedUsername == \"\" {\n+\t\treturn getCurrentUser()\n+\t}\n+\n+\tif err := validateUsername(requestedUsername); err != nil {\n+\t\treturn nil, fmt.Errorf(\"invalid username %q: %w\", requestedUsername, err)\n+\t}\n+\n+\tu, err := lookupUser(requestedUsername)\n+\tif err != nil {\n+\t\treturn nil, &UserNotFoundError{Username: requestedUsername, Cause: err}\n+\t}\n+\treturn u, nil\n+}\n+\n+// isSameResolvedUser compares two resolved user identities\n+func isSameResolvedUser(user1, user2 *user.User) bool {\n+\tif user1 == nil || user2 == nil {\n+\t\treturn user1 == user2\n+\t}\n+\treturn user1.Uid == user2.Uid\n+}\n+\n+// privilegeCheckContext holds all context needed for privilege checking\n+type privilegeCheckContext struct {\n+\tcurrentUser           *user.User\n+\tcurrentUserPrivileged bool\n+\tallowRoot             bool\n+}\n+\n+// isSameUser checks if two usernames refer to the same user\n+// SECURITY: This function must be conservative - it should only return true\n+// when we're certain both usernames refer to the exact same user identity\n+func isSameUser(requestedUsername, currentUsername string) bool {\n+\t// Empty requested username means current user\n+\tif requestedUsername == \"\" {\n+\t\treturn true\n+\t}\n+\n+\t// Exact match (most common case)\n+\tif getCurrentOS() == \"windows\" {\n+\t\tif strings.EqualFold(requestedUsername, currentUsername) {\n+\t\t\treturn true\n+\t\t}\n+\t} else {\n+\t\tif requestedUsername == currentUsername {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\t// Windows domain resolution: only allow domain stripping when comparing\n+\t// a bare username against the current user's domain-qualified name\n+\tif getCurrentOS() == \"windows\" {\n+\t\treturn isWindowsSameUser(requestedUsername, currentUsername)\n+\t}\n+\n+\treturn false\n+}\n+\n+// isWindowsSameUser handles Windows-specific user comparison with domain logic\n+func isWindowsSameUser(requestedUsername, currentUsername string) bool {\n+\t// Extract domain and username parts\n+\textractParts := func(name string) (domain, user string) {\n+\t\t// Handle DOMAIN\\username format\n+\t\tif idx := strings.LastIndex(name, `\\`); idx != -1 {\n+\t\t\treturn name[:idx], name[idx+1:]\n+\t\t}\n+\t\t// Handle user@domain.com format\n+\t\tif idx := strings.Index(name, \"@\"); idx != -1 {\n+\t\t\treturn name[idx+1:], name[:idx]\n+\t\t}\n+\t\t// No domain specified - local machine\n+\t\treturn \"\", name\n+\t}\n+\n+\treqDomain, reqUser := extractParts(requestedUsername)\n+\tcurDomain, curUser := extractParts(currentUsername)\n+\n+\t// Case-insensitive username comparison\n+\tif !strings.EqualFold(reqUser, curUser) {\n+\t\treturn false\n+\t}\n+\n+\t// If requested username has no domain, it refers to local machine user\n+\t// Allow this to match the current user regardless of current user's domain\n+\tif reqDomain == \"\" {\n+\t\treturn true\n+\t}\n+\n+\t// If both have domains, they must match exactly (case-insensitive)\n+\treturn strings.EqualFold(reqDomain, curDomain)\n+}\n+\n+// SetAllowRootLogin configures root login access\n+func (s *Server) SetAllowRootLogin(allow bool) {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\ts.allowRootLogin = allow\n+}\n+\n+// userNameLookup performs user lookup with root login permission check\n+func (s *Server) userNameLookup(username string) (*user.User, error) {\n+\tresult := s.CheckPrivileges(PrivilegeCheckRequest{\n+\t\tRequestedUsername:         username,\n+\t\tFeatureSupportsUserSwitch: true,\n+\t\tFeatureName:               FeatureSSHLogin,\n+\t})\n+\n+\tif !result.Allowed {\n+\t\treturn nil, result.Error\n+\t}\n+\n+\treturn result.User, nil\n+}\n+\n+// userPrivilegeCheck performs user lookup with full privilege check result\n+func (s *Server) userPrivilegeCheck(username string) (PrivilegeCheckResult, error) {\n+\tresult := s.CheckPrivileges(PrivilegeCheckRequest{\n+\t\tRequestedUsername:         username,\n+\t\tFeatureSupportsUserSwitch: true,\n+\t\tFeatureName:               FeatureSSHLogin,\n+\t})\n+\n+\tif !result.Allowed {\n+\t\treturn result, result.Error\n+\t}\n+\n+\treturn result, nil\n+}\n+\n+// isPrivilegedUsername checks if the given username represents a privileged user across platforms.\n+// On Unix: root\n+// On Windows: Administrator, SYSTEM (case-insensitive)\n+// Handles domain-qualified usernames like \"DOMAIN\\Administrator\" or \"user@domain.com\"\n+func isPrivilegedUsername(username string) bool {\n+\tif getCurrentOS() != \"windows\" {\n+\t\treturn username == \"root\"\n+\t}\n+\n+\tbareUsername := username\n+\t// Handle Windows domain format: DOMAIN\\username\n+\tif idx := strings.LastIndex(username, `\\`); idx != -1 {\n+\t\tbareUsername = username[idx+1:]\n+\t}\n+\t// Handle email-style format: username@domain.com\n+\tif idx := strings.Index(bareUsername, \"@\"); idx != -1 {\n+\t\tbareUsername = bareUsername[:idx]\n+\t}\n+\n+\treturn isWindowsPrivilegedUser(bareUsername)\n+}\n+\n+// isWindowsPrivilegedUser checks if a bare username (domain already stripped) represents a Windows privileged account\n+func isWindowsPrivilegedUser(bareUsername string) bool {\n+\t// common privileged usernames (case insensitive)\n+\tprivilegedNames := []string{\n+\t\t\"administrator\",\n+\t\t\"admin\",\n+\t\t\"root\",\n+\t\t\"system\",\n+\t\t\"localsystem\",\n+\t\t\"networkservice\",\n+\t\t\"localservice\",\n+\t}\n+\n+\tusernameLower := strings.ToLower(bareUsername)\n+\tfor _, privilegedName := range privilegedNames {\n+\t\tif usernameLower == privilegedName {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\t// computer accounts (ending with $) are not privileged by themselves\n+\t// They only gain privileges through group membership or specific SIDs\n+\n+\tif targetUser, err := lookupUser(bareUsername); err == nil {\n+\t\treturn isWindowsPrivilegedSID(targetUser.Uid)\n+\t}\n+\n+\treturn false\n+}\n+\n+// isWindowsPrivilegedSID checks if a Windows SID represents a privileged account\n+func isWindowsPrivilegedSID(sid string) bool {\n+\tprivilegedSIDs := []string{\n+\t\t\"S-1-5-18\",     // Local System (SYSTEM)\n+\t\t\"S-1-5-19\",     // Local Service (NT AUTHORITY\\LOCAL SERVICE)\n+\t\t\"S-1-5-20\",     // Network Service (NT AUTHORITY\\NETWORK SERVICE)\n+\t\t\"S-1-5-32-544\", // Administrators group (BUILTIN\\Administrators)\n+\t\t\"S-1-5-500\",    // Built-in Administrator account (local machine RID 500)\n+\t}\n+\n+\tfor _, privilegedSID := range privilegedSIDs {\n+\t\tif sid == privilegedSID {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\t// Check for domain administrator accounts (RID 500 in any domain)\n+\t// Format: S-1-5-21-domain-domain-domain-500\n+\t// This is reliable as RID 500 is reserved for the domain Administrator account\n+\tif strings.HasPrefix(sid, \"S-1-5-21-\") && strings.HasSuffix(sid, \"-500\") {\n+\t\treturn true\n+\t}\n+\n+\t// Check for other well-known privileged RIDs in domain contexts\n+\t// RID 512 = Domain Admins group, RID 516 = Domain Controllers group\n+\tif strings.HasPrefix(sid, \"S-1-5-21-\") {\n+\t\tif strings.HasSuffix(sid, \"-512\") || // Domain Admins group\n+\t\t\tstrings.HasSuffix(sid, \"-516\") || // Domain Controllers group\n+\t\t\tstrings.HasSuffix(sid, \"-519\") { // Enterprise Admins group\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\treturn false\n+}\n+\n+// isCurrentProcessPrivileged checks if the current process is running with elevated privileges.\n+// On Unix systems, this means running as root (UID 0).\n+// On Windows, this means running as Administrator or SYSTEM.\n+func isCurrentProcessPrivileged() bool {\n+\tif getCurrentOS() == \"windows\" {\n+\t\treturn isWindowsElevated()\n+\t}\n+\treturn getEuid() == 0\n+}\n+\n+// isWindowsElevated checks if the current process is running with elevated privileges on Windows\n+func isWindowsElevated() bool {\n+\tcurrentUser, err := getCurrentUser()\n+\tif err != nil {\n+\t\tlog.Errorf(\"failed to get current user for privilege check, assuming non-privileged: %v\", err)\n+\t\treturn false\n+\t}\n+\n+\tif isWindowsPrivilegedSID(currentUser.Uid) {\n+\t\tlog.Debugf(\"Windows user switching supported: running as privileged SID %s\", currentUser.Uid)\n+\t\treturn true\n+\t}\n+\n+\tif isPrivilegedUsername(currentUser.Username) {\n+\t\tlog.Debugf(\"Windows user switching supported: running as privileged username %s\", currentUser.Username)\n+\t\treturn true\n+\t}\n+\n+\tlog.Debugf(\"Windows user switching not supported: not running as privileged user (current: %s)\", currentUser.Uid)\n+\treturn false\n+}\ndiff --git a/client/ssh/server/user_utils_js.go b/client/ssh/server/user_utils_js.go\nnew file mode 100644\nindex 00000000000..163b24c6ce4\n--- /dev/null\n+++ b/client/ssh/server/user_utils_js.go\n@@ -0,0 +1,8 @@\n+//go:build js\n+\n+package server\n+\n+// validateUsername is not supported on JS/WASM\n+func validateUsername(_ string) error {\n+\treturn errNotSupported\n+}\ndiff --git a/client/ssh/server/userswitching_js.go b/client/ssh/server/userswitching_js.go\nnew file mode 100644\nindex 00000000000..333c19259a9\n--- /dev/null\n+++ b/client/ssh/server/userswitching_js.go\n@@ -0,0 +1,8 @@\n+//go:build js\n+\n+package server\n+\n+// enableUserSwitching is not supported on JS/WASM\n+func enableUserSwitching() error {\n+\treturn errNotSupported\n+}\ndiff --git a/client/ssh/server/userswitching_unix.go b/client/ssh/server/userswitching_unix.go\nnew file mode 100644\nindex 00000000000..06fefabd75e\n--- /dev/null\n+++ b/client/ssh/server/userswitching_unix.go\n@@ -0,0 +1,233 @@\n+//go:build unix\n+\n+package server\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"net\"\n+\t\"net/netip\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"os/user\"\n+\t\"regexp\"\n+\t\"runtime\"\n+\t\"strconv\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+)\n+\n+// POSIX portable filename character set regex: [a-zA-Z0-9._-]\n+// First character cannot be hyphen (POSIX requirement)\n+var posixUsernameRegex = regexp.MustCompile(`^[a-zA-Z0-9._][a-zA-Z0-9._-]*$`)\n+\n+// validateUsername validates that a username conforms to POSIX standards with security considerations\n+func validateUsername(username string) error {\n+\tif username == \"\" {\n+\t\treturn errors.New(\"username cannot be empty\")\n+\t}\n+\n+\t// POSIX allows up to 256 characters, but practical limit is 32 for compatibility\n+\tif len(username) > 32 {\n+\t\treturn errors.New(\"username too long (max 32 characters)\")\n+\t}\n+\n+\tif !posixUsernameRegex.MatchString(username) {\n+\t\treturn errors.New(\"username contains invalid characters (must match POSIX portable filename character set)\")\n+\t}\n+\n+\tif username == \".\" || username == \"..\" {\n+\t\treturn fmt.Errorf(\"username cannot be '.' or '..'\")\n+\t}\n+\n+\t// Warn if username is fully numeric (can cause issues with UID/username ambiguity)\n+\tif isFullyNumeric(username) {\n+\t\tlog.Warnf(\"fully numeric username '%s' may cause issues with some commands\", username)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// isFullyNumeric checks if username contains only digits\n+func isFullyNumeric(username string) bool {\n+\tfor _, char := range username {\n+\t\tif char < '0' || char > '9' {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+// createPtyLoginCommand creates a Pty command using login for privileged processes\n+func (s *Server) createPtyLoginCommand(localUser *user.User, ptyReq ssh.Pty, session ssh.Session) (*exec.Cmd, error) {\n+\tloginPath, args, err := s.getLoginCmd(localUser.Username, session.RemoteAddr())\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"get login command: %w\", err)\n+\t}\n+\n+\texecCmd := exec.CommandContext(session.Context(), loginPath, args...)\n+\texecCmd.Dir = localUser.HomeDir\n+\texecCmd.Env = s.preparePtyEnv(localUser, ptyReq, session)\n+\n+\treturn execCmd, nil\n+}\n+\n+// getLoginCmd returns the login command and args for privileged Pty user switching\n+func (s *Server) getLoginCmd(username string, remoteAddr net.Addr) (string, []string, error) {\n+\tloginPath, err := exec.LookPath(\"login\")\n+\tif err != nil {\n+\t\treturn \"\", nil, fmt.Errorf(\"login command not available: %w\", err)\n+\t}\n+\n+\taddrPort, err := netip.ParseAddrPort(remoteAddr.String())\n+\tif err != nil {\n+\t\treturn \"\", nil, fmt.Errorf(\"parse remote address: %w\", err)\n+\t}\n+\n+\tswitch runtime.GOOS {\n+\tcase \"linux\":\n+\t\t// Special handling for Arch Linux without /etc/pam.d/remote\n+\t\tif s.fileExists(\"/etc/arch-release\") && !s.fileExists(\"/etc/pam.d/remote\") {\n+\t\t\treturn loginPath, []string{\"-f\", username, \"-p\"}, nil\n+\t\t}\n+\t\treturn loginPath, []string{\"-f\", username, \"-h\", addrPort.Addr().String(), \"-p\"}, nil\n+\tcase \"darwin\", \"freebsd\", \"openbsd\", \"netbsd\", \"dragonfly\":\n+\t\treturn loginPath, []string{\"-fp\", \"-h\", addrPort.Addr().String(), username}, nil\n+\tdefault:\n+\t\treturn \"\", nil, fmt.Errorf(\"unsupported Unix platform for login command: %s\", runtime.GOOS)\n+\t}\n+}\n+\n+// fileExists checks if a file exists (helper for login command logic)\n+func (s *Server) fileExists(path string) bool {\n+\t_, err := os.Stat(path)\n+\treturn err == nil\n+}\n+\n+// parseUserCredentials extracts numeric UID, GID, and supplementary groups\n+func (s *Server) parseUserCredentials(localUser *user.User) (uint32, uint32, []uint32, error) {\n+\tuid64, err := strconv.ParseUint(localUser.Uid, 10, 32)\n+\tif err != nil {\n+\t\treturn 0, 0, nil, fmt.Errorf(\"invalid UID %s: %w\", localUser.Uid, err)\n+\t}\n+\tuid := uint32(uid64)\n+\n+\tgid64, err := strconv.ParseUint(localUser.Gid, 10, 32)\n+\tif err != nil {\n+\t\treturn 0, 0, nil, fmt.Errorf(\"invalid GID %s: %w\", localUser.Gid, err)\n+\t}\n+\tgid := uint32(gid64)\n+\n+\tgroups, err := s.getSupplementaryGroups(localUser.Username)\n+\tif err != nil {\n+\t\tlog.Warnf(\"failed to get supplementary groups for user %s: %v\", localUser.Username, err)\n+\t\tgroups = []uint32{gid}\n+\t}\n+\n+\treturn uid, gid, groups, nil\n+}\n+\n+// getSupplementaryGroups retrieves supplementary group IDs for a user\n+func (s *Server) getSupplementaryGroups(username string) ([]uint32, error) {\n+\tu, err := user.Lookup(username)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"lookup user %s: %w\", username, err)\n+\t}\n+\n+\tgroupIDStrings, err := u.GroupIds()\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"get group IDs for user %s: %w\", username, err)\n+\t}\n+\n+\tgroups := make([]uint32, len(groupIDStrings))\n+\tfor i, gidStr := range groupIDStrings {\n+\t\tgid64, err := strconv.ParseUint(gidStr, 10, 32)\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"invalid group ID %s for user %s: %w\", gidStr, username, err)\n+\t\t}\n+\t\tgroups[i] = uint32(gid64)\n+\t}\n+\n+\treturn groups, nil\n+}\n+\n+// createExecutorCommand creates a command that spawns netbird ssh exec for privilege dropping.\n+// Returns the command and a cleanup function (no-op on Unix).\n+func (s *Server) createExecutorCommand(session ssh.Session, localUser *user.User, hasPty bool) (*exec.Cmd, func(), error) {\n+\tlog.Debugf(\"creating executor command for user %s (Pty: %v)\", localUser.Username, hasPty)\n+\n+\tif err := validateUsername(localUser.Username); err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"invalid username %q: %w\", localUser.Username, err)\n+\t}\n+\n+\tuid, gid, groups, err := s.parseUserCredentials(localUser)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"parse user credentials: %w\", err)\n+\t}\n+\tprivilegeDropper := NewPrivilegeDropper()\n+\tconfig := ExecutorConfig{\n+\t\tUID:        uid,\n+\t\tGID:        gid,\n+\t\tGroups:     groups,\n+\t\tWorkingDir: localUser.HomeDir,\n+\t\tShell:      getUserShell(localUser.Uid),\n+\t\tCommand:    session.RawCommand(),\n+\t\tPTY:        hasPty,\n+\t}\n+\n+\tcmd, err := privilegeDropper.CreateExecutorCommand(session.Context(), config)\n+\treturn cmd, func() {}, err\n+}\n+\n+// enableUserSwitching is a no-op on Unix systems\n+func enableUserSwitching() error {\n+\treturn nil\n+}\n+\n+// createPtyCommand creates the exec.Cmd for Pty execution respecting privilege check results\n+func (s *Server) createPtyCommand(privilegeResult PrivilegeCheckResult, ptyReq ssh.Pty, session ssh.Session) (*exec.Cmd, error) {\n+\tlocalUser := privilegeResult.User\n+\tif localUser == nil {\n+\t\treturn nil, errors.New(\"no user in privilege result\")\n+\t}\n+\n+\tif privilegeResult.UsedFallback {\n+\t\treturn s.createDirectPtyCommand(session, localUser, ptyReq), nil\n+\t}\n+\n+\treturn s.createPtyLoginCommand(localUser, ptyReq, session)\n+}\n+\n+// createDirectPtyCommand creates a direct Pty command without privilege dropping\n+func (s *Server) createDirectPtyCommand(session ssh.Session, localUser *user.User, ptyReq ssh.Pty) *exec.Cmd {\n+\tlog.Debugf(\"creating direct Pty command for user %s (no user switching needed)\", localUser.Username)\n+\n+\tshell := getUserShell(localUser.Uid)\n+\targs := s.getShellCommandArgs(shell, session.RawCommand())\n+\n+\tcmd := exec.CommandContext(session.Context(), args[0], args[1:]...)\n+\tcmd.Dir = localUser.HomeDir\n+\tcmd.Env = s.preparePtyEnv(localUser, ptyReq, session)\n+\n+\treturn cmd\n+}\n+\n+// preparePtyEnv prepares environment variables for Pty execution\n+func (s *Server) preparePtyEnv(localUser *user.User, ptyReq ssh.Pty, session ssh.Session) []string {\n+\ttermType := ptyReq.Term\n+\tif termType == \"\" {\n+\t\ttermType = \"xterm-256color\"\n+\t}\n+\n+\tenv := prepareUserEnv(localUser, getUserShell(localUser.Uid))\n+\tenv = append(env, prepareSSHEnv(session)...)\n+\tenv = append(env, fmt.Sprintf(\"TERM=%s\", termType))\n+\n+\tfor _, v := range session.Environ() {\n+\t\tif acceptEnv(v) {\n+\t\t\tenv = append(env, v)\n+\t\t}\n+\t}\n+\treturn env\n+}\ndiff --git a/client/ssh/server/userswitching_windows.go b/client/ssh/server/userswitching_windows.go\nnew file mode 100644\nindex 00000000000..5a5f75fa4c5\n--- /dev/null\n+++ b/client/ssh/server/userswitching_windows.go\n@@ -0,0 +1,274 @@\n+//go:build windows\n+\n+package server\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"os/exec\"\n+\t\"os/user\"\n+\t\"strings\"\n+\t\"unsafe\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"golang.org/x/sys/windows\"\n+)\n+\n+// validateUsername validates Windows usernames according to SAM Account Name rules\n+func validateUsername(username string) error {\n+\tif username == \"\" {\n+\t\treturn fmt.Errorf(\"username cannot be empty\")\n+\t}\n+\n+\tusernameToValidate := extractUsernameFromDomain(username)\n+\n+\tif err := validateUsernameLength(usernameToValidate); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif err := validateUsernameCharacters(usernameToValidate); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif err := validateUsernameFormat(usernameToValidate); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn nil\n+}\n+\n+// extractUsernameFromDomain extracts the username part from domain\\username or username@domain format\n+func extractUsernameFromDomain(username string) string {\n+\tif idx := strings.LastIndex(username, `\\`); idx != -1 {\n+\t\treturn username[idx+1:]\n+\t}\n+\tif idx := strings.Index(username, \"@\"); idx != -1 {\n+\t\treturn username[:idx]\n+\t}\n+\treturn username\n+}\n+\n+// validateUsernameLength checks if username length is within Windows limits\n+func validateUsernameLength(username string) error {\n+\tif len(username) > 20 {\n+\t\treturn fmt.Errorf(\"username too long (max 20 characters for Windows)\")\n+\t}\n+\treturn nil\n+}\n+\n+// validateUsernameCharacters checks for invalid characters in Windows usernames\n+func validateUsernameCharacters(username string) error {\n+\tinvalidChars := []rune{'\"', '/', '[', ']', ':', ';', '|', '=', ',', '+', '*', '?', '<', '>', ' ', '`', '&', '\\n'}\n+\tfor _, char := range username {\n+\t\tfor _, invalid := range invalidChars {\n+\t\t\tif char == invalid {\n+\t\t\t\treturn fmt.Errorf(\"username contains invalid characters\")\n+\t\t\t}\n+\t\t}\n+\t\tif char < 32 || char == 127 {\n+\t\t\treturn fmt.Errorf(\"username contains control characters\")\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// validateUsernameFormat checks for invalid username formats and patterns\n+func validateUsernameFormat(username string) error {\n+\tif username == \".\" || username == \"..\" {\n+\t\treturn fmt.Errorf(\"username cannot be '.' or '..'\")\n+\t}\n+\n+\tif strings.HasSuffix(username, \".\") {\n+\t\treturn fmt.Errorf(\"username cannot end with a period\")\n+\t}\n+\n+\treturn nil\n+}\n+\n+// createExecutorCommand creates a command using Windows executor for privilege dropping.\n+// Returns the command and a cleanup function that must be called after starting the process.\n+func (s *Server) createExecutorCommand(session ssh.Session, localUser *user.User, hasPty bool) (*exec.Cmd, func(), error) {\n+\tlog.Debugf(\"creating Windows executor command for user %s (Pty: %v)\", localUser.Username, hasPty)\n+\n+\tusername, _ := s.parseUsername(localUser.Username)\n+\tif err := validateUsername(username); err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"invalid username %q: %w\", username, err)\n+\t}\n+\n+\treturn s.createUserSwitchCommand(localUser, session, hasPty)\n+}\n+\n+// createUserSwitchCommand creates a command with Windows user switching.\n+// Returns the command and a cleanup function that must be called after starting the process.\n+func (s *Server) createUserSwitchCommand(localUser *user.User, session ssh.Session, interactive bool) (*exec.Cmd, func(), error) {\n+\tusername, domain := s.parseUsername(localUser.Username)\n+\n+\tshell := getUserShell(localUser.Uid)\n+\n+\trawCmd := session.RawCommand()\n+\tvar command string\n+\tif rawCmd != \"\" {\n+\t\tcommand = rawCmd\n+\t}\n+\n+\tconfig := WindowsExecutorConfig{\n+\t\tUsername:    username,\n+\t\tDomain:      domain,\n+\t\tWorkingDir:  localUser.HomeDir,\n+\t\tShell:       shell,\n+\t\tCommand:     command,\n+\t\tInteractive: interactive || (rawCmd == \"\"),\n+\t}\n+\n+\tdropper := NewPrivilegeDropper()\n+\tcmd, token, err := dropper.CreateWindowsExecutorCommand(session.Context(), config)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tcleanup := func() {\n+\t\tif token != 0 {\n+\t\t\tif err := windows.CloseHandle(windows.Handle(token)); err != nil {\n+\t\t\t\tlog.Debugf(\"close primary token: %v\", err)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn cmd, cleanup, nil\n+}\n+\n+// parseUsername extracts username and domain from a Windows username\n+func (s *Server) parseUsername(fullUsername string) (username, domain string) {\n+\t// Handle DOMAIN\\username format\n+\tif idx := strings.LastIndex(fullUsername, `\\`); idx != -1 {\n+\t\tdomain = fullUsername[:idx]\n+\t\tusername = fullUsername[idx+1:]\n+\t\treturn username, domain\n+\t}\n+\n+\t// Handle username@domain format\n+\tif username, domain, ok := strings.Cut(fullUsername, \"@\"); ok {\n+\t\treturn username, domain\n+\t}\n+\n+\t// Local user (no domain)\n+\treturn fullUsername, \".\"\n+}\n+\n+// hasPrivilege checks if the current process has a specific privilege\n+func hasPrivilege(token windows.Handle, privilegeName string) (bool, error) {\n+\tvar luid windows.LUID\n+\tif err := windows.LookupPrivilegeValue(nil, windows.StringToUTF16Ptr(privilegeName), &luid); err != nil {\n+\t\treturn false, fmt.Errorf(\"lookup privilege value: %w\", err)\n+\t}\n+\n+\tvar returnLength uint32\n+\terr := windows.GetTokenInformation(\n+\t\twindows.Token(token),\n+\t\twindows.TokenPrivileges,\n+\t\tnil, // null buffer to get size\n+\t\t0,\n+\t\t&returnLength,\n+\t)\n+\n+\tif err != nil && !errors.Is(err, windows.ERROR_INSUFFICIENT_BUFFER) {\n+\t\treturn false, fmt.Errorf(\"get token information size: %w\", err)\n+\t}\n+\n+\tbuffer := make([]byte, returnLength)\n+\terr = windows.GetTokenInformation(\n+\t\twindows.Token(token),\n+\t\twindows.TokenPrivileges,\n+\t\t&buffer[0],\n+\t\treturnLength,\n+\t\t&returnLength,\n+\t)\n+\tif err != nil {\n+\t\treturn false, fmt.Errorf(\"get token information: %w\", err)\n+\t}\n+\n+\tprivileges := (*windows.Tokenprivileges)(unsafe.Pointer(&buffer[0]))\n+\n+\t// Check if the privilege is present and enabled\n+\tfor i := uint32(0); i < privileges.PrivilegeCount; i++ {\n+\t\tprivilege := (*windows.LUIDAndAttributes)(unsafe.Pointer(\n+\t\t\tuintptr(unsafe.Pointer(&privileges.Privileges[0])) +\n+\t\t\t\tuintptr(i)*unsafe.Sizeof(windows.LUIDAndAttributes{}),\n+\t\t))\n+\t\tif privilege.Luid == luid {\n+\t\t\treturn (privilege.Attributes & windows.SE_PRIVILEGE_ENABLED) != 0, nil\n+\t\t}\n+\t}\n+\n+\treturn false, nil\n+}\n+\n+// enablePrivilege enables a specific privilege for the current process token\n+// This is required because privileges like SeAssignPrimaryTokenPrivilege are present\n+// but disabled by default, even for the SYSTEM account\n+func enablePrivilege(token windows.Handle, privilegeName string) error {\n+\tvar luid windows.LUID\n+\tif err := windows.LookupPrivilegeValue(nil, windows.StringToUTF16Ptr(privilegeName), &luid); err != nil {\n+\t\treturn fmt.Errorf(\"lookup privilege value for %s: %w\", privilegeName, err)\n+\t}\n+\n+\tprivileges := windows.Tokenprivileges{\n+\t\tPrivilegeCount: 1,\n+\t\tPrivileges: [1]windows.LUIDAndAttributes{\n+\t\t\t{\n+\t\t\t\tLuid:       luid,\n+\t\t\t\tAttributes: windows.SE_PRIVILEGE_ENABLED,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\terr := windows.AdjustTokenPrivileges(\n+\t\twindows.Token(token),\n+\t\tfalse,\n+\t\t&privileges,\n+\t\t0,\n+\t\tnil,\n+\t\tnil,\n+\t)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"adjust token privileges for %s: %w\", privilegeName, err)\n+\t}\n+\n+\thasPriv, err := hasPrivilege(token, privilegeName)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"verify privilege %s after enabling: %w\", privilegeName, err)\n+\t}\n+\tif !hasPriv {\n+\t\treturn fmt.Errorf(\"privilege %s could not be enabled (may not be granted to account)\", privilegeName)\n+\t}\n+\n+\tlog.Debugf(\"Successfully enabled privilege %s for current process\", privilegeName)\n+\treturn nil\n+}\n+\n+// enableUserSwitching enables required privileges for Windows user switching\n+func enableUserSwitching() error {\n+\tprocess := windows.CurrentProcess()\n+\n+\tvar token windows.Token\n+\terr := windows.OpenProcessToken(\n+\t\tprocess,\n+\t\twindows.TOKEN_ADJUST_PRIVILEGES|windows.TOKEN_QUERY,\n+\t\t&token,\n+\t)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"open process token: %w\", err)\n+\t}\n+\tdefer func() {\n+\t\tif err := windows.CloseHandle(windows.Handle(token)); err != nil {\n+\t\t\tlog.Debugf(\"Failed to close process token: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tif err := enablePrivilege(windows.Handle(token), \"SeAssignPrimaryTokenPrivilege\"); err != nil {\n+\t\treturn fmt.Errorf(\"enable SeAssignPrimaryTokenPrivilege: %w\", err)\n+\t}\n+\tlog.Infof(\"Windows user switching privileges enabled successfully\")\n+\treturn nil\n+}\ndiff --git a/client/ssh/server/winpty/conpty.go b/client/ssh/server/winpty/conpty.go\nnew file mode 100644\nindex 00000000000..0f3659ffe86\n--- /dev/null\n+++ b/client/ssh/server/winpty/conpty.go\n@@ -0,0 +1,487 @@\n+//go:build windows\n+\n+package winpty\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"syscall\"\n+\t\"unsafe\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"golang.org/x/sys/windows\"\n+)\n+\n+var (\n+\tErrEmptyEnvironment = errors.New(\"empty environment\")\n+)\n+\n+const (\n+\textendedStartupInfoPresent       = 0x00080000\n+\tcreateUnicodeEnvironment         = 0x00000400\n+\tprocThreadAttributePseudoConsole = 0x00020016\n+\n+\tPowerShellCommandFlag = \"-Command\"\n+\n+\terrCloseInputRead     = \"close input read handle: %v\"\n+\terrCloseConPtyCleanup = \"close ConPty handle during cleanup\"\n+)\n+\n+// PtyConfig holds configuration for Pty execution.\n+type PtyConfig struct {\n+\tShell      string\n+\tCommand    string\n+\tWidth      int\n+\tHeight     int\n+\tWorkingDir string\n+}\n+\n+// UserConfig holds user execution configuration.\n+type UserConfig struct {\n+\tToken       windows.Handle\n+\tEnvironment []string\n+}\n+\n+var (\n+\tkernel32                              = windows.NewLazySystemDLL(\"kernel32.dll\")\n+\tprocClosePseudoConsole                = kernel32.NewProc(\"ClosePseudoConsole\")\n+\tprocInitializeProcThreadAttributeList = kernel32.NewProc(\"InitializeProcThreadAttributeList\")\n+\tprocUpdateProcThreadAttribute         = kernel32.NewProc(\"UpdateProcThreadAttribute\")\n+\tprocDeleteProcThreadAttributeList     = kernel32.NewProc(\"DeleteProcThreadAttributeList\")\n+)\n+\n+// ExecutePtyWithUserToken executes a command with ConPty using user token.\n+func ExecutePtyWithUserToken(ctx context.Context, session ssh.Session, ptyConfig PtyConfig, userConfig UserConfig) error {\n+\targs := buildShellArgs(ptyConfig.Shell, ptyConfig.Command)\n+\tcommandLine := buildCommandLine(args)\n+\n+\tconfig := ExecutionConfig{\n+\t\tPty:     ptyConfig,\n+\t\tUser:    userConfig,\n+\t\tSession: session,\n+\t\tContext: ctx,\n+\t}\n+\n+\treturn executeConPtyWithConfig(commandLine, config)\n+}\n+\n+// ExecutionConfig holds all execution configuration.\n+type ExecutionConfig struct {\n+\tPty     PtyConfig\n+\tUser    UserConfig\n+\tSession ssh.Session\n+\tContext context.Context\n+}\n+\n+// executeConPtyWithConfig creates ConPty and executes process with configuration.\n+func executeConPtyWithConfig(commandLine string, config ExecutionConfig) error {\n+\tctx := config.Context\n+\tsession := config.Session\n+\twidth := config.Pty.Width\n+\theight := config.Pty.Height\n+\tuserToken := config.User.Token\n+\tuserEnv := config.User.Environment\n+\tworkingDir := config.Pty.WorkingDir\n+\n+\tinputRead, inputWrite, outputRead, outputWrite, err := createConPtyPipes()\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"create ConPty pipes: %w\", err)\n+\t}\n+\n+\thPty, err := createConPty(width, height, inputRead, outputWrite)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"create ConPty: %w\", err)\n+\t}\n+\n+\tprimaryToken, err := duplicateToPrimaryToken(userToken)\n+\tif err != nil {\n+\t\tif closeErr, _, _ := procClosePseudoConsole.Call(uintptr(hPty)); closeErr == 0 {\n+\t\t\tlog.Debugf(errCloseConPtyCleanup)\n+\t\t}\n+\t\tcloseHandles(inputRead, inputWrite, outputRead, outputWrite)\n+\t\treturn fmt.Errorf(\"duplicate to primary token: %w\", err)\n+\t}\n+\tdefer func() {\n+\t\tif err := windows.CloseHandle(primaryToken); err != nil {\n+\t\t\tlog.Debugf(\"close primary token: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tsiEx, err := setupConPtyStartupInfo(hPty)\n+\tif err != nil {\n+\t\tif closeErr, _, _ := procClosePseudoConsole.Call(uintptr(hPty)); closeErr == 0 {\n+\t\t\tlog.Debugf(errCloseConPtyCleanup)\n+\t\t}\n+\t\tcloseHandles(inputRead, inputWrite, outputRead, outputWrite)\n+\t\treturn fmt.Errorf(\"setup startup info: %w\", err)\n+\t}\n+\tdefer func() {\n+\t\t_, _, _ = procDeleteProcThreadAttributeList.Call(uintptr(unsafe.Pointer(siEx.ProcThreadAttributeList)))\n+\t}()\n+\n+\tpi, err := createConPtyProcess(commandLine, primaryToken, userEnv, workingDir, siEx)\n+\tif err != nil {\n+\t\tif closeErr, _, _ := procClosePseudoConsole.Call(uintptr(hPty)); closeErr == 0 {\n+\t\t\tlog.Debugf(errCloseConPtyCleanup)\n+\t\t}\n+\t\tcloseHandles(inputRead, inputWrite, outputRead, outputWrite)\n+\t\treturn fmt.Errorf(\"create process as user with ConPty: %w\", err)\n+\t}\n+\tdefer closeProcessInfo(pi)\n+\n+\tif err := windows.CloseHandle(inputRead); err != nil {\n+\t\tlog.Debugf(errCloseInputRead, err)\n+\t}\n+\tif err := windows.CloseHandle(outputWrite); err != nil {\n+\t\tlog.Debugf(\"close output write handle: %v\", err)\n+\t}\n+\n+\treturn bridgeConPtyIO(ctx, hPty, inputWrite, outputRead, session, session, session, pi.Process)\n+}\n+\n+// createConPtyPipes creates input/output pipes for ConPty.\n+func createConPtyPipes() (inputRead, inputWrite, outputRead, outputWrite windows.Handle, err error) {\n+\tif err := windows.CreatePipe(&inputRead, &inputWrite, nil, 0); err != nil {\n+\t\treturn 0, 0, 0, 0, fmt.Errorf(\"create input pipe: %w\", err)\n+\t}\n+\n+\tif err := windows.CreatePipe(&outputRead, &outputWrite, nil, 0); err != nil {\n+\t\tif closeErr := windows.CloseHandle(inputRead); closeErr != nil {\n+\t\t\tlog.Debugf(errCloseInputRead, closeErr)\n+\t\t}\n+\t\tif closeErr := windows.CloseHandle(inputWrite); closeErr != nil {\n+\t\t\tlog.Debugf(\"close input write handle: %v\", closeErr)\n+\t\t}\n+\t\treturn 0, 0, 0, 0, fmt.Errorf(\"create output pipe: %w\", err)\n+\t}\n+\n+\treturn inputRead, inputWrite, outputRead, outputWrite, nil\n+}\n+\n+// createConPty creates a Windows ConPty with the specified size and pipe handles.\n+func createConPty(width, height int, inputRead, outputWrite windows.Handle) (windows.Handle, error) {\n+\tsize := windows.Coord{X: int16(width), Y: int16(height)}\n+\n+\tvar hPty windows.Handle\n+\tif err := windows.CreatePseudoConsole(size, inputRead, outputWrite, 0, &hPty); err != nil {\n+\t\treturn 0, fmt.Errorf(\"CreatePseudoConsole: %w\", err)\n+\t}\n+\n+\treturn hPty, nil\n+}\n+\n+// setupConPtyStartupInfo prepares the STARTUPINFOEX with ConPty attributes.\n+func setupConPtyStartupInfo(hPty windows.Handle) (*windows.StartupInfoEx, error) {\n+\tvar siEx windows.StartupInfoEx\n+\tsiEx.StartupInfo.Cb = uint32(unsafe.Sizeof(siEx))\n+\n+\tvar attrListSize uintptr\n+\tret, _, _ := procInitializeProcThreadAttributeList.Call(0, 1, 0, uintptr(unsafe.Pointer(&attrListSize)))\n+\tif ret == 0 && attrListSize == 0 {\n+\t\treturn nil, fmt.Errorf(\"get attribute list size\")\n+\t}\n+\n+\tattrListBytes := make([]byte, attrListSize)\n+\tsiEx.ProcThreadAttributeList = (*windows.ProcThreadAttributeList)(unsafe.Pointer(&attrListBytes[0]))\n+\n+\tret, _, err := procInitializeProcThreadAttributeList.Call(\n+\t\tuintptr(unsafe.Pointer(siEx.ProcThreadAttributeList)),\n+\t\t1,\n+\t\t0,\n+\t\tuintptr(unsafe.Pointer(&attrListSize)),\n+\t)\n+\tif ret == 0 {\n+\t\treturn nil, fmt.Errorf(\"initialize attribute list: %w\", err)\n+\t}\n+\n+\tret, _, err = procUpdateProcThreadAttribute.Call(\n+\t\tuintptr(unsafe.Pointer(siEx.ProcThreadAttributeList)),\n+\t\t0,\n+\t\tprocThreadAttributePseudoConsole,\n+\t\tuintptr(hPty),\n+\t\tunsafe.Sizeof(hPty),\n+\t\t0,\n+\t\t0,\n+\t)\n+\tif ret == 0 {\n+\t\treturn nil, fmt.Errorf(\"update thread attribute: %w\", err)\n+\t}\n+\n+\treturn &siEx, nil\n+}\n+\n+// createConPtyProcess creates the actual process with ConPty.\n+func createConPtyProcess(commandLine string, userToken windows.Handle, userEnv []string, workingDir string, siEx *windows.StartupInfoEx) (*windows.ProcessInformation, error) {\n+\tvar pi windows.ProcessInformation\n+\tcreationFlags := uint32(extendedStartupInfoPresent | createUnicodeEnvironment)\n+\n+\tcommandLinePtr, err := windows.UTF16PtrFromString(commandLine)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"convert command line to UTF16: %w\", err)\n+\t}\n+\n+\tenvPtr, err := convertEnvironmentToUTF16(userEnv)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar workingDirPtr *uint16\n+\tif workingDir != \"\" {\n+\t\tworkingDirPtr, err = windows.UTF16PtrFromString(workingDir)\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"convert working directory to UTF16: %w\", err)\n+\t\t}\n+\t}\n+\n+\tsiEx.StartupInfo.Flags |= windows.STARTF_USESTDHANDLES\n+\tsiEx.StartupInfo.StdInput = windows.Handle(0)\n+\tsiEx.StartupInfo.StdOutput = windows.Handle(0)\n+\tsiEx.StartupInfo.StdErr = siEx.StartupInfo.StdOutput\n+\n+\tif userToken != windows.InvalidHandle {\n+\t\terr = windows.CreateProcessAsUser(\n+\t\t\twindows.Token(userToken),\n+\t\t\tnil,\n+\t\t\tcommandLinePtr,\n+\t\t\tnil,\n+\t\t\tnil,\n+\t\t\ttrue,\n+\t\t\tcreationFlags,\n+\t\t\tenvPtr,\n+\t\t\tworkingDirPtr,\n+\t\t\t&siEx.StartupInfo,\n+\t\t\t&pi,\n+\t\t)\n+\t} else {\n+\t\terr = windows.CreateProcess(\n+\t\t\tnil,\n+\t\t\tcommandLinePtr,\n+\t\t\tnil,\n+\t\t\tnil,\n+\t\t\ttrue,\n+\t\t\tcreationFlags,\n+\t\t\tenvPtr,\n+\t\t\tworkingDirPtr,\n+\t\t\t&siEx.StartupInfo,\n+\t\t\t&pi,\n+\t\t)\n+\t}\n+\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"create process: %w\", err)\n+\t}\n+\n+\treturn &pi, nil\n+}\n+\n+// convertEnvironmentToUTF16 converts environment variables to Windows UTF16 format.\n+func convertEnvironmentToUTF16(userEnv []string) (*uint16, error) {\n+\tif len(userEnv) == 0 {\n+\t\t// Return nil pointer for empty environment - Windows API will inherit parent environment\n+\t\treturn nil, nil //nolint:nilnil // Intentional nil,nil for empty environment\n+\t}\n+\n+\tvar envUTF16 []uint16\n+\tfor _, envVar := range userEnv {\n+\t\tif envVar != \"\" {\n+\t\t\tutf16Str, err := windows.UTF16FromString(envVar)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Debugf(\"skipping invalid environment variable: %s (error: %v)\", envVar, err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tenvUTF16 = append(envUTF16, utf16Str[:len(utf16Str)-1]...)\n+\t\t\tenvUTF16 = append(envUTF16, 0)\n+\t\t}\n+\t}\n+\tenvUTF16 = append(envUTF16, 0)\n+\n+\tif len(envUTF16) > 0 {\n+\t\treturn &envUTF16[0], nil\n+\t}\n+\t// Return nil pointer when no valid environment variables found\n+\treturn nil, nil //nolint:nilnil // Intentional nil,nil for empty environment\n+}\n+\n+// duplicateToPrimaryToken converts an impersonation token to a primary token.\n+func duplicateToPrimaryToken(token windows.Handle) (windows.Handle, error) {\n+\tvar primaryToken windows.Handle\n+\tif err := windows.DuplicateTokenEx(\n+\t\twindows.Token(token),\n+\t\twindows.TOKEN_ALL_ACCESS,\n+\t\tnil,\n+\t\twindows.SecurityImpersonation,\n+\t\twindows.TokenPrimary,\n+\t\t(*windows.Token)(&primaryToken),\n+\t); err != nil {\n+\t\treturn 0, fmt.Errorf(\"duplicate token: %w\", err)\n+\t}\n+\treturn primaryToken, nil\n+}\n+\n+// SessionExiter provides the Exit method for reporting process exit status.\n+type SessionExiter interface {\n+\tExit(code int) error\n+}\n+\n+// bridgeConPtyIO handles I/O bridging between ConPty and readers/writers.\n+func bridgeConPtyIO(ctx context.Context, hPty, inputWrite, outputRead windows.Handle, reader io.ReadCloser, writer io.Writer, session SessionExiter, process windows.Handle) error {\n+\tif err := ctx.Err(); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tvar wg sync.WaitGroup\n+\tstartIOBridging(ctx, &wg, inputWrite, outputRead, reader, writer)\n+\n+\tprocessErr := waitForProcess(ctx, process)\n+\tif processErr != nil {\n+\t\treturn processErr\n+\t}\n+\n+\tvar exitCode uint32\n+\tif err := windows.GetExitCodeProcess(process, &exitCode); err != nil {\n+\t\tlog.Debugf(\"get exit code: %v\", err)\n+\t} else {\n+\t\tif err := session.Exit(int(exitCode)); err != nil {\n+\t\t\tlog.Debugf(\"report exit code: %v\", err)\n+\t\t}\n+\t}\n+\n+\t// Clean up in the original order after process completes\n+\tif err := reader.Close(); err != nil {\n+\t\tlog.Debugf(\"close reader: %v\", err)\n+\t}\n+\n+\tret, _, err := procClosePseudoConsole.Call(uintptr(hPty))\n+\tif ret == 0 {\n+\t\tlog.Debugf(\"close ConPty handle: %v\", err)\n+\t}\n+\n+\twg.Wait()\n+\n+\tif err := windows.CloseHandle(outputRead); err != nil {\n+\t\tlog.Debugf(\"close output read handle: %v\", err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// startIOBridging starts the I/O bridging goroutines.\n+func startIOBridging(ctx context.Context, wg *sync.WaitGroup, inputWrite, outputRead windows.Handle, reader io.ReadCloser, writer io.Writer) {\n+\twg.Add(2)\n+\n+\t// Input: reader (SSH session) -> inputWrite (ConPty)\n+\tgo func() {\n+\t\tdefer wg.Done()\n+\t\tdefer func() {\n+\t\t\tif err := windows.CloseHandle(inputWrite); err != nil {\n+\t\t\t\tlog.Debugf(\"close input write handle in goroutine: %v\", err)\n+\t\t\t}\n+\t\t}()\n+\n+\t\tif _, err := io.Copy(&windowsHandleWriter{handle: inputWrite}, reader); err != nil {\n+\t\t\tlog.Debugf(\"input copy ended with error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\t// Output: outputRead (ConPty) -> writer (SSH session)\n+\tgo func() {\n+\t\tdefer wg.Done()\n+\t\tif _, err := io.Copy(writer, &windowsHandleReader{handle: outputRead}); err != nil {\n+\t\t\tlog.Debugf(\"output copy ended with error: %v\", err)\n+\t\t}\n+\t}()\n+}\n+\n+// waitForProcess waits for process completion with context cancellation.\n+func waitForProcess(ctx context.Context, process windows.Handle) error {\n+\tif _, err := windows.WaitForSingleObject(process, windows.INFINITE); err != nil {\n+\t\treturn fmt.Errorf(\"wait for process %d: %w\", process, err)\n+\t}\n+\treturn nil\n+}\n+\n+// buildShellArgs builds shell arguments for ConPty execution.\n+func buildShellArgs(shell, command string) []string {\n+\tif command != \"\" {\n+\t\treturn []string{shell, PowerShellCommandFlag, command}\n+\t}\n+\treturn []string{shell}\n+}\n+\n+// buildCommandLine builds a Windows command line from arguments using proper escaping.\n+func buildCommandLine(args []string) string {\n+\tif len(args) == 0 {\n+\t\treturn \"\"\n+\t}\n+\n+\tvar result strings.Builder\n+\tfor i, arg := range args {\n+\t\tif i > 0 {\n+\t\t\tresult.WriteString(\" \")\n+\t\t}\n+\t\tresult.WriteString(syscall.EscapeArg(arg))\n+\t}\n+\treturn result.String()\n+}\n+\n+// closeHandles closes multiple Windows handles.\n+func closeHandles(handles ...windows.Handle) {\n+\tfor _, handle := range handles {\n+\t\tif handle != windows.InvalidHandle {\n+\t\t\tif err := windows.CloseHandle(handle); err != nil {\n+\t\t\t\tlog.Debugf(\"close handle: %v\", err)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// closeProcessInfo closes process and thread handles.\n+func closeProcessInfo(pi *windows.ProcessInformation) {\n+\tif pi != nil {\n+\t\tif err := windows.CloseHandle(pi.Process); err != nil {\n+\t\t\tlog.Debugf(\"close process handle: %v\", err)\n+\t\t}\n+\t\tif err := windows.CloseHandle(pi.Thread); err != nil {\n+\t\t\tlog.Debugf(\"close thread handle: %v\", err)\n+\t\t}\n+\t}\n+}\n+\n+// windowsHandleReader wraps a Windows handle for reading.\n+type windowsHandleReader struct {\n+\thandle windows.Handle\n+}\n+\n+func (r *windowsHandleReader) Read(p []byte) (n int, err error) {\n+\tvar bytesRead uint32\n+\tif err := windows.ReadFile(r.handle, p, &bytesRead, nil); err != nil {\n+\t\treturn 0, err\n+\t}\n+\treturn int(bytesRead), nil\n+}\n+\n+func (r *windowsHandleReader) Close() error {\n+\treturn windows.CloseHandle(r.handle)\n+}\n+\n+// windowsHandleWriter wraps a Windows handle for writing.\n+type windowsHandleWriter struct {\n+\thandle windows.Handle\n+}\n+\n+func (w *windowsHandleWriter) Write(p []byte) (n int, err error) {\n+\tvar bytesWritten uint32\n+\tif err := windows.WriteFile(w.handle, p, &bytesWritten, nil); err != nil {\n+\t\treturn 0, err\n+\t}\n+\treturn int(bytesWritten), nil\n+}\n+\n+func (w *windowsHandleWriter) Close() error {\n+\treturn windows.CloseHandle(w.handle)\n+}\ndiff --git a/client/ssh/server_mock.go b/client/ssh/server_mock.go\ndeleted file mode 100644\nindex 76f43fd4e03..00000000000\n--- a/client/ssh/server_mock.go\n+++ /dev/null\n@@ -1,46 +0,0 @@\n-//go:build !js\n-\n-package ssh\n-\n-import \"context\"\n-\n-// MockServer mocks ssh.Server\n-type MockServer struct {\n-\tCtx                     context.Context\n-\tStopFunc                func() error\n-\tStartFunc               func() error\n-\tAddAuthorizedKeyFunc    func(peer, newKey string) error\n-\tRemoveAuthorizedKeyFunc func(peer string)\n-}\n-\n-// RemoveAuthorizedKey removes SSH key of a given peer from the authorized keys\n-func (srv *MockServer) RemoveAuthorizedKey(peer string) {\n-\tif srv.RemoveAuthorizedKeyFunc == nil {\n-\t\treturn\n-\t}\n-\tsrv.RemoveAuthorizedKeyFunc(peer)\n-}\n-\n-// AddAuthorizedKey add a given peer key to server authorized keys\n-func (srv *MockServer) AddAuthorizedKey(peer, newKey string) error {\n-\tif srv.AddAuthorizedKeyFunc == nil {\n-\t\treturn nil\n-\t}\n-\treturn srv.AddAuthorizedKeyFunc(peer, newKey)\n-}\n-\n-// Stop stops SSH server.\n-func (srv *MockServer) Stop() error {\n-\tif srv.StopFunc == nil {\n-\t\treturn nil\n-\t}\n-\treturn srv.StopFunc()\n-}\n-\n-// Start starts SSH server. Blocking\n-func (srv *MockServer) Start() error {\n-\tif srv.StartFunc == nil {\n-\t\treturn nil\n-\t}\n-\treturn srv.StartFunc()\n-}\ndiff --git a/client/ssh/util.go b/client/ssh/ssh.go\nsimilarity index 86%\nrename from client/ssh/util.go\nrename to client/ssh/ssh.go\nindex a54a609bc28..c0024c5999d 100644\n--- a/client/ssh/util.go\n+++ b/client/ssh/ssh.go\n@@ -32,9 +32,8 @@ const RSA KeyType = \"rsa\"\n // RSAKeySize is a size of newly generated RSA key\n const RSAKeySize = 2048\n \n-// GeneratePrivateKey creates RSA Private Key of specified byte size\n+// GeneratePrivateKey creates a private key of the specified type.\n func GeneratePrivateKey(keyType KeyType) ([]byte, error) {\n-\n \tvar key crypto.Signer\n \tvar err error\n \tswitch keyType {\n@@ -59,7 +58,7 @@ func GeneratePrivateKey(keyType KeyType) ([]byte, error) {\n \treturn pemBytes, nil\n }\n \n-// GeneratePublicKey returns the public part of the private key\n+// GeneratePublicKey returns the public part of the private key.\n func GeneratePublicKey(key []byte) ([]byte, error) {\n \tsigner, err := gossh.ParsePrivateKey(key)\n \tif err != nil {\n@@ -70,20 +69,17 @@ func GeneratePublicKey(key []byte) ([]byte, error) {\n \treturn []byte(strKey), nil\n }\n \n-// EncodePrivateKeyToPEM encodes Private Key from RSA to PEM format\n+// EncodePrivateKeyToPEM encodes a private key to PEM format.\n func EncodePrivateKeyToPEM(privateKey crypto.Signer) ([]byte, error) {\n \tmk, err := x509.MarshalPKCS8PrivateKey(privateKey)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\t// pem.Block\n \tprivBlock := pem.Block{\n \t\tType:  \"PRIVATE KEY\",\n \t\tBytes: mk,\n \t}\n-\n-\t// Private key in PEM format\n \tprivatePEM := pem.EncodeToMemory(&privBlock)\n \treturn privatePEM, nil\n }\ndiff --git a/client/ssh/window_freebsd.go b/client/ssh/window_freebsd.go\ndeleted file mode 100644\nindex ef4848341c6..00000000000\n--- a/client/ssh/window_freebsd.go\n+++ /dev/null\n@@ -1,10 +0,0 @@\n-//go:build freebsd\n-\n-package ssh\n-\n-import (\n-\t\"os\"\n-)\n-\n-func setWinSize(file *os.File, width, height int) {\n-}\ndiff --git a/client/ssh/window_unix.go b/client/ssh/window_unix.go\ndeleted file mode 100644\nindex 2891eb70e1b..00000000000\n--- a/client/ssh/window_unix.go\n+++ /dev/null\n@@ -1,14 +0,0 @@\n-//go:build linux || darwin\n-\n-package ssh\n-\n-import (\n-\t\"os\"\n-\t\"syscall\"\n-\t\"unsafe\"\n-)\n-\n-func setWinSize(file *os.File, width, height int) {\n-\tsyscall.Syscall(syscall.SYS_IOCTL, file.Fd(), uintptr(syscall.TIOCSWINSZ), //nolint\n-\t\tuintptr(unsafe.Pointer(&struct{ h, w, x, y uint16 }{uint16(height), uint16(width), 0, 0})))\n-}\ndiff --git a/client/ssh/window_windows.go b/client/ssh/window_windows.go\ndeleted file mode 100644\nindex 5abd41f271a..00000000000\n--- a/client/ssh/window_windows.go\n+++ /dev/null\n@@ -1,9 +0,0 @@\n-package ssh\n-\n-import (\n-\t\"os\"\n-)\n-\n-func setWinSize(file *os.File, width, height int) {\n-\n-}\ndiff --git a/client/status/status.go b/client/status/status.go\nindex 8a0b7bae0ab..d975f0e2944 100644\n--- a/client/status/status.go\n+++ b/client/status/status.go\n@@ -81,6 +81,18 @@ type NsServerGroupStateOutput struct {\n \tError   string   `json:\"error\" yaml:\"error\"`\n }\n \n+type SSHSessionOutput struct {\n+\tUsername      string `json:\"username\" yaml:\"username\"`\n+\tRemoteAddress string `json:\"remoteAddress\" yaml:\"remoteAddress\"`\n+\tCommand       string `json:\"command\" yaml:\"command\"`\n+\tJWTUsername   string `json:\"jwtUsername,omitempty\" yaml:\"jwtUsername,omitempty\"`\n+}\n+\n+type SSHServerStateOutput struct {\n+\tEnabled  bool               `json:\"enabled\" yaml:\"enabled\"`\n+\tSessions []SSHSessionOutput `json:\"sessions\" yaml:\"sessions\"`\n+}\n+\n type OutputOverview struct {\n \tPeers                   PeersStateOutput           `json:\"peers\" yaml:\"peers\"`\n \tCliVersion              string                     `json:\"cliVersion\" yaml:\"cliVersion\"`\n@@ -100,6 +112,7 @@ type OutputOverview struct {\n \tEvents                  []SystemEventOutput        `json:\"events\" yaml:\"events\"`\n \tLazyConnectionEnabled   bool                       `json:\"lazyConnectionEnabled\" yaml:\"lazyConnectionEnabled\"`\n \tProfileName             string                     `json:\"profileName\" yaml:\"profileName\"`\n+\tSSHServerState          SSHServerStateOutput       `json:\"sshServer\" yaml:\"sshServer\"`\n }\n \n func ConvertToStatusOutputOverview(resp *proto.StatusResponse, anon bool, statusFilter string, prefixNamesFilter []string, prefixNamesFilterMap map[string]struct{}, ipsFilter map[string]struct{}, connectionTypeFilter string, profName string) OutputOverview {\n@@ -121,6 +134,7 @@ func ConvertToStatusOutputOverview(resp *proto.StatusResponse, anon bool, status\n \n \trelayOverview := mapRelays(pbFullStatus.GetRelays())\n \tpeersOverview := mapPeers(resp.GetFullStatus().GetPeers(), statusFilter, prefixNamesFilter, prefixNamesFilterMap, ipsFilter, connectionTypeFilter)\n+\tsshServerOverview := mapSSHServer(pbFullStatus.GetSshServerState())\n \n \toverview := OutputOverview{\n \t\tPeers:                   peersOverview,\n@@ -141,6 +155,7 @@ func ConvertToStatusOutputOverview(resp *proto.StatusResponse, anon bool, status\n \t\tEvents:                  mapEvents(pbFullStatus.GetEvents()),\n \t\tLazyConnectionEnabled:   pbFullStatus.GetLazyConnectionEnabled(),\n \t\tProfileName:             profName,\n+\t\tSSHServerState:          sshServerOverview,\n \t}\n \n \tif anon {\n@@ -190,6 +205,30 @@ func mapNSGroups(servers []*proto.NSGroupState) []NsServerGroupStateOutput {\n \treturn mappedNSGroups\n }\n \n+func mapSSHServer(sshServerState *proto.SSHServerState) SSHServerStateOutput {\n+\tif sshServerState == nil {\n+\t\treturn SSHServerStateOutput{\n+\t\t\tEnabled:  false,\n+\t\t\tSessions: []SSHSessionOutput{},\n+\t\t}\n+\t}\n+\n+\tsessions := make([]SSHSessionOutput, 0, len(sshServerState.GetSessions()))\n+\tfor _, session := range sshServerState.GetSessions() {\n+\t\tsessions = append(sessions, SSHSessionOutput{\n+\t\t\tUsername:      session.GetUsername(),\n+\t\t\tRemoteAddress: session.GetRemoteAddress(),\n+\t\t\tCommand:       session.GetCommand(),\n+\t\t\tJWTUsername:   session.GetJwtUsername(),\n+\t\t})\n+\t}\n+\n+\treturn SSHServerStateOutput{\n+\t\tEnabled:  sshServerState.GetEnabled(),\n+\t\tSessions: sessions,\n+\t}\n+}\n+\n func mapPeers(\n \tpeers []*proto.PeerState,\n \tstatusFilter string,\n@@ -300,7 +339,7 @@ func ParseToYAML(overview OutputOverview) (string, error) {\n \treturn string(yamlBytes), nil\n }\n \n-func ParseGeneralSummary(overview OutputOverview, showURL bool, showRelays bool, showNameServers bool) string {\n+func ParseGeneralSummary(overview OutputOverview, showURL bool, showRelays bool, showNameServers bool, showSSHSessions bool) string {\n \tvar managementConnString string\n \tif overview.ManagementState.Connected {\n \t\tmanagementConnString = \"Connected\"\n@@ -405,6 +444,41 @@ func ParseGeneralSummary(overview OutputOverview, showURL bool, showRelays bool,\n \t\tlazyConnectionEnabledStatus = \"true\"\n \t}\n \n+\tsshServerStatus := \"Disabled\"\n+\tif overview.SSHServerState.Enabled {\n+\t\tsessionCount := len(overview.SSHServerState.Sessions)\n+\t\tif sessionCount > 0 {\n+\t\t\tsessionWord := \"session\"\n+\t\t\tif sessionCount > 1 {\n+\t\t\t\tsessionWord = \"sessions\"\n+\t\t\t}\n+\t\t\tsshServerStatus = fmt.Sprintf(\"Enabled (%d active %s)\", sessionCount, sessionWord)\n+\t\t} else {\n+\t\t\tsshServerStatus = \"Enabled\"\n+\t\t}\n+\n+\t\tif showSSHSessions && sessionCount > 0 {\n+\t\t\tfor _, session := range overview.SSHServerState.Sessions {\n+\t\t\t\tvar sessionDisplay string\n+\t\t\t\tif session.JWTUsername != \"\" {\n+\t\t\t\t\tsessionDisplay = fmt.Sprintf(\"[%s@%s -> %s] %s\",\n+\t\t\t\t\t\tsession.JWTUsername,\n+\t\t\t\t\t\tsession.RemoteAddress,\n+\t\t\t\t\t\tsession.Username,\n+\t\t\t\t\t\tsession.Command,\n+\t\t\t\t\t)\n+\t\t\t\t} else {\n+\t\t\t\t\tsessionDisplay = fmt.Sprintf(\"[%s@%s] %s\",\n+\t\t\t\t\t\tsession.Username,\n+\t\t\t\t\t\tsession.RemoteAddress,\n+\t\t\t\t\t\tsession.Command,\n+\t\t\t\t\t)\n+\t\t\t\t}\n+\t\t\t\tsshServerStatus += \"\\n  \" + sessionDisplay\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tpeersCountString := fmt.Sprintf(\"%d/%d Connected\", overview.Peers.Connected, overview.Peers.Total)\n \n \tgoos := runtime.GOOS\n@@ -428,6 +502,7 @@ func ParseGeneralSummary(overview OutputOverview, showURL bool, showRelays bool,\n \t\t\t\"Interface type: %s\\n\"+\n \t\t\t\"Quantum resistance: %s\\n\"+\n \t\t\t\"Lazy connection: %s\\n\"+\n+\t\t\t\"SSH Server: %s\\n\"+\n \t\t\t\"Networks: %s\\n\"+\n \t\t\t\"Forwarding rules: %d\\n\"+\n \t\t\t\"Peers count: %s\\n\",\n@@ -444,6 +519,7 @@ func ParseGeneralSummary(overview OutputOverview, showURL bool, showRelays bool,\n \t\tinterfaceTypeString,\n \t\trosenpassEnabledStatus,\n \t\tlazyConnectionEnabledStatus,\n+\t\tsshServerStatus,\n \t\tnetworks,\n \t\toverview.NumberOfForwardingRules,\n \t\tpeersCountString,\n@@ -454,7 +530,7 @@ func ParseGeneralSummary(overview OutputOverview, showURL bool, showRelays bool,\n func ParseToFullDetailSummary(overview OutputOverview) string {\n \tparsedPeersString := parsePeers(overview.Peers, overview.RosenpassEnabled, overview.RosenpassPermissive)\n \tparsedEventsString := parseEvents(overview.Events)\n-\tsummary := ParseGeneralSummary(overview, true, true, true)\n+\tsummary := ParseGeneralSummary(overview, true, true, true, true)\n \n \treturn fmt.Sprintf(\n \t\t\"Peers detail:\"+\n@@ -746,4 +822,13 @@ func anonymizeOverview(a *anonymize.Anonymizer, overview *OutputOverview) {\n \t\t\tevent.Metadata[k] = a.AnonymizeString(v)\n \t\t}\n \t}\n+\n+\tfor i, session := range overview.SSHServerState.Sessions {\n+\t\tif host, port, err := net.SplitHostPort(session.RemoteAddress); err == nil {\n+\t\t\toverview.SSHServerState.Sessions[i].RemoteAddress = fmt.Sprintf(\"%s:%s\", a.AnonymizeIPString(host), port)\n+\t\t} else {\n+\t\t\toverview.SSHServerState.Sessions[i].RemoteAddress = a.AnonymizeIPString(session.RemoteAddress)\n+\t\t}\n+\t\toverview.SSHServerState.Sessions[i].Command = a.AnonymizeString(session.Command)\n+\t}\n }\ndiff --git a/client/system/info.go b/client/system/info.go\nindex a180be4c0d6..01176e76512 100644\n--- a/client/system/info.go\n+++ b/client/system/info.go\n@@ -72,6 +72,12 @@ type Info struct {\n \tBlockInbound        bool\n \n \tLazyConnectionEnabled bool\n+\n+\tEnableSSHRoot                 bool\n+\tEnableSSHSFTP                 bool\n+\tEnableSSHLocalPortForwarding  bool\n+\tEnableSSHRemotePortForwarding bool\n+\tDisableSSHAuth                bool\n }\n \n func (i *Info) SetFlags(\n@@ -79,6 +85,8 @@ func (i *Info) SetFlags(\n \tserverSSHAllowed *bool,\n \tdisableClientRoutes, disableServerRoutes,\n \tdisableDNS, disableFirewall, blockLANAccess, blockInbound, lazyConnectionEnabled bool,\n+\tenableSSHRoot, enableSSHSFTP, enableSSHLocalPortForwarding, enableSSHRemotePortForwarding *bool,\n+\tdisableSSHAuth *bool,\n ) {\n \ti.RosenpassEnabled = rosenpassEnabled\n \ti.RosenpassPermissive = rosenpassPermissive\n@@ -94,6 +102,22 @@ func (i *Info) SetFlags(\n \ti.BlockInbound = blockInbound\n \n \ti.LazyConnectionEnabled = lazyConnectionEnabled\n+\n+\tif enableSSHRoot != nil {\n+\t\ti.EnableSSHRoot = *enableSSHRoot\n+\t}\n+\tif enableSSHSFTP != nil {\n+\t\ti.EnableSSHSFTP = *enableSSHSFTP\n+\t}\n+\tif enableSSHLocalPortForwarding != nil {\n+\t\ti.EnableSSHLocalPortForwarding = *enableSSHLocalPortForwarding\n+\t}\n+\tif enableSSHRemotePortForwarding != nil {\n+\t\ti.EnableSSHRemotePortForwarding = *enableSSHRemotePortForwarding\n+\t}\n+\tif disableSSHAuth != nil {\n+\t\ti.DisableSSHAuth = *disableSSHAuth\n+\t}\n }\n \n // extractUserAgent extracts Netbird's agent (client) name and version from the outgoing context\ndiff --git a/client/ui/client_ui.go b/client/ui/client_ui.go\nindex d3ab424233e..44643616d32 100644\n--- a/client/ui/client_ui.go\n+++ b/client/ui/client_ui.go\n@@ -55,6 +55,7 @@ const (\n \n const (\n \tcensoredPreSharedKey = \"**********\"\n+\tmaxSSHJWTCacheTTL    = 86_400 // 24 hours in seconds\n )\n \n func main() {\n@@ -265,25 +266,38 @@ type serviceClient struct {\n \tiMTU           *widget.Entry\n \n \t// switch elements for settings form\n-\tsRosenpassPermissive *widget.Check\n-\tsNetworkMonitor      *widget.Check\n-\tsDisableDNS          *widget.Check\n-\tsDisableClientRoutes *widget.Check\n-\tsDisableServerRoutes *widget.Check\n-\tsBlockLANAccess      *widget.Check\n+\tsRosenpassPermissive        *widget.Check\n+\tsNetworkMonitor             *widget.Check\n+\tsDisableDNS                 *widget.Check\n+\tsDisableClientRoutes        *widget.Check\n+\tsDisableServerRoutes        *widget.Check\n+\tsBlockLANAccess             *widget.Check\n+\tsEnableSSHRoot              *widget.Check\n+\tsEnableSSHSFTP              *widget.Check\n+\tsEnableSSHLocalPortForward  *widget.Check\n+\tsEnableSSHRemotePortForward *widget.Check\n+\tsDisableSSHAuth             *widget.Check\n+\tiSSHJWTCacheTTL             *widget.Entry\n \n \t// observable settings over corresponding iMngURL and iPreSharedKey values.\n-\tmanagementURL       string\n-\tpreSharedKey        string\n-\tRosenpassPermissive bool\n-\tinterfaceName       string\n-\tinterfacePort       int\n-\tmtu                 uint16\n-\tnetworkMonitor      bool\n-\tdisableDNS          bool\n-\tdisableClientRoutes bool\n-\tdisableServerRoutes bool\n-\tblockLANAccess      bool\n+\tmanagementURL string\n+\tpreSharedKey  string\n+\n+\tRosenpassPermissive        bool\n+\tinterfaceName              string\n+\tinterfacePort              int\n+\tmtu                        uint16\n+\tnetworkMonitor             bool\n+\tdisableDNS                 bool\n+\tdisableClientRoutes        bool\n+\tdisableServerRoutes        bool\n+\tblockLANAccess             bool\n+\tenableSSHRoot              bool\n+\tenableSSHSFTP              bool\n+\tenableSSHLocalPortForward  bool\n+\tenableSSHRemotePortForward bool\n+\tdisableSSHAuth             bool\n+\tsshJWTCacheTTL             int\n \n \tconnected            bool\n \tupdate               *version.Update\n@@ -435,18 +449,22 @@ func (s *serviceClient) showSettingsUI() {\n \ts.sDisableClientRoutes = widget.NewCheck(\"This peer won't route traffic to other peers\", nil)\n \ts.sDisableServerRoutes = widget.NewCheck(\"This peer won't act as router for others\", nil)\n \ts.sBlockLANAccess = widget.NewCheck(\"Blocks local network access when used as exit node\", nil)\n+\ts.sEnableSSHRoot = widget.NewCheck(\"Enable SSH Root Login\", nil)\n+\ts.sEnableSSHSFTP = widget.NewCheck(\"Enable SSH SFTP\", nil)\n+\ts.sEnableSSHLocalPortForward = widget.NewCheck(\"Enable SSH Local Port Forwarding\", nil)\n+\ts.sEnableSSHRemotePortForward = widget.NewCheck(\"Enable SSH Remote Port Forwarding\", nil)\n+\ts.sDisableSSHAuth = widget.NewCheck(\"Disable SSH Authentication\", nil)\n+\ts.iSSHJWTCacheTTL = widget.NewEntry()\n \n \ts.wSettings.SetContent(s.getSettingsForm())\n-\ts.wSettings.Resize(fyne.NewSize(600, 500))\n+\ts.wSettings.Resize(fyne.NewSize(600, 400))\n \ts.wSettings.SetFixedSize(true)\n \n \ts.getSrvConfig()\n \ts.wSettings.Show()\n }\n \n-// getSettingsForm to embed it into settings window.\n-func (s *serviceClient) getSettingsForm() *widget.Form {\n-\n+func (s *serviceClient) getConnectionForm() *widget.Form {\n \tvar activeProfName string\n \tactiveProf, err := s.profileManager.GetActiveProfile()\n \tif err != nil {\n@@ -457,153 +475,277 @@ func (s *serviceClient) getSettingsForm() *widget.Form {\n \treturn &widget.Form{\n \t\tItems: []*widget.FormItem{\n \t\t\t{Text: \"Profile\", Widget: widget.NewLabel(activeProfName)},\n+\t\t\t{Text: \"Management URL\", Widget: s.iMngURL},\n+\t\t\t{Text: \"Pre-shared Key\", Widget: s.iPreSharedKey},\n \t\t\t{Text: \"Quantum-Resistance\", Widget: s.sRosenpassPermissive},\n \t\t\t{Text: \"Interface Name\", Widget: s.iInterfaceName},\n \t\t\t{Text: \"Interface Port\", Widget: s.iInterfacePort},\n \t\t\t{Text: \"MTU\", Widget: s.iMTU},\n-\t\t\t{Text: \"Management URL\", Widget: s.iMngURL},\n-\t\t\t{Text: \"Pre-shared Key\", Widget: s.iPreSharedKey},\n \t\t\t{Text: \"Log File\", Widget: s.iLogFile},\n-\t\t\t{Text: \"Network Monitor\", Widget: s.sNetworkMonitor},\n-\t\t\t{Text: \"Disable DNS\", Widget: s.sDisableDNS},\n-\t\t\t{Text: \"Disable Client Routes\", Widget: s.sDisableClientRoutes},\n-\t\t\t{Text: \"Disable Server Routes\", Widget: s.sDisableServerRoutes},\n-\t\t\t{Text: \"Disable LAN Access\", Widget: s.sBlockLANAccess},\n \t\t},\n-\t\tSubmitText: \"Save\",\n-\t\tOnSubmit: func() {\n-\t\t\t// Check if update settings are disabled by daemon\n-\t\t\tfeatures, err := s.getFeatures()\n-\t\t\tif err != nil {\n-\t\t\t\tlog.Errorf(\"failed to get features from daemon: %v\", err)\n-\t\t\t\t// Continue with default behavior if features can't be retrieved\n-\t\t\t} else if features != nil && features.DisableUpdateSettings {\n-\t\t\t\tlog.Warn(\"Configuration updates are disabled by daemon\")\n-\t\t\t\tdialog.ShowError(fmt.Errorf(\"Configuration updates are disabled by daemon\"), s.wSettings)\n-\t\t\t\treturn\n-\t\t\t}\n+\t}\n+}\n \n-\t\t\tif s.iPreSharedKey.Text != \"\" && s.iPreSharedKey.Text != censoredPreSharedKey {\n-\t\t\t\t// validate preSharedKey if it added\n-\t\t\t\tif _, err := wgtypes.ParseKey(s.iPreSharedKey.Text); err != nil {\n-\t\t\t\t\tdialog.ShowError(fmt.Errorf(\"Invalid Pre-shared Key Value\"), s.wSettings)\n-\t\t\t\t\treturn\n-\t\t\t\t}\n-\t\t\t}\n+func (s *serviceClient) saveSettings() {\n+\t// Check if update settings are disabled by daemon\n+\tfeatures, err := s.getFeatures()\n+\tif err != nil {\n+\t\tlog.Errorf(\"failed to get features from daemon: %v\", err)\n+\t\t// Continue with default behavior if features can't be retrieved\n+\t} else if features != nil && features.DisableUpdateSettings {\n+\t\tlog.Warn(\"Configuration updates are disabled by daemon\")\n+\t\tdialog.ShowError(fmt.Errorf(\"Configuration updates are disabled by daemon\"), s.wSettings)\n+\t\treturn\n+\t}\n \n-\t\t\tport, err := strconv.ParseInt(s.iInterfacePort.Text, 10, 64)\n-\t\t\tif err != nil {\n-\t\t\t\tdialog.ShowError(errors.New(\"Invalid interface port\"), s.wSettings)\n-\t\t\t\treturn\n-\t\t\t}\n+\tif err := s.validateSettings(); err != nil {\n+\t\tdialog.ShowError(err, s.wSettings)\n+\t\treturn\n+\t}\n \n-\t\t\tvar mtu int64\n-\t\t\tmtuText := strings.TrimSpace(s.iMTU.Text)\n-\t\t\tif mtuText != \"\" {\n-\t\t\t\tvar err error\n-\t\t\t\tmtu, err = strconv.ParseInt(mtuText, 10, 64)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tdialog.ShowError(errors.New(\"Invalid MTU value\"), s.wSettings)\n-\t\t\t\t\treturn\n-\t\t\t\t}\n-\t\t\t\tif mtu < iface.MinMTU || mtu > iface.MaxMTU {\n-\t\t\t\t\tdialog.ShowError(fmt.Errorf(\"MTU must be between %d and %d bytes\", iface.MinMTU, iface.MaxMTU), s.wSettings)\n-\t\t\t\t\treturn\n-\t\t\t\t}\n-\t\t\t}\n+\tport, mtu, err := s.parseNumericSettings()\n+\tif err != nil {\n+\t\tdialog.ShowError(err, s.wSettings)\n+\t\treturn\n+\t}\n+\n+\tiMngURL := strings.TrimSpace(s.iMngURL.Text)\n+\n+\tif s.hasSettingsChanged(iMngURL, port, mtu) {\n+\t\tif err := s.applySettingsChanges(iMngURL, port, mtu); err != nil {\n+\t\t\tdialog.ShowError(err, s.wSettings)\n+\t\t\treturn\n+\t\t}\n+\t}\n \n-\t\t\tiMngURL := strings.TrimSpace(s.iMngURL.Text)\n+\ts.wSettings.Close()\n+}\n \n-\t\t\tdefer s.wSettings.Close()\n+func (s *serviceClient) validateSettings() error {\n+\tif s.iPreSharedKey.Text != \"\" && s.iPreSharedKey.Text != censoredPreSharedKey {\n+\t\tif _, err := wgtypes.ParseKey(s.iPreSharedKey.Text); err != nil {\n+\t\t\treturn fmt.Errorf(\"Invalid Pre-shared Key Value\")\n+\t\t}\n+\t}\n+\treturn nil\n+}\n \n-\t\t\t// Check if any settings have changed\n-\t\t\tif s.managementURL != iMngURL || s.preSharedKey != s.iPreSharedKey.Text ||\n-\t\t\t\ts.RosenpassPermissive != s.sRosenpassPermissive.Checked ||\n-\t\t\t\ts.interfaceName != s.iInterfaceName.Text || s.interfacePort != int(port) ||\n-\t\t\t\ts.mtu != uint16(mtu) ||\n-\t\t\t\ts.networkMonitor != s.sNetworkMonitor.Checked ||\n-\t\t\t\ts.disableDNS != s.sDisableDNS.Checked ||\n-\t\t\t\ts.disableClientRoutes != s.sDisableClientRoutes.Checked ||\n-\t\t\t\ts.disableServerRoutes != s.sDisableServerRoutes.Checked ||\n-\t\t\t\ts.blockLANAccess != s.sBlockLANAccess.Checked {\n+func (s *serviceClient) parseNumericSettings() (int64, int64, error) {\n+\tport, err := strconv.ParseInt(s.iInterfacePort.Text, 10, 64)\n+\tif err != nil {\n+\t\treturn 0, 0, errors.New(\"Invalid interface port\")\n+\t}\n+\tif port < 1 || port > 65535 {\n+\t\treturn 0, 0, errors.New(\"Invalid interface port: out of range 1-65535\")\n+\t}\n \n-\t\t\t\ts.managementURL = iMngURL\n-\t\t\t\ts.preSharedKey = s.iPreSharedKey.Text\n-\t\t\t\ts.mtu = uint16(mtu)\n+\tvar mtu int64\n+\tmtuText := strings.TrimSpace(s.iMTU.Text)\n+\tif mtuText != \"\" {\n+\t\tmtu, err = strconv.ParseInt(mtuText, 10, 64)\n+\t\tif err != nil {\n+\t\t\treturn 0, 0, errors.New(\"Invalid MTU value\")\n+\t\t}\n+\t\tif mtu < iface.MinMTU || mtu > iface.MaxMTU {\n+\t\t\treturn 0, 0, fmt.Errorf(\"MTU must be between %d and %d bytes\", iface.MinMTU, iface.MaxMTU)\n+\t\t}\n+\t}\n \n-\t\t\t\tcurrUser, err := user.Current()\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tlog.Errorf(\"get current user: %v\", err)\n-\t\t\t\t\treturn\n-\t\t\t\t}\n+\treturn port, mtu, nil\n+}\n \n-\t\t\t\tvar req proto.SetConfigRequest\n-\t\t\t\treq.ProfileName = activeProf.Name\n-\t\t\t\treq.Username = currUser.Username\n+func (s *serviceClient) hasSettingsChanged(iMngURL string, port, mtu int64) bool {\n+\treturn s.managementURL != iMngURL ||\n+\t\ts.preSharedKey != s.iPreSharedKey.Text ||\n+\t\ts.RosenpassPermissive != s.sRosenpassPermissive.Checked ||\n+\t\ts.interfaceName != s.iInterfaceName.Text ||\n+\t\ts.interfacePort != int(port) ||\n+\t\ts.mtu != uint16(mtu) ||\n+\t\ts.networkMonitor != s.sNetworkMonitor.Checked ||\n+\t\ts.disableDNS != s.sDisableDNS.Checked ||\n+\t\ts.disableClientRoutes != s.sDisableClientRoutes.Checked ||\n+\t\ts.disableServerRoutes != s.sDisableServerRoutes.Checked ||\n+\t\ts.blockLANAccess != s.sBlockLANAccess.Checked ||\n+\t\ts.hasSSHChanges()\n+}\n \n-\t\t\t\tif iMngURL != \"\" {\n-\t\t\t\t\treq.ManagementUrl = iMngURL\n-\t\t\t\t}\n+func (s *serviceClient) applySettingsChanges(iMngURL string, port, mtu int64) error {\n+\ts.managementURL = iMngURL\n+\ts.preSharedKey = s.iPreSharedKey.Text\n+\ts.mtu = uint16(mtu)\n \n-\t\t\t\treq.RosenpassPermissive = &s.sRosenpassPermissive.Checked\n-\t\t\t\treq.InterfaceName = &s.iInterfaceName.Text\n-\t\t\t\treq.WireguardPort = &port\n-\t\t\t\tif mtu > 0 {\n-\t\t\t\t\treq.Mtu = &mtu\n-\t\t\t\t}\n-\t\t\t\treq.NetworkMonitor = &s.sNetworkMonitor.Checked\n-\t\t\t\treq.DisableDns = &s.sDisableDNS.Checked\n-\t\t\t\treq.DisableClientRoutes = &s.sDisableClientRoutes.Checked\n-\t\t\t\treq.DisableServerRoutes = &s.sDisableServerRoutes.Checked\n-\t\t\t\treq.BlockLanAccess = &s.sBlockLANAccess.Checked\n-\n-\t\t\t\tif s.iPreSharedKey.Text != censoredPreSharedKey {\n-\t\t\t\t\treq.OptionalPreSharedKey = &s.iPreSharedKey.Text\n-\t\t\t\t}\n+\treq, err := s.buildSetConfigRequest(iMngURL, port, mtu)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"build config request: %w\", err)\n+\t}\n \n-\t\t\t\tconn, err := s.getSrvClient(failFastTimeout)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tlog.Errorf(\"get client: %v\", err)\n-\t\t\t\t\tdialog.ShowError(fmt.Errorf(\"Failed to connect to the service: %v\", err), s.wSettings)\n-\t\t\t\t\treturn\n-\t\t\t\t}\n-\t\t\t\t_, err = conn.SetConfig(s.ctx, &req)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tlog.Errorf(\"set config: %v\", err)\n-\t\t\t\t\tdialog.ShowError(fmt.Errorf(\"Failed to set configuration: %v\", err), s.wSettings)\n-\t\t\t\t\treturn\n-\t\t\t\t}\n+\tif err := s.sendConfigUpdate(req); err != nil {\n+\t\treturn fmt.Errorf(\"set configuration: %w\", err)\n+\t}\n \n-\t\t\t\tgo func() {\n-\t\t\t\t\tstatus, err := conn.Status(s.ctx, &proto.StatusRequest{})\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\tlog.Errorf(\"get service status: %v\", err)\n-\t\t\t\t\t\tdialog.ShowError(fmt.Errorf(\"Failed to get service status: %v\", err), s.wSettings)\n-\t\t\t\t\t\treturn\n-\t\t\t\t\t}\n-\t\t\t\t\tif status.Status == string(internal.StatusConnected) {\n-\t\t\t\t\t\t// run down & up\n-\t\t\t\t\t\t_, err = conn.Down(s.ctx, &proto.DownRequest{})\n-\t\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\t\tlog.Errorf(\"down service: %v\", err)\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t_, err = conn.Up(s.ctx, &proto.UpRequest{})\n-\t\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\t\tlog.Errorf(\"up service: %v\", err)\n-\t\t\t\t\t\t\tdialog.ShowError(fmt.Errorf(\"Failed to reconnect: %v\", err), s.wSettings)\n-\t\t\t\t\t\t\treturn\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}()\n+\treturn nil\n+}\n+\n+func (s *serviceClient) buildSetConfigRequest(iMngURL string, port, mtu int64) (*proto.SetConfigRequest, error) {\n+\tcurrUser, err := user.Current()\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"get current user: %w\", err)\n+\t}\n+\n+\tactiveProf, err := s.profileManager.GetActiveProfile()\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"get active profile: %w\", err)\n+\t}\n+\n+\treq := &proto.SetConfigRequest{\n+\t\tProfileName: activeProf.Name,\n+\t\tUsername:    currUser.Username,\n+\t}\n+\n+\tif iMngURL != \"\" {\n+\t\treq.ManagementUrl = iMngURL\n+\t}\n+\n+\treq.RosenpassPermissive = &s.sRosenpassPermissive.Checked\n+\treq.InterfaceName = &s.iInterfaceName.Text\n+\treq.WireguardPort = &port\n+\tif mtu > 0 {\n+\t\treq.Mtu = &mtu\n+\t}\n+\n+\treq.NetworkMonitor = &s.sNetworkMonitor.Checked\n+\treq.DisableDns = &s.sDisableDNS.Checked\n+\treq.DisableClientRoutes = &s.sDisableClientRoutes.Checked\n+\treq.DisableServerRoutes = &s.sDisableServerRoutes.Checked\n+\treq.BlockLanAccess = &s.sBlockLANAccess.Checked\n+\n+\treq.EnableSSHRoot = &s.sEnableSSHRoot.Checked\n+\treq.EnableSSHSFTP = &s.sEnableSSHSFTP.Checked\n+\treq.EnableSSHLocalPortForwarding = &s.sEnableSSHLocalPortForward.Checked\n+\treq.EnableSSHRemotePortForwarding = &s.sEnableSSHRemotePortForward.Checked\n+\treq.DisableSSHAuth = &s.sDisableSSHAuth.Checked\n+\n+\tsshJWTCacheTTLText := strings.TrimSpace(s.iSSHJWTCacheTTL.Text)\n+\tif sshJWTCacheTTLText != \"\" {\n+\t\tsshJWTCacheTTL, err := strconv.ParseInt(sshJWTCacheTTLText, 10, 32)\n+\t\tif err != nil {\n+\t\t\treturn nil, errors.New(\"Invalid SSH JWT Cache TTL value\")\n+\t\t}\n+\t\tif sshJWTCacheTTL < 0 || sshJWTCacheTTL > maxSSHJWTCacheTTL {\n+\t\t\treturn nil, fmt.Errorf(\"SSH JWT Cache TTL must be between 0 and %d seconds\", maxSSHJWTCacheTTL)\n+\t\t}\n+\t\tsshJWTCacheTTL32 := int32(sshJWTCacheTTL)\n+\t\treq.SshJWTCacheTTL = &sshJWTCacheTTL32\n+\t}\n+\n+\tif s.iPreSharedKey.Text != censoredPreSharedKey {\n+\t\treq.OptionalPreSharedKey = &s.iPreSharedKey.Text\n+\t}\n+\n+\treturn req, nil\n+}\n+\n+func (s *serviceClient) sendConfigUpdate(req *proto.SetConfigRequest) error {\n+\tconn, err := s.getSrvClient(failFastTimeout)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"get client: %w\", err)\n+\t}\n+\n+\t_, err = conn.SetConfig(s.ctx, req)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"set config: %w\", err)\n+\t}\n+\n+\t// Reconnect if connected to apply the new settings\n+\tgo func() {\n+\t\tstatus, err := conn.Status(s.ctx, &proto.StatusRequest{})\n+\t\tif err != nil {\n+\t\t\tlog.Errorf(\"get service status: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t\tif status.Status == string(internal.StatusConnected) {\n+\t\t\t// run down & up\n+\t\t\t_, err = conn.Down(s.ctx, &proto.DownRequest{})\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Errorf(\"down service: %v\", err)\n+\t\t\t}\n+\n+\t\t\t_, err = conn.Up(s.ctx, &proto.UpRequest{})\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Errorf(\"up service: %v\", err)\n+\t\t\t\treturn\n \t\t\t}\n+\t\t}\n+\t}()\n+\n+\treturn nil\n+}\n+\n+func (s *serviceClient) getSettingsForm() fyne.CanvasObject {\n+\tconnectionForm := s.getConnectionForm()\n+\tnetworkForm := s.getNetworkForm()\n+\tsshForm := s.getSSHForm()\n+\ttabs := container.NewAppTabs(\n+\t\tcontainer.NewTabItem(\"Connection\", connectionForm),\n+\t\tcontainer.NewTabItem(\"Network\", networkForm),\n+\t\tcontainer.NewTabItem(\"SSH\", sshForm),\n+\t)\n+\tsaveButton := widget.NewButtonWithIcon(\"Save\", theme.ConfirmIcon(), s.saveSettings)\n+\tsaveButton.Importance = widget.HighImportance\n+\tcancelButton := widget.NewButtonWithIcon(\"Cancel\", theme.CancelIcon(), func() {\n+\t\ts.wSettings.Close()\n+\t})\n+\tbuttonContainer := container.NewHBox(\n+\t\tlayout.NewSpacer(),\n+\t\tcancelButton,\n+\t\tsaveButton,\n+\t)\n+\treturn container.NewBorder(nil, buttonContainer, nil, nil, tabs)\n+}\n+\n+func (s *serviceClient) getNetworkForm() *widget.Form {\n+\treturn &widget.Form{\n+\t\tItems: []*widget.FormItem{\n+\t\t\t{Text: \"Network Monitor\", Widget: s.sNetworkMonitor},\n+\t\t\t{Text: \"Disable DNS\", Widget: s.sDisableDNS},\n+\t\t\t{Text: \"Disable Client Routes\", Widget: s.sDisableClientRoutes},\n+\t\t\t{Text: \"Disable Server Routes\", Widget: s.sDisableServerRoutes},\n+\t\t\t{Text: \"Disable LAN Access\", Widget: s.sBlockLANAccess},\n \t\t},\n-\t\tOnCancel: func() {\n-\t\t\ts.wSettings.Close()\n+\t}\n+}\n+\n+func (s *serviceClient) getSSHForm() *widget.Form {\n+\treturn &widget.Form{\n+\t\tItems: []*widget.FormItem{\n+\t\t\t{Text: \"Enable SSH Root Login\", Widget: s.sEnableSSHRoot},\n+\t\t\t{Text: \"Enable SSH SFTP\", Widget: s.sEnableSSHSFTP},\n+\t\t\t{Text: \"Enable SSH Local Port Forwarding\", Widget: s.sEnableSSHLocalPortForward},\n+\t\t\t{Text: \"Enable SSH Remote Port Forwarding\", Widget: s.sEnableSSHRemotePortForward},\n+\t\t\t{Text: \"Disable SSH Authentication\", Widget: s.sDisableSSHAuth},\n+\t\t\t{Text: \"JWT Cache TTL (seconds, 0=disabled)\", Widget: s.iSSHJWTCacheTTL},\n \t\t},\n \t}\n }\n \n+func (s *serviceClient) hasSSHChanges() bool {\n+\tcurrentSSHJWTCacheTTL := s.sshJWTCacheTTL\n+\tif text := strings.TrimSpace(s.iSSHJWTCacheTTL.Text); text != \"\" {\n+\t\tval, err := strconv.Atoi(text)\n+\t\tif err != nil {\n+\t\t\treturn true\n+\t\t}\n+\t\tcurrentSSHJWTCacheTTL = val\n+\t}\n+\n+\treturn s.enableSSHRoot != s.sEnableSSHRoot.Checked ||\n+\t\ts.enableSSHSFTP != s.sEnableSSHSFTP.Checked ||\n+\t\ts.enableSSHLocalPortForward != s.sEnableSSHLocalPortForward.Checked ||\n+\t\ts.enableSSHRemotePortForward != s.sEnableSSHRemotePortForward.Checked ||\n+\t\ts.disableSSHAuth != s.sDisableSSHAuth.Checked ||\n+\t\ts.sshJWTCacheTTL != currentSSHJWTCacheTTL\n+}\n+\n func (s *serviceClient) login(ctx context.Context, openURL bool) (*proto.LoginResponse, error) {\n \tconn, err := s.getSrvClient(defaultFailTimeout)\n \tif err != nil {\n@@ -1123,6 +1265,25 @@ func (s *serviceClient) getSrvConfig() {\n \ts.disableServerRoutes = cfg.DisableServerRoutes\n \ts.blockLANAccess = cfg.BlockLANAccess\n \n+\tif cfg.EnableSSHRoot != nil {\n+\t\ts.enableSSHRoot = *cfg.EnableSSHRoot\n+\t}\n+\tif cfg.EnableSSHSFTP != nil {\n+\t\ts.enableSSHSFTP = *cfg.EnableSSHSFTP\n+\t}\n+\tif cfg.EnableSSHLocalPortForwarding != nil {\n+\t\ts.enableSSHLocalPortForward = *cfg.EnableSSHLocalPortForwarding\n+\t}\n+\tif cfg.EnableSSHRemotePortForwarding != nil {\n+\t\ts.enableSSHRemotePortForward = *cfg.EnableSSHRemotePortForwarding\n+\t}\n+\tif cfg.DisableSSHAuth != nil {\n+\t\ts.disableSSHAuth = *cfg.DisableSSHAuth\n+\t}\n+\tif cfg.SSHJWTCacheTTL != nil {\n+\t\ts.sshJWTCacheTTL = *cfg.SSHJWTCacheTTL\n+\t}\n+\n \tif s.showAdvancedSettings {\n \t\ts.iMngURL.SetText(s.managementURL)\n \t\ts.iPreSharedKey.SetText(cfg.PreSharedKey)\n@@ -1143,6 +1304,24 @@ func (s *serviceClient) getSrvConfig() {\n \t\ts.sDisableClientRoutes.SetChecked(cfg.DisableClientRoutes)\n \t\ts.sDisableServerRoutes.SetChecked(cfg.DisableServerRoutes)\n \t\ts.sBlockLANAccess.SetChecked(cfg.BlockLANAccess)\n+\t\tif cfg.EnableSSHRoot != nil {\n+\t\t\ts.sEnableSSHRoot.SetChecked(*cfg.EnableSSHRoot)\n+\t\t}\n+\t\tif cfg.EnableSSHSFTP != nil {\n+\t\t\ts.sEnableSSHSFTP.SetChecked(*cfg.EnableSSHSFTP)\n+\t\t}\n+\t\tif cfg.EnableSSHLocalPortForwarding != nil {\n+\t\t\ts.sEnableSSHLocalPortForward.SetChecked(*cfg.EnableSSHLocalPortForwarding)\n+\t\t}\n+\t\tif cfg.EnableSSHRemotePortForwarding != nil {\n+\t\t\ts.sEnableSSHRemotePortForward.SetChecked(*cfg.EnableSSHRemotePortForwarding)\n+\t\t}\n+\t\tif cfg.DisableSSHAuth != nil {\n+\t\t\ts.sDisableSSHAuth.SetChecked(*cfg.DisableSSHAuth)\n+\t\t}\n+\t\tif cfg.SSHJWTCacheTTL != nil {\n+\t\t\ts.iSSHJWTCacheTTL.SetText(strconv.Itoa(*cfg.SSHJWTCacheTTL))\n+\t\t}\n \t}\n \n \tif s.mNotifications == nil {\n@@ -1213,6 +1392,15 @@ func protoConfigToConfig(cfg *proto.GetConfigResponse) *profilemanager.Config {\n \tconfig.DisableServerRoutes = cfg.DisableServerRoutes\n \tconfig.BlockLANAccess = cfg.BlockLanAccess\n \n+\tconfig.EnableSSHRoot = &cfg.EnableSSHRoot\n+\tconfig.EnableSSHSFTP = &cfg.EnableSSHSFTP\n+\tconfig.EnableSSHLocalPortForwarding = &cfg.EnableSSHLocalPortForwarding\n+\tconfig.EnableSSHRemotePortForwarding = &cfg.EnableSSHRemotePortForwarding\n+\tconfig.DisableSSHAuth = &cfg.DisableSSHAuth\n+\n+\tttl := int(cfg.SshJWTCacheTTL)\n+\tconfig.SSHJWTCacheTTL = &ttl\n+\n \treturn &config\n }\n \ndiff --git a/client/wasm/cmd/main.go b/client/wasm/cmd/main.go\nindex d542e273960..4dc14a1ca01 100644\n--- a/client/wasm/cmd/main.go\n+++ b/client/wasm/cmd/main.go\n@@ -11,6 +11,7 @@ import (\n \tlog \"github.com/sirupsen/logrus\"\n \n \tnetbird \"github.com/netbirdio/netbird/client/embed\"\n+\tsshdetection \"github.com/netbirdio/netbird/client/ssh/detection\"\n \t\"github.com/netbirdio/netbird/client/wasm/internal/http\"\n \t\"github.com/netbirdio/netbird/client/wasm/internal/rdp\"\n \t\"github.com/netbirdio/netbird/client/wasm/internal/ssh\"\n@@ -125,10 +126,15 @@ func createSSHMethod(client *netbird.Client) js.Func {\n \t\t\tusername = args[2].String()\n \t\t}\n \n+\t\tvar jwtToken string\n+\t\tif len(args) > 3 && !args[3].IsNull() && !args[3].IsUndefined() {\n+\t\t\tjwtToken = args[3].String()\n+\t\t}\n+\n \t\treturn createPromise(func(resolve, reject js.Value) {\n \t\t\tsshClient := ssh.NewClient(client)\n \n-\t\t\tif err := sshClient.Connect(host, port, username); err != nil {\n+\t\t\tif err := sshClient.Connect(host, port, username, jwtToken); err != nil {\n \t\t\t\treject.Invoke(err.Error())\n \t\t\t\treturn\n \t\t\t}\n@@ -191,12 +197,43 @@ func createPromise(handler func(resolve, reject js.Value)) js.Value {\n \t}))\n }\n \n+// createDetectSSHServerMethod creates the SSH server detection method\n+func createDetectSSHServerMethod(client *netbird.Client) js.Func {\n+\treturn js.FuncOf(func(this js.Value, args []js.Value) any {\n+\t\tif len(args) < 2 {\n+\t\t\treturn js.ValueOf(\"error: requires host and port\")\n+\t\t}\n+\n+\t\thost := args[0].String()\n+\t\tport := args[1].Int()\n+\n+\t\treturn createPromise(func(resolve, reject js.Value) {\n+\t\t\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n+\t\t\tdefer cancel()\n+\n+\t\t\tserverType, err := detectSSHServerType(ctx, client, host, port)\n+\t\t\tif err != nil {\n+\t\t\t\treject.Invoke(err.Error())\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tresolve.Invoke(js.ValueOf(serverType.RequiresJWT()))\n+\t\t})\n+\t})\n+}\n+\n+// detectSSHServerType detects SSH server type using NetBird network connection\n+func detectSSHServerType(ctx context.Context, client *netbird.Client, host string, port int) (sshdetection.ServerType, error) {\n+\treturn sshdetection.DetectSSHServerType(ctx, client, host, port)\n+}\n+\n // createClientObject wraps the NetBird client in a JavaScript object\n func createClientObject(client *netbird.Client) js.Value {\n \tobj := make(map[string]interface{})\n \n \tobj[\"start\"] = createStartMethod(client)\n \tobj[\"stop\"] = createStopMethod(client)\n+\tobj[\"detectSSHServerType\"] = createDetectSSHServerMethod(client)\n \tobj[\"createSSHConnection\"] = createSSHMethod(client)\n \tobj[\"proxyRequest\"] = createProxyRequestMethod(client)\n \tobj[\"createRDPProxy\"] = createRDPProxyMethod(client)\ndiff --git a/client/wasm/internal/ssh/client.go b/client/wasm/internal/ssh/client.go\nindex ca35525ebd4..568437e56bc 100644\n--- a/client/wasm/internal/ssh/client.go\n+++ b/client/wasm/internal/ssh/client.go\n@@ -13,6 +13,7 @@ import (\n \t\"golang.org/x/crypto/ssh\"\n \n \tnetbird \"github.com/netbirdio/netbird/client/embed\"\n+\tnbssh \"github.com/netbirdio/netbird/client/ssh\"\n )\n \n const (\n@@ -45,34 +46,19 @@ func NewClient(nbClient *netbird.Client) *Client {\n }\n \n // Connect establishes an SSH connection through NetBird network\n-func (c *Client) Connect(host string, port int, username string) error {\n+func (c *Client) Connect(host string, port int, username, jwtToken string) error {\n \taddr := fmt.Sprintf(\"%s:%d\", host, port)\n \tlogrus.Infof(\"SSH: Connecting to %s as %s\", addr, username)\n \n-\tvar authMethods []ssh.AuthMethod\n-\n-\tnbConfig, err := c.nbClient.GetConfig()\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"get NetBird config: %w\", err)\n-\t}\n-\tif nbConfig.SSHKey == \"\" {\n-\t\treturn fmt.Errorf(\"no NetBird SSH key available - key should be generated during client initialization\")\n-\t}\n-\n-\tsigner, err := parseSSHPrivateKey([]byte(nbConfig.SSHKey))\n+\tauthMethods, err := c.getAuthMethods(jwtToken)\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"parse NetBird SSH private key: %w\", err)\n+\t\treturn err\n \t}\n \n-\tpubKey := signer.PublicKey()\n-\tlogrus.Infof(\"SSH: Using NetBird key authentication with public key type: %s\", pubKey.Type())\n-\n-\tauthMethods = append(authMethods, ssh.PublicKeys(signer))\n-\n \tconfig := &ssh.ClientConfig{\n \t\tUser:            username,\n \t\tAuth:            authMethods,\n-\t\tHostKeyCallback: ssh.InsecureIgnoreHostKey(),\n+\t\tHostKeyCallback: nbssh.CreateHostKeyCallback(c.nbClient),\n \t\tTimeout:         sshDialTimeout,\n \t}\n \n@@ -96,6 +82,33 @@ func (c *Client) Connect(host string, port int, username string) error {\n \treturn nil\n }\n \n+// getAuthMethods returns SSH authentication methods, preferring JWT if available\n+func (c *Client) getAuthMethods(jwtToken string) ([]ssh.AuthMethod, error) {\n+\tif jwtToken != \"\" {\n+\t\tlogrus.Debugf(\"SSH: Using JWT password authentication\")\n+\t\treturn []ssh.AuthMethod{ssh.Password(jwtToken)}, nil\n+\t}\n+\n+\tlogrus.Debugf(\"SSH: No JWT token, using public key authentication\")\n+\n+\tnbConfig, err := c.nbClient.GetConfig()\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"get NetBird config: %w\", err)\n+\t}\n+\n+\tif nbConfig.SSHKey == \"\" {\n+\t\treturn nil, fmt.Errorf(\"no NetBird SSH key available\")\n+\t}\n+\n+\tsigner, err := ssh.ParsePrivateKey([]byte(nbConfig.SSHKey))\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"parse NetBird SSH private key: %w\", err)\n+\t}\n+\n+\tlogrus.Debugf(\"SSH: Added public key auth\")\n+\treturn []ssh.AuthMethod{ssh.PublicKeys(signer)}, nil\n+}\n+\n // StartSession starts an SSH session with PTY\n func (c *Client) StartSession(cols, rows int) error {\n \tif c.sshClient == nil {\ndiff --git a/client/wasm/internal/ssh/key.go b/client/wasm/internal/ssh/key.go\ndeleted file mode 100644\nindex 4868ba30ae0..00000000000\n--- a/client/wasm/internal/ssh/key.go\n+++ /dev/null\n@@ -1,50 +0,0 @@\n-//go:build js\n-\n-package ssh\n-\n-import (\n-\t\"crypto/x509\"\n-\t\"encoding/pem\"\n-\t\"fmt\"\n-\t\"strings\"\n-\n-\t\"github.com/sirupsen/logrus\"\n-\t\"golang.org/x/crypto/ssh\"\n-)\n-\n-// parseSSHPrivateKey parses a private key in either SSH or PKCS8 format\n-func parseSSHPrivateKey(keyPEM []byte) (ssh.Signer, error) {\n-\tkeyStr := string(keyPEM)\n-\tif !strings.Contains(keyStr, \"-----BEGIN\") {\n-\t\tkeyPEM = []byte(\"-----BEGIN PRIVATE KEY-----\\n\" + keyStr + \"\\n-----END PRIVATE KEY-----\")\n-\t}\n-\n-\tsigner, err := ssh.ParsePrivateKey(keyPEM)\n-\tif err == nil {\n-\t\treturn signer, nil\n-\t}\n-\tlogrus.Debugf(\"SSH: Failed to parse as SSH format: %v\", err)\n-\n-\tblock, _ := pem.Decode(keyPEM)\n-\tif block == nil {\n-\t\tkeyPreview := string(keyPEM)\n-\t\tif len(keyPreview) > 100 {\n-\t\t\tkeyPreview = keyPreview[:100]\n-\t\t}\n-\t\treturn nil, fmt.Errorf(\"decode PEM block from key: %s\", keyPreview)\n-\t}\n-\n-\tkey, err := x509.ParsePKCS8PrivateKey(block.Bytes)\n-\tif err != nil {\n-\t\tlogrus.Debugf(\"SSH: Failed to parse as PKCS8: %v\", err)\n-\t\tif rsaKey, err := x509.ParsePKCS1PrivateKey(block.Bytes); err == nil {\n-\t\t\treturn ssh.NewSignerFromKey(rsaKey)\n-\t\t}\n-\t\tif ecKey, err := x509.ParseECPrivateKey(block.Bytes); err == nil {\n-\t\t\treturn ssh.NewSignerFromKey(ecKey)\n-\t\t}\n-\t\treturn nil, fmt.Errorf(\"parse private key: %w\", err)\n-\t}\n-\n-\treturn ssh.NewSignerFromKey(key)\n-}\ndiff --git a/go.mod b/go.mod\nindex 2d7e0d31ca4..45a36190dd3 100644\n--- a/go.mod\n+++ b/go.mod\n@@ -1,6 +1,6 @@\n module github.com/netbirdio/netbird\n \n-go 1.23.0\n+go 1.23.1\n \n require (\n \tcunicu.li/go-rosenpass v0.4.0\n@@ -17,8 +17,8 @@ require (\n \tgithub.com/spf13/cobra v1.7.0\n \tgithub.com/spf13/pflag v1.0.5\n \tgithub.com/vishvananda/netlink v1.3.1\n-\tgolang.org/x/crypto v0.40.0\n-\tgolang.org/x/sys v0.34.0\n+\tgolang.org/x/crypto v0.41.0\n+\tgolang.org/x/sys v0.35.0\n \tgolang.zx2c4.com/wireguard v0.0.0-20230704135630-469159ecf7d1\n \tgolang.zx2c4.com/wireguard/wgctrl v0.0.0-20230429144221-925a1e7659e6\n \tgolang.zx2c4.com/wireguard/windows v0.5.3\n@@ -31,6 +31,7 @@ require (\n \tfyne.io/fyne/v2 v2.7.0\n \tfyne.io/systray v1.11.1-0.20250603113521-ca66a66d8b58\n \tgithub.com/TheJumpCloud/jcapi-go v3.0.0+incompatible\n+\tgithub.com/awnumar/memguard v0.23.0\n \tgithub.com/aws/aws-sdk-go-v2 v1.36.3\n \tgithub.com/aws/aws-sdk-go-v2/config v1.29.14\n \tgithub.com/aws/aws-sdk-go-v2/service/s3 v1.79.2\n@@ -76,6 +77,7 @@ require (\n \tgithub.com/pion/stun/v3 v3.0.0\n \tgithub.com/pion/transport/v3 v3.0.7\n \tgithub.com/pion/turn/v3 v3.0.1\n+\tgithub.com/pkg/sftp v1.13.9\n \tgithub.com/prometheus/client_golang v1.22.0\n \tgithub.com/quic-go/quic-go v0.49.1\n \tgithub.com/redis/go-redis/v9 v9.7.3\n@@ -108,7 +110,7 @@ require (\n \tgolang.org/x/net v0.42.0\n \tgolang.org/x/oauth2 v0.30.0\n \tgolang.org/x/sync v0.16.0\n-\tgolang.org/x/term v0.33.0\n+\tgolang.org/x/term v0.34.0\n \tgolang.org/x/time v0.12.0\n \tgoogle.golang.org/api v0.177.0\n \tgopkg.in/yaml.v3 v3.0.1\n@@ -130,6 +132,7 @@ require (\n \tgithub.com/Microsoft/go-winio v0.6.2 // indirect\n \tgithub.com/Microsoft/hcsshim v0.12.3 // indirect\n \tgithub.com/anmitsu/go-shlex v0.0.0-20200514113438-38f4b401e2be // indirect\n+\tgithub.com/awnumar/memcall v0.4.0 // indirect\n \tgithub.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.6.10 // indirect\n \tgithub.com/aws/aws-sdk-go-v2/credentials v1.17.67 // indirect\n \tgithub.com/aws/aws-sdk-go-v2/feature/ec2/imds v1.16.30 // indirect\n@@ -197,6 +200,7 @@ require (\n \tgithub.com/kelseyhightower/envconfig v1.4.0 // indirect\n \tgithub.com/klauspost/compress v1.18.0 // indirect\n \tgithub.com/klauspost/cpuid/v2 v2.2.7 // indirect\n+\tgithub.com/kr/fs v0.1.0 // indirect\n \tgithub.com/libdns/libdns v0.2.2 // indirect\n \tgithub.com/lufia/plan9stats v0.0.0-20240513124658-fba389f38bae // indirect\n \tgithub.com/magiconair/properties v1.8.7 // indirect\n@@ -248,8 +252,8 @@ require (\n \tgo.opentelemetry.io/otel/trace v1.35.0 // indirect\n \tgo.uber.org/multierr v1.11.0 // indirect\n \tgolang.org/x/image v0.24.0 // indirect\n-\tgolang.org/x/text v0.27.0 // indirect\n-\tgolang.org/x/tools v0.34.0 // indirect\n+\tgolang.org/x/text v0.28.0 // indirect\n+\tgolang.org/x/tools v0.35.0 // indirect\n \tgolang.zx2c4.com/wintun v0.0.0-20230126152724-0fa3db229ce2 // indirect\n \tgoogle.golang.org/genproto/googleapis/rpc v0.0.0-20250707201910-8d1bb00bc6a7 // indirect\n \tgopkg.in/square/go-jose.v2 v2.6.0 // indirect\ndiff --git a/go.sum b/go.sum\nindex f4b62dff0bf..ec68a8f59a7 100644\n--- a/go.sum\n+++ b/go.sum\n@@ -31,6 +31,10 @@ github.com/TheJumpCloud/jcapi-go v3.0.0+incompatible h1:hqcTK6ZISdip65SR792lwYJT\n github.com/TheJumpCloud/jcapi-go v3.0.0+incompatible/go.mod h1:6B1nuc1MUs6c62ODZDl7hVE5Pv7O2XGSkgg2olnq34I=\n github.com/anmitsu/go-shlex v0.0.0-20200514113438-38f4b401e2be h1:9AeTilPcZAjCFIImctFaOjnTIavg87rW78vTPkQqLI8=\n github.com/anmitsu/go-shlex v0.0.0-20200514113438-38f4b401e2be/go.mod h1:ySMOLuWl6zY27l47sB3qLNK6tF2fkHG55UZxx8oIVo4=\n+github.com/awnumar/memcall v0.4.0 h1:B7hgZYdfH6Ot1Goaz8jGne/7i8xD4taZie/PNSFZ29g=\n+github.com/awnumar/memcall v0.4.0/go.mod h1:8xOx1YbfyuCg3Fy6TO8DK0kZUua3V42/goA5Ru47E8w=\n+github.com/awnumar/memguard v0.23.0 h1:sJ3a1/SWlcuKIQ7MV+R9p0Pvo9CWsMbGZvcZQtmc68A=\n+github.com/awnumar/memguard v0.23.0/go.mod h1:olVofBrsPdITtJ2HgxQKrEYEMyIBAIciVG4wNnZhW9M=\n github.com/aws/aws-sdk-go-v2 v1.36.3 h1:mJoei2CxPutQVxaATCzDUjcZEjVRdpsiiXi2o38yqWM=\n github.com/aws/aws-sdk-go-v2 v1.36.3/go.mod h1:LLXuLpgzEbD766Z5ECcRmi8AzSwfZItDtmABVkRLGzg=\n github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.6.10 h1:zAybnyUQXIZ5mok5Jqwlf58/TFE7uvd3IAsa1aF9cXs=\n@@ -303,6 +307,8 @@ github.com/klauspost/compress v1.18.0/go.mod h1:2Pp+KzxcywXVXMr50+X0Q/Lsb43OQHYW\n github.com/klauspost/cpuid/v2 v2.0.12/go.mod h1:g2LTdtYhdyuGPqyWyv7qRAmj1WBqxuObKfj5c0PQa7c=\n github.com/klauspost/cpuid/v2 v2.2.7 h1:ZWSB3igEs+d0qvnxR/ZBzXVmxkgt8DdzP6m9pfuVLDM=\n github.com/klauspost/cpuid/v2 v2.2.7/go.mod h1:Lcz8mBdAVJIBVzewtcLocK12l3Y+JytZYpaMropDUws=\n+github.com/kr/fs v0.1.0 h1:Jskdu9ieNAYnjxsi0LbQp1ulIKZV1LAFgK1tWhpZgl8=\n+github.com/kr/fs v0.1.0/go.mod h1:FFnZGqtBN9Gxj7eW1uZ42v5BccTP0vu6NEaFoC2HwRg=\n github.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\n github.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\n github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\n@@ -432,6 +438,8 @@ github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\n github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\n github.com/pkg/profile v1.7.0 h1:hnbDkaNWPCLMO9wGLdBFTIZvzDrDfBM2072E1S9gJkA=\n github.com/pkg/profile v1.7.0/go.mod h1:8Uer0jas47ZQMJ7VD+OHknK4YDY07LPUC6dEvqDjvNo=\n+github.com/pkg/sftp v1.13.9 h1:4NGkvGudBL7GteO3m6qnaQ4pC0Kvf0onSVc9gR3EWBw=\n+github.com/pkg/sftp v1.13.9/go.mod h1:OBN7bVXdstkFFN/gdnHPUb5TE8eb8G1Rp9wCItqjkkA=\n github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\n github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\n github.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c/go.mod h1:OmDBASR4679mdNQnz2pUhc2G8CO2JrUAVFDRBDP/hJE=\n@@ -587,9 +595,13 @@ golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPh\n golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\n golang.org/x/crypto v0.8.0/go.mod h1:mRqEX+O9/h5TFCrQhkgjo2yKi0yYA+9ecGkdQoHrywE=\n golang.org/x/crypto v0.12.0/go.mod h1:NF0Gs7EO5K4qLn+Ylc+fih8BSTeIjAP05siRnAh98yw=\n+golang.org/x/crypto v0.13.0/go.mod h1:y6Z2r+Rw4iayiXXAIxJIDAJ1zMW4yaTpebo8fPOliYc=\n golang.org/x/crypto v0.18.0/go.mod h1:R0j02AL6hcrfOiy9T4ZYp/rcWeMxM3L6QYxlOuEG1mg=\n-golang.org/x/crypto v0.40.0 h1:r4x+VvoG5Fm+eJcxMaY8CQM7Lb0l1lsmjGBQ6s8BfKM=\n-golang.org/x/crypto v0.40.0/go.mod h1:Qr1vMER5WyS2dfPHAlsOj01wgLbsyWtFn/aY+5+ZdxY=\n+golang.org/x/crypto v0.19.0/go.mod h1:Iy9bg/ha4yyC70EfRS8jz+B6ybOBKMaSxLj6P6oBDfU=\n+golang.org/x/crypto v0.23.0/go.mod h1:CKFgDieR+mRhux2Lsu27y0fO304Db0wZe70UKqHu0v8=\n+golang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\n+golang.org/x/crypto v0.41.0 h1:WKYxWedPGCTVVl5+WHSSrOBT0O8lx32+zxmHxijgXp4=\n+golang.org/x/crypto v0.41.0/go.mod h1:pO5AFd7FA68rFak7rOAGVuygIISepHftHnr8dr6+sUc=\n golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\n golang.org/x/exp v0.0.0-20240506185415-9bf2ced13842 h1:vr/HnozRka3pE4EsMEg1lgkXJkTFJCVUX+S/ZT6wYzM=\n golang.org/x/exp v0.0.0-20240506185415-9bf2ced13842/go.mod h1:XtvwrStGgqGPLc4cjQfWqZHG1YFdYs6swckp8vpsjnc=\n@@ -607,6 +619,9 @@ golang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\n golang.org/x/mod v0.4.2/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\n golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\n golang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\n+golang.org/x/mod v0.12.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\n+golang.org/x/mod v0.15.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\n+golang.org/x/mod v0.17.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\n golang.org/x/mod v0.26.0 h1:EGMPT//Ezu+ylkCijjPc+f4Aih7sZvaAr+O3EHBxvZg=\n golang.org/x/mod v0.26.0/go.mod h1:/j6NAhSk8iQ723BGAUyoAcn7SlD7s15Dp9Nd/SfeaFQ=\n golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\n@@ -628,7 +643,10 @@ golang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=\n golang.org/x/net v0.9.0/go.mod h1:d48xBJpPfHeWQsugry2m+kC02ZBRGRgulfHnEXEuWns=\n golang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=\n golang.org/x/net v0.14.0/go.mod h1:PpSgVXXLK0OxS0F31C1/tv6XNguvCrnXIDrFMspZIUI=\n+golang.org/x/net v0.15.0/go.mod h1:idbUs1IY1+zTqbi8yxTbhexhEEk5ur9LInksu6HrEpk=\n golang.org/x/net v0.20.0/go.mod h1:z8BVo6PvndSri0LbOE3hAn0apkU+1YvI6E70E9jsnvY=\n+golang.org/x/net v0.21.0/go.mod h1:bIjVDfnllIU7BJ2DNgfnXvpSvtn8VRwhlsaeUTyUS44=\n+golang.org/x/net v0.25.0/go.mod h1:JkAGAh7GEvH74S6FOH42FLoXpXbE/aqXSrIQjXgsiwM=\n golang.org/x/net v0.42.0 h1:jzkYrhi3YQWD6MLBJcsklgQsoAcw89EcZbJw8Z614hs=\n golang.org/x/net v0.42.0/go.mod h1:FF1RA5d3u7nAYA4z2TkclSCKh68eSXtiFwcWQpPXdt8=\n golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\n@@ -643,6 +661,10 @@ golang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJ\n golang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n golang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n+golang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=\n+golang.org/x/sync v0.6.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\n+golang.org/x/sync v0.7.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\n+golang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\n golang.org/x/sync v0.16.0 h1:ycBJEhp9p4vXvUZNszeOq0kGTPghopOL8q0fq3vstxw=\n golang.org/x/sync v0.16.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=\n golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n@@ -675,19 +697,28 @@ golang.org/x/sys v0.7.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.10.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.11.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n+golang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.16.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\n+golang.org/x/sys v0.17.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\n golang.org/x/sys v0.19.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\n-golang.org/x/sys v0.34.0 h1:H5Y5sJ2L2JRdyv7ROF1he/lPdvFsd0mJHFw2ThKHxLA=\n-golang.org/x/sys v0.34.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=\n+golang.org/x/sys v0.20.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\n+golang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\n+golang.org/x/sys v0.35.0 h1:vz1N37gP5bs89s7He8XuIYXpyY0+QlsKmzipCbUtyxI=\n+golang.org/x/sys v0.35.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=\n+golang.org/x/telemetry v0.0.0-20240228155512-f48c80bd79b2/go.mod h1:TeRTkGYfJXctD9OcfyVLyj2J3IxLnKwHJR8f4D8a3YE=\n golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\n golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\n golang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=\n golang.org/x/term v0.7.0/go.mod h1:P32HKFT3hSsZrRxla30E9HqToFYAQPCMs/zFMBUFqPY=\n golang.org/x/term v0.8.0/go.mod h1:xPskH00ivmX89bAKVGSKKtLOWNx2+17Eiy94tnKShWo=\n golang.org/x/term v0.11.0/go.mod h1:zC9APTIj3jG3FdV/Ons+XE1riIZXG4aZ4GTHiPZJPIU=\n+golang.org/x/term v0.12.0/go.mod h1:owVbMEjm3cBLCHdkQu9b1opXd4ETQWc3BhuQGKgXgvU=\n golang.org/x/term v0.16.0/go.mod h1:yn7UURbUtPyrVJPGPq404EukNFxcm/foM+bV/bfcDsY=\n-golang.org/x/term v0.33.0 h1:NuFncQrRcaRvVmgRkvM3j/F00gWIAlcmlB8ACEKmGIg=\n-golang.org/x/term v0.33.0/go.mod h1:s18+ql9tYWp1IfpV9DmCtQDDSRBUjKaw9M1eAv5UeF0=\n+golang.org/x/term v0.17.0/go.mod h1:lLRBjIVuehSbZlaOtGMbcMncT+aqLLLmKrsjNrUguwk=\n+golang.org/x/term v0.20.0/go.mod h1:8UkIAJTvZgivsXaD6/pH6U9ecQzZ45awqEOzuCvwpFY=\n+golang.org/x/term v0.27.0/go.mod h1:iMsnZpn0cago0GOrHO2+Y7u7JPn5AylBrcoWkElMTSM=\n+golang.org/x/term v0.34.0 h1:O/2T7POpk0ZZ7MAzMeWFSg6S5IpWd/RXDlM9hgM3DR4=\n+golang.org/x/term v0.34.0/go.mod h1:5jC53AEywhIVebHgPVeg0mj8OD3VO9OzclacVrqpaAw=\n golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\n golang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=\n golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\n@@ -695,9 +726,12 @@ golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\n golang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\n golang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=\n golang.org/x/text v0.12.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=\n+golang.org/x/text v0.13.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=\n golang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\n-golang.org/x/text v0.27.0 h1:4fGWRpyh641NLlecmyl4LOe6yDdfaYNrGb2zdfo4JV4=\n-golang.org/x/text v0.27.0/go.mod h1:1D28KMCvyooCX9hBiosv5Tz/+YLxj0j7XhWjpSUF7CU=\n+golang.org/x/text v0.15.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\n+golang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\n+golang.org/x/text v0.28.0 h1:rhazDwis8INMIwQ4tpjLDzUhx6RlXqZNPEM0huQojng=\n+golang.org/x/text v0.28.0/go.mod h1:U8nCwOR8jO/marOQ0QbDiOngZVEBB7MAiitBuMjXiNU=\n golang.org/x/time v0.12.0 h1:ScB/8o8olJvc+CQPWrK3fPZNfh7qgwCrY0zJmoEQLSE=\n golang.org/x/time v0.12.0/go.mod h1:CDIdPxbZBQxdj6cxyCIdrNogrJKMJ7pr37NYpMcMDSg=\n golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\n@@ -713,8 +747,10 @@ golang.org/x/tools v0.0.0-20210106214847-113979e3529a/go.mod h1:emZCQorbCU4vsT4f\n golang.org/x/tools v0.1.1/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\n golang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\n golang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=\n-golang.org/x/tools v0.34.0 h1:qIpSLOxeCYGg9TrcJokLBG4KFA6d795g0xkBkiESGlo=\n-golang.org/x/tools v0.34.0/go.mod h1:pAP9OwEaY1CAW3HOmg3hLZC5Z0CCmzjAF2UQMSqNARg=\n+golang.org/x/tools v0.13.0/go.mod h1:HvlwmtVNQAhOuCjW7xxvovg8wbNq7LwfXh/k7wXUl58=\n+golang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d/go.mod h1:aiJjzUbINMkxbQROHiO6hDPo2LHcIPhhQsa9DLh0yGk=\n+golang.org/x/tools v0.35.0 h1:mBffYraMEf7aa0sB+NuKnuCy8qI/9Bughn8dC2Gu5r0=\n+golang.org/x/tools v0.35.0/go.mod h1:NKdj5HkL/73byiZSJjqJgKn3ep7KjFkBOkR/Hps3VPw=\n golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ndiff --git a/management/internals/server/modules.go b/management/internals/server/modules.go\nindex 409bdaaba00..18a8427be87 100644\n--- a/management/internals/server/modules.go\n+++ b/management/internals/server/modules.go\n@@ -66,7 +66,7 @@ func (s *BaseServer) PeersManager() peers.Manager {\n \n func (s *BaseServer) AccountManager() account.Manager {\n \treturn Create(s, func() account.Manager {\n-\t\taccountManager, err := server.BuildManager(context.Background(), s.Store(), s.NetworkMapController(), s.IdpManager(), s.mgmtSingleAccModeDomain, s.EventStore(), s.GeoLocationManager(), s.userDeleteFromIDPEnabled, s.IntegratedValidator(), s.Metrics(), s.ProxyController(), s.SettingsManager(), s.PermissionsManager(), s.config.DisableDefaultPolicy)\n+\t\taccountManager, err := server.BuildManager(context.Background(), s.config, s.Store(), s.NetworkMapController(), s.IdpManager(), s.mgmtSingleAccModeDomain, s.EventStore(), s.GeoLocationManager(), s.userDeleteFromIDPEnabled, s.IntegratedValidator(), s.Metrics(), s.ProxyController(), s.SettingsManager(), s.PermissionsManager(), s.config.DisableDefaultPolicy)\n \t\tif err != nil {\n \t\t\tlog.Fatalf(\"failed to create account manager: %v\", err)\n \t\t}\ndiff --git a/management/internals/shared/grpc/conversion.go b/management/internals/shared/grpc/conversion.go\nindex 9a4681eae7b..7f64034dfa8 100644\n--- a/management/internals/shared/grpc/conversion.go\n+++ b/management/internals/shared/grpc/conversion.go\n@@ -3,6 +3,8 @@ package grpc\n import (\n \t\"context\"\n \t\"fmt\"\n+\t\"net/url\"\n+\t\"strings\"\n \n \tintegrationsConfig \"github.com/netbirdio/management-integrations/integrations/config\"\n \tnbdns \"github.com/netbirdio/netbird/dns\"\n@@ -81,12 +83,21 @@ func toNetbirdConfig(config *nbconfig.Config, turnCredentials *Token, relayToken\n \treturn nbConfig\n }\n \n-func toPeerConfig(peer *nbpeer.Peer, network *types.Network, dnsName string, settings *types.Settings) *proto.PeerConfig {\n+func toPeerConfig(peer *nbpeer.Peer, network *types.Network, dnsName string, settings *types.Settings, config *nbconfig.Config) *proto.PeerConfig {\n \tnetmask, _ := network.Net.Mask.Size()\n \tfqdn := peer.FQDN(dnsName)\n+\n+\tsshConfig := &proto.SSHConfig{\n+\t\tSshEnabled: peer.SSHEnabled,\n+\t}\n+\n+\tif peer.SSHEnabled {\n+\t\tsshConfig.JwtConfig = buildJWTConfig(config)\n+\t}\n+\n \treturn &proto.PeerConfig{\n-\t\tAddress:                         fmt.Sprintf(\"%s/%d\", peer.IP.String(), netmask), // take it from the network\n-\t\tSshConfig:                       &proto.SSHConfig{SshEnabled: peer.SSHEnabled},\n+\t\tAddress:                         fmt.Sprintf(\"%s/%d\", peer.IP.String(), netmask),\n+\t\tSshConfig:                       sshConfig,\n \t\tFqdn:                            fqdn,\n \t\tRoutingPeerDnsResolutionEnabled: settings.RoutingPeerDNSResolutionEnabled,\n \t\tLazyConnectionEnabled:           settings.LazyConnectionEnabled,\n@@ -95,7 +106,7 @@ func toPeerConfig(peer *nbpeer.Peer, network *types.Network, dnsName string, set\n \n func ToSyncResponse(ctx context.Context, config *nbconfig.Config, peer *nbpeer.Peer, turnCredentials *Token, relayCredentials *Token, networkMap *types.NetworkMap, dnsName string, checks []*posture.Checks, dnsCache *cache.DNSConfigCache, settings *types.Settings, extraSettings *types.ExtraSettings, peerGroups []string, dnsFwdPort int64) *proto.SyncResponse {\n \tresponse := &proto.SyncResponse{\n-\t\tPeerConfig: toPeerConfig(peer, networkMap.Network, dnsName, settings),\n+\t\tPeerConfig: toPeerConfig(peer, networkMap.Network, dnsName, settings, config),\n \t\tNetworkMap: &proto.NetworkMap{\n \t\t\tSerial:    networkMap.Network.CurrentSerial(),\n \t\t\tRoutes:    toProtocolRoutes(networkMap.Routes),\n@@ -350,3 +361,51 @@ func convertToProtoNameServerGroup(nsGroup *nbdns.NameServerGroup) *proto.NameSe\n \t}\n \treturn protoGroup\n }\n+\n+// buildJWTConfig constructs JWT configuration for SSH servers from management server config\n+func buildJWTConfig(config *nbconfig.Config) *proto.JWTConfig {\n+\tif config == nil {\n+\t\treturn nil\n+\t}\n+\n+\tif config.HttpConfig == nil || config.HttpConfig.AuthAudience == \"\" {\n+\t\treturn nil\n+\t}\n+\n+\tissuer := strings.TrimSpace(config.HttpConfig.AuthIssuer)\n+\tif issuer == \"\" {\n+\t\tif config.DeviceAuthorizationFlow != nil {\n+\t\t\tif d := deriveIssuerFromTokenEndpoint(config.DeviceAuthorizationFlow.ProviderConfig.TokenEndpoint); d != \"\" {\n+\t\t\t\tissuer = d\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif issuer == \"\" {\n+\t\treturn nil\n+\t}\n+\n+\tkeysLocation := strings.TrimSpace(config.HttpConfig.AuthKeysLocation)\n+\tif keysLocation == \"\" {\n+\t\tkeysLocation = strings.TrimSuffix(issuer, \"/\") + \"/.well-known/jwks.json\"\n+\t}\n+\n+\treturn &proto.JWTConfig{\n+\t\tIssuer:       issuer,\n+\t\tAudience:     config.HttpConfig.AuthAudience,\n+\t\tKeysLocation: keysLocation,\n+\t}\n+}\n+\n+// deriveIssuerFromTokenEndpoint extracts the issuer URL from a token endpoint\n+func deriveIssuerFromTokenEndpoint(tokenEndpoint string) string {\n+\tif tokenEndpoint == \"\" {\n+\t\treturn \"\"\n+\t}\n+\n+\tu, err := url.Parse(tokenEndpoint)\n+\tif err != nil {\n+\t\treturn \"\"\n+\t}\n+\n+\treturn fmt.Sprintf(\"%s://%s/\", u.Scheme, u.Host)\n+}\ndiff --git a/management/internals/shared/grpc/server.go b/management/internals/shared/grpc/server.go\nindex 08a840316d9..4364272a080 100644\n--- a/management/internals/shared/grpc/server.go\n+++ b/management/internals/shared/grpc/server.go\n@@ -646,7 +646,7 @@ func (s *Server) prepareLoginResponse(ctx context.Context, peer *nbpeer.Peer, ne\n \t// if peer has reached this point then it has logged in\n \tloginResp := &proto.LoginResponse{\n \t\tNetbirdConfig: toNetbirdConfig(s.config, nil, relayToken, nil),\n-\t\tPeerConfig:    toPeerConfig(peer, netMap.Network, s.networkMapController.GetDNSDomain(settings), settings),\n+\t\tPeerConfig:    toPeerConfig(peer, netMap.Network, s.networkMapController.GetDNSDomain(settings), settings, s.config),\n \t\tChecks:        toProtocolChecks(ctx, postureChecks),\n \t}\n \ndiff --git a/management/server/account.go b/management/server/account.go\nindex a4b2a752b9a..3e498536ce5 100644\n--- a/management/server/account.go\n+++ b/management/server/account.go\n@@ -15,6 +15,8 @@ import (\n \t\"sync\"\n \t\"time\"\n \n+\t\"github.com/netbirdio/netbird/shared/auth\"\n+\n \tcacheStore \"github.com/eko/gocache/lib/v4/store\"\n \t\"github.com/eko/gocache/store/redis/v4\"\n \t\"github.com/rs/xid\"\n@@ -25,6 +27,7 @@ import (\n \tnbdns \"github.com/netbirdio/netbird/dns\"\n \t\"github.com/netbirdio/netbird/formatter/hook\"\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map\"\n+\tnbconfig \"github.com/netbirdio/netbird/management/internals/server/config\"\n \t\"github.com/netbirdio/netbird/management/server/account\"\n \t\"github.com/netbirdio/netbird/management/server/activity\"\n \tnbcache \"github.com/netbirdio/netbird/management/server/cache\"\n@@ -81,6 +84,9 @@ type DefaultAccountManager struct {\n \tproxyController port_forwarding.Controller\n \tsettingsManager settings.Manager\n \n+\t// config contains the management server configuration\n+\tconfig *nbconfig.Config\n+\n \t// singleAccountMode indicates whether the instance has a single account.\n \t// If true, then every new user will end up under the same account.\n \t// This value will be set to false if management service has more than one account.\n@@ -171,6 +177,7 @@ func (am *DefaultAccountManager) getJWTGroupsChanges(user *types.User, groups []\n // BuildManager creates a new DefaultAccountManager with a provided Store\n func BuildManager(\n \tctx context.Context,\n+\tconfig *nbconfig.Config,\n \tstore store.Store,\n \tnetworkMapController network_map.Controller,\n \tidpManager idp.Manager,\n@@ -192,6 +199,7 @@ func BuildManager(\n \n \tam := &DefaultAccountManager{\n \t\tStore:                    store,\n+\t\tconfig:                   config,\n \t\tgeo:                      geo,\n \t\tnetworkMapController:     networkMapController,\n \t\tidpManager:               idpManager,\n@@ -1006,7 +1014,7 @@ func (am *DefaultAccountManager) removeUserFromCache(ctx context.Context, accoun\n }\n \n // updateAccountDomainAttributesIfNotUpToDate updates the account domain attributes if they are not up to date and then, saves the account changes\n-func (am *DefaultAccountManager) updateAccountDomainAttributesIfNotUpToDate(ctx context.Context, accountID string, userAuth nbcontext.UserAuth,\n+func (am *DefaultAccountManager) updateAccountDomainAttributesIfNotUpToDate(ctx context.Context, accountID string, userAuth auth.UserAuth,\n \tprimaryDomain bool,\n ) error {\n \tif userAuth.Domain == \"\" {\n@@ -1055,7 +1063,7 @@ func (am *DefaultAccountManager) handleExistingUserAccount(\n \tctx context.Context,\n \tuserAccountID string,\n \tdomainAccountID string,\n-\tuserAuth nbcontext.UserAuth,\n+\tuserAuth auth.UserAuth,\n ) error {\n \tprimaryDomain := domainAccountID == \"\" || userAccountID == domainAccountID\n \terr := am.updateAccountDomainAttributesIfNotUpToDate(ctx, userAccountID, userAuth, primaryDomain)\n@@ -1074,7 +1082,7 @@ func (am *DefaultAccountManager) handleExistingUserAccount(\n \n // addNewPrivateAccount validates if there is an existing primary account for the domain, if so it adds the new user to that account,\n // otherwise it will create a new account and make it primary account for the domain.\n-func (am *DefaultAccountManager) addNewPrivateAccount(ctx context.Context, domainAccountID string, userAuth nbcontext.UserAuth) (string, error) {\n+func (am *DefaultAccountManager) addNewPrivateAccount(ctx context.Context, domainAccountID string, userAuth auth.UserAuth) (string, error) {\n \tif userAuth.UserId == \"\" {\n \t\treturn \"\", fmt.Errorf(\"user ID is empty\")\n \t}\n@@ -1105,7 +1113,7 @@ func (am *DefaultAccountManager) addNewPrivateAccount(ctx context.Context, domai\n \treturn newAccount.Id, nil\n }\n \n-func (am *DefaultAccountManager) addNewUserToDomainAccount(ctx context.Context, domainAccountID string, userAuth nbcontext.UserAuth) (string, error) {\n+func (am *DefaultAccountManager) addNewUserToDomainAccount(ctx context.Context, domainAccountID string, userAuth auth.UserAuth) (string, error) {\n \tnewUser := types.NewRegularUser(userAuth.UserId)\n \tnewUser.AccountID = domainAccountID\n \n@@ -1217,7 +1225,7 @@ func (am *DefaultAccountManager) GetAccountOnboarding(ctx context.Context, accou\n \n \tonboarding, err := am.Store.GetAccountOnboarding(ctx, accountID)\n \tif err != nil && err.Error() != status.NewAccountOnboardingNotFoundError(accountID).Error() {\n-\t\tlog.Errorf(\"failed to get account onboarding for accountssssssss %s: %v\", accountID, err)\n+\t\tlog.Errorf(\"failed to get account onboarding for account %s: %v\", accountID, err)\n \t\treturn nil, err\n \t}\n \n@@ -1269,7 +1277,7 @@ func (am *DefaultAccountManager) UpdateAccountOnboarding(ctx context.Context, ac\n \treturn newOnboarding, nil\n }\n \n-func (am *DefaultAccountManager) GetAccountIDFromUserAuth(ctx context.Context, userAuth nbcontext.UserAuth) (string, string, error) {\n+func (am *DefaultAccountManager) GetAccountIDFromUserAuth(ctx context.Context, userAuth auth.UserAuth) (string, string, error) {\n \tif userAuth.UserId == \"\" {\n \t\treturn \"\", \"\", errors.New(emptyUserID)\n \t}\n@@ -1313,7 +1321,7 @@ func (am *DefaultAccountManager) GetAccountIDFromUserAuth(ctx context.Context, u\n // syncJWTGroups processes the JWT groups for a user, updates the account based on the groups,\n // and propagates changes to peers if group propagation is enabled.\n // requires userAuth to have been ValidateAndParseToken and EnsureUserAccessByJWTGroups by the AuthManager\n-func (am *DefaultAccountManager) SyncUserJWTGroups(ctx context.Context, userAuth nbcontext.UserAuth) error {\n+func (am *DefaultAccountManager) SyncUserJWTGroups(ctx context.Context, userAuth auth.UserAuth) error {\n \tif userAuth.IsChild || userAuth.IsPAT {\n \t\treturn nil\n \t}\n@@ -1471,7 +1479,7 @@ func (am *DefaultAccountManager) SyncUserJWTGroups(ctx context.Context, userAuth\n // Existing user + Existing account + Existing domain reclassified Domain as private -> Nothing changes (index domain)\n //\n // UserAuth IsChild -> checks that account exists\n-func (am *DefaultAccountManager) getAccountIDWithAuthorizationClaims(ctx context.Context, userAuth nbcontext.UserAuth) (string, error) {\n+func (am *DefaultAccountManager) getAccountIDWithAuthorizationClaims(ctx context.Context, userAuth auth.UserAuth) (string, error) {\n \tlog.WithContext(ctx).Tracef(\"getting account with authorization claims. User ID: \\\"%s\\\", Account ID: \\\"%s\\\", Domain: \\\"%s\\\", Domain Category: \\\"%s\\\"\",\n \t\tuserAuth.UserId, userAuth.AccountId, userAuth.Domain, userAuth.DomainCategory)\n \n@@ -1550,7 +1558,7 @@ func (am *DefaultAccountManager) getPrivateDomainWithGlobalLock(ctx context.Cont\n \treturn domainAccountID, cancel, nil\n }\n \n-func (am *DefaultAccountManager) handlePrivateAccountWithIDFromClaim(ctx context.Context, userAuth nbcontext.UserAuth) (string, error) {\n+func (am *DefaultAccountManager) handlePrivateAccountWithIDFromClaim(ctx context.Context, userAuth auth.UserAuth) (string, error) {\n \tuserAccountID, err := am.Store.GetAccountIDByUserID(ctx, store.LockingStrengthNone, userAuth.UserId)\n \tif err != nil {\n \t\tlog.WithContext(ctx).Errorf(\"error getting account ID by user ID: %v\", err)\n@@ -1598,7 +1606,7 @@ func handleNotFound(err error) error {\n \treturn nil\n }\n \n-func domainIsUpToDate(domain string, domainCategory string, userAuth nbcontext.UserAuth) bool {\n+func domainIsUpToDate(domain string, domainCategory string, userAuth auth.UserAuth) bool {\n \treturn domainCategory == types.PrivateCategory || userAuth.DomainCategory != types.PrivateCategory || domain != userAuth.Domain\n }\n \ndiff --git a/management/server/account/manager.go b/management/server/account/manager.go\nindex 7c174a48195..9b3902d87d2 100644\n--- a/management/server/account/manager.go\n+++ b/management/server/account/manager.go\n@@ -6,10 +6,11 @@ import (\n \t\"net/netip\"\n \t\"time\"\n \n+\t\"github.com/netbirdio/netbird/shared/auth\"\n+\n \tnbdns \"github.com/netbirdio/netbird/dns\"\n \t\"github.com/netbirdio/netbird/management/server/activity\"\n \tnbcache \"github.com/netbirdio/netbird/management/server/cache\"\n-\tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/idp\"\n \tnbpeer \"github.com/netbirdio/netbird/management/server/peer\"\n \t\"github.com/netbirdio/netbird/management/server/peers/ephemeral\"\n@@ -45,10 +46,10 @@ type Manager interface {\n \tGetAccountOnboarding(ctx context.Context, accountID string, userID string) (*types.AccountOnboarding, error)\n \tAccountExists(ctx context.Context, accountID string) (bool, error)\n \tGetAccountIDByUserID(ctx context.Context, userID, domain string) (string, error)\n-\tGetAccountIDFromUserAuth(ctx context.Context, userAuth nbcontext.UserAuth) (string, string, error)\n+\tGetAccountIDFromUserAuth(ctx context.Context, userAuth auth.UserAuth) (string, string, error)\n \tDeleteAccount(ctx context.Context, accountID, userID string) error\n \tGetUserByID(ctx context.Context, id string) (*types.User, error)\n-\tGetUserFromUserAuth(ctx context.Context, userAuth nbcontext.UserAuth) (*types.User, error)\n+\tGetUserFromUserAuth(ctx context.Context, userAuth auth.UserAuth) (*types.User, error)\n \tListUsers(ctx context.Context, accountID string) ([]*types.User, error)\n \tGetPeers(ctx context.Context, accountID, userID, nameFilter, ipFilter string) ([]*nbpeer.Peer, error)\n \tMarkPeerConnected(ctx context.Context, peerKey string, connected bool, realIP net.IP, accountID string) error\n@@ -117,11 +118,11 @@ type Manager interface {\n \tUpdateAccountPeers(ctx context.Context, accountID string)\n \tBufferUpdateAccountPeers(ctx context.Context, accountID string)\n \tBuildUserInfosForAccount(ctx context.Context, accountID, initiatorUserID string, accountUsers []*types.User) (map[string]*types.UserInfo, error)\n-\tSyncUserJWTGroups(ctx context.Context, userAuth nbcontext.UserAuth) error\n+\tSyncUserJWTGroups(ctx context.Context, userAuth auth.UserAuth) error\n \tGetStore() store.Store\n \tGetOrCreateAccountByPrivateDomain(ctx context.Context, initiatorId, domain string) (*types.Account, bool, error)\n \tUpdateToPrimaryAccount(ctx context.Context, accountId string) error\n \tGetOwnerInfo(ctx context.Context, accountId string) (*types.UserInfo, error)\n-\tGetCurrentUserInfo(ctx context.Context, userAuth nbcontext.UserAuth) (*users.UserInfoWithPermissions, error)\n+\tGetCurrentUserInfo(ctx context.Context, userAuth auth.UserAuth) (*users.UserInfoWithPermissions, error)\n \tSetEphemeralManager(em ephemeral.Manager)\n }\ndiff --git a/management/server/auth/manager.go b/management/server/auth/manager.go\nindex ece9dc32110..0c62357dcc0 100644\n--- a/management/server/auth/manager.go\n+++ b/management/server/auth/manager.go\n@@ -9,18 +9,19 @@ import (\n \n \t\"github.com/golang-jwt/jwt/v5\"\n \n+\t\"github.com/netbirdio/netbird/shared/auth\"\n+\n \t\"github.com/netbirdio/netbird/base62\"\n-\tnbjwt \"github.com/netbirdio/netbird/management/server/auth/jwt\"\n-\tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/store\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n+\tnbjwt \"github.com/netbirdio/netbird/shared/auth/jwt\"\n )\n \n var _ Manager = (*manager)(nil)\n \n type Manager interface {\n-\tValidateAndParseToken(ctx context.Context, value string) (nbcontext.UserAuth, *jwt.Token, error)\n-\tEnsureUserAccessByJWTGroups(ctx context.Context, userAuth nbcontext.UserAuth, token *jwt.Token) (nbcontext.UserAuth, error)\n+\tValidateAndParseToken(ctx context.Context, value string) (auth.UserAuth, *jwt.Token, error)\n+\tEnsureUserAccessByJWTGroups(ctx context.Context, userAuth auth.UserAuth, token *jwt.Token) (auth.UserAuth, error)\n \tMarkPATUsed(ctx context.Context, tokenID string) error\n \tGetPATInfo(ctx context.Context, token string) (user *types.User, pat *types.PersonalAccessToken, domain string, category string, err error)\n }\n@@ -55,20 +56,20 @@ func NewManager(store store.Store, issuer, audience, keysLocation, userIdClaim s\n \t}\n }\n \n-func (m *manager) ValidateAndParseToken(ctx context.Context, value string) (nbcontext.UserAuth, *jwt.Token, error) {\n+func (m *manager) ValidateAndParseToken(ctx context.Context, value string) (auth.UserAuth, *jwt.Token, error) {\n \ttoken, err := m.validator.ValidateAndParse(ctx, value)\n \tif err != nil {\n-\t\treturn nbcontext.UserAuth{}, nil, err\n+\t\treturn auth.UserAuth{}, nil, err\n \t}\n \n \tuserAuth, err := m.extractor.ToUserAuth(token)\n \tif err != nil {\n-\t\treturn nbcontext.UserAuth{}, nil, err\n+\t\treturn auth.UserAuth{}, nil, err\n \t}\n \treturn userAuth, token, err\n }\n \n-func (m *manager) EnsureUserAccessByJWTGroups(ctx context.Context, userAuth nbcontext.UserAuth, token *jwt.Token) (nbcontext.UserAuth, error) {\n+func (m *manager) EnsureUserAccessByJWTGroups(ctx context.Context, userAuth auth.UserAuth, token *jwt.Token) (auth.UserAuth, error) {\n \tif userAuth.IsChild || userAuth.IsPAT {\n \t\treturn userAuth, nil\n \t}\ndiff --git a/management/server/auth/manager_mock.go b/management/server/auth/manager_mock.go\nindex 30a7a716190..edf158a4978 100644\n--- a/management/server/auth/manager_mock.go\n+++ b/management/server/auth/manager_mock.go\n@@ -3,9 +3,10 @@ package auth\n import (\n \t\"context\"\n \n+\t\"github.com/netbirdio/netbird/shared/auth\"\n+\n \t\"github.com/golang-jwt/jwt/v5\"\n \n-\tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n )\n \n@@ -15,18 +16,18 @@ var (\n \n // @note really dislike this mocking approach but rather than have to do additional test refactoring.\n type MockManager struct {\n-\tValidateAndParseTokenFunc       func(ctx context.Context, value string) (nbcontext.UserAuth, *jwt.Token, error)\n-\tEnsureUserAccessByJWTGroupsFunc func(ctx context.Context, userAuth nbcontext.UserAuth, token *jwt.Token) (nbcontext.UserAuth, error)\n+\tValidateAndParseTokenFunc       func(ctx context.Context, value string) (auth.UserAuth, *jwt.Token, error)\n+\tEnsureUserAccessByJWTGroupsFunc func(ctx context.Context, userAuth auth.UserAuth, token *jwt.Token) (auth.UserAuth, error)\n \tMarkPATUsedFunc                 func(ctx context.Context, tokenID string) error\n \tGetPATInfoFunc                  func(ctx context.Context, token string) (user *types.User, pat *types.PersonalAccessToken, domain string, category string, err error)\n }\n \n // EnsureUserAccessByJWTGroups implements Manager.\n-func (m *MockManager) EnsureUserAccessByJWTGroups(ctx context.Context, userAuth nbcontext.UserAuth, token *jwt.Token) (nbcontext.UserAuth, error) {\n+func (m *MockManager) EnsureUserAccessByJWTGroups(ctx context.Context, userAuth auth.UserAuth, token *jwt.Token) (auth.UserAuth, error) {\n \tif m.EnsureUserAccessByJWTGroupsFunc != nil {\n \t\treturn m.EnsureUserAccessByJWTGroupsFunc(ctx, userAuth, token)\n \t}\n-\treturn nbcontext.UserAuth{}, nil\n+\treturn auth.UserAuth{}, nil\n }\n \n // GetPATInfo implements Manager.\n@@ -46,9 +47,9 @@ func (m *MockManager) MarkPATUsed(ctx context.Context, tokenID string) error {\n }\n \n // ValidateAndParseToken implements Manager.\n-func (m *MockManager) ValidateAndParseToken(ctx context.Context, value string) (nbcontext.UserAuth, *jwt.Token, error) {\n+func (m *MockManager) ValidateAndParseToken(ctx context.Context, value string) (auth.UserAuth, *jwt.Token, error) {\n \tif m.ValidateAndParseTokenFunc != nil {\n \t\treturn m.ValidateAndParseTokenFunc(ctx, value)\n \t}\n-\treturn nbcontext.UserAuth{}, &jwt.Token{}, nil\n+\treturn auth.UserAuth{}, &jwt.Token{}, nil\n }\ndiff --git a/management/server/context/auth.go b/management/server/context/auth.go\nindex 5cb28ddb7cb..cc59b8a63d0 100644\n--- a/management/server/context/auth.go\n+++ b/management/server/context/auth.go\n@@ -4,7 +4,8 @@ import (\n \t\"context\"\n \t\"fmt\"\n \t\"net/http\"\n-\t\"time\"\n+\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n )\n \n type key int\n@@ -13,45 +14,22 @@ const (\n \tUserAuthContextKey key = iota\n )\n \n-type UserAuth struct {\n-\t// The account id the user is accessing\n-\tAccountId string\n-\t// The account domain\n-\tDomain string\n-\t// The account domain category, TBC values\n-\tDomainCategory string\n-\t// Indicates whether this user was invited, TBC logic\n-\tInvited bool\n-\t// Indicates whether this is a child account\n-\tIsChild bool\n-\n-\t// The user id\n-\tUserId string\n-\t// Last login time for this user\n-\tLastLogin time.Time\n-\t// The Groups the user belongs to on this account\n-\tGroups []string\n-\n-\t// Indicates whether this user has authenticated with a Personal Access Token\n-\tIsPAT bool\n-}\n-\n-func GetUserAuthFromRequest(r *http.Request) (UserAuth, error) {\n+func GetUserAuthFromRequest(r *http.Request) (auth.UserAuth, error) {\n \treturn GetUserAuthFromContext(r.Context())\n }\n \n-func SetUserAuthInRequest(r *http.Request, userAuth UserAuth) *http.Request {\n+func SetUserAuthInRequest(r *http.Request, userAuth auth.UserAuth) *http.Request {\n \treturn r.WithContext(SetUserAuthInContext(r.Context(), userAuth))\n }\n \n-func GetUserAuthFromContext(ctx context.Context) (UserAuth, error) {\n-\tif userAuth, ok := ctx.Value(UserAuthContextKey).(UserAuth); ok {\n+func GetUserAuthFromContext(ctx context.Context) (auth.UserAuth, error) {\n+\tif userAuth, ok := ctx.Value(UserAuthContextKey).(auth.UserAuth); ok {\n \t\treturn userAuth, nil\n \t}\n-\treturn UserAuth{}, fmt.Errorf(\"user auth not in context\")\n+\treturn auth.UserAuth{}, fmt.Errorf(\"user auth not in context\")\n }\n \n-func SetUserAuthInContext(ctx context.Context, userAuth UserAuth) context.Context {\n+func SetUserAuthInContext(ctx context.Context, userAuth auth.UserAuth) context.Context {\n \t//nolint\n \tctx = context.WithValue(ctx, UserIDKey, userAuth.UserId)\n \t//nolint\ndiff --git a/management/server/http/handlers/dns/dns_settings_handler.go b/management/server/http/handlers/dns/dns_settings_handler.go\nindex 08a0b2afd2d..67638aea5ad 100644\n--- a/management/server/http/handlers/dns/dns_settings_handler.go\n+++ b/management/server/http/handlers/dns/dns_settings_handler.go\n@@ -9,9 +9,9 @@ import (\n \n \t\"github.com/netbirdio/netbird/management/server/account\"\n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n+\t\"github.com/netbirdio/netbird/management/server/types\"\n \t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/shared/management/http/util\"\n-\t\"github.com/netbirdio/netbird/management/server/types\"\n )\n \n // dnsSettingsHandler is a handler that returns the DNS settings of the account\ndiff --git a/management/server/http/handlers/groups/groups_handler.go b/management/server/http/handlers/groups/groups_handler.go\nindex e861e873c1e..208a2e8288f 100644\n--- a/management/server/http/handlers/groups/groups_handler.go\n+++ b/management/server/http/handlers/groups/groups_handler.go\n@@ -11,10 +11,10 @@ import (\n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \tnbpeer \"github.com/netbirdio/netbird/management/server/peer\"\n \n+\t\"github.com/netbirdio/netbird/management/server/types\"\n \t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/shared/management/http/util\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n-\t\"github.com/netbirdio/netbird/management/server/types\"\n )\n \n // handler is a handler that returns groups of the account\ndiff --git a/management/server/http/handlers/networks/handler.go b/management/server/http/handlers/networks/handler.go\nindex d7b598a5d7b..f99eca7941f 100644\n--- a/management/server/http/handlers/networks/handler.go\n+++ b/management/server/http/handlers/networks/handler.go\n@@ -12,15 +12,15 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/account\"\n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/groups\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/util\"\n \t\"github.com/netbirdio/netbird/management/server/networks\"\n \t\"github.com/netbirdio/netbird/management/server/networks/resources\"\n \t\"github.com/netbirdio/netbird/management/server/networks/routers\"\n \trouterTypes \"github.com/netbirdio/netbird/management/server/networks/routers/types\"\n \t\"github.com/netbirdio/netbird/management/server/networks/types\"\n-\t\"github.com/netbirdio/netbird/shared/management/status\"\n \tnbtypes \"github.com/netbirdio/netbird/management/server/types\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/util\"\n+\t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n \n // handler is a handler that returns networks of the account\ndiff --git a/management/server/http/handlers/networks/resources_handler.go b/management/server/http/handlers/networks/resources_handler.go\nindex 59396dcebb6..c31729a39c7 100644\n--- a/management/server/http/handlers/networks/resources_handler.go\n+++ b/management/server/http/handlers/networks/resources_handler.go\n@@ -8,10 +8,10 @@ import (\n \n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/groups\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/util\"\n \t\"github.com/netbirdio/netbird/management/server/networks/resources\"\n \t\"github.com/netbirdio/netbird/management/server/networks/resources/types\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/util\"\n )\n \n type resourceHandler struct {\ndiff --git a/management/server/http/handlers/networks/routers_handler.go b/management/server/http/handlers/networks/routers_handler.go\nindex 2e64c637ff5..c311a29feb4 100644\n--- a/management/server/http/handlers/networks/routers_handler.go\n+++ b/management/server/http/handlers/networks/routers_handler.go\n@@ -7,10 +7,10 @@ import (\n \t\"github.com/gorilla/mux\"\n \n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/util\"\n \t\"github.com/netbirdio/netbird/management/server/networks/routers\"\n \t\"github.com/netbirdio/netbird/management/server/networks/routers/types\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/util\"\n )\n \n type routersHandler struct {\ndiff --git a/management/server/http/handlers/policies/geolocations_handler.go b/management/server/http/handlers/policies/geolocations_handler.go\nindex cb699579305..a2d656a4716 100644\n--- a/management/server/http/handlers/policies/geolocations_handler.go\n+++ b/management/server/http/handlers/policies/geolocations_handler.go\n@@ -9,11 +9,11 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/account\"\n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/geolocation\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/util\"\n \t\"github.com/netbirdio/netbird/management/server/permissions\"\n \t\"github.com/netbirdio/netbird/management/server/permissions/modules\"\n \t\"github.com/netbirdio/netbird/management/server/permissions/operations\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/util\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n \ndiff --git a/management/server/http/handlers/policies/policies_handler.go b/management/server/http/handlers/policies/policies_handler.go\nindex 4d6bad5e390..ab1639ab146 100644\n--- a/management/server/http/handlers/policies/policies_handler.go\n+++ b/management/server/http/handlers/policies/policies_handler.go\n@@ -10,10 +10,10 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/account\"\n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/geolocation\"\n+\t\"github.com/netbirdio/netbird/management/server/types\"\n \t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/shared/management/http/util\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n-\t\"github.com/netbirdio/netbird/management/server/types\"\n )\n \n // handler is a handler that returns policy of the account\ndiff --git a/management/server/http/handlers/policies/posture_checks_handler.go b/management/server/http/handlers/policies/posture_checks_handler.go\nindex 3ebc4d1e105..744cde10b0e 100644\n--- a/management/server/http/handlers/policies/posture_checks_handler.go\n+++ b/management/server/http/handlers/policies/posture_checks_handler.go\n@@ -9,9 +9,9 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/account\"\n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/geolocation\"\n+\t\"github.com/netbirdio/netbird/management/server/posture\"\n \t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/shared/management/http/util\"\n-\t\"github.com/netbirdio/netbird/management/server/posture\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n \ndiff --git a/management/server/http/handlers/setup_keys/setupkeys_handler.go b/management/server/http/handlers/setup_keys/setupkeys_handler.go\nindex 2287dadfe22..d267b6eea2a 100644\n--- a/management/server/http/handlers/setup_keys/setupkeys_handler.go\n+++ b/management/server/http/handlers/setup_keys/setupkeys_handler.go\n@@ -10,10 +10,10 @@ import (\n \n \t\"github.com/netbirdio/netbird/management/server/account\"\n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n+\t\"github.com/netbirdio/netbird/management/server/types\"\n \t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/shared/management/http/util\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n-\t\"github.com/netbirdio/netbird/management/server/types\"\n )\n \n // handler is a handler that returns a list of setup keys of the account\ndiff --git a/management/server/http/handlers/users/pat_handler.go b/management/server/http/handlers/users/pat_handler.go\nindex bae07af4a58..867db3ca9f7 100644\n--- a/management/server/http/handlers/users/pat_handler.go\n+++ b/management/server/http/handlers/users/pat_handler.go\n@@ -8,10 +8,10 @@ import (\n \n \t\"github.com/netbirdio/netbird/management/server/account\"\n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n+\t\"github.com/netbirdio/netbird/management/server/types\"\n \t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/shared/management/http/util\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n-\t\"github.com/netbirdio/netbird/management/server/types\"\n )\n \n // patHandler is the nameserver group handler of the account\ndiff --git a/management/server/http/middleware/auth_middleware.go b/management/server/http/middleware/auth_middleware.go\nindex bce917a2552..9439165a46f 100644\n--- a/management/server/http/middleware/auth_middleware.go\n+++ b/management/server/http/middleware/auth_middleware.go\n@@ -10,22 +10,23 @@ import (\n \n \tlog \"github.com/sirupsen/logrus\"\n \n-\t\"github.com/netbirdio/netbird/management/server/auth\"\n+\tserverauth \"github.com/netbirdio/netbird/management/server/auth\"\n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/http/middleware/bypass\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n \t\"github.com/netbirdio/netbird/shared/management/http/util\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n \n-type EnsureAccountFunc func(ctx context.Context, userAuth nbcontext.UserAuth) (string, string, error)\n-type SyncUserJWTGroupsFunc func(ctx context.Context, userAuth nbcontext.UserAuth) error\n+type EnsureAccountFunc func(ctx context.Context, userAuth auth.UserAuth) (string, string, error)\n+type SyncUserJWTGroupsFunc func(ctx context.Context, userAuth auth.UserAuth) error\n \n-type GetUserFromUserAuthFunc func(ctx context.Context, userAuth nbcontext.UserAuth) (*types.User, error)\n+type GetUserFromUserAuthFunc func(ctx context.Context, userAuth auth.UserAuth) (*types.User, error)\n \n // AuthMiddleware middleware to verify personal access tokens (PAT) and JWT tokens\n type AuthMiddleware struct {\n-\tauthManager         auth.Manager\n+\tauthManager         serverauth.Manager\n \tensureAccount       EnsureAccountFunc\n \tgetUserFromUserAuth GetUserFromUserAuthFunc\n \tsyncUserJWTGroups   SyncUserJWTGroupsFunc\n@@ -34,7 +35,7 @@ type AuthMiddleware struct {\n \n // NewAuthMiddleware instance constructor\n func NewAuthMiddleware(\n-\tauthManager auth.Manager,\n+\tauthManager serverauth.Manager,\n \tensureAccount EnsureAccountFunc,\n \tsyncUserJWTGroups SyncUserJWTGroupsFunc,\n \tgetUserFromUserAuth GetUserFromUserAuthFunc,\n@@ -61,18 +62,18 @@ func (m *AuthMiddleware) Handler(h http.Handler) http.Handler {\n \t\t\treturn\n \t\t}\n \n-\t\tauth := strings.Split(r.Header.Get(\"Authorization\"), \" \")\n-\t\tauthType := strings.ToLower(auth[0])\n+\t\tauthHeader := strings.Split(r.Header.Get(\"Authorization\"), \" \")\n+\t\tauthType := strings.ToLower(authHeader[0])\n \n \t\t// fallback to token when receive pat as bearer\n-\t\tif len(auth) >= 2 && authType == \"bearer\" && strings.HasPrefix(auth[1], \"nbp_\") {\n+\t\tif len(authHeader) >= 2 && authType == \"bearer\" && strings.HasPrefix(authHeader[1], \"nbp_\") {\n \t\t\tauthType = \"token\"\n-\t\t\tauth[0] = authType\n+\t\t\tauthHeader[0] = authType\n \t\t}\n \n \t\tswitch authType {\n \t\tcase \"bearer\":\n-\t\t\trequest, err := m.checkJWTFromRequest(r, auth)\n+\t\t\trequest, err := m.checkJWTFromRequest(r, authHeader)\n \t\t\tif err != nil {\n \t\t\t\tlog.WithContext(r.Context()).Errorf(\"Error when validating JWT: %s\", err.Error())\n \t\t\t\tutil.WriteError(r.Context(), status.Errorf(status.Unauthorized, \"token invalid\"), w)\n@@ -81,7 +82,7 @@ func (m *AuthMiddleware) Handler(h http.Handler) http.Handler {\n \n \t\t\th.ServeHTTP(w, request)\n \t\tcase \"token\":\n-\t\t\trequest, err := m.checkPATFromRequest(r, auth)\n+\t\t\trequest, err := m.checkPATFromRequest(r, authHeader)\n \t\t\tif err != nil {\n \t\t\t\tlog.WithContext(r.Context()).Debugf(\"Error when validating PAT: %s\", err.Error())\n \t\t\t\t// Check if it's a status error, otherwise default to Unauthorized\n@@ -100,8 +101,8 @@ func (m *AuthMiddleware) Handler(h http.Handler) http.Handler {\n }\n \n // CheckJWTFromRequest checks if the JWT is valid\n-func (m *AuthMiddleware) checkJWTFromRequest(r *http.Request, auth []string) (*http.Request, error) {\n-\ttoken, err := getTokenFromJWTRequest(auth)\n+func (m *AuthMiddleware) checkJWTFromRequest(r *http.Request, authHeaderParts []string) (*http.Request, error) {\n+\ttoken, err := getTokenFromJWTRequest(authHeaderParts)\n \n \t// If an error occurs, call the error handler and return an error\n \tif err != nil {\n@@ -151,8 +152,8 @@ func (m *AuthMiddleware) checkJWTFromRequest(r *http.Request, auth []string) (*h\n }\n \n // CheckPATFromRequest checks if the PAT is valid\n-func (m *AuthMiddleware) checkPATFromRequest(r *http.Request, auth []string) (*http.Request, error) {\n-\ttoken, err := getTokenFromPATRequest(auth)\n+func (m *AuthMiddleware) checkPATFromRequest(r *http.Request, authHeaderParts []string) (*http.Request, error) {\n+\ttoken, err := getTokenFromPATRequest(authHeaderParts)\n \tif err != nil {\n \t\treturn r, fmt.Errorf(\"error extracting token: %w\", err)\n \t}\n@@ -177,7 +178,7 @@ func (m *AuthMiddleware) checkPATFromRequest(r *http.Request, auth []string) (*h\n \t\treturn r, err\n \t}\n \n-\tuserAuth := nbcontext.UserAuth{\n+\tuserAuth := auth.UserAuth{\n \t\tUserId:         user.Id,\n \t\tAccountId:      user.AccountID,\n \t\tDomain:         accDomain,\ndiff --git a/management/server/mock_server/account_mock.go b/management/server/mock_server/account_mock.go\nindex 781d84f5f2c..0178e51f506 100644\n--- a/management/server/mock_server/account_mock.go\n+++ b/management/server/mock_server/account_mock.go\n@@ -2,6 +2,7 @@ package mock_server\n \n import (\n \t\"context\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n \t\"net\"\n \t\"net/netip\"\n \t\"time\"\n@@ -12,7 +13,6 @@ import (\n \tnbdns \"github.com/netbirdio/netbird/dns\"\n \t\"github.com/netbirdio/netbird/management/server/account\"\n \t\"github.com/netbirdio/netbird/management/server/activity\"\n-\tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/idp\"\n \tnbpeer \"github.com/netbirdio/netbird/management/server/peer\"\n \t\"github.com/netbirdio/netbird/management/server/peers/ephemeral\"\n@@ -34,7 +34,7 @@ type MockAccountManager struct {\n \tGetSetupKeyFunc                       func(ctx context.Context, accountID, userID, keyID string) (*types.SetupKey, error)\n \tAccountExistsFunc                     func(ctx context.Context, accountID string) (bool, error)\n \tGetAccountIDByUserIdFunc              func(ctx context.Context, userId, domain string) (string, error)\n-\tGetUserFromUserAuthFunc               func(ctx context.Context, userAuth nbcontext.UserAuth) (*types.User, error)\n+\tGetUserFromUserAuthFunc               func(ctx context.Context, userAuth auth.UserAuth) (*types.User, error)\n \tListUsersFunc                         func(ctx context.Context, accountID string) ([]*types.User, error)\n \tGetPeersFunc                          func(ctx context.Context, accountID, userID, nameFilter, ipFilter string) ([]*nbpeer.Peer, error)\n \tMarkPeerConnectedFunc                 func(ctx context.Context, peerKey string, connected bool, realIP net.IP) error\n@@ -84,7 +84,7 @@ type MockAccountManager struct {\n \tDeleteNameServerGroupFunc             func(ctx context.Context, accountID, nsGroupID, userID string) error\n \tListNameServerGroupsFunc              func(ctx context.Context, accountID string, userID string) ([]*nbdns.NameServerGroup, error)\n \tCreateUserFunc                        func(ctx context.Context, accountID, userID string, key *types.UserInfo) (*types.UserInfo, error)\n-\tGetAccountIDFromUserAuthFunc          func(ctx context.Context, userAuth nbcontext.UserAuth) (string, string, error)\n+\tGetAccountIDFromUserAuthFunc          func(ctx context.Context, userAuth auth.UserAuth) (string, string, error)\n \tDeleteAccountFunc                     func(ctx context.Context, accountID, userID string) error\n \tGetDNSDomainFunc                      func(settings *types.Settings) string\n \tStoreEventFunc                        func(ctx context.Context, initiatorID, targetID, accountID string, activityID activity.ActivityDescriber, meta map[string]any)\n@@ -119,7 +119,7 @@ type MockAccountManager struct {\n \tGetStoreFunc                          func() store.Store\n \tUpdateToPrimaryAccountFunc            func(ctx context.Context, accountId string) error\n \tGetOwnerInfoFunc                      func(ctx context.Context, accountID string) (*types.UserInfo, error)\n-\tGetCurrentUserInfoFunc                func(ctx context.Context, userAuth nbcontext.UserAuth) (*users.UserInfoWithPermissions, error)\n+\tGetCurrentUserInfoFunc                func(ctx context.Context, userAuth auth.UserAuth) (*users.UserInfoWithPermissions, error)\n \tGetAccountMetaFunc                    func(ctx context.Context, accountID, userID string) (*types.AccountMeta, error)\n \tGetAccountOnboardingFunc              func(ctx context.Context, accountID, userID string) (*types.AccountOnboarding, error)\n \tUpdateAccountOnboardingFunc           func(ctx context.Context, accountID, userID string, onboarding *types.AccountOnboarding) (*types.AccountOnboarding, error)\n@@ -470,7 +470,7 @@ func (am *MockAccountManager) UpdatePeerMeta(ctx context.Context, peerID string,\n }\n \n // GetUser mock implementation of GetUser from server.AccountManager interface\n-func (am *MockAccountManager) GetUserFromUserAuth(ctx context.Context, userAuth nbcontext.UserAuth) (*types.User, error) {\n+func (am *MockAccountManager) GetUserFromUserAuth(ctx context.Context, userAuth auth.UserAuth) (*types.User, error) {\n \tif am.GetUserFromUserAuthFunc != nil {\n \t\treturn am.GetUserFromUserAuthFunc(ctx, userAuth)\n \t}\n@@ -675,7 +675,7 @@ func (am *MockAccountManager) CreateUser(ctx context.Context, accountID, userID\n \treturn nil, status.Errorf(codes.Unimplemented, \"method CreateUser is not implemented\")\n }\n \n-func (am *MockAccountManager) GetAccountIDFromUserAuth(ctx context.Context, userAuth nbcontext.UserAuth) (string, string, error) {\n+func (am *MockAccountManager) GetAccountIDFromUserAuth(ctx context.Context, userAuth auth.UserAuth) (string, string, error) {\n \tif am.GetAccountIDFromUserAuthFunc != nil {\n \t\treturn am.GetAccountIDFromUserAuthFunc(ctx, userAuth)\n \t}\n@@ -937,7 +937,7 @@ func (am *MockAccountManager) BuildUserInfosForAccount(ctx context.Context, acco\n \treturn nil, status.Errorf(codes.Unimplemented, \"method BuildUserInfosForAccount is not implemented\")\n }\n \n-func (am *MockAccountManager) SyncUserJWTGroups(ctx context.Context, userAuth nbcontext.UserAuth) error {\n+func (am *MockAccountManager) SyncUserJWTGroups(ctx context.Context, userAuth auth.UserAuth) error {\n \treturn status.Errorf(codes.Unimplemented, \"method SyncUserJWTGroups is not implemented\")\n }\n \n@@ -969,7 +969,7 @@ func (am *MockAccountManager) GetOwnerInfo(ctx context.Context, accountId string\n \treturn nil, status.Errorf(codes.Unimplemented, \"method GetOwnerInfo is not implemented\")\n }\n \n-func (am *MockAccountManager) GetCurrentUserInfo(ctx context.Context, userAuth nbcontext.UserAuth) (*users.UserInfoWithPermissions, error) {\n+func (am *MockAccountManager) GetCurrentUserInfo(ctx context.Context, userAuth auth.UserAuth) (*users.UserInfoWithPermissions, error) {\n \tif am.GetCurrentUserInfoFunc != nil {\n \t\treturn am.GetCurrentUserInfoFunc(ctx, userAuth)\n \t}\ndiff --git a/management/server/networks/resources/types/resource.go b/management/server/networks/resources/types/resource.go\nindex 7874be85865..6b8cf94129c 100644\n--- a/management/server/networks/resources/types/resource.go\n+++ b/management/server/networks/resources/types/resource.go\n@@ -8,11 +8,11 @@ import (\n \n \t\"github.com/rs/xid\"\n \n-\tnbDomain \"github.com/netbirdio/netbird/shared/management/domain\"\n \trouterTypes \"github.com/netbirdio/netbird/management/server/networks/routers/types\"\n \tnetworkTypes \"github.com/netbirdio/netbird/management/server/networks/types\"\n \tnbpeer \"github.com/netbirdio/netbird/management/server/peer\"\n \t\"github.com/netbirdio/netbird/route\"\n+\tnbDomain \"github.com/netbirdio/netbird/shared/management/domain\"\n \n \t\"github.com/netbirdio/netbird/shared/management/http/api\"\n )\ndiff --git a/management/server/networks/routers/types/router.go b/management/server/networks/routers/types/router.go\nindex 72b15fd9a9a..e90c61a97e1 100644\n--- a/management/server/networks/routers/types/router.go\n+++ b/management/server/networks/routers/types/router.go\n@@ -5,8 +5,8 @@ import (\n \n \t\"github.com/rs/xid\"\n \n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/management/server/networks/types\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n )\n \n type NetworkRouter struct {\ndiff --git a/management/server/posture/checks.go b/management/server/posture/checks.go\nindex d65dc50456d..f0bbbc32e10 100644\n--- a/management/server/posture/checks.go\n+++ b/management/server/posture/checks.go\n@@ -7,8 +7,8 @@ import (\n \t\"regexp\"\n \n \t\"github.com/hashicorp/go-version\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \tnbpeer \"github.com/netbirdio/netbird/management/server/peer\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n \ndiff --git a/management/server/types/route_firewall_rule.go b/management/server/types/route_firewall_rule.go\nindex 6eb391cb5fd..da29e1d87f4 100644\n--- a/management/server/types/route_firewall_rule.go\n+++ b/management/server/types/route_firewall_rule.go\n@@ -1,8 +1,8 @@\n package types\n \n import (\n-\t\"github.com/netbirdio/netbird/shared/management/domain\"\n \t\"github.com/netbirdio/netbird/route\"\n+\t\"github.com/netbirdio/netbird/shared/management/domain\"\n )\n \n // RouteFirewallRule a firewall rule applicable for a routed network.\ndiff --git a/management/server/user.go b/management/server/user.go\nindex be4e491a809..6b8bcbcad41 100644\n--- a/management/server/user.go\n+++ b/management/server/user.go\n@@ -7,12 +7,13 @@ import (\n \t\"strings\"\n \t\"time\"\n \n+\tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n+\n \t\"github.com/google/uuid\"\n \tlog \"github.com/sirupsen/logrus\"\n \n \t\"github.com/netbirdio/netbird/management/server/activity\"\n-\tnbContext \"github.com/netbirdio/netbird/management/server/context\"\n-\tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/idp\"\n \tnbpeer \"github.com/netbirdio/netbird/management/server/peer\"\n \t\"github.com/netbirdio/netbird/management/server/permissions/modules\"\n@@ -175,9 +176,9 @@ func (am *DefaultAccountManager) GetUserByID(ctx context.Context, id string) (*t\n \treturn am.Store.GetUserByUserID(ctx, store.LockingStrengthNone, id)\n }\n \n-// GetUser looks up a user by provided nbContext.UserAuths.\n+// GetUser looks up a user by provided auth.UserAuths.\n // Expects account to have been created already.\n-func (am *DefaultAccountManager) GetUserFromUserAuth(ctx context.Context, userAuth nbContext.UserAuth) (*types.User, error) {\n+func (am *DefaultAccountManager) GetUserFromUserAuth(ctx context.Context, userAuth auth.UserAuth) (*types.User, error) {\n \tuser, err := am.Store.GetUserByUserID(ctx, store.LockingStrengthNone, userAuth.UserId)\n \tif err != nil {\n \t\treturn nil, err\n@@ -970,7 +971,7 @@ func (am *DefaultAccountManager) expireAndUpdatePeers(ctx context.Context, accou\n \tvar peerIDs []string\n \tfor _, peer := range peers {\n \t\t// nolint:staticcheck\n-\t\tctx = context.WithValue(ctx, nbContext.PeerIDKey, peer.Key)\n+\t\tctx = context.WithValue(ctx, nbcontext.PeerIDKey, peer.Key)\n \n \t\tif peer.UserID == \"\" {\n \t\t\t// we do not want to expire peers that are added via setup key\n@@ -1214,7 +1215,7 @@ func validateUserInvite(invite *types.UserInfo) error {\n }\n \n // GetCurrentUserInfo retrieves the account's current user info and permissions\n-func (am *DefaultAccountManager) GetCurrentUserInfo(ctx context.Context, userAuth nbcontext.UserAuth) (*users.UserInfoWithPermissions, error) {\n+func (am *DefaultAccountManager) GetCurrentUserInfo(ctx context.Context, userAuth auth.UserAuth) (*users.UserInfoWithPermissions, error) {\n \taccountID, userID := userAuth.AccountId, userAuth.UserId\n \n \tuser, err := am.Store.GetUserByUserID(ctx, store.LockingStrengthNone, userID)\ndiff --git a/relay/server/peer.go b/relay/server/peer.go\nindex c47f2e96038..c5ff41857e3 100644\n--- a/relay/server/peer.go\n+++ b/relay/server/peer.go\n@@ -9,10 +9,10 @@ import (\n \n \tlog \"github.com/sirupsen/logrus\"\n \n-\t\"github.com/netbirdio/netbird/shared/relay/healthcheck\"\n-\t\"github.com/netbirdio/netbird/shared/relay/messages\"\n \t\"github.com/netbirdio/netbird/relay/metrics\"\n \t\"github.com/netbirdio/netbird/relay/server/store\"\n+\t\"github.com/netbirdio/netbird/shared/relay/healthcheck\"\n+\t\"github.com/netbirdio/netbird/shared/relay/messages\"\n )\n \n const (\ndiff --git a/management/server/auth/jwt/extractor.go b/shared/auth/jwt/extractor.go\nsimilarity index 92%\nrename from management/server/auth/jwt/extractor.go\nrename to shared/auth/jwt/extractor.go\nindex d270d0ff173..a41d5f07a60 100644\n--- a/management/server/auth/jwt/extractor.go\n+++ b/shared/auth/jwt/extractor.go\n@@ -8,7 +8,7 @@ import (\n \t\"github.com/golang-jwt/jwt/v5\"\n \tlog \"github.com/sirupsen/logrus\"\n \n-\tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n )\n \n const (\n@@ -87,9 +87,10 @@ func (c ClaimsExtractor) audienceClaim(claimName string) string {\n \treturn url\n }\n \n-func (c *ClaimsExtractor) ToUserAuth(token *jwt.Token) (nbcontext.UserAuth, error) {\n+// ToUserAuth extracts user authentication information from a JWT token\n+func (c *ClaimsExtractor) ToUserAuth(token *jwt.Token) (auth.UserAuth, error) {\n \tclaims := token.Claims.(jwt.MapClaims)\n-\tuserAuth := nbcontext.UserAuth{}\n+\tuserAuth := auth.UserAuth{}\n \n \tuserID, ok := claims[c.userIDClaim].(string)\n \tif !ok {\n@@ -122,6 +123,7 @@ func (c *ClaimsExtractor) ToUserAuth(token *jwt.Token) (nbcontext.UserAuth, erro\n \treturn userAuth, nil\n }\n \n+// ToGroups extracts group information from a JWT token\n func (c *ClaimsExtractor) ToGroups(token *jwt.Token, claimName string) []string {\n \tclaims := token.Claims.(jwt.MapClaims)\n \tuserJWTGroups := make([]string, 0)\ndiff --git a/management/server/auth/jwt/validator.go b/shared/auth/jwt/validator.go\nsimilarity index 100%\nrename from management/server/auth/jwt/validator.go\nrename to shared/auth/jwt/validator.go\ndiff --git a/shared/auth/user.go b/shared/auth/user.go\nnew file mode 100644\nindex 00000000000..c1bae808e20\n--- /dev/null\n+++ b/shared/auth/user.go\n@@ -0,0 +1,28 @@\n+package auth\n+\n+import (\n+\t\"time\"\n+)\n+\n+type UserAuth struct {\n+\t// The account id the user is accessing\n+\tAccountId string\n+\t// The account domain\n+\tDomain string\n+\t// The account domain category, TBC values\n+\tDomainCategory string\n+\t// Indicates whether this user was invited, TBC logic\n+\tInvited bool\n+\t// Indicates whether this is a child account\n+\tIsChild bool\n+\n+\t// The user id\n+\tUserId string\n+\t// Last login time for this user\n+\tLastLogin time.Time\n+\t// The Groups the user belongs to on this account\n+\tGroups []string\n+\n+\t// Indicates whether this user has authenticated with a Personal Access Token\n+\tIsPAT bool\n+}\ndiff --git a/shared/context/keys.go b/shared/context/keys.go\nindex 5345ee214c4..c5b5da044e7 100644\n--- a/shared/context/keys.go\n+++ b/shared/context/keys.go\n@@ -5,4 +5,4 @@ const (\n \tAccountIDKey = \"accountID\"\n \tUserIDKey    = \"userID\"\n \tPeerIDKey    = \"peerID\"\n-)\n\\ No newline at end of file\n+)\ndiff --git a/shared/management/operations/operation.go b/shared/management/operations/operation.go\nindex b9b50036254..b1ba128154c 100644\n--- a/shared/management/operations/operation.go\n+++ b/shared/management/operations/operation.go\n@@ -1,4 +1,4 @@\n package operations\n \n // Operation represents a permission operation type\n-type Operation string\n\\ No newline at end of file\n+type Operation string\ndiff --git a/shared/management/proto/management.pb.go b/shared/management/proto/management.pb.go\nindex 0de00ec0c9c..ca12cf48cb7 100644\n--- a/shared/management/proto/management.pb.go\n+++ b/shared/management/proto/management.pb.go\n@@ -1,19 +1,18 @@\n // Code generated by protoc-gen-go. DO NOT EDIT.\n // versions:\n // \tprotoc-gen-go v1.26.0\n-// \tprotoc        v6.32.0\n+// \tprotoc        v6.32.1\n // source: management.proto\n \n package proto\n \n import (\n-\treflect \"reflect\"\n-\tsync \"sync\"\n-\n \tprotoreflect \"google.golang.org/protobuf/reflect/protoreflect\"\n \tprotoimpl \"google.golang.org/protobuf/runtime/protoimpl\"\n \tdurationpb \"google.golang.org/protobuf/types/known/durationpb\"\n \ttimestamppb \"google.golang.org/protobuf/types/known/timestamppb\"\n+\treflect \"reflect\"\n+\tsync \"sync\"\n )\n \n const (\n@@ -268,7 +267,7 @@ func (x DeviceAuthorizationFlowProvider) Number() protoreflect.EnumNumber {\n \n // Deprecated: Use DeviceAuthorizationFlowProvider.Descriptor instead.\n func (DeviceAuthorizationFlowProvider) EnumDescriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{23, 0}\n+\treturn file_management_proto_rawDescGZIP(), []int{24, 0}\n }\n \n type EncryptedMessage struct {\n@@ -799,16 +798,21 @@ type Flags struct {\n \tsizeCache     protoimpl.SizeCache\n \tunknownFields protoimpl.UnknownFields\n \n-\tRosenpassEnabled      bool `protobuf:\"varint,1,opt,name=rosenpassEnabled,proto3\" json:\"rosenpassEnabled,omitempty\"`\n-\tRosenpassPermissive   bool `protobuf:\"varint,2,opt,name=rosenpassPermissive,proto3\" json:\"rosenpassPermissive,omitempty\"`\n-\tServerSSHAllowed      bool `protobuf:\"varint,3,opt,name=serverSSHAllowed,proto3\" json:\"serverSSHAllowed,omitempty\"`\n-\tDisableClientRoutes   bool `protobuf:\"varint,4,opt,name=disableClientRoutes,proto3\" json:\"disableClientRoutes,omitempty\"`\n-\tDisableServerRoutes   bool `protobuf:\"varint,5,opt,name=disableServerRoutes,proto3\" json:\"disableServerRoutes,omitempty\"`\n-\tDisableDNS            bool `protobuf:\"varint,6,opt,name=disableDNS,proto3\" json:\"disableDNS,omitempty\"`\n-\tDisableFirewall       bool `protobuf:\"varint,7,opt,name=disableFirewall,proto3\" json:\"disableFirewall,omitempty\"`\n-\tBlockLANAccess        bool `protobuf:\"varint,8,opt,name=blockLANAccess,proto3\" json:\"blockLANAccess,omitempty\"`\n-\tBlockInbound          bool `protobuf:\"varint,9,opt,name=blockInbound,proto3\" json:\"blockInbound,omitempty\"`\n-\tLazyConnectionEnabled bool `protobuf:\"varint,10,opt,name=lazyConnectionEnabled,proto3\" json:\"lazyConnectionEnabled,omitempty\"`\n+\tRosenpassEnabled              bool `protobuf:\"varint,1,opt,name=rosenpassEnabled,proto3\" json:\"rosenpassEnabled,omitempty\"`\n+\tRosenpassPermissive           bool `protobuf:\"varint,2,opt,name=rosenpassPermissive,proto3\" json:\"rosenpassPermissive,omitempty\"`\n+\tServerSSHAllowed              bool `protobuf:\"varint,3,opt,name=serverSSHAllowed,proto3\" json:\"serverSSHAllowed,omitempty\"`\n+\tDisableClientRoutes           bool `protobuf:\"varint,4,opt,name=disableClientRoutes,proto3\" json:\"disableClientRoutes,omitempty\"`\n+\tDisableServerRoutes           bool `protobuf:\"varint,5,opt,name=disableServerRoutes,proto3\" json:\"disableServerRoutes,omitempty\"`\n+\tDisableDNS                    bool `protobuf:\"varint,6,opt,name=disableDNS,proto3\" json:\"disableDNS,omitempty\"`\n+\tDisableFirewall               bool `protobuf:\"varint,7,opt,name=disableFirewall,proto3\" json:\"disableFirewall,omitempty\"`\n+\tBlockLANAccess                bool `protobuf:\"varint,8,opt,name=blockLANAccess,proto3\" json:\"blockLANAccess,omitempty\"`\n+\tBlockInbound                  bool `protobuf:\"varint,9,opt,name=blockInbound,proto3\" json:\"blockInbound,omitempty\"`\n+\tLazyConnectionEnabled         bool `protobuf:\"varint,10,opt,name=lazyConnectionEnabled,proto3\" json:\"lazyConnectionEnabled,omitempty\"`\n+\tEnableSSHRoot                 bool `protobuf:\"varint,11,opt,name=enableSSHRoot,proto3\" json:\"enableSSHRoot,omitempty\"`\n+\tEnableSSHSFTP                 bool `protobuf:\"varint,12,opt,name=enableSSHSFTP,proto3\" json:\"enableSSHSFTP,omitempty\"`\n+\tEnableSSHLocalPortForwarding  bool `protobuf:\"varint,13,opt,name=enableSSHLocalPortForwarding,proto3\" json:\"enableSSHLocalPortForwarding,omitempty\"`\n+\tEnableSSHRemotePortForwarding bool `protobuf:\"varint,14,opt,name=enableSSHRemotePortForwarding,proto3\" json:\"enableSSHRemotePortForwarding,omitempty\"`\n+\tDisableSSHAuth                bool `protobuf:\"varint,15,opt,name=disableSSHAuth,proto3\" json:\"disableSSHAuth,omitempty\"`\n }\n \n func (x *Flags) Reset() {\n@@ -913,6 +917,41 @@ func (x *Flags) GetLazyConnectionEnabled() bool {\n \treturn false\n }\n \n+func (x *Flags) GetEnableSSHRoot() bool {\n+\tif x != nil {\n+\t\treturn x.EnableSSHRoot\n+\t}\n+\treturn false\n+}\n+\n+func (x *Flags) GetEnableSSHSFTP() bool {\n+\tif x != nil {\n+\t\treturn x.EnableSSHSFTP\n+\t}\n+\treturn false\n+}\n+\n+func (x *Flags) GetEnableSSHLocalPortForwarding() bool {\n+\tif x != nil {\n+\t\treturn x.EnableSSHLocalPortForwarding\n+\t}\n+\treturn false\n+}\n+\n+func (x *Flags) GetEnableSSHRemotePortForwarding() bool {\n+\tif x != nil {\n+\t\treturn x.EnableSSHRemotePortForwarding\n+\t}\n+\treturn false\n+}\n+\n+func (x *Flags) GetDisableSSHAuth() bool {\n+\tif x != nil {\n+\t\treturn x.DisableSSHAuth\n+\t}\n+\treturn false\n+}\n+\n // PeerSystemMeta is machine meta data like OS and version.\n type PeerSystemMeta struct {\n \tstate         protoimpl.MessageState\n@@ -1273,6 +1312,7 @@ type NetbirdConfig struct {\n \tSignal *HostConfig  `protobuf:\"bytes,3,opt,name=signal,proto3\" json:\"signal,omitempty\"`\n \tRelay  *RelayConfig `protobuf:\"bytes,4,opt,name=relay,proto3\" json:\"relay,omitempty\"`\n \tFlow   *FlowConfig  `protobuf:\"bytes,5,opt,name=flow,proto3\" json:\"flow,omitempty\"`\n+\tJwt    *JWTConfig   `protobuf:\"bytes,6,opt,name=jwt,proto3\" json:\"jwt,omitempty\"`\n }\n \n func (x *NetbirdConfig) Reset() {\n@@ -1342,6 +1382,13 @@ func (x *NetbirdConfig) GetFlow() *FlowConfig {\n \treturn nil\n }\n \n+func (x *NetbirdConfig) GetJwt() *JWTConfig {\n+\tif x != nil {\n+\t\treturn x.Jwt\n+\t}\n+\treturn nil\n+}\n+\n // HostConfig describes connection properties of some server (e.g. STUN, Signal, Management)\n type HostConfig struct {\n \tstate         protoimpl.MessageState\n@@ -1568,6 +1615,78 @@ func (x *FlowConfig) GetDnsCollection() bool {\n \treturn false\n }\n \n+// JWTConfig represents JWT authentication configuration\n+type JWTConfig struct {\n+\tstate         protoimpl.MessageState\n+\tsizeCache     protoimpl.SizeCache\n+\tunknownFields protoimpl.UnknownFields\n+\n+\tIssuer       string `protobuf:\"bytes,1,opt,name=issuer,proto3\" json:\"issuer,omitempty\"`\n+\tAudience     string `protobuf:\"bytes,2,opt,name=audience,proto3\" json:\"audience,omitempty\"`\n+\tKeysLocation string `protobuf:\"bytes,3,opt,name=keysLocation,proto3\" json:\"keysLocation,omitempty\"`\n+\tMaxTokenAge  int64  `protobuf:\"varint,4,opt,name=maxTokenAge,proto3\" json:\"maxTokenAge,omitempty\"`\n+}\n+\n+func (x *JWTConfig) Reset() {\n+\t*x = JWTConfig{}\n+\tif protoimpl.UnsafeEnabled {\n+\t\tmi := &file_management_proto_msgTypes[17]\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tms.StoreMessageInfo(mi)\n+\t}\n+}\n+\n+func (x *JWTConfig) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*JWTConfig) ProtoMessage() {}\n+\n+func (x *JWTConfig) ProtoReflect() protoreflect.Message {\n+\tmi := &file_management_proto_msgTypes[17]\n+\tif protoimpl.UnsafeEnabled && x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use JWTConfig.ProtoReflect.Descriptor instead.\n+func (*JWTConfig) Descriptor() ([]byte, []int) {\n+\treturn file_management_proto_rawDescGZIP(), []int{17}\n+}\n+\n+func (x *JWTConfig) GetIssuer() string {\n+\tif x != nil {\n+\t\treturn x.Issuer\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *JWTConfig) GetAudience() string {\n+\tif x != nil {\n+\t\treturn x.Audience\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *JWTConfig) GetKeysLocation() string {\n+\tif x != nil {\n+\t\treturn x.KeysLocation\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *JWTConfig) GetMaxTokenAge() int64 {\n+\tif x != nil {\n+\t\treturn x.MaxTokenAge\n+\t}\n+\treturn 0\n+}\n+\n // ProtectedHostConfig is similar to HostConfig but has additional user and password\n // Mostly used for TURN servers\n type ProtectedHostConfig struct {\n@@ -1583,7 +1702,7 @@ type ProtectedHostConfig struct {\n func (x *ProtectedHostConfig) Reset() {\n \t*x = ProtectedHostConfig{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[17]\n+\t\tmi := &file_management_proto_msgTypes[18]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -1596,7 +1715,7 @@ func (x *ProtectedHostConfig) String() string {\n func (*ProtectedHostConfig) ProtoMessage() {}\n \n func (x *ProtectedHostConfig) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[17]\n+\tmi := &file_management_proto_msgTypes[18]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -1609,7 +1728,7 @@ func (x *ProtectedHostConfig) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use ProtectedHostConfig.ProtoReflect.Descriptor instead.\n func (*ProtectedHostConfig) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{17}\n+\treturn file_management_proto_rawDescGZIP(), []int{18}\n }\n \n func (x *ProtectedHostConfig) GetHostConfig() *HostConfig {\n@@ -1656,7 +1775,7 @@ type PeerConfig struct {\n func (x *PeerConfig) Reset() {\n \t*x = PeerConfig{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[18]\n+\t\tmi := &file_management_proto_msgTypes[19]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -1669,7 +1788,7 @@ func (x *PeerConfig) String() string {\n func (*PeerConfig) ProtoMessage() {}\n \n func (x *PeerConfig) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[18]\n+\tmi := &file_management_proto_msgTypes[19]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -1682,7 +1801,7 @@ func (x *PeerConfig) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use PeerConfig.ProtoReflect.Descriptor instead.\n func (*PeerConfig) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{18}\n+\treturn file_management_proto_rawDescGZIP(), []int{19}\n }\n \n func (x *PeerConfig) GetAddress() string {\n@@ -1770,7 +1889,7 @@ type NetworkMap struct {\n func (x *NetworkMap) Reset() {\n \t*x = NetworkMap{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[19]\n+\t\tmi := &file_management_proto_msgTypes[20]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -1783,7 +1902,7 @@ func (x *NetworkMap) String() string {\n func (*NetworkMap) ProtoMessage() {}\n \n func (x *NetworkMap) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[19]\n+\tmi := &file_management_proto_msgTypes[20]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -1796,7 +1915,7 @@ func (x *NetworkMap) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use NetworkMap.ProtoReflect.Descriptor instead.\n func (*NetworkMap) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{19}\n+\treturn file_management_proto_rawDescGZIP(), []int{20}\n }\n \n func (x *NetworkMap) GetSerial() uint64 {\n@@ -1904,7 +2023,7 @@ type RemotePeerConfig struct {\n func (x *RemotePeerConfig) Reset() {\n \t*x = RemotePeerConfig{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[20]\n+\t\tmi := &file_management_proto_msgTypes[21]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -1917,7 +2036,7 @@ func (x *RemotePeerConfig) String() string {\n func (*RemotePeerConfig) ProtoMessage() {}\n \n func (x *RemotePeerConfig) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[20]\n+\tmi := &file_management_proto_msgTypes[21]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -1930,7 +2049,7 @@ func (x *RemotePeerConfig) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use RemotePeerConfig.ProtoReflect.Descriptor instead.\n func (*RemotePeerConfig) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{20}\n+\treturn file_management_proto_rawDescGZIP(), []int{21}\n }\n \n func (x *RemotePeerConfig) GetWgPubKey() string {\n@@ -1978,13 +2097,14 @@ type SSHConfig struct {\n \tSshEnabled bool `protobuf:\"varint,1,opt,name=sshEnabled,proto3\" json:\"sshEnabled,omitempty\"`\n \t// sshPubKey is a SSH public key of a peer to be added to authorized_hosts.\n \t// This property should be ignore if SSHConfig comes from PeerConfig.\n-\tSshPubKey []byte `protobuf:\"bytes,2,opt,name=sshPubKey,proto3\" json:\"sshPubKey,omitempty\"`\n+\tSshPubKey []byte     `protobuf:\"bytes,2,opt,name=sshPubKey,proto3\" json:\"sshPubKey,omitempty\"`\n+\tJwtConfig *JWTConfig `protobuf:\"bytes,3,opt,name=jwtConfig,proto3\" json:\"jwtConfig,omitempty\"`\n }\n \n func (x *SSHConfig) Reset() {\n \t*x = SSHConfig{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[21]\n+\t\tmi := &file_management_proto_msgTypes[22]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -1997,7 +2117,7 @@ func (x *SSHConfig) String() string {\n func (*SSHConfig) ProtoMessage() {}\n \n func (x *SSHConfig) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[21]\n+\tmi := &file_management_proto_msgTypes[22]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2010,7 +2130,7 @@ func (x *SSHConfig) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SSHConfig.ProtoReflect.Descriptor instead.\n func (*SSHConfig) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{21}\n+\treturn file_management_proto_rawDescGZIP(), []int{22}\n }\n \n func (x *SSHConfig) GetSshEnabled() bool {\n@@ -2027,6 +2147,13 @@ func (x *SSHConfig) GetSshPubKey() []byte {\n \treturn nil\n }\n \n+func (x *SSHConfig) GetJwtConfig() *JWTConfig {\n+\tif x != nil {\n+\t\treturn x.JwtConfig\n+\t}\n+\treturn nil\n+}\n+\n // DeviceAuthorizationFlowRequest empty struct for future expansion\n type DeviceAuthorizationFlowRequest struct {\n \tstate         protoimpl.MessageState\n@@ -2037,7 +2164,7 @@ type DeviceAuthorizationFlowRequest struct {\n func (x *DeviceAuthorizationFlowRequest) Reset() {\n \t*x = DeviceAuthorizationFlowRequest{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[22]\n+\t\tmi := &file_management_proto_msgTypes[23]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2050,7 +2177,7 @@ func (x *DeviceAuthorizationFlowRequest) String() string {\n func (*DeviceAuthorizationFlowRequest) ProtoMessage() {}\n \n func (x *DeviceAuthorizationFlowRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[22]\n+\tmi := &file_management_proto_msgTypes[23]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2063,7 +2190,7 @@ func (x *DeviceAuthorizationFlowRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use DeviceAuthorizationFlowRequest.ProtoReflect.Descriptor instead.\n func (*DeviceAuthorizationFlowRequest) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{22}\n+\treturn file_management_proto_rawDescGZIP(), []int{23}\n }\n \n // DeviceAuthorizationFlow represents Device Authorization Flow information\n@@ -2082,7 +2209,7 @@ type DeviceAuthorizationFlow struct {\n func (x *DeviceAuthorizationFlow) Reset() {\n \t*x = DeviceAuthorizationFlow{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[23]\n+\t\tmi := &file_management_proto_msgTypes[24]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2095,7 +2222,7 @@ func (x *DeviceAuthorizationFlow) String() string {\n func (*DeviceAuthorizationFlow) ProtoMessage() {}\n \n func (x *DeviceAuthorizationFlow) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[23]\n+\tmi := &file_management_proto_msgTypes[24]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2108,7 +2235,7 @@ func (x *DeviceAuthorizationFlow) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use DeviceAuthorizationFlow.ProtoReflect.Descriptor instead.\n func (*DeviceAuthorizationFlow) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{23}\n+\treturn file_management_proto_rawDescGZIP(), []int{24}\n }\n \n func (x *DeviceAuthorizationFlow) GetProvider() DeviceAuthorizationFlowProvider {\n@@ -2135,7 +2262,7 @@ type PKCEAuthorizationFlowRequest struct {\n func (x *PKCEAuthorizationFlowRequest) Reset() {\n \t*x = PKCEAuthorizationFlowRequest{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[24]\n+\t\tmi := &file_management_proto_msgTypes[25]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2148,7 +2275,7 @@ func (x *PKCEAuthorizationFlowRequest) String() string {\n func (*PKCEAuthorizationFlowRequest) ProtoMessage() {}\n \n func (x *PKCEAuthorizationFlowRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[24]\n+\tmi := &file_management_proto_msgTypes[25]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2161,7 +2288,7 @@ func (x *PKCEAuthorizationFlowRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use PKCEAuthorizationFlowRequest.ProtoReflect.Descriptor instead.\n func (*PKCEAuthorizationFlowRequest) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{24}\n+\treturn file_management_proto_rawDescGZIP(), []int{25}\n }\n \n // PKCEAuthorizationFlow represents Authorization Code Flow information\n@@ -2178,7 +2305,7 @@ type PKCEAuthorizationFlow struct {\n func (x *PKCEAuthorizationFlow) Reset() {\n \t*x = PKCEAuthorizationFlow{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[25]\n+\t\tmi := &file_management_proto_msgTypes[26]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2191,7 +2318,7 @@ func (x *PKCEAuthorizationFlow) String() string {\n func (*PKCEAuthorizationFlow) ProtoMessage() {}\n \n func (x *PKCEAuthorizationFlow) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[25]\n+\tmi := &file_management_proto_msgTypes[26]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2204,7 +2331,7 @@ func (x *PKCEAuthorizationFlow) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use PKCEAuthorizationFlow.ProtoReflect.Descriptor instead.\n func (*PKCEAuthorizationFlow) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{25}\n+\treturn file_management_proto_rawDescGZIP(), []int{26}\n }\n \n func (x *PKCEAuthorizationFlow) GetProviderConfig() *ProviderConfig {\n@@ -2250,7 +2377,7 @@ type ProviderConfig struct {\n func (x *ProviderConfig) Reset() {\n \t*x = ProviderConfig{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[26]\n+\t\tmi := &file_management_proto_msgTypes[27]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2263,7 +2390,7 @@ func (x *ProviderConfig) String() string {\n func (*ProviderConfig) ProtoMessage() {}\n \n func (x *ProviderConfig) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[26]\n+\tmi := &file_management_proto_msgTypes[27]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2276,7 +2403,7 @@ func (x *ProviderConfig) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use ProviderConfig.ProtoReflect.Descriptor instead.\n func (*ProviderConfig) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{26}\n+\treturn file_management_proto_rawDescGZIP(), []int{27}\n }\n \n func (x *ProviderConfig) GetClientID() string {\n@@ -2384,7 +2511,7 @@ type Route struct {\n func (x *Route) Reset() {\n \t*x = Route{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[27]\n+\t\tmi := &file_management_proto_msgTypes[28]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2397,7 +2524,7 @@ func (x *Route) String() string {\n func (*Route) ProtoMessage() {}\n \n func (x *Route) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[27]\n+\tmi := &file_management_proto_msgTypes[28]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2410,7 +2537,7 @@ func (x *Route) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use Route.ProtoReflect.Descriptor instead.\n func (*Route) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{27}\n+\treturn file_management_proto_rawDescGZIP(), []int{28}\n }\n \n func (x *Route) GetID() string {\n@@ -2498,7 +2625,7 @@ type DNSConfig struct {\n func (x *DNSConfig) Reset() {\n \t*x = DNSConfig{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[28]\n+\t\tmi := &file_management_proto_msgTypes[29]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2511,7 +2638,7 @@ func (x *DNSConfig) String() string {\n func (*DNSConfig) ProtoMessage() {}\n \n func (x *DNSConfig) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[28]\n+\tmi := &file_management_proto_msgTypes[29]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2524,7 +2651,7 @@ func (x *DNSConfig) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use DNSConfig.ProtoReflect.Descriptor instead.\n func (*DNSConfig) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{28}\n+\treturn file_management_proto_rawDescGZIP(), []int{29}\n }\n \n func (x *DNSConfig) GetServiceEnable() bool {\n@@ -2568,7 +2695,7 @@ type CustomZone struct {\n func (x *CustomZone) Reset() {\n \t*x = CustomZone{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[29]\n+\t\tmi := &file_management_proto_msgTypes[30]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2581,7 +2708,7 @@ func (x *CustomZone) String() string {\n func (*CustomZone) ProtoMessage() {}\n \n func (x *CustomZone) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[29]\n+\tmi := &file_management_proto_msgTypes[30]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2594,7 +2721,7 @@ func (x *CustomZone) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use CustomZone.ProtoReflect.Descriptor instead.\n func (*CustomZone) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{29}\n+\treturn file_management_proto_rawDescGZIP(), []int{30}\n }\n \n func (x *CustomZone) GetDomain() string {\n@@ -2627,7 +2754,7 @@ type SimpleRecord struct {\n func (x *SimpleRecord) Reset() {\n \t*x = SimpleRecord{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[30]\n+\t\tmi := &file_management_proto_msgTypes[31]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2640,7 +2767,7 @@ func (x *SimpleRecord) String() string {\n func (*SimpleRecord) ProtoMessage() {}\n \n func (x *SimpleRecord) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[30]\n+\tmi := &file_management_proto_msgTypes[31]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2653,7 +2780,7 @@ func (x *SimpleRecord) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SimpleRecord.ProtoReflect.Descriptor instead.\n func (*SimpleRecord) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{30}\n+\treturn file_management_proto_rawDescGZIP(), []int{31}\n }\n \n func (x *SimpleRecord) GetName() string {\n@@ -2706,7 +2833,7 @@ type NameServerGroup struct {\n func (x *NameServerGroup) Reset() {\n \t*x = NameServerGroup{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[31]\n+\t\tmi := &file_management_proto_msgTypes[32]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2719,7 +2846,7 @@ func (x *NameServerGroup) String() string {\n func (*NameServerGroup) ProtoMessage() {}\n \n func (x *NameServerGroup) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[31]\n+\tmi := &file_management_proto_msgTypes[32]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2732,7 +2859,7 @@ func (x *NameServerGroup) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use NameServerGroup.ProtoReflect.Descriptor instead.\n func (*NameServerGroup) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{31}\n+\treturn file_management_proto_rawDescGZIP(), []int{32}\n }\n \n func (x *NameServerGroup) GetNameServers() []*NameServer {\n@@ -2777,7 +2904,7 @@ type NameServer struct {\n func (x *NameServer) Reset() {\n \t*x = NameServer{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[32]\n+\t\tmi := &file_management_proto_msgTypes[33]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2790,7 +2917,7 @@ func (x *NameServer) String() string {\n func (*NameServer) ProtoMessage() {}\n \n func (x *NameServer) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[32]\n+\tmi := &file_management_proto_msgTypes[33]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2803,7 +2930,7 @@ func (x *NameServer) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use NameServer.ProtoReflect.Descriptor instead.\n func (*NameServer) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{32}\n+\treturn file_management_proto_rawDescGZIP(), []int{33}\n }\n \n func (x *NameServer) GetIP() string {\n@@ -2846,7 +2973,7 @@ type FirewallRule struct {\n func (x *FirewallRule) Reset() {\n \t*x = FirewallRule{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[33]\n+\t\tmi := &file_management_proto_msgTypes[34]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2859,7 +2986,7 @@ func (x *FirewallRule) String() string {\n func (*FirewallRule) ProtoMessage() {}\n \n func (x *FirewallRule) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[33]\n+\tmi := &file_management_proto_msgTypes[34]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2872,7 +2999,7 @@ func (x *FirewallRule) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use FirewallRule.ProtoReflect.Descriptor instead.\n func (*FirewallRule) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{33}\n+\treturn file_management_proto_rawDescGZIP(), []int{34}\n }\n \n func (x *FirewallRule) GetPeerIP() string {\n@@ -2936,7 +3063,7 @@ type NetworkAddress struct {\n func (x *NetworkAddress) Reset() {\n \t*x = NetworkAddress{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[34]\n+\t\tmi := &file_management_proto_msgTypes[35]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2949,7 +3076,7 @@ func (x *NetworkAddress) String() string {\n func (*NetworkAddress) ProtoMessage() {}\n \n func (x *NetworkAddress) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[34]\n+\tmi := &file_management_proto_msgTypes[35]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2962,7 +3089,7 @@ func (x *NetworkAddress) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use NetworkAddress.ProtoReflect.Descriptor instead.\n func (*NetworkAddress) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{34}\n+\treturn file_management_proto_rawDescGZIP(), []int{35}\n }\n \n func (x *NetworkAddress) GetNetIP() string {\n@@ -2990,7 +3117,7 @@ type Checks struct {\n func (x *Checks) Reset() {\n \t*x = Checks{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[35]\n+\t\tmi := &file_management_proto_msgTypes[36]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -3003,7 +3130,7 @@ func (x *Checks) String() string {\n func (*Checks) ProtoMessage() {}\n \n func (x *Checks) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[35]\n+\tmi := &file_management_proto_msgTypes[36]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3016,7 +3143,7 @@ func (x *Checks) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use Checks.ProtoReflect.Descriptor instead.\n func (*Checks) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{35}\n+\treturn file_management_proto_rawDescGZIP(), []int{36}\n }\n \n func (x *Checks) GetFiles() []string {\n@@ -3041,7 +3168,7 @@ type PortInfo struct {\n func (x *PortInfo) Reset() {\n \t*x = PortInfo{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[36]\n+\t\tmi := &file_management_proto_msgTypes[37]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -3054,7 +3181,7 @@ func (x *PortInfo) String() string {\n func (*PortInfo) ProtoMessage() {}\n \n func (x *PortInfo) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[36]\n+\tmi := &file_management_proto_msgTypes[37]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3067,7 +3194,7 @@ func (x *PortInfo) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use PortInfo.ProtoReflect.Descriptor instead.\n func (*PortInfo) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{36}\n+\treturn file_management_proto_rawDescGZIP(), []int{37}\n }\n \n func (m *PortInfo) GetPortSelection() isPortInfo_PortSelection {\n@@ -3138,7 +3265,7 @@ type RouteFirewallRule struct {\n func (x *RouteFirewallRule) Reset() {\n \t*x = RouteFirewallRule{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[37]\n+\t\tmi := &file_management_proto_msgTypes[38]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -3151,7 +3278,7 @@ func (x *RouteFirewallRule) String() string {\n func (*RouteFirewallRule) ProtoMessage() {}\n \n func (x *RouteFirewallRule) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[37]\n+\tmi := &file_management_proto_msgTypes[38]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3164,7 +3291,7 @@ func (x *RouteFirewallRule) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use RouteFirewallRule.ProtoReflect.Descriptor instead.\n func (*RouteFirewallRule) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{37}\n+\treturn file_management_proto_rawDescGZIP(), []int{38}\n }\n \n func (x *RouteFirewallRule) GetSourceRanges() []string {\n@@ -3255,7 +3382,7 @@ type ForwardingRule struct {\n func (x *ForwardingRule) Reset() {\n \t*x = ForwardingRule{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[38]\n+\t\tmi := &file_management_proto_msgTypes[39]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -3268,7 +3395,7 @@ func (x *ForwardingRule) String() string {\n func (*ForwardingRule) ProtoMessage() {}\n \n func (x *ForwardingRule) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[38]\n+\tmi := &file_management_proto_msgTypes[39]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3281,7 +3408,7 @@ func (x *ForwardingRule) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use ForwardingRule.ProtoReflect.Descriptor instead.\n func (*ForwardingRule) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{38}\n+\treturn file_management_proto_rawDescGZIP(), []int{39}\n }\n \n func (x *ForwardingRule) GetProtocol() RuleProtocol {\n@@ -3324,7 +3451,7 @@ type PortInfo_Range struct {\n func (x *PortInfo_Range) Reset() {\n \t*x = PortInfo_Range{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[39]\n+\t\tmi := &file_management_proto_msgTypes[40]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -3337,7 +3464,7 @@ func (x *PortInfo_Range) String() string {\n func (*PortInfo_Range) ProtoMessage() {}\n \n func (x *PortInfo_Range) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[39]\n+\tmi := &file_management_proto_msgTypes[40]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3350,7 +3477,7 @@ func (x *PortInfo_Range) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use PortInfo_Range.ProtoReflect.Descriptor instead.\n func (*PortInfo_Range) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{36, 0}\n+\treturn file_management_proto_rawDescGZIP(), []int{37, 0}\n }\n \n func (x *PortInfo_Range) GetStart() uint32 {\n@@ -3438,7 +3565,7 @@ var file_management_proto_rawDesc = []byte{\n \t0x73, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x05, 0x65, 0x78, 0x69, 0x73, 0x74, 0x12,\n \t0x2a, 0x0a, 0x10, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x49, 0x73, 0x52, 0x75, 0x6e, 0x6e,\n \t0x69, 0x6e, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x10, 0x70, 0x72, 0x6f, 0x63, 0x65,\n-\t0x73, 0x73, 0x49, 0x73, 0x52, 0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x22, 0xc1, 0x03, 0x0a, 0x05,\n+\t0x73, 0x73, 0x49, 0x73, 0x52, 0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x22, 0xbf, 0x05, 0x0a, 0x05,\n \t0x46, 0x6c, 0x61, 0x67, 0x73, 0x12, 0x2a, 0x0a, 0x10, 0x72, 0x6f, 0x73, 0x65, 0x6e, 0x70, 0x61,\n \t0x73, 0x73, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52,\n \t0x10, 0x72, 0x6f, 0x73, 0x65, 0x6e, 0x70, 0x61, 0x73, 0x73, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65,\n@@ -3466,435 +3593,465 @@ var file_management_proto_rawDesc = []byte{\n \t0x63, 0x6b, 0x49, 0x6e, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x12, 0x34, 0x0a, 0x15, 0x6c, 0x61, 0x7a,\n \t0x79, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c,\n \t0x65, 0x64, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x08, 0x52, 0x15, 0x6c, 0x61, 0x7a, 0x79, 0x43, 0x6f,\n-\t0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x22,\n-\t0xf2, 0x04, 0x0a, 0x0e, 0x50, 0x65, 0x65, 0x72, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x4d, 0x65,\n-\t0x74, 0x61, 0x12, 0x1a, 0x0a, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01,\n-\t0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x12,\n-\t0x0a, 0x04, 0x67, 0x6f, 0x4f, 0x53, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x67, 0x6f,\n-\t0x4f, 0x53, 0x12, 0x16, 0x0a, 0x06, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x18, 0x03, 0x20, 0x01,\n-\t0x28, 0x09, 0x52, 0x06, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x12, 0x12, 0x0a, 0x04, 0x63, 0x6f,\n-\t0x72, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x63, 0x6f, 0x72, 0x65, 0x12, 0x1a,\n-\t0x0a, 0x08, 0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09,\n-\t0x52, 0x08, 0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x12, 0x0e, 0x0a, 0x02, 0x4f, 0x53,\n-\t0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x4f, 0x53, 0x12, 0x26, 0x0a, 0x0e, 0x6e, 0x65,\n-\t0x74, 0x62, 0x69, 0x72, 0x64, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x07, 0x20, 0x01,\n-\t0x28, 0x09, 0x52, 0x0e, 0x6e, 0x65, 0x74, 0x62, 0x69, 0x72, 0x64, 0x56, 0x65, 0x72, 0x73, 0x69,\n-\t0x6f, 0x6e, 0x12, 0x1c, 0x0a, 0x09, 0x75, 0x69, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18,\n-\t0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x75, 0x69, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,\n-\t0x12, 0x24, 0x0a, 0x0d, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f,\n-\t0x6e, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x56,\n-\t0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x1c, 0x0a, 0x09, 0x4f, 0x53, 0x56, 0x65, 0x72, 0x73,\n-\t0x69, 0x6f, 0x6e, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x4f, 0x53, 0x56, 0x65, 0x72,\n-\t0x73, 0x69, 0x6f, 0x6e, 0x12, 0x46, 0x0a, 0x10, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x41,\n-\t0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x18, 0x0b, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a,\n-\t0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4e, 0x65, 0x74, 0x77,\n-\t0x6f, 0x72, 0x6b, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x10, 0x6e, 0x65, 0x74, 0x77,\n-\t0x6f, 0x72, 0x6b, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x12, 0x28, 0x0a, 0x0f,\n-\t0x73, 0x79, 0x73, 0x53, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18,\n-\t0x0c, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x73, 0x79, 0x73, 0x53, 0x65, 0x72, 0x69, 0x61, 0x6c,\n-\t0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x12, 0x26, 0x0a, 0x0e, 0x73, 0x79, 0x73, 0x50, 0x72, 0x6f,\n-\t0x64, 0x75, 0x63, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e,\n-\t0x73, 0x79, 0x73, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x28,\n-\t0x0a, 0x0f, 0x73, 0x79, 0x73, 0x4d, 0x61, 0x6e, 0x75, 0x66, 0x61, 0x63, 0x74, 0x75, 0x72, 0x65,\n-\t0x72, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x73, 0x79, 0x73, 0x4d, 0x61, 0x6e, 0x75,\n-\t0x66, 0x61, 0x63, 0x74, 0x75, 0x72, 0x65, 0x72, 0x12, 0x39, 0x0a, 0x0b, 0x65, 0x6e, 0x76, 0x69,\n-\t0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e,\n-\t0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x76, 0x69, 0x72,\n-\t0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x52, 0x0b, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d,\n-\t0x65, 0x6e, 0x74, 0x12, 0x26, 0x0a, 0x05, 0x66, 0x69, 0x6c, 0x65, 0x73, 0x18, 0x10, 0x20, 0x03,\n-\t0x28, 0x0b, 0x32, 0x10, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e,\n-\t0x46, 0x69, 0x6c, 0x65, 0x52, 0x05, 0x66, 0x69, 0x6c, 0x65, 0x73, 0x12, 0x27, 0x0a, 0x05, 0x66,\n-\t0x6c, 0x61, 0x67, 0x73, 0x18, 0x11, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x61, 0x6e,\n-\t0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x46, 0x6c, 0x61, 0x67, 0x73, 0x52, 0x05, 0x66,\n-\t0x6c, 0x61, 0x67, 0x73, 0x22, 0xb4, 0x01, 0x0a, 0x0d, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65,\n-\t0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x3f, 0x0a, 0x0d, 0x6e, 0x65, 0x74, 0x62, 0x69, 0x72,\n-\t0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e,\n-\t0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4e, 0x65, 0x74, 0x62, 0x69,\n-\t0x72, 0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0d, 0x6e, 0x65, 0x74, 0x62, 0x69, 0x72,\n-\t0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x36, 0x0a, 0x0a, 0x70, 0x65, 0x65, 0x72, 0x43,\n-\t0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61,\n-\t0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e,\n-\t0x66, 0x69, 0x67, 0x52, 0x0a, 0x70, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12,\n-\t0x2a, 0x0a, 0x06, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32,\n-\t0x12, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x43, 0x68, 0x65,\n-\t0x63, 0x6b, 0x73, 0x52, 0x06, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x73, 0x22, 0x79, 0x0a, 0x11, 0x53,\n-\t0x65, 0x72, 0x76, 0x65, 0x72, 0x4b, 0x65, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,\n-\t0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b,\n-\t0x65, 0x79, 0x12, 0x38, 0x0a, 0x09, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x41, 0x74, 0x18,\n-\t0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,\n-\t0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,\n-\t0x70, 0x52, 0x09, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x41, 0x74, 0x12, 0x18, 0x0a, 0x07,\n-\t0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x07, 0x76,\n-\t0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0x07, 0x0a, 0x05, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22,\n-\t0xff, 0x01, 0x0a, 0x0d, 0x4e, 0x65, 0x74, 0x62, 0x69, 0x72, 0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69,\n-\t0x67, 0x12, 0x2c, 0x0a, 0x05, 0x73, 0x74, 0x75, 0x6e, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b,\n-\t0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x48, 0x6f,\n-\t0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x05, 0x73, 0x74, 0x75, 0x6e, 0x73, 0x12,\n-\t0x35, 0x0a, 0x05, 0x74, 0x75, 0x72, 0x6e, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1f,\n-\t0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x72, 0x6f, 0x74,\n-\t0x65, 0x63, 0x74, 0x65, 0x64, 0x48, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52,\n-\t0x05, 0x74, 0x75, 0x72, 0x6e, 0x73, 0x12, 0x2e, 0x0a, 0x06, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c,\n-\t0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d,\n-\t0x65, 0x6e, 0x74, 0x2e, 0x48, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x06,\n-\t0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x12, 0x2d, 0x0a, 0x05, 0x72, 0x65, 0x6c, 0x61, 0x79, 0x18,\n-\t0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65,\n-\t0x6e, 0x74, 0x2e, 0x52, 0x65, 0x6c, 0x61, 0x79, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x05,\n-\t0x72, 0x65, 0x6c, 0x61, 0x79, 0x12, 0x2a, 0x0a, 0x04, 0x66, 0x6c, 0x6f, 0x77, 0x18, 0x05, 0x20,\n-\t0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74,\n-\t0x2e, 0x46, 0x6c, 0x6f, 0x77, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x04, 0x66, 0x6c, 0x6f,\n-\t0x77, 0x22, 0x98, 0x01, 0x0a, 0x0a, 0x48, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,\n-\t0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x69, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x75,\n-\t0x72, 0x69, 0x12, 0x3b, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x02,\n-\t0x20, 0x01, 0x28, 0x0e, 0x32, 0x1f, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e,\n-\t0x74, 0x2e, 0x48, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x50, 0x72, 0x6f,\n-\t0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x52, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x22,\n-\t0x3b, 0x0a, 0x08, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x07, 0x0a, 0x03, 0x55,\n-\t0x44, 0x50, 0x10, 0x00, 0x12, 0x07, 0x0a, 0x03, 0x54, 0x43, 0x50, 0x10, 0x01, 0x12, 0x08, 0x0a,\n-\t0x04, 0x48, 0x54, 0x54, 0x50, 0x10, 0x02, 0x12, 0x09, 0x0a, 0x05, 0x48, 0x54, 0x54, 0x50, 0x53,\n-\t0x10, 0x03, 0x12, 0x08, 0x0a, 0x04, 0x44, 0x54, 0x4c, 0x53, 0x10, 0x04, 0x22, 0x6d, 0x0a, 0x0b,\n-\t0x52, 0x65, 0x6c, 0x61, 0x79, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x12, 0x0a, 0x04, 0x75,\n-\t0x72, 0x6c, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x04, 0x75, 0x72, 0x6c, 0x73, 0x12,\n-\t0x22, 0x0a, 0x0c, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x18,\n-\t0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x50, 0x61, 0x79, 0x6c,\n-\t0x6f, 0x61, 0x64, 0x12, 0x26, 0x0a, 0x0e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x53, 0x69, 0x67, 0x6e,\n-\t0x61, 0x74, 0x75, 0x72, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x74, 0x6f, 0x6b,\n-\t0x65, 0x6e, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x22, 0xad, 0x02, 0x0a, 0x0a,\n-\t0x46, 0x6c, 0x6f, 0x77, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72,\n-\t0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x75, 0x72, 0x6c, 0x12, 0x22, 0x0a, 0x0c,\n-\t0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x18, 0x02, 0x20, 0x01,\n-\t0x28, 0x09, 0x52, 0x0c, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64,\n-\t0x12, 0x26, 0x0a, 0x0e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75,\n-\t0x72, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x53,\n-\t0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x12, 0x35, 0x0a, 0x08, 0x69, 0x6e, 0x74, 0x65,\n-\t0x72, 0x76, 0x61, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f,\n-\t0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72,\n-\t0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x08, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x12,\n-\t0x18, 0x0a, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08,\n-\t0x52, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x6f, 0x75,\n-\t0x6e, 0x74, 0x65, 0x72, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x63, 0x6f, 0x75,\n-\t0x6e, 0x74, 0x65, 0x72, 0x73, 0x12, 0x2e, 0x0a, 0x12, 0x65, 0x78, 0x69, 0x74, 0x4e, 0x6f, 0x64,\n-\t0x65, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x07, 0x20, 0x01, 0x28,\n-\t0x08, 0x52, 0x12, 0x65, 0x78, 0x69, 0x74, 0x4e, 0x6f, 0x64, 0x65, 0x43, 0x6f, 0x6c, 0x6c, 0x65,\n-\t0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x24, 0x0a, 0x0d, 0x64, 0x6e, 0x73, 0x43, 0x6f, 0x6c, 0x6c,\n-\t0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x64, 0x6e,\n-\t0x73, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x7d, 0x0a, 0x13, 0x50,\n-\t0x72, 0x6f, 0x74, 0x65, 0x63, 0x74, 0x65, 0x64, 0x48, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66,\n-\t0x69, 0x67, 0x12, 0x36, 0x0a, 0x0a, 0x68, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,\n-\t0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d,\n-\t0x65, 0x6e, 0x74, 0x2e, 0x48, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0a,\n-\t0x68, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x73,\n-\t0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x12, 0x1a,\n-\t0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,\n-\t0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x22, 0x93, 0x02, 0x0a, 0x0a, 0x50,\n-\t0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x64, 0x64,\n-\t0x72, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72,\n-\t0x65, 0x73, 0x73, 0x12, 0x10, 0x0a, 0x03, 0x64, 0x6e, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,\n-\t0x52, 0x03, 0x64, 0x6e, 0x73, 0x12, 0x33, 0x0a, 0x09, 0x73, 0x73, 0x68, 0x43, 0x6f, 0x6e, 0x66,\n-\t0x69, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67,\n-\t0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x53, 0x48, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52,\n-\t0x09, 0x73, 0x73, 0x68, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x12, 0x0a, 0x04, 0x66, 0x71,\n-\t0x64, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x66, 0x71, 0x64, 0x6e, 0x12, 0x48,\n-\t0x0a, 0x1f, 0x52, 0x6f, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x50, 0x65, 0x65, 0x72, 0x44, 0x6e, 0x73,\n-\t0x52, 0x65, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65,\n-\t0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x1f, 0x52, 0x6f, 0x75, 0x74, 0x69, 0x6e, 0x67,\n-\t0x50, 0x65, 0x65, 0x72, 0x44, 0x6e, 0x73, 0x52, 0x65, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f,\n-\t0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x34, 0x0a, 0x15, 0x4c, 0x61, 0x7a, 0x79,\n-\t0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65,\n-\t0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x15, 0x4c, 0x61, 0x7a, 0x79, 0x43, 0x6f, 0x6e,\n-\t0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x10,\n-\t0x0a, 0x03, 0x6d, 0x74, 0x75, 0x18, 0x07, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x6d, 0x74, 0x75,\n-\t0x22, 0xb9, 0x05, 0x0a, 0x0a, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x4d, 0x61, 0x70, 0x12,\n-\t0x16, 0x0a, 0x06, 0x53, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52,\n-\t0x06, 0x53, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x12, 0x36, 0x0a, 0x0a, 0x70, 0x65, 0x65, 0x72, 0x43,\n-\t0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61,\n-\t0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e,\n-\t0x66, 0x69, 0x67, 0x52, 0x0a, 0x70, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12,\n-\t0x3e, 0x0a, 0x0b, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x73, 0x18, 0x03,\n+\t0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12,\n+\t0x24, 0x0a, 0x0d, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x53, 0x48, 0x52, 0x6f, 0x6f, 0x74,\n+\t0x18, 0x0b, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x53,\n+\t0x48, 0x52, 0x6f, 0x6f, 0x74, 0x12, 0x24, 0x0a, 0x0d, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x53,\n+\t0x53, 0x48, 0x53, 0x46, 0x54, 0x50, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x65, 0x6e,\n+\t0x61, 0x62, 0x6c, 0x65, 0x53, 0x53, 0x48, 0x53, 0x46, 0x54, 0x50, 0x12, 0x42, 0x0a, 0x1c, 0x65,\n+\t0x6e, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x53, 0x48, 0x4c, 0x6f, 0x63, 0x61, 0x6c, 0x50, 0x6f, 0x72,\n+\t0x74, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x18, 0x0d, 0x20, 0x01, 0x28,\n+\t0x08, 0x52, 0x1c, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x53, 0x48, 0x4c, 0x6f, 0x63, 0x61,\n+\t0x6c, 0x50, 0x6f, 0x72, 0x74, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x12,\n+\t0x44, 0x0a, 0x1d, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x53, 0x48, 0x52, 0x65, 0x6d, 0x6f,\n+\t0x74, 0x65, 0x50, 0x6f, 0x72, 0x74, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x69, 0x6e, 0x67,\n+\t0x18, 0x0e, 0x20, 0x01, 0x28, 0x08, 0x52, 0x1d, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x53,\n+\t0x48, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x6f, 0x72, 0x74, 0x46, 0x6f, 0x72, 0x77, 0x61,\n+\t0x72, 0x64, 0x69, 0x6e, 0x67, 0x12, 0x26, 0x0a, 0x0e, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65,\n+\t0x53, 0x53, 0x48, 0x41, 0x75, 0x74, 0x68, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0e, 0x64,\n+\t0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x53, 0x48, 0x41, 0x75, 0x74, 0x68, 0x22, 0xf2, 0x04,\n+\t0x0a, 0x0e, 0x50, 0x65, 0x65, 0x72, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x4d, 0x65, 0x74, 0x61,\n+\t0x12, 0x1a, 0x0a, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01,\n+\t0x28, 0x09, 0x52, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x12, 0x0a, 0x04,\n+\t0x67, 0x6f, 0x4f, 0x53, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x67, 0x6f, 0x4f, 0x53,\n+\t0x12, 0x16, 0x0a, 0x06, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,\n+\t0x52, 0x06, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x12, 0x12, 0x0a, 0x04, 0x63, 0x6f, 0x72, 0x65,\n+\t0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x63, 0x6f, 0x72, 0x65, 0x12, 0x1a, 0x0a, 0x08,\n+\t0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08,\n+\t0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x12, 0x0e, 0x0a, 0x02, 0x4f, 0x53, 0x18, 0x06,\n+\t0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x4f, 0x53, 0x12, 0x26, 0x0a, 0x0e, 0x6e, 0x65, 0x74, 0x62,\n+\t0x69, 0x72, 0x64, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09,\n+\t0x52, 0x0e, 0x6e, 0x65, 0x74, 0x62, 0x69, 0x72, 0x64, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,\n+\t0x12, 0x1c, 0x0a, 0x09, 0x75, 0x69, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x08, 0x20,\n+\t0x01, 0x28, 0x09, 0x52, 0x09, 0x75, 0x69, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x24,\n+\t0x0a, 0x0d, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18,\n+\t0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x56, 0x65, 0x72,\n+\t0x73, 0x69, 0x6f, 0x6e, 0x12, 0x1c, 0x0a, 0x09, 0x4f, 0x53, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f,\n+\t0x6e, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x4f, 0x53, 0x56, 0x65, 0x72, 0x73, 0x69,\n+\t0x6f, 0x6e, 0x12, 0x46, 0x0a, 0x10, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x41, 0x64, 0x64,\n+\t0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x18, 0x0b, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x6d,\n+\t0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72,\n+\t0x6b, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x10, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72,\n+\t0x6b, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x12, 0x28, 0x0a, 0x0f, 0x73, 0x79,\n+\t0x73, 0x53, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x0c, 0x20,\n+\t0x01, 0x28, 0x09, 0x52, 0x0f, 0x73, 0x79, 0x73, 0x53, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x4e, 0x75,\n+\t0x6d, 0x62, 0x65, 0x72, 0x12, 0x26, 0x0a, 0x0e, 0x73, 0x79, 0x73, 0x50, 0x72, 0x6f, 0x64, 0x75,\n+\t0x63, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x73, 0x79,\n+\t0x73, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x28, 0x0a, 0x0f,\n+\t0x73, 0x79, 0x73, 0x4d, 0x61, 0x6e, 0x75, 0x66, 0x61, 0x63, 0x74, 0x75, 0x72, 0x65, 0x72, 0x18,\n+\t0x0e, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x73, 0x79, 0x73, 0x4d, 0x61, 0x6e, 0x75, 0x66, 0x61,\n+\t0x63, 0x74, 0x75, 0x72, 0x65, 0x72, 0x12, 0x39, 0x0a, 0x0b, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f,\n+\t0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x6d, 0x61,\n+\t0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e,\n+\t0x6d, 0x65, 0x6e, 0x74, 0x52, 0x0b, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e,\n+\t0x74, 0x12, 0x26, 0x0a, 0x05, 0x66, 0x69, 0x6c, 0x65, 0x73, 0x18, 0x10, 0x20, 0x03, 0x28, 0x0b,\n+\t0x32, 0x10, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x46, 0x69,\n+\t0x6c, 0x65, 0x52, 0x05, 0x66, 0x69, 0x6c, 0x65, 0x73, 0x12, 0x27, 0x0a, 0x05, 0x66, 0x6c, 0x61,\n+\t0x67, 0x73, 0x18, 0x11, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67,\n+\t0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x46, 0x6c, 0x61, 0x67, 0x73, 0x52, 0x05, 0x66, 0x6c, 0x61,\n+\t0x67, 0x73, 0x22, 0xb4, 0x01, 0x0a, 0x0d, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x73, 0x70,\n+\t0x6f, 0x6e, 0x73, 0x65, 0x12, 0x3f, 0x0a, 0x0d, 0x6e, 0x65, 0x74, 0x62, 0x69, 0x72, 0x64, 0x43,\n+\t0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x6d, 0x61,\n+\t0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4e, 0x65, 0x74, 0x62, 0x69, 0x72, 0x64,\n+\t0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0d, 0x6e, 0x65, 0x74, 0x62, 0x69, 0x72, 0x64, 0x43,\n+\t0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x36, 0x0a, 0x0a, 0x70, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e,\n+\t0x66, 0x69, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61,\n+\t0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69,\n+\t0x67, 0x52, 0x0a, 0x70, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x2a, 0x0a,\n+\t0x06, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e,\n+\t0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x43, 0x68, 0x65, 0x63, 0x6b,\n+\t0x73, 0x52, 0x06, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x73, 0x22, 0x79, 0x0a, 0x11, 0x53, 0x65, 0x72,\n+\t0x76, 0x65, 0x72, 0x4b, 0x65, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x10,\n+\t0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79,\n+\t0x12, 0x38, 0x0a, 0x09, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x41, 0x74, 0x18, 0x02, 0x20,\n+\t0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,\n+\t0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52,\n+\t0x09, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x41, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x76, 0x65,\n+\t0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x07, 0x76, 0x65, 0x72,\n+\t0x73, 0x69, 0x6f, 0x6e, 0x22, 0x07, 0x0a, 0x05, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0xa8, 0x02,\n+\t0x0a, 0x0d, 0x4e, 0x65, 0x74, 0x62, 0x69, 0x72, 0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12,\n+\t0x2c, 0x0a, 0x05, 0x73, 0x74, 0x75, 0x6e, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16,\n+\t0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x48, 0x6f, 0x73, 0x74,\n+\t0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x05, 0x73, 0x74, 0x75, 0x6e, 0x73, 0x12, 0x35, 0x0a,\n+\t0x05, 0x74, 0x75, 0x72, 0x6e, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x6d,\n+\t0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x65, 0x63,\n+\t0x74, 0x65, 0x64, 0x48, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x05, 0x74,\n+\t0x75, 0x72, 0x6e, 0x73, 0x12, 0x2e, 0x0a, 0x06, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x18, 0x03,\n+\t0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e,\n+\t0x74, 0x2e, 0x48, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x06, 0x73, 0x69,\n+\t0x67, 0x6e, 0x61, 0x6c, 0x12, 0x2d, 0x0a, 0x05, 0x72, 0x65, 0x6c, 0x61, 0x79, 0x18, 0x04, 0x20,\n+\t0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74,\n+\t0x2e, 0x52, 0x65, 0x6c, 0x61, 0x79, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x05, 0x72, 0x65,\n+\t0x6c, 0x61, 0x79, 0x12, 0x2a, 0x0a, 0x04, 0x66, 0x6c, 0x6f, 0x77, 0x18, 0x05, 0x20, 0x01, 0x28,\n+\t0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x46,\n+\t0x6c, 0x6f, 0x77, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x04, 0x66, 0x6c, 0x6f, 0x77, 0x12,\n+\t0x27, 0x0a, 0x03, 0x6a, 0x77, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d,\n+\t0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4a, 0x57, 0x54, 0x43, 0x6f, 0x6e,\n+\t0x66, 0x69, 0x67, 0x52, 0x03, 0x6a, 0x77, 0x74, 0x22, 0x98, 0x01, 0x0a, 0x0a, 0x48, 0x6f, 0x73,\n+\t0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x69, 0x18, 0x01,\n+\t0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x75, 0x72, 0x69, 0x12, 0x3b, 0x0a, 0x08, 0x70, 0x72, 0x6f,\n+\t0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1f, 0x2e, 0x6d, 0x61,\n+\t0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x48, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e,\n+\t0x66, 0x69, 0x67, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x52, 0x08, 0x70, 0x72,\n+\t0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x22, 0x3b, 0x0a, 0x08, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63,\n+\t0x6f, 0x6c, 0x12, 0x07, 0x0a, 0x03, 0x55, 0x44, 0x50, 0x10, 0x00, 0x12, 0x07, 0x0a, 0x03, 0x54,\n+\t0x43, 0x50, 0x10, 0x01, 0x12, 0x08, 0x0a, 0x04, 0x48, 0x54, 0x54, 0x50, 0x10, 0x02, 0x12, 0x09,\n+\t0x0a, 0x05, 0x48, 0x54, 0x54, 0x50, 0x53, 0x10, 0x03, 0x12, 0x08, 0x0a, 0x04, 0x44, 0x54, 0x4c,\n+\t0x53, 0x10, 0x04, 0x22, 0x6d, 0x0a, 0x0b, 0x52, 0x65, 0x6c, 0x61, 0x79, 0x43, 0x6f, 0x6e, 0x66,\n+\t0x69, 0x67, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x72, 0x6c, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09,\n+\t0x52, 0x04, 0x75, 0x72, 0x6c, 0x73, 0x12, 0x22, 0x0a, 0x0c, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x50,\n+\t0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x74, 0x6f,\n+\t0x6b, 0x65, 0x6e, 0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x26, 0x0a, 0x0e, 0x74, 0x6f,\n+\t0x6b, 0x65, 0x6e, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x18, 0x03, 0x20, 0x01,\n+\t0x28, 0x09, 0x52, 0x0e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75,\n+\t0x72, 0x65, 0x22, 0xad, 0x02, 0x0a, 0x0a, 0x46, 0x6c, 0x6f, 0x77, 0x43, 0x6f, 0x6e, 0x66, 0x69,\n+\t0x67, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03,\n+\t0x75, 0x72, 0x6c, 0x12, 0x22, 0x0a, 0x0c, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x50, 0x61, 0x79, 0x6c,\n+\t0x6f, 0x61, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x74, 0x6f, 0x6b, 0x65, 0x6e,\n+\t0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x26, 0x0a, 0x0e, 0x74, 0x6f, 0x6b, 0x65, 0x6e,\n+\t0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52,\n+\t0x0e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x12,\n+\t0x35, 0x0a, 0x08, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28,\n+\t0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,\n+\t0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x08, 0x69, 0x6e,\n+\t0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x12, 0x18, 0x0a, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65,\n+\t0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64,\n+\t0x12, 0x1a, 0x0a, 0x08, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x73, 0x18, 0x06, 0x20, 0x01,\n+\t0x28, 0x08, 0x52, 0x08, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x73, 0x12, 0x2e, 0x0a, 0x12,\n+\t0x65, 0x78, 0x69, 0x74, 0x4e, 0x6f, 0x64, 0x65, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69,\n+\t0x6f, 0x6e, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x52, 0x12, 0x65, 0x78, 0x69, 0x74, 0x4e, 0x6f,\n+\t0x64, 0x65, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x24, 0x0a, 0x0d,\n+\t0x64, 0x6e, 0x73, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x08, 0x20,\n+\t0x01, 0x28, 0x08, 0x52, 0x0d, 0x64, 0x6e, 0x73, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69,\n+\t0x6f, 0x6e, 0x22, 0x85, 0x01, 0x0a, 0x09, 0x4a, 0x57, 0x54, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,\n+\t0x12, 0x16, 0x0a, 0x06, 0x69, 0x73, 0x73, 0x75, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,\n+\t0x52, 0x06, 0x69, 0x73, 0x73, 0x75, 0x65, 0x72, 0x12, 0x1a, 0x0a, 0x08, 0x61, 0x75, 0x64, 0x69,\n+\t0x65, 0x6e, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x61, 0x75, 0x64, 0x69,\n+\t0x65, 0x6e, 0x63, 0x65, 0x12, 0x22, 0x0a, 0x0c, 0x6b, 0x65, 0x79, 0x73, 0x4c, 0x6f, 0x63, 0x61,\n+\t0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x6b, 0x65, 0x79, 0x73,\n+\t0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x20, 0x0a, 0x0b, 0x6d, 0x61, 0x78, 0x54,\n+\t0x6f, 0x6b, 0x65, 0x6e, 0x41, 0x67, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0b, 0x6d,\n+\t0x61, 0x78, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x41, 0x67, 0x65, 0x22, 0x7d, 0x0a, 0x13, 0x50, 0x72,\n+\t0x6f, 0x74, 0x65, 0x63, 0x74, 0x65, 0x64, 0x48, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69,\n+\t0x67, 0x12, 0x36, 0x0a, 0x0a, 0x68, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18,\n+\t0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65,\n+\t0x6e, 0x74, 0x2e, 0x48, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0a, 0x68,\n+\t0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x73, 0x65,\n+\t0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x12, 0x1a, 0x0a,\n+\t0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52,\n+\t0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x22, 0x93, 0x02, 0x0a, 0x0a, 0x50, 0x65,\n+\t0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72,\n+\t0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65,\n+\t0x73, 0x73, 0x12, 0x10, 0x0a, 0x03, 0x64, 0x6e, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,\n+\t0x03, 0x64, 0x6e, 0x73, 0x12, 0x33, 0x0a, 0x09, 0x73, 0x73, 0x68, 0x43, 0x6f, 0x6e, 0x66, 0x69,\n+\t0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65,\n+\t0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x53, 0x48, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x09,\n+\t0x73, 0x73, 0x68, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x12, 0x0a, 0x04, 0x66, 0x71, 0x64,\n+\t0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x66, 0x71, 0x64, 0x6e, 0x12, 0x48, 0x0a,\n+\t0x1f, 0x52, 0x6f, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x50, 0x65, 0x65, 0x72, 0x44, 0x6e, 0x73, 0x52,\n+\t0x65, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64,\n+\t0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x1f, 0x52, 0x6f, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x50,\n+\t0x65, 0x65, 0x72, 0x44, 0x6e, 0x73, 0x52, 0x65, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e,\n+\t0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x34, 0x0a, 0x15, 0x4c, 0x61, 0x7a, 0x79, 0x43,\n+\t0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64,\n+\t0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x15, 0x4c, 0x61, 0x7a, 0x79, 0x43, 0x6f, 0x6e, 0x6e,\n+\t0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x10, 0x0a,\n+\t0x03, 0x6d, 0x74, 0x75, 0x18, 0x07, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x6d, 0x74, 0x75, 0x22,\n+\t0xb9, 0x05, 0x0a, 0x0a, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x4d, 0x61, 0x70, 0x12, 0x16,\n+\t0x0a, 0x06, 0x53, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06,\n+\t0x53, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x12, 0x36, 0x0a, 0x0a, 0x70, 0x65, 0x65, 0x72, 0x43, 0x6f,\n+\t0x6e, 0x66, 0x69, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e,\n+\t0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66,\n+\t0x69, 0x67, 0x52, 0x0a, 0x70, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x3e,\n+\t0x0a, 0x0b, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x73, 0x18, 0x03, 0x20,\n+\t0x03, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74,\n+\t0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69,\n+\t0x67, 0x52, 0x0b, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x73, 0x12, 0x2e,\n+\t0x0a, 0x12, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x73, 0x49, 0x73, 0x45,\n+\t0x6d, 0x70, 0x74, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x12, 0x72, 0x65, 0x6d, 0x6f,\n+\t0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x73, 0x49, 0x73, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x29,\n+\t0x0a, 0x06, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x11,\n+\t0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x6f, 0x75, 0x74,\n+\t0x65, 0x52, 0x06, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x12, 0x33, 0x0a, 0x09, 0x44, 0x4e, 0x53,\n+\t0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d,\n+\t0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x44, 0x4e, 0x53, 0x43, 0x6f, 0x6e,\n+\t0x66, 0x69, 0x67, 0x52, 0x09, 0x44, 0x4e, 0x53, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x40,\n+\t0x0a, 0x0c, 0x6f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65, 0x50, 0x65, 0x65, 0x72, 0x73, 0x18, 0x07,\n \t0x20, 0x03, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e,\n \t0x74, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66,\n-\t0x69, 0x67, 0x52, 0x0b, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x73, 0x12,\n-\t0x2e, 0x0a, 0x12, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x73, 0x49, 0x73,\n-\t0x45, 0x6d, 0x70, 0x74, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x12, 0x72, 0x65, 0x6d,\n-\t0x6f, 0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x73, 0x49, 0x73, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12,\n-\t0x29, 0x0a, 0x06, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32,\n-\t0x11, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x6f, 0x75,\n-\t0x74, 0x65, 0x52, 0x06, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x12, 0x33, 0x0a, 0x09, 0x44, 0x4e,\n-\t0x53, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e,\n-\t0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x44, 0x4e, 0x53, 0x43, 0x6f,\n-\t0x6e, 0x66, 0x69, 0x67, 0x52, 0x09, 0x44, 0x4e, 0x53, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12,\n-\t0x40, 0x0a, 0x0c, 0x6f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65, 0x50, 0x65, 0x65, 0x72, 0x73, 0x18,\n-\t0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65,\n-\t0x6e, 0x74, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e,\n-\t0x66, 0x69, 0x67, 0x52, 0x0c, 0x6f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65, 0x50, 0x65, 0x65, 0x72,\n-\t0x73, 0x12, 0x3e, 0x0a, 0x0d, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c,\n-\t0x65, 0x73, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67,\n-\t0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75,\n-\t0x6c, 0x65, 0x52, 0x0d, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65,\n-\t0x73, 0x12, 0x32, 0x0a, 0x14, 0x66, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c,\n-\t0x65, 0x73, 0x49, 0x73, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x52,\n-\t0x14, 0x66, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x49, 0x73,\n-\t0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x4f, 0x0a, 0x13, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x46,\n-\t0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x18, 0x0a, 0x20, 0x03,\n-\t0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e,\n-\t0x52, 0x6f, 0x75, 0x74, 0x65, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c,\n-\t0x65, 0x52, 0x13, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c,\n-\t0x6c, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x3e, 0x0a, 0x1a, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73,\n-\t0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x49, 0x73, 0x45,\n-\t0x6d, 0x70, 0x74, 0x79, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x08, 0x52, 0x1a, 0x72, 0x6f, 0x75, 0x74,\n-\t0x65, 0x73, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x49,\n-\t0x73, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x44, 0x0a, 0x0f, 0x66, 0x6f, 0x72, 0x77, 0x61, 0x72,\n-\t0x64, 0x69, 0x6e, 0x67, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x18, 0x0c, 0x20, 0x03, 0x28, 0x0b, 0x32,\n-\t0x1a, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x46, 0x6f, 0x72,\n-\t0x77, 0x61, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x75, 0x6c, 0x65, 0x52, 0x0f, 0x66, 0x6f, 0x72,\n-\t0x77, 0x61, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x22, 0xbb, 0x01, 0x0a,\n-\t0x10, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69,\n-\t0x67, 0x12, 0x1a, 0x0a, 0x08, 0x77, 0x67, 0x50, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x18, 0x01, 0x20,\n-\t0x01, 0x28, 0x09, 0x52, 0x08, 0x77, 0x67, 0x50, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x12, 0x1e, 0x0a,\n-\t0x0a, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x49, 0x70, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28,\n-\t0x09, 0x52, 0x0a, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x49, 0x70, 0x73, 0x12, 0x33, 0x0a,\n-\t0x09, 0x73, 0x73, 0x68, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b,\n-\t0x32, 0x15, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x53,\n-\t0x48, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x09, 0x73, 0x73, 0x68, 0x43, 0x6f, 0x6e, 0x66,\n-\t0x69, 0x67, 0x12, 0x12, 0x0a, 0x04, 0x66, 0x71, 0x64, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09,\n-\t0x52, 0x04, 0x66, 0x71, 0x64, 0x6e, 0x12, 0x22, 0x0a, 0x0c, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x56,\n-\t0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x61, 0x67,\n-\t0x65, 0x6e, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0x49, 0x0a, 0x09, 0x53, 0x53,\n-\t0x48, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x1e, 0x0a, 0x0a, 0x73, 0x73, 0x68, 0x45, 0x6e,\n-\t0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x73, 0x73, 0x68,\n-\t0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x1c, 0x0a, 0x09, 0x73, 0x73, 0x68, 0x50, 0x75,\n-\t0x62, 0x4b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x09, 0x73, 0x73, 0x68, 0x50,\n-\t0x75, 0x62, 0x4b, 0x65, 0x79, 0x22, 0x20, 0x0a, 0x1e, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x41,\n-\t0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x6f, 0x77,\n-\t0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0xbf, 0x01, 0x0a, 0x17, 0x44, 0x65, 0x76, 0x69,\n-\t0x63, 0x65, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46,\n-\t0x6c, 0x6f, 0x77, 0x12, 0x48, 0x0a, 0x08, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x18,\n-\t0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65,\n-\t0x6e, 0x74, 0x2e, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69,\n-\t0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x6f, 0x77, 0x2e, 0x70, 0x72, 0x6f, 0x76, 0x69,\n-\t0x64, 0x65, 0x72, 0x52, 0x08, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x12, 0x42, 0x0a,\n-\t0x0e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18,\n-\t0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65,\n-\t0x6e, 0x74, 0x2e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69,\n-\t0x67, 0x52, 0x0e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69,\n-\t0x67, 0x22, 0x16, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x12, 0x0a, 0x0a,\n-\t0x06, 0x48, 0x4f, 0x53, 0x54, 0x45, 0x44, 0x10, 0x00, 0x22, 0x1e, 0x0a, 0x1c, 0x50, 0x4b, 0x43,\n-\t0x45, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c,\n-\t0x6f, 0x77, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x5b, 0x0a, 0x15, 0x50, 0x4b, 0x43,\n-\t0x45, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c,\n-\t0x6f, 0x77, 0x12, 0x42, 0x0a, 0x0e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43, 0x6f,\n-\t0x6e, 0x66, 0x69, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x6d, 0x61, 0x6e,\n-\t0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72,\n-\t0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72,\n-\t0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x22, 0xb8, 0x03, 0x0a, 0x0e, 0x50, 0x72, 0x6f, 0x76, 0x69,\n-\t0x64, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x1a, 0x0a, 0x08, 0x43, 0x6c, 0x69,\n-\t0x65, 0x6e, 0x74, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x43, 0x6c, 0x69,\n-\t0x65, 0x6e, 0x74, 0x49, 0x44, 0x12, 0x22, 0x0a, 0x0c, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x53,\n-\t0x65, 0x63, 0x72, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x43, 0x6c, 0x69,\n-\t0x65, 0x6e, 0x74, 0x53, 0x65, 0x63, 0x72, 0x65, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x44, 0x6f, 0x6d,\n-\t0x61, 0x69, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x44, 0x6f, 0x6d, 0x61, 0x69,\n-\t0x6e, 0x12, 0x1a, 0x0a, 0x08, 0x41, 0x75, 0x64, 0x69, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x04, 0x20,\n-\t0x01, 0x28, 0x09, 0x52, 0x08, 0x41, 0x75, 0x64, 0x69, 0x65, 0x6e, 0x63, 0x65, 0x12, 0x2e, 0x0a,\n-\t0x12, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x41, 0x75, 0x74, 0x68, 0x45, 0x6e, 0x64, 0x70, 0x6f,\n-\t0x69, 0x6e, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x12, 0x44, 0x65, 0x76, 0x69, 0x63,\n-\t0x65, 0x41, 0x75, 0x74, 0x68, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x12, 0x24, 0x0a,\n-\t0x0d, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x06,\n-\t0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x45, 0x6e, 0x64, 0x70, 0x6f,\n-\t0x69, 0x6e, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x53, 0x63, 0x6f, 0x70, 0x65, 0x18, 0x07, 0x20, 0x01,\n-\t0x28, 0x09, 0x52, 0x05, 0x53, 0x63, 0x6f, 0x70, 0x65, 0x12, 0x1e, 0x0a, 0x0a, 0x55, 0x73, 0x65,\n-\t0x49, 0x44, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x55,\n-\t0x73, 0x65, 0x49, 0x44, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x34, 0x0a, 0x15, 0x41, 0x75, 0x74,\n-\t0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69,\n-\t0x6e, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x15, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72,\n-\t0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x12,\n-\t0x22, 0x0a, 0x0c, 0x52, 0x65, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x55, 0x52, 0x4c, 0x73, 0x18,\n-\t0x0a, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0c, 0x52, 0x65, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x55,\n-\t0x52, 0x4c, 0x73, 0x12, 0x2e, 0x0a, 0x12, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x72,\n-\t0x6f, 0x6d, 0x70, 0x74, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x08, 0x52,\n-\t0x12, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x6d, 0x70, 0x74, 0x4c, 0x6f,\n-\t0x67, 0x69, 0x6e, 0x12, 0x1c, 0x0a, 0x09, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x46, 0x6c, 0x61, 0x67,\n-\t0x18, 0x0c, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x46, 0x6c, 0x61,\n-\t0x67, 0x22, 0x93, 0x02, 0x0a, 0x05, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x49,\n-\t0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x49, 0x44, 0x12, 0x18, 0x0a, 0x07, 0x4e,\n-\t0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x4e, 0x65,\n-\t0x74, 0x77, 0x6f, 0x72, 0x6b, 0x12, 0x20, 0x0a, 0x0b, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b,\n-\t0x54, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0b, 0x4e, 0x65, 0x74, 0x77,\n-\t0x6f, 0x72, 0x6b, 0x54, 0x79, 0x70, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x50, 0x65, 0x65, 0x72, 0x18,\n-\t0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x50, 0x65, 0x65, 0x72, 0x12, 0x16, 0x0a, 0x06, 0x4d,\n-\t0x65, 0x74, 0x72, 0x69, 0x63, 0x18, 0x05, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x4d, 0x65, 0x74,\n-\t0x72, 0x69, 0x63, 0x12, 0x1e, 0x0a, 0x0a, 0x4d, 0x61, 0x73, 0x71, 0x75, 0x65, 0x72, 0x61, 0x64,\n-\t0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x4d, 0x61, 0x73, 0x71, 0x75, 0x65, 0x72,\n-\t0x61, 0x64, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x4e, 0x65, 0x74, 0x49, 0x44, 0x18, 0x07, 0x20, 0x01,\n-\t0x28, 0x09, 0x52, 0x05, 0x4e, 0x65, 0x74, 0x49, 0x44, 0x12, 0x18, 0x0a, 0x07, 0x44, 0x6f, 0x6d,\n-\t0x61, 0x69, 0x6e, 0x73, 0x18, 0x08, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x44, 0x6f, 0x6d, 0x61,\n-\t0x69, 0x6e, 0x73, 0x12, 0x1c, 0x0a, 0x09, 0x6b, 0x65, 0x65, 0x70, 0x52, 0x6f, 0x75, 0x74, 0x65,\n-\t0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x6b, 0x65, 0x65, 0x70, 0x52, 0x6f, 0x75, 0x74,\n-\t0x65, 0x12, 0x24, 0x0a, 0x0d, 0x73, 0x6b, 0x69, 0x70, 0x41, 0x75, 0x74, 0x6f, 0x41, 0x70, 0x70,\n-\t0x6c, 0x79, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x73, 0x6b, 0x69, 0x70, 0x41, 0x75,\n-\t0x74, 0x6f, 0x41, 0x70, 0x70, 0x6c, 0x79, 0x22, 0xda, 0x01, 0x0a, 0x09, 0x44, 0x4e, 0x53, 0x43,\n-\t0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x24, 0x0a, 0x0d, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,\n-\t0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x53, 0x65,\n-\t0x72, 0x76, 0x69, 0x63, 0x65, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x47, 0x0a, 0x10, 0x4e,\n-\t0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x73, 0x18,\n-\t0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65,\n-\t0x6e, 0x74, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x47, 0x72, 0x6f,\n-\t0x75, 0x70, 0x52, 0x10, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x47, 0x72,\n-\t0x6f, 0x75, 0x70, 0x73, 0x12, 0x38, 0x0a, 0x0b, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5a, 0x6f,\n-\t0x6e, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61,\n-\t0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5a, 0x6f, 0x6e,\n-\t0x65, 0x52, 0x0b, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5a, 0x6f, 0x6e, 0x65, 0x73, 0x12, 0x24,\n-\t0x0a, 0x0d, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x65, 0x72, 0x50, 0x6f, 0x72, 0x74, 0x18,\n-\t0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0d, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x65, 0x72,\n-\t0x50, 0x6f, 0x72, 0x74, 0x22, 0x58, 0x0a, 0x0a, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5a, 0x6f,\n-\t0x6e, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x18, 0x01, 0x20, 0x01,\n-\t0x28, 0x09, 0x52, 0x06, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x12, 0x32, 0x0a, 0x07, 0x52, 0x65,\n-\t0x63, 0x6f, 0x72, 0x64, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x6d, 0x61,\n-\t0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x52,\n-\t0x65, 0x63, 0x6f, 0x72, 0x64, 0x52, 0x07, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x22, 0x74,\n-\t0x0a, 0x0c, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x12, 0x12,\n-\t0x0a, 0x04, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x4e, 0x61,\n-\t0x6d, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x54, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03,\n-\t0x52, 0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x18,\n-\t0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x12, 0x10, 0x0a, 0x03,\n-\t0x54, 0x54, 0x4c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x03, 0x54, 0x54, 0x4c, 0x12, 0x14,\n-\t0x0a, 0x05, 0x52, 0x44, 0x61, 0x74, 0x61, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x52,\n-\t0x44, 0x61, 0x74, 0x61, 0x22, 0xb3, 0x01, 0x0a, 0x0f, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72,\n-\t0x76, 0x65, 0x72, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x12, 0x38, 0x0a, 0x0b, 0x4e, 0x61, 0x6d, 0x65,\n-\t0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e,\n-\t0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x53,\n-\t0x65, 0x72, 0x76, 0x65, 0x72, 0x52, 0x0b, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65,\n-\t0x72, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x50, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79, 0x18, 0x02, 0x20,\n-\t0x01, 0x28, 0x08, 0x52, 0x07, 0x50, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79, 0x12, 0x18, 0x0a, 0x07,\n-\t0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x44,\n-\t0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x12, 0x32, 0x0a, 0x14, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68,\n-\t0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x04,\n-\t0x20, 0x01, 0x28, 0x08, 0x52, 0x14, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x44, 0x6f, 0x6d, 0x61,\n-\t0x69, 0x6e, 0x73, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x22, 0x48, 0x0a, 0x0a, 0x4e, 0x61,\n-\t0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x12, 0x0e, 0x0a, 0x02, 0x49, 0x50, 0x18, 0x01,\n-\t0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x49, 0x50, 0x12, 0x16, 0x0a, 0x06, 0x4e, 0x53, 0x54, 0x79,\n-\t0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x4e, 0x53, 0x54, 0x79, 0x70, 0x65,\n-\t0x12, 0x12, 0x0a, 0x04, 0x50, 0x6f, 0x72, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x04,\n-\t0x50, 0x6f, 0x72, 0x74, 0x22, 0xa7, 0x02, 0x0a, 0x0c, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c,\n-\t0x6c, 0x52, 0x75, 0x6c, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x50, 0x65, 0x65, 0x72, 0x49, 0x50, 0x18,\n-\t0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x50, 0x65, 0x65, 0x72, 0x49, 0x50, 0x12, 0x37, 0x0a,\n-\t0x09, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e,\n-\t0x32, 0x19, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75,\n-\t0x6c, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x09, 0x44, 0x69, 0x72,\n-\t0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x2e, 0x0a, 0x06, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e,\n-\t0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d,\n-\t0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x06,\n-\t0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x34, 0x0a, 0x08, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63,\n-\t0x6f, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x18, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67,\n-\t0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63,\n-\t0x6f, 0x6c, 0x52, 0x08, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x12, 0x0a, 0x04,\n-\t0x50, 0x6f, 0x72, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x50, 0x6f, 0x72, 0x74,\n-\t0x12, 0x30, 0x0a, 0x08, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x18, 0x06, 0x20, 0x01,\n-\t0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e,\n-\t0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x08, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e,\n-\t0x66, 0x6f, 0x12, 0x1a, 0x0a, 0x08, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49, 0x44, 0x18, 0x07,\n-\t0x20, 0x01, 0x28, 0x0c, 0x52, 0x08, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49, 0x44, 0x22, 0x38,\n-\t0x0a, 0x0e, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,\n-\t0x12, 0x14, 0x0a, 0x05, 0x6e, 0x65, 0x74, 0x49, 0x50, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,\n-\t0x05, 0x6e, 0x65, 0x74, 0x49, 0x50, 0x12, 0x10, 0x0a, 0x03, 0x6d, 0x61, 0x63, 0x18, 0x02, 0x20,\n-\t0x01, 0x28, 0x09, 0x52, 0x03, 0x6d, 0x61, 0x63, 0x22, 0x1e, 0x0a, 0x06, 0x43, 0x68, 0x65, 0x63,\n-\t0x6b, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,\n-\t0x09, 0x52, 0x05, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x22, 0x96, 0x01, 0x0a, 0x08, 0x50, 0x6f, 0x72,\n-\t0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x14, 0x0a, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x01, 0x20,\n-\t0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x12, 0x32, 0x0a, 0x05, 0x72,\n-\t0x61, 0x6e, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x6d, 0x61, 0x6e,\n-\t0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f,\n-\t0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x48, 0x00, 0x52, 0x05, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x1a,\n-\t0x2f, 0x0a, 0x05, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x72,\n-\t0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x12, 0x10,\n-\t0x0a, 0x03, 0x65, 0x6e, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x03, 0x65, 0x6e, 0x64,\n-\t0x42, 0x0f, 0x0a, 0x0d, 0x70, 0x6f, 0x72, 0x74, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f,\n-\t0x6e, 0x22, 0x87, 0x03, 0x0a, 0x11, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x46, 0x69, 0x72, 0x65, 0x77,\n-\t0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x12, 0x22, 0x0a, 0x0c, 0x73, 0x6f, 0x75, 0x72, 0x63,\n-\t0x65, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0c, 0x73,\n-\t0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x12, 0x2e, 0x0a, 0x06, 0x61,\n-\t0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x16, 0x2e, 0x6d, 0x61,\n-\t0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x41, 0x63, 0x74,\n-\t0x69, 0x6f, 0x6e, 0x52, 0x06, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x20, 0x0a, 0x0b, 0x64,\n-\t0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,\n-\t0x52, 0x0b, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x34, 0x0a,\n-\t0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32,\n-\t0x18, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75, 0x6c,\n-\t0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x52, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f,\n-\t0x63, 0x6f, 0x6c, 0x12, 0x30, 0x0a, 0x08, 0x70, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x18,\n-\t0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65,\n-\t0x6e, 0x74, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x08, 0x70, 0x6f, 0x72,\n-\t0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x1c, 0x0a, 0x09, 0x69, 0x73, 0x44, 0x79, 0x6e, 0x61, 0x6d,\n-\t0x69, 0x63, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x69, 0x73, 0x44, 0x79, 0x6e, 0x61,\n-\t0x6d, 0x69, 0x63, 0x12, 0x18, 0x0a, 0x07, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x18, 0x07,\n-\t0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x12, 0x26, 0x0a,\n-\t0x0e, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18,\n-\t0x08, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0e, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x50, 0x72, 0x6f,\n-\t0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x1a, 0x0a, 0x08, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49,\n-\t0x44, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x08, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49,\n-\t0x44, 0x12, 0x18, 0x0a, 0x07, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x49, 0x44, 0x18, 0x0a, 0x20, 0x01,\n-\t0x28, 0x09, 0x52, 0x07, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x49, 0x44, 0x22, 0xf2, 0x01, 0x0a, 0x0e,\n-\t0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x75, 0x6c, 0x65, 0x12, 0x34,\n-\t0x0a, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e,\n-\t0x32, 0x18, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75,\n-\t0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x52, 0x08, 0x70, 0x72, 0x6f, 0x74,\n-\t0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x3e, 0x0a, 0x0f, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74,\n-\t0x69, 0x6f, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e,\n-\t0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x49,\n-\t0x6e, 0x66, 0x6f, 0x52, 0x0f, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e,\n-\t0x50, 0x6f, 0x72, 0x74, 0x12, 0x2c, 0x0a, 0x11, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74,\n-\t0x65, 0x64, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52,\n-\t0x11, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74, 0x65, 0x64, 0x41, 0x64, 0x64, 0x72, 0x65,\n-\t0x73, 0x73, 0x12, 0x3c, 0x0a, 0x0e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74, 0x65, 0x64,\n-\t0x50, 0x6f, 0x72, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x61, 0x6e,\n-\t0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f,\n-\t0x52, 0x0e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74, 0x65, 0x64, 0x50, 0x6f, 0x72, 0x74,\n-\t0x2a, 0x4c, 0x0a, 0x0c, 0x52, 0x75, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c,\n-\t0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x00, 0x12, 0x07, 0x0a,\n-\t0x03, 0x41, 0x4c, 0x4c, 0x10, 0x01, 0x12, 0x07, 0x0a, 0x03, 0x54, 0x43, 0x50, 0x10, 0x02, 0x12,\n-\t0x07, 0x0a, 0x03, 0x55, 0x44, 0x50, 0x10, 0x03, 0x12, 0x08, 0x0a, 0x04, 0x49, 0x43, 0x4d, 0x50,\n-\t0x10, 0x04, 0x12, 0x0a, 0x0a, 0x06, 0x43, 0x55, 0x53, 0x54, 0x4f, 0x4d, 0x10, 0x05, 0x2a, 0x20,\n-\t0x0a, 0x0d, 0x52, 0x75, 0x6c, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12,\n-\t0x06, 0x0a, 0x02, 0x49, 0x4e, 0x10, 0x00, 0x12, 0x07, 0x0a, 0x03, 0x4f, 0x55, 0x54, 0x10, 0x01,\n-\t0x2a, 0x22, 0x0a, 0x0a, 0x52, 0x75, 0x6c, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x0a,\n-\t0x0a, 0x06, 0x41, 0x43, 0x43, 0x45, 0x50, 0x54, 0x10, 0x00, 0x12, 0x08, 0x0a, 0x04, 0x44, 0x52,\n-\t0x4f, 0x50, 0x10, 0x01, 0x32, 0xcd, 0x04, 0x0a, 0x11, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d,\n-\t0x65, 0x6e, 0x74, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x45, 0x0a, 0x05, 0x4c, 0x6f,\n-\t0x67, 0x69, 0x6e, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74,\n-\t0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67,\n-\t0x65, 0x1a, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45,\n-\t0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22,\n-\t0x00, 0x12, 0x46, 0x0a, 0x04, 0x53, 0x79, 0x6e, 0x63, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61,\n-\t0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64,\n-\t0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65,\n+\t0x69, 0x67, 0x52, 0x0c, 0x6f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65, 0x50, 0x65, 0x65, 0x72, 0x73,\n+\t0x12, 0x3e, 0x0a, 0x0d, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65,\n+\t0x73, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65,\n+\t0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c,\n+\t0x65, 0x52, 0x0d, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x73,\n+\t0x12, 0x32, 0x0a, 0x14, 0x66, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65,\n+\t0x73, 0x49, 0x73, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x52, 0x14,\n+\t0x66, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x49, 0x73, 0x45,\n+\t0x6d, 0x70, 0x74, 0x79, 0x12, 0x4f, 0x0a, 0x13, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x46, 0x69,\n+\t0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x18, 0x0a, 0x20, 0x03, 0x28,\n+\t0x0b, 0x32, 0x1d, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52,\n+\t0x6f, 0x75, 0x74, 0x65, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65,\n+\t0x52, 0x13, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c,\n+\t0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x3e, 0x0a, 0x1a, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x46,\n+\t0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x49, 0x73, 0x45, 0x6d,\n+\t0x70, 0x74, 0x79, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x08, 0x52, 0x1a, 0x72, 0x6f, 0x75, 0x74, 0x65,\n+\t0x73, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x49, 0x73,\n+\t0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x44, 0x0a, 0x0f, 0x66, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64,\n+\t0x69, 0x6e, 0x67, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x18, 0x0c, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a,\n+\t0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x46, 0x6f, 0x72, 0x77,\n+\t0x61, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x75, 0x6c, 0x65, 0x52, 0x0f, 0x66, 0x6f, 0x72, 0x77,\n+\t0x61, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x22, 0xbb, 0x01, 0x0a, 0x10,\n+\t0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,\n+\t0x12, 0x1a, 0x0a, 0x08, 0x77, 0x67, 0x50, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01,\n+\t0x28, 0x09, 0x52, 0x08, 0x77, 0x67, 0x50, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x12, 0x1e, 0x0a, 0x0a,\n+\t0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x49, 0x70, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09,\n+\t0x52, 0x0a, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x49, 0x70, 0x73, 0x12, 0x33, 0x0a, 0x09,\n+\t0x73, 0x73, 0x68, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32,\n+\t0x15, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x53, 0x48,\n+\t0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x09, 0x73, 0x73, 0x68, 0x43, 0x6f, 0x6e, 0x66, 0x69,\n+\t0x67, 0x12, 0x12, 0x0a, 0x04, 0x66, 0x71, 0x64, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52,\n+\t0x04, 0x66, 0x71, 0x64, 0x6e, 0x12, 0x22, 0x0a, 0x0c, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x56, 0x65,\n+\t0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x61, 0x67, 0x65,\n+\t0x6e, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0x7e, 0x0a, 0x09, 0x53, 0x53, 0x48,\n+\t0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x1e, 0x0a, 0x0a, 0x73, 0x73, 0x68, 0x45, 0x6e, 0x61,\n+\t0x62, 0x6c, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x73, 0x73, 0x68, 0x45,\n+\t0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x1c, 0x0a, 0x09, 0x73, 0x73, 0x68, 0x50, 0x75, 0x62,\n+\t0x4b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x09, 0x73, 0x73, 0x68, 0x50, 0x75,\n+\t0x62, 0x4b, 0x65, 0x79, 0x12, 0x33, 0x0a, 0x09, 0x6a, 0x77, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69,\n+\t0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65,\n+\t0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4a, 0x57, 0x54, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x09,\n+\t0x6a, 0x77, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x22, 0x20, 0x0a, 0x1e, 0x44, 0x65, 0x76,\n+\t0x69, 0x63, 0x65, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e,\n+\t0x46, 0x6c, 0x6f, 0x77, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0xbf, 0x01, 0x0a, 0x17,\n+\t0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74,\n+\t0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x6f, 0x77, 0x12, 0x48, 0x0a, 0x08, 0x50, 0x72, 0x6f, 0x76, 0x69,\n+\t0x64, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2c, 0x2e, 0x6d, 0x61, 0x6e, 0x61,\n+\t0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x41, 0x75, 0x74,\n+\t0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x6f, 0x77, 0x2e, 0x70,\n+\t0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x52, 0x08, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65,\n+\t0x72, 0x12, 0x42, 0x0a, 0x0e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43, 0x6f, 0x6e,\n+\t0x66, 0x69, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x6d, 0x61, 0x6e, 0x61,\n+\t0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43,\n+\t0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43,\n+\t0x6f, 0x6e, 0x66, 0x69, 0x67, 0x22, 0x16, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65,\n+\t0x72, 0x12, 0x0a, 0x0a, 0x06, 0x48, 0x4f, 0x53, 0x54, 0x45, 0x44, 0x10, 0x00, 0x22, 0x1e, 0x0a,\n+\t0x1c, 0x50, 0x4b, 0x43, 0x45, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69,\n+\t0x6f, 0x6e, 0x46, 0x6c, 0x6f, 0x77, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x5b, 0x0a,\n+\t0x15, 0x50, 0x4b, 0x43, 0x45, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69,\n+\t0x6f, 0x6e, 0x46, 0x6c, 0x6f, 0x77, 0x12, 0x42, 0x0a, 0x0e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64,\n+\t0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a,\n+\t0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x72, 0x6f, 0x76,\n+\t0x69, 0x64, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0e, 0x50, 0x72, 0x6f, 0x76,\n+\t0x69, 0x64, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x22, 0xb8, 0x03, 0x0a, 0x0e, 0x50,\n+\t0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x1a, 0x0a,\n+\t0x08, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,\n+\t0x08, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x44, 0x12, 0x22, 0x0a, 0x0c, 0x43, 0x6c, 0x69,\n+\t0x65, 0x6e, 0x74, 0x53, 0x65, 0x63, 0x72, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,\n+\t0x0c, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x53, 0x65, 0x63, 0x72, 0x65, 0x74, 0x12, 0x16, 0x0a,\n+\t0x06, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x44,\n+\t0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x12, 0x1a, 0x0a, 0x08, 0x41, 0x75, 0x64, 0x69, 0x65, 0x6e, 0x63,\n+\t0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x41, 0x75, 0x64, 0x69, 0x65, 0x6e, 0x63,\n+\t0x65, 0x12, 0x2e, 0x0a, 0x12, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x41, 0x75, 0x74, 0x68, 0x45,\n+\t0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x12, 0x44,\n+\t0x65, 0x76, 0x69, 0x63, 0x65, 0x41, 0x75, 0x74, 0x68, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e,\n+\t0x74, 0x12, 0x24, 0x0a, 0x0d, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69,\n+\t0x6e, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x45,\n+\t0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x53, 0x63, 0x6f, 0x70, 0x65,\n+\t0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x53, 0x63, 0x6f, 0x70, 0x65, 0x12, 0x1e, 0x0a,\n+\t0x0a, 0x55, 0x73, 0x65, 0x49, 0x44, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x08, 0x20, 0x01, 0x28,\n+\t0x08, 0x52, 0x0a, 0x55, 0x73, 0x65, 0x49, 0x44, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x34, 0x0a,\n+\t0x15, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e,\n+\t0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x15, 0x41, 0x75,\n+\t0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x64, 0x70, 0x6f,\n+\t0x69, 0x6e, 0x74, 0x12, 0x22, 0x0a, 0x0c, 0x52, 0x65, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x55,\n+\t0x52, 0x4c, 0x73, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0c, 0x52, 0x65, 0x64, 0x69, 0x72,\n+\t0x65, 0x63, 0x74, 0x55, 0x52, 0x4c, 0x73, 0x12, 0x2e, 0x0a, 0x12, 0x44, 0x69, 0x73, 0x61, 0x62,\n+\t0x6c, 0x65, 0x50, 0x72, 0x6f, 0x6d, 0x70, 0x74, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x18, 0x0b, 0x20,\n+\t0x01, 0x28, 0x08, 0x52, 0x12, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x6d,\n+\t0x70, 0x74, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x12, 0x1c, 0x0a, 0x09, 0x4c, 0x6f, 0x67, 0x69, 0x6e,\n+\t0x46, 0x6c, 0x61, 0x67, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x4c, 0x6f, 0x67, 0x69,\n+\t0x6e, 0x46, 0x6c, 0x61, 0x67, 0x22, 0x93, 0x02, 0x0a, 0x05, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x12,\n+\t0x0e, 0x0a, 0x02, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x49, 0x44, 0x12,\n+\t0x18, 0x0a, 0x07, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,\n+\t0x52, 0x07, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x12, 0x20, 0x0a, 0x0b, 0x4e, 0x65, 0x74,\n+\t0x77, 0x6f, 0x72, 0x6b, 0x54, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0b,\n+\t0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x54, 0x79, 0x70, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x50,\n+\t0x65, 0x65, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x50, 0x65, 0x65, 0x72, 0x12,\n+\t0x16, 0x0a, 0x06, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x18, 0x05, 0x20, 0x01, 0x28, 0x03, 0x52,\n+\t0x06, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x12, 0x1e, 0x0a, 0x0a, 0x4d, 0x61, 0x73, 0x71, 0x75,\n+\t0x65, 0x72, 0x61, 0x64, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x4d, 0x61, 0x73,\n+\t0x71, 0x75, 0x65, 0x72, 0x61, 0x64, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x4e, 0x65, 0x74, 0x49, 0x44,\n+\t0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x4e, 0x65, 0x74, 0x49, 0x44, 0x12, 0x18, 0x0a,\n+\t0x07, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x18, 0x08, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07,\n+\t0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x12, 0x1c, 0x0a, 0x09, 0x6b, 0x65, 0x65, 0x70, 0x52,\n+\t0x6f, 0x75, 0x74, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x6b, 0x65, 0x65, 0x70,\n+\t0x52, 0x6f, 0x75, 0x74, 0x65, 0x12, 0x24, 0x0a, 0x0d, 0x73, 0x6b, 0x69, 0x70, 0x41, 0x75, 0x74,\n+\t0x6f, 0x41, 0x70, 0x70, 0x6c, 0x79, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x73, 0x6b,\n+\t0x69, 0x70, 0x41, 0x75, 0x74, 0x6f, 0x41, 0x70, 0x70, 0x6c, 0x79, 0x22, 0xda, 0x01, 0x0a, 0x09,\n+\t0x44, 0x4e, 0x53, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x24, 0x0a, 0x0d, 0x53, 0x65, 0x72,\n+\t0x76, 0x69, 0x63, 0x65, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08,\n+\t0x52, 0x0d, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x12,\n+\t0x47, 0x0a, 0x10, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x47, 0x72, 0x6f,\n+\t0x75, 0x70, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x6d, 0x61, 0x6e, 0x61,\n+\t0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65,\n+\t0x72, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x52, 0x10, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76,\n+\t0x65, 0x72, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x73, 0x12, 0x38, 0x0a, 0x0b, 0x43, 0x75, 0x73, 0x74,\n+\t0x6f, 0x6d, 0x5a, 0x6f, 0x6e, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e,\n+\t0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x43, 0x75, 0x73, 0x74, 0x6f,\n+\t0x6d, 0x5a, 0x6f, 0x6e, 0x65, 0x52, 0x0b, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5a, 0x6f, 0x6e,\n+\t0x65, 0x73, 0x12, 0x24, 0x0a, 0x0d, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x65, 0x72, 0x50,\n+\t0x6f, 0x72, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0d, 0x46, 0x6f, 0x72, 0x77, 0x61,\n+\t0x72, 0x64, 0x65, 0x72, 0x50, 0x6f, 0x72, 0x74, 0x22, 0x58, 0x0a, 0x0a, 0x43, 0x75, 0x73, 0x74,\n+\t0x6f, 0x6d, 0x5a, 0x6f, 0x6e, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e,\n+\t0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x12, 0x32,\n+\t0x0a, 0x07, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32,\n+\t0x18, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x69, 0x6d,\n+\t0x70, 0x6c, 0x65, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x52, 0x07, 0x52, 0x65, 0x63, 0x6f, 0x72,\n+\t0x64, 0x73, 0x22, 0x74, 0x0a, 0x0c, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x52, 0x65, 0x63, 0x6f,\n+\t0x72, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,\n+\t0x52, 0x04, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x54, 0x79, 0x70, 0x65, 0x18, 0x02,\n+\t0x20, 0x01, 0x28, 0x03, 0x52, 0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x43, 0x6c,\n+\t0x61, 0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x43, 0x6c, 0x61, 0x73, 0x73,\n+\t0x12, 0x10, 0x0a, 0x03, 0x54, 0x54, 0x4c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x03, 0x54,\n+\t0x54, 0x4c, 0x12, 0x14, 0x0a, 0x05, 0x52, 0x44, 0x61, 0x74, 0x61, 0x18, 0x05, 0x20, 0x01, 0x28,\n+\t0x09, 0x52, 0x05, 0x52, 0x44, 0x61, 0x74, 0x61, 0x22, 0xb3, 0x01, 0x0a, 0x0f, 0x4e, 0x61, 0x6d,\n+\t0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x12, 0x38, 0x0a, 0x0b,\n+\t0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,\n+\t0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4e,\n+\t0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x52, 0x0b, 0x4e, 0x61, 0x6d, 0x65, 0x53,\n+\t0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x50, 0x72, 0x69, 0x6d, 0x61, 0x72,\n+\t0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x50, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79,\n+\t0x12, 0x18, 0x0a, 0x07, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28,\n+\t0x09, 0x52, 0x07, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x12, 0x32, 0x0a, 0x14, 0x53, 0x65,\n+\t0x61, 0x72, 0x63, 0x68, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x45, 0x6e, 0x61, 0x62, 0x6c,\n+\t0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x14, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68,\n+\t0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x22, 0x48,\n+\t0x0a, 0x0a, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x12, 0x0e, 0x0a, 0x02,\n+\t0x49, 0x50, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x49, 0x50, 0x12, 0x16, 0x0a, 0x06,\n+\t0x4e, 0x53, 0x54, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x4e, 0x53,\n+\t0x54, 0x79, 0x70, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x50, 0x6f, 0x72, 0x74, 0x18, 0x03, 0x20, 0x01,\n+\t0x28, 0x03, 0x52, 0x04, 0x50, 0x6f, 0x72, 0x74, 0x22, 0xa7, 0x02, 0x0a, 0x0c, 0x46, 0x69, 0x72,\n+\t0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x50, 0x65, 0x65,\n+\t0x72, 0x49, 0x50, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x50, 0x65, 0x65, 0x72, 0x49,\n+\t0x50, 0x12, 0x37, 0x0a, 0x09, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02,\n+\t0x20, 0x01, 0x28, 0x0e, 0x32, 0x19, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e,\n+\t0x74, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52,\n+\t0x09, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x2e, 0x0a, 0x06, 0x41, 0x63,\n+\t0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e,\n+\t0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x41, 0x63, 0x74, 0x69,\n+\t0x6f, 0x6e, 0x52, 0x06, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x34, 0x0a, 0x08, 0x50, 0x72,\n+\t0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x18, 0x2e, 0x6d,\n+\t0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x50, 0x72,\n+\t0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x52, 0x08, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c,\n+\t0x12, 0x12, 0x0a, 0x04, 0x50, 0x6f, 0x72, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,\n+\t0x50, 0x6f, 0x72, 0x74, 0x12, 0x30, 0x0a, 0x08, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f,\n+\t0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d,\n+\t0x65, 0x6e, 0x74, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x08, 0x50, 0x6f,\n+\t0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x1a, 0x0a, 0x08, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79,\n+\t0x49, 0x44, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x08, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79,\n+\t0x49, 0x44, 0x22, 0x38, 0x0a, 0x0e, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x41, 0x64, 0x64,\n+\t0x72, 0x65, 0x73, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x6e, 0x65, 0x74, 0x49, 0x50, 0x18, 0x01, 0x20,\n+\t0x01, 0x28, 0x09, 0x52, 0x05, 0x6e, 0x65, 0x74, 0x49, 0x50, 0x12, 0x10, 0x0a, 0x03, 0x6d, 0x61,\n+\t0x63, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6d, 0x61, 0x63, 0x22, 0x1e, 0x0a, 0x06,\n+\t0x43, 0x68, 0x65, 0x63, 0x6b, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x18,\n+\t0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x05, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x22, 0x96, 0x01, 0x0a,\n+\t0x08, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x14, 0x0a, 0x04, 0x70, 0x6f, 0x72,\n+\t0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x12,\n+\t0x32, 0x0a, 0x05, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a,\n+\t0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x6f, 0x72, 0x74,\n+\t0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x48, 0x00, 0x52, 0x05, 0x72, 0x61,\n+\t0x6e, 0x67, 0x65, 0x1a, 0x2f, 0x0a, 0x05, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x14, 0x0a, 0x05,\n+\t0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x05, 0x73, 0x74, 0x61,\n+\t0x72, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x65, 0x6e, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52,\n+\t0x03, 0x65, 0x6e, 0x64, 0x42, 0x0f, 0x0a, 0x0d, 0x70, 0x6f, 0x72, 0x74, 0x53, 0x65, 0x6c, 0x65,\n+\t0x63, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x87, 0x03, 0x0a, 0x11, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x46,\n+\t0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x12, 0x22, 0x0a, 0x0c, 0x73,\n+\t0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,\n+\t0x09, 0x52, 0x0c, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x12,\n+\t0x2e, 0x0a, 0x06, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32,\n+\t0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75, 0x6c,\n+\t0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x06, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12,\n+\t0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03,\n+\t0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f,\n+\t0x6e, 0x12, 0x34, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x04, 0x20,\n+\t0x01, 0x28, 0x0e, 0x32, 0x18, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74,\n+\t0x2e, 0x52, 0x75, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x52, 0x08, 0x70,\n+\t0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x30, 0x0a, 0x08, 0x70, 0x6f, 0x72, 0x74, 0x49,\n+\t0x6e, 0x66, 0x6f, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x61, 0x6e, 0x61,\n+\t0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52,\n+\t0x08, 0x70, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x1c, 0x0a, 0x09, 0x69, 0x73, 0x44,\n+\t0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x69, 0x73,\n+\t0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x12, 0x18, 0x0a, 0x07, 0x64, 0x6f, 0x6d, 0x61, 0x69,\n+\t0x6e, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e,\n+\t0x73, 0x12, 0x26, 0x0a, 0x0e, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x50, 0x72, 0x6f, 0x74, 0x6f,\n+\t0x63, 0x6f, 0x6c, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0e, 0x63, 0x75, 0x73, 0x74, 0x6f,\n+\t0x6d, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x1a, 0x0a, 0x08, 0x50, 0x6f, 0x6c,\n+\t0x69, 0x63, 0x79, 0x49, 0x44, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x08, 0x50, 0x6f, 0x6c,\n+\t0x69, 0x63, 0x79, 0x49, 0x44, 0x12, 0x18, 0x0a, 0x07, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x49, 0x44,\n+\t0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x49, 0x44, 0x22,\n+\t0xf2, 0x01, 0x0a, 0x0e, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x75,\n+\t0x6c, 0x65, 0x12, 0x34, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x01,\n+\t0x20, 0x01, 0x28, 0x0e, 0x32, 0x18, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e,\n+\t0x74, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x52, 0x08,\n+\t0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x3e, 0x0a, 0x0f, 0x64, 0x65, 0x73, 0x74,\n+\t0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28,\n+\t0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50,\n+\t0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x0f, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61,\n+\t0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x12, 0x2c, 0x0a, 0x11, 0x74, 0x72, 0x61, 0x6e,\n+\t0x73, 0x6c, 0x61, 0x74, 0x65, 0x64, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x03, 0x20,\n+\t0x01, 0x28, 0x0c, 0x52, 0x11, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74, 0x65, 0x64, 0x41,\n+\t0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x3c, 0x0a, 0x0e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6c,\n+\t0x61, 0x74, 0x65, 0x64, 0x50, 0x6f, 0x72, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14,\n+\t0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x6f, 0x72, 0x74,\n+\t0x49, 0x6e, 0x66, 0x6f, 0x52, 0x0e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74, 0x65, 0x64,\n+\t0x50, 0x6f, 0x72, 0x74, 0x2a, 0x4c, 0x0a, 0x0c, 0x52, 0x75, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74,\n+\t0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10,\n+\t0x00, 0x12, 0x07, 0x0a, 0x03, 0x41, 0x4c, 0x4c, 0x10, 0x01, 0x12, 0x07, 0x0a, 0x03, 0x54, 0x43,\n+\t0x50, 0x10, 0x02, 0x12, 0x07, 0x0a, 0x03, 0x55, 0x44, 0x50, 0x10, 0x03, 0x12, 0x08, 0x0a, 0x04,\n+\t0x49, 0x43, 0x4d, 0x50, 0x10, 0x04, 0x12, 0x0a, 0x0a, 0x06, 0x43, 0x55, 0x53, 0x54, 0x4f, 0x4d,\n+\t0x10, 0x05, 0x2a, 0x20, 0x0a, 0x0d, 0x52, 0x75, 0x6c, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74,\n+\t0x69, 0x6f, 0x6e, 0x12, 0x06, 0x0a, 0x02, 0x49, 0x4e, 0x10, 0x00, 0x12, 0x07, 0x0a, 0x03, 0x4f,\n+\t0x55, 0x54, 0x10, 0x01, 0x2a, 0x22, 0x0a, 0x0a, 0x52, 0x75, 0x6c, 0x65, 0x41, 0x63, 0x74, 0x69,\n+\t0x6f, 0x6e, 0x12, 0x0a, 0x0a, 0x06, 0x41, 0x43, 0x43, 0x45, 0x50, 0x54, 0x10, 0x00, 0x12, 0x08,\n+\t0x0a, 0x04, 0x44, 0x52, 0x4f, 0x50, 0x10, 0x01, 0x32, 0xcd, 0x04, 0x0a, 0x11, 0x4d, 0x61, 0x6e,\n+\t0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x45,\n+\t0x0a, 0x05, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65,\n \t0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65,\n-\t0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x00, 0x30, 0x01, 0x12, 0x42, 0x0a, 0x0c, 0x47, 0x65, 0x74,\n-\t0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x4b, 0x65, 0x79, 0x12, 0x11, 0x2e, 0x6d, 0x61, 0x6e, 0x61,\n-\t0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x1d, 0x2e, 0x6d,\n-\t0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72,\n-\t0x4b, 0x65, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x33, 0x0a,\n-\t0x09, 0x69, 0x73, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x79, 0x12, 0x11, 0x2e, 0x6d, 0x61, 0x6e,\n-\t0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x11, 0x2e,\n+\t0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65,\n+\t0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73,\n+\t0x61, 0x67, 0x65, 0x22, 0x00, 0x12, 0x46, 0x0a, 0x04, 0x53, 0x79, 0x6e, 0x63, 0x12, 0x1c, 0x2e,\n+\t0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79,\n+\t0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x1c, 0x2e, 0x6d, 0x61,\n+\t0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74,\n+\t0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x00, 0x30, 0x01, 0x12, 0x42, 0x0a,\n+\t0x0c, 0x47, 0x65, 0x74, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x4b, 0x65, 0x79, 0x12, 0x11, 0x2e,\n \t0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79,\n-\t0x22, 0x00, 0x12, 0x5a, 0x0a, 0x1a, 0x47, 0x65, 0x74, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x41,\n-\t0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x6f, 0x77,\n-\t0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e,\n-\t0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x1c,\n+\t0x1a, 0x1d, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x65,\n+\t0x72, 0x76, 0x65, 0x72, 0x4b, 0x65, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,\n+\t0x00, 0x12, 0x33, 0x0a, 0x09, 0x69, 0x73, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x79, 0x12, 0x11,\n+\t0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6d, 0x70, 0x74,\n+\t0x79, 0x1a, 0x11, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45,\n+\t0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x12, 0x5a, 0x0a, 0x1a, 0x47, 0x65, 0x74, 0x44, 0x65, 0x76,\n+\t0x69, 0x63, 0x65, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e,\n+\t0x46, 0x6c, 0x6f, 0x77, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e,\n+\t0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61,\n+\t0x67, 0x65, 0x1a, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e,\n+\t0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,\n+\t0x22, 0x00, 0x12, 0x58, 0x0a, 0x18, 0x47, 0x65, 0x74, 0x50, 0x4b, 0x43, 0x45, 0x41, 0x75, 0x74,\n+\t0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x6f, 0x77, 0x12, 0x1c,\n \t0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72,\n-\t0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x00, 0x12, 0x58,\n-\t0x0a, 0x18, 0x47, 0x65, 0x74, 0x50, 0x4b, 0x43, 0x45, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69,\n-\t0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x6f, 0x77, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e,\n-\t0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65,\n-\t0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67,\n+\t0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x1c, 0x2e, 0x6d,\n+\t0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70,\n+\t0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x00, 0x12, 0x3d, 0x0a, 0x08,\n+\t0x53, 0x79, 0x6e, 0x63, 0x4d, 0x65, 0x74, 0x61, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67,\n \t0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d,\n-\t0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x00, 0x12, 0x3d, 0x0a, 0x08, 0x53, 0x79, 0x6e, 0x63,\n-\t0x4d, 0x65, 0x74, 0x61, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e,\n-\t0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61,\n-\t0x67, 0x65, 0x1a, 0x11, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e,\n-\t0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x12, 0x3b, 0x0a, 0x06, 0x4c, 0x6f, 0x67, 0x6f, 0x75,\n-\t0x74, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45,\n-\t0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a,\n-\t0x11, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6d, 0x70,\n-\t0x74, 0x79, 0x22, 0x00, 0x42, 0x08, 0x5a, 0x06, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x06,\n-\t0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,\n+\t0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x11, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d,\n+\t0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x12, 0x3b, 0x0a, 0x06, 0x4c,\n+\t0x6f, 0x67, 0x6f, 0x75, 0x74, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65,\n+\t0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73,\n+\t0x61, 0x67, 0x65, 0x1a, 0x11, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74,\n+\t0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x42, 0x08, 0x5a, 0x06, 0x2f, 0x70, 0x72, 0x6f,\n+\t0x74, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,\n }\n \n var (\n@@ -3910,7 +4067,7 @@ func file_management_proto_rawDescGZIP() []byte {\n }\n \n var file_management_proto_enumTypes = make([]protoimpl.EnumInfo, 5)\n-var file_management_proto_msgTypes = make([]protoimpl.MessageInfo, 40)\n+var file_management_proto_msgTypes = make([]protoimpl.MessageInfo, 41)\n var file_management_proto_goTypes = []interface{}{\n \t(RuleProtocol)(0),                      // 0: management.RuleProtocol\n \t(RuleDirection)(0),                     // 1: management.RuleDirection\n@@ -3934,107 +4091,110 @@ var file_management_proto_goTypes = []interface{}{\n \t(*HostConfig)(nil),                     // 19: management.HostConfig\n \t(*RelayConfig)(nil),                    // 20: management.RelayConfig\n \t(*FlowConfig)(nil),                     // 21: management.FlowConfig\n-\t(*ProtectedHostConfig)(nil),            // 22: management.ProtectedHostConfig\n-\t(*PeerConfig)(nil),                     // 23: management.PeerConfig\n-\t(*NetworkMap)(nil),                     // 24: management.NetworkMap\n-\t(*RemotePeerConfig)(nil),               // 25: management.RemotePeerConfig\n-\t(*SSHConfig)(nil),                      // 26: management.SSHConfig\n-\t(*DeviceAuthorizationFlowRequest)(nil), // 27: management.DeviceAuthorizationFlowRequest\n-\t(*DeviceAuthorizationFlow)(nil),        // 28: management.DeviceAuthorizationFlow\n-\t(*PKCEAuthorizationFlowRequest)(nil),   // 29: management.PKCEAuthorizationFlowRequest\n-\t(*PKCEAuthorizationFlow)(nil),          // 30: management.PKCEAuthorizationFlow\n-\t(*ProviderConfig)(nil),                 // 31: management.ProviderConfig\n-\t(*Route)(nil),                          // 32: management.Route\n-\t(*DNSConfig)(nil),                      // 33: management.DNSConfig\n-\t(*CustomZone)(nil),                     // 34: management.CustomZone\n-\t(*SimpleRecord)(nil),                   // 35: management.SimpleRecord\n-\t(*NameServerGroup)(nil),                // 36: management.NameServerGroup\n-\t(*NameServer)(nil),                     // 37: management.NameServer\n-\t(*FirewallRule)(nil),                   // 38: management.FirewallRule\n-\t(*NetworkAddress)(nil),                 // 39: management.NetworkAddress\n-\t(*Checks)(nil),                         // 40: management.Checks\n-\t(*PortInfo)(nil),                       // 41: management.PortInfo\n-\t(*RouteFirewallRule)(nil),              // 42: management.RouteFirewallRule\n-\t(*ForwardingRule)(nil),                 // 43: management.ForwardingRule\n-\t(*PortInfo_Range)(nil),                 // 44: management.PortInfo.Range\n-\t(*timestamppb.Timestamp)(nil),          // 45: google.protobuf.Timestamp\n-\t(*durationpb.Duration)(nil),            // 46: google.protobuf.Duration\n+\t(*JWTConfig)(nil),                      // 22: management.JWTConfig\n+\t(*ProtectedHostConfig)(nil),            // 23: management.ProtectedHostConfig\n+\t(*PeerConfig)(nil),                     // 24: management.PeerConfig\n+\t(*NetworkMap)(nil),                     // 25: management.NetworkMap\n+\t(*RemotePeerConfig)(nil),               // 26: management.RemotePeerConfig\n+\t(*SSHConfig)(nil),                      // 27: management.SSHConfig\n+\t(*DeviceAuthorizationFlowRequest)(nil), // 28: management.DeviceAuthorizationFlowRequest\n+\t(*DeviceAuthorizationFlow)(nil),        // 29: management.DeviceAuthorizationFlow\n+\t(*PKCEAuthorizationFlowRequest)(nil),   // 30: management.PKCEAuthorizationFlowRequest\n+\t(*PKCEAuthorizationFlow)(nil),          // 31: management.PKCEAuthorizationFlow\n+\t(*ProviderConfig)(nil),                 // 32: management.ProviderConfig\n+\t(*Route)(nil),                          // 33: management.Route\n+\t(*DNSConfig)(nil),                      // 34: management.DNSConfig\n+\t(*CustomZone)(nil),                     // 35: management.CustomZone\n+\t(*SimpleRecord)(nil),                   // 36: management.SimpleRecord\n+\t(*NameServerGroup)(nil),                // 37: management.NameServerGroup\n+\t(*NameServer)(nil),                     // 38: management.NameServer\n+\t(*FirewallRule)(nil),                   // 39: management.FirewallRule\n+\t(*NetworkAddress)(nil),                 // 40: management.NetworkAddress\n+\t(*Checks)(nil),                         // 41: management.Checks\n+\t(*PortInfo)(nil),                       // 42: management.PortInfo\n+\t(*RouteFirewallRule)(nil),              // 43: management.RouteFirewallRule\n+\t(*ForwardingRule)(nil),                 // 44: management.ForwardingRule\n+\t(*PortInfo_Range)(nil),                 // 45: management.PortInfo.Range\n+\t(*timestamppb.Timestamp)(nil),          // 46: google.protobuf.Timestamp\n+\t(*durationpb.Duration)(nil),            // 47: google.protobuf.Duration\n }\n var file_management_proto_depIdxs = []int32{\n \t14, // 0: management.SyncRequest.meta:type_name -> management.PeerSystemMeta\n \t18, // 1: management.SyncResponse.netbirdConfig:type_name -> management.NetbirdConfig\n-\t23, // 2: management.SyncResponse.peerConfig:type_name -> management.PeerConfig\n-\t25, // 3: management.SyncResponse.remotePeers:type_name -> management.RemotePeerConfig\n-\t24, // 4: management.SyncResponse.NetworkMap:type_name -> management.NetworkMap\n-\t40, // 5: management.SyncResponse.Checks:type_name -> management.Checks\n+\t24, // 2: management.SyncResponse.peerConfig:type_name -> management.PeerConfig\n+\t26, // 3: management.SyncResponse.remotePeers:type_name -> management.RemotePeerConfig\n+\t25, // 4: management.SyncResponse.NetworkMap:type_name -> management.NetworkMap\n+\t41, // 5: management.SyncResponse.Checks:type_name -> management.Checks\n \t14, // 6: management.SyncMetaRequest.meta:type_name -> management.PeerSystemMeta\n \t14, // 7: management.LoginRequest.meta:type_name -> management.PeerSystemMeta\n \t10, // 8: management.LoginRequest.peerKeys:type_name -> management.PeerKeys\n-\t39, // 9: management.PeerSystemMeta.networkAddresses:type_name -> management.NetworkAddress\n+\t40, // 9: management.PeerSystemMeta.networkAddresses:type_name -> management.NetworkAddress\n \t11, // 10: management.PeerSystemMeta.environment:type_name -> management.Environment\n \t12, // 11: management.PeerSystemMeta.files:type_name -> management.File\n \t13, // 12: management.PeerSystemMeta.flags:type_name -> management.Flags\n \t18, // 13: management.LoginResponse.netbirdConfig:type_name -> management.NetbirdConfig\n-\t23, // 14: management.LoginResponse.peerConfig:type_name -> management.PeerConfig\n-\t40, // 15: management.LoginResponse.Checks:type_name -> management.Checks\n-\t45, // 16: management.ServerKeyResponse.expiresAt:type_name -> google.protobuf.Timestamp\n+\t24, // 14: management.LoginResponse.peerConfig:type_name -> management.PeerConfig\n+\t41, // 15: management.LoginResponse.Checks:type_name -> management.Checks\n+\t46, // 16: management.ServerKeyResponse.expiresAt:type_name -> google.protobuf.Timestamp\n \t19, // 17: management.NetbirdConfig.stuns:type_name -> management.HostConfig\n-\t22, // 18: management.NetbirdConfig.turns:type_name -> management.ProtectedHostConfig\n+\t23, // 18: management.NetbirdConfig.turns:type_name -> management.ProtectedHostConfig\n \t19, // 19: management.NetbirdConfig.signal:type_name -> management.HostConfig\n \t20, // 20: management.NetbirdConfig.relay:type_name -> management.RelayConfig\n \t21, // 21: management.NetbirdConfig.flow:type_name -> management.FlowConfig\n-\t3,  // 22: management.HostConfig.protocol:type_name -> management.HostConfig.Protocol\n-\t46, // 23: management.FlowConfig.interval:type_name -> google.protobuf.Duration\n-\t19, // 24: management.ProtectedHostConfig.hostConfig:type_name -> management.HostConfig\n-\t26, // 25: management.PeerConfig.sshConfig:type_name -> management.SSHConfig\n-\t23, // 26: management.NetworkMap.peerConfig:type_name -> management.PeerConfig\n-\t25, // 27: management.NetworkMap.remotePeers:type_name -> management.RemotePeerConfig\n-\t32, // 28: management.NetworkMap.Routes:type_name -> management.Route\n-\t33, // 29: management.NetworkMap.DNSConfig:type_name -> management.DNSConfig\n-\t25, // 30: management.NetworkMap.offlinePeers:type_name -> management.RemotePeerConfig\n-\t38, // 31: management.NetworkMap.FirewallRules:type_name -> management.FirewallRule\n-\t42, // 32: management.NetworkMap.routesFirewallRules:type_name -> management.RouteFirewallRule\n-\t43, // 33: management.NetworkMap.forwardingRules:type_name -> management.ForwardingRule\n-\t26, // 34: management.RemotePeerConfig.sshConfig:type_name -> management.SSHConfig\n-\t4,  // 35: management.DeviceAuthorizationFlow.Provider:type_name -> management.DeviceAuthorizationFlow.provider\n-\t31, // 36: management.DeviceAuthorizationFlow.ProviderConfig:type_name -> management.ProviderConfig\n-\t31, // 37: management.PKCEAuthorizationFlow.ProviderConfig:type_name -> management.ProviderConfig\n-\t36, // 38: management.DNSConfig.NameServerGroups:type_name -> management.NameServerGroup\n-\t34, // 39: management.DNSConfig.CustomZones:type_name -> management.CustomZone\n-\t35, // 40: management.CustomZone.Records:type_name -> management.SimpleRecord\n-\t37, // 41: management.NameServerGroup.NameServers:type_name -> management.NameServer\n-\t1,  // 42: management.FirewallRule.Direction:type_name -> management.RuleDirection\n-\t2,  // 43: management.FirewallRule.Action:type_name -> management.RuleAction\n-\t0,  // 44: management.FirewallRule.Protocol:type_name -> management.RuleProtocol\n-\t41, // 45: management.FirewallRule.PortInfo:type_name -> management.PortInfo\n-\t44, // 46: management.PortInfo.range:type_name -> management.PortInfo.Range\n-\t2,  // 47: management.RouteFirewallRule.action:type_name -> management.RuleAction\n-\t0,  // 48: management.RouteFirewallRule.protocol:type_name -> management.RuleProtocol\n-\t41, // 49: management.RouteFirewallRule.portInfo:type_name -> management.PortInfo\n-\t0,  // 50: management.ForwardingRule.protocol:type_name -> management.RuleProtocol\n-\t41, // 51: management.ForwardingRule.destinationPort:type_name -> management.PortInfo\n-\t41, // 52: management.ForwardingRule.translatedPort:type_name -> management.PortInfo\n-\t5,  // 53: management.ManagementService.Login:input_type -> management.EncryptedMessage\n-\t5,  // 54: management.ManagementService.Sync:input_type -> management.EncryptedMessage\n-\t17, // 55: management.ManagementService.GetServerKey:input_type -> management.Empty\n-\t17, // 56: management.ManagementService.isHealthy:input_type -> management.Empty\n-\t5,  // 57: management.ManagementService.GetDeviceAuthorizationFlow:input_type -> management.EncryptedMessage\n-\t5,  // 58: management.ManagementService.GetPKCEAuthorizationFlow:input_type -> management.EncryptedMessage\n-\t5,  // 59: management.ManagementService.SyncMeta:input_type -> management.EncryptedMessage\n-\t5,  // 60: management.ManagementService.Logout:input_type -> management.EncryptedMessage\n-\t5,  // 61: management.ManagementService.Login:output_type -> management.EncryptedMessage\n-\t5,  // 62: management.ManagementService.Sync:output_type -> management.EncryptedMessage\n-\t16, // 63: management.ManagementService.GetServerKey:output_type -> management.ServerKeyResponse\n-\t17, // 64: management.ManagementService.isHealthy:output_type -> management.Empty\n-\t5,  // 65: management.ManagementService.GetDeviceAuthorizationFlow:output_type -> management.EncryptedMessage\n-\t5,  // 66: management.ManagementService.GetPKCEAuthorizationFlow:output_type -> management.EncryptedMessage\n-\t17, // 67: management.ManagementService.SyncMeta:output_type -> management.Empty\n-\t17, // 68: management.ManagementService.Logout:output_type -> management.Empty\n-\t61, // [61:69] is the sub-list for method output_type\n-\t53, // [53:61] is the sub-list for method input_type\n-\t53, // [53:53] is the sub-list for extension type_name\n-\t53, // [53:53] is the sub-list for extension extendee\n-\t0,  // [0:53] is the sub-list for field type_name\n+\t22, // 22: management.NetbirdConfig.jwt:type_name -> management.JWTConfig\n+\t3,  // 23: management.HostConfig.protocol:type_name -> management.HostConfig.Protocol\n+\t47, // 24: management.FlowConfig.interval:type_name -> google.protobuf.Duration\n+\t19, // 25: management.ProtectedHostConfig.hostConfig:type_name -> management.HostConfig\n+\t27, // 26: management.PeerConfig.sshConfig:type_name -> management.SSHConfig\n+\t24, // 27: management.NetworkMap.peerConfig:type_name -> management.PeerConfig\n+\t26, // 28: management.NetworkMap.remotePeers:type_name -> management.RemotePeerConfig\n+\t33, // 29: management.NetworkMap.Routes:type_name -> management.Route\n+\t34, // 30: management.NetworkMap.DNSConfig:type_name -> management.DNSConfig\n+\t26, // 31: management.NetworkMap.offlinePeers:type_name -> management.RemotePeerConfig\n+\t39, // 32: management.NetworkMap.FirewallRules:type_name -> management.FirewallRule\n+\t43, // 33: management.NetworkMap.routesFirewallRules:type_name -> management.RouteFirewallRule\n+\t44, // 34: management.NetworkMap.forwardingRules:type_name -> management.ForwardingRule\n+\t27, // 35: management.RemotePeerConfig.sshConfig:type_name -> management.SSHConfig\n+\t22, // 36: management.SSHConfig.jwtConfig:type_name -> management.JWTConfig\n+\t4,  // 37: management.DeviceAuthorizationFlow.Provider:type_name -> management.DeviceAuthorizationFlow.provider\n+\t32, // 38: management.DeviceAuthorizationFlow.ProviderConfig:type_name -> management.ProviderConfig\n+\t32, // 39: management.PKCEAuthorizationFlow.ProviderConfig:type_name -> management.ProviderConfig\n+\t37, // 40: management.DNSConfig.NameServerGroups:type_name -> management.NameServerGroup\n+\t35, // 41: management.DNSConfig.CustomZones:type_name -> management.CustomZone\n+\t36, // 42: management.CustomZone.Records:type_name -> management.SimpleRecord\n+\t38, // 43: management.NameServerGroup.NameServers:type_name -> management.NameServer\n+\t1,  // 44: management.FirewallRule.Direction:type_name -> management.RuleDirection\n+\t2,  // 45: management.FirewallRule.Action:type_name -> management.RuleAction\n+\t0,  // 46: management.FirewallRule.Protocol:type_name -> management.RuleProtocol\n+\t42, // 47: management.FirewallRule.PortInfo:type_name -> management.PortInfo\n+\t45, // 48: management.PortInfo.range:type_name -> management.PortInfo.Range\n+\t2,  // 49: management.RouteFirewallRule.action:type_name -> management.RuleAction\n+\t0,  // 50: management.RouteFirewallRule.protocol:type_name -> management.RuleProtocol\n+\t42, // 51: management.RouteFirewallRule.portInfo:type_name -> management.PortInfo\n+\t0,  // 52: management.ForwardingRule.protocol:type_name -> management.RuleProtocol\n+\t42, // 53: management.ForwardingRule.destinationPort:type_name -> management.PortInfo\n+\t42, // 54: management.ForwardingRule.translatedPort:type_name -> management.PortInfo\n+\t5,  // 55: management.ManagementService.Login:input_type -> management.EncryptedMessage\n+\t5,  // 56: management.ManagementService.Sync:input_type -> management.EncryptedMessage\n+\t17, // 57: management.ManagementService.GetServerKey:input_type -> management.Empty\n+\t17, // 58: management.ManagementService.isHealthy:input_type -> management.Empty\n+\t5,  // 59: management.ManagementService.GetDeviceAuthorizationFlow:input_type -> management.EncryptedMessage\n+\t5,  // 60: management.ManagementService.GetPKCEAuthorizationFlow:input_type -> management.EncryptedMessage\n+\t5,  // 61: management.ManagementService.SyncMeta:input_type -> management.EncryptedMessage\n+\t5,  // 62: management.ManagementService.Logout:input_type -> management.EncryptedMessage\n+\t5,  // 63: management.ManagementService.Login:output_type -> management.EncryptedMessage\n+\t5,  // 64: management.ManagementService.Sync:output_type -> management.EncryptedMessage\n+\t16, // 65: management.ManagementService.GetServerKey:output_type -> management.ServerKeyResponse\n+\t17, // 66: management.ManagementService.isHealthy:output_type -> management.Empty\n+\t5,  // 67: management.ManagementService.GetDeviceAuthorizationFlow:output_type -> management.EncryptedMessage\n+\t5,  // 68: management.ManagementService.GetPKCEAuthorizationFlow:output_type -> management.EncryptedMessage\n+\t17, // 69: management.ManagementService.SyncMeta:output_type -> management.Empty\n+\t17, // 70: management.ManagementService.Logout:output_type -> management.Empty\n+\t63, // [63:71] is the sub-list for method output_type\n+\t55, // [55:63] is the sub-list for method input_type\n+\t55, // [55:55] is the sub-list for extension type_name\n+\t55, // [55:55] is the sub-list for extension extendee\n+\t0,  // [0:55] is the sub-list for field type_name\n }\n \n func init() { file_management_proto_init() }\n@@ -4248,7 +4408,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*ProtectedHostConfig); i {\n+\t\t\tswitch v := v.(*JWTConfig); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4260,7 +4420,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*PeerConfig); i {\n+\t\t\tswitch v := v.(*ProtectedHostConfig); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4272,7 +4432,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*NetworkMap); i {\n+\t\t\tswitch v := v.(*PeerConfig); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4284,7 +4444,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*RemotePeerConfig); i {\n+\t\t\tswitch v := v.(*NetworkMap); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4296,7 +4456,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*SSHConfig); i {\n+\t\t\tswitch v := v.(*RemotePeerConfig); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4308,7 +4468,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*DeviceAuthorizationFlowRequest); i {\n+\t\t\tswitch v := v.(*SSHConfig); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4320,7 +4480,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*DeviceAuthorizationFlow); i {\n+\t\t\tswitch v := v.(*DeviceAuthorizationFlowRequest); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4332,7 +4492,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*PKCEAuthorizationFlowRequest); i {\n+\t\t\tswitch v := v.(*DeviceAuthorizationFlow); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4344,7 +4504,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*PKCEAuthorizationFlow); i {\n+\t\t\tswitch v := v.(*PKCEAuthorizationFlowRequest); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4356,7 +4516,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[26].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*ProviderConfig); i {\n+\t\t\tswitch v := v.(*PKCEAuthorizationFlow); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4368,7 +4528,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[27].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*Route); i {\n+\t\t\tswitch v := v.(*ProviderConfig); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4380,7 +4540,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[28].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*DNSConfig); i {\n+\t\t\tswitch v := v.(*Route); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4392,7 +4552,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[29].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*CustomZone); i {\n+\t\t\tswitch v := v.(*DNSConfig); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4404,7 +4564,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[30].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*SimpleRecord); i {\n+\t\t\tswitch v := v.(*CustomZone); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4416,7 +4576,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[31].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*NameServerGroup); i {\n+\t\t\tswitch v := v.(*SimpleRecord); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4428,7 +4588,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[32].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*NameServer); i {\n+\t\t\tswitch v := v.(*NameServerGroup); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4440,7 +4600,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[33].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*FirewallRule); i {\n+\t\t\tswitch v := v.(*NameServer); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4452,7 +4612,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[34].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*NetworkAddress); i {\n+\t\t\tswitch v := v.(*FirewallRule); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4464,7 +4624,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[35].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*Checks); i {\n+\t\t\tswitch v := v.(*NetworkAddress); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4476,7 +4636,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[36].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*PortInfo); i {\n+\t\t\tswitch v := v.(*Checks); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4488,7 +4648,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[37].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*RouteFirewallRule); i {\n+\t\t\tswitch v := v.(*PortInfo); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4500,7 +4660,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[38].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*ForwardingRule); i {\n+\t\t\tswitch v := v.(*RouteFirewallRule); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4512,6 +4672,18 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[39].Exporter = func(v interface{}, i int) interface{} {\n+\t\t\tswitch v := v.(*ForwardingRule); i {\n+\t\t\tcase 0:\n+\t\t\t\treturn &v.state\n+\t\t\tcase 1:\n+\t\t\t\treturn &v.sizeCache\n+\t\t\tcase 2:\n+\t\t\t\treturn &v.unknownFields\n+\t\t\tdefault:\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t}\n+\t\tfile_management_proto_msgTypes[40].Exporter = func(v interface{}, i int) interface{} {\n \t\t\tswitch v := v.(*PortInfo_Range); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n@@ -4524,7 +4696,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t}\n-\tfile_management_proto_msgTypes[36].OneofWrappers = []interface{}{\n+\tfile_management_proto_msgTypes[37].OneofWrappers = []interface{}{\n \t\t(*PortInfo_Port)(nil),\n \t\t(*PortInfo_Range_)(nil),\n \t}\n@@ -4534,7 +4706,7 @@ func file_management_proto_init() {\n \t\t\tGoPackagePath: reflect.TypeOf(x{}).PkgPath(),\n \t\t\tRawDescriptor: file_management_proto_rawDesc,\n \t\t\tNumEnums:      5,\n-\t\t\tNumMessages:   40,\n+\t\t\tNumMessages:   41,\n \t\t\tNumExtensions: 0,\n \t\t\tNumServices:   1,\n \t\t},\ndiff --git a/shared/management/proto/management.proto b/shared/management/proto/management.proto\nindex 3982ea2af11..16737cf5898 100644\n--- a/shared/management/proto/management.proto\n+++ b/shared/management/proto/management.proto\n@@ -146,6 +146,12 @@ message Flags {\n   bool blockInbound = 9;\n \n   bool lazyConnectionEnabled = 10;\n+\n+  bool enableSSHRoot = 11;\n+  bool enableSSHSFTP = 12;\n+  bool enableSSHLocalPortForwarding = 13;\n+  bool enableSSHRemotePortForwarding = 14;\n+  bool disableSSHAuth = 15;\n }\n \n // PeerSystemMeta is machine meta data like OS and version.\n@@ -202,6 +208,8 @@ message NetbirdConfig {\n   RelayConfig relay = 4;\n \n   FlowConfig flow = 5;\n+\n+  JWTConfig jwt = 6;\n }\n \n // HostConfig describes connection properties of some server (e.g. STUN, Signal, Management)\n@@ -240,6 +248,14 @@ message FlowConfig {\n   bool dnsCollection = 8;\n }\n \n+// JWTConfig represents JWT authentication configuration\n+message JWTConfig {\n+  string issuer = 1;\n+  string audience = 2;\n+  string keysLocation = 3;\n+  int64 maxTokenAge = 4;\n+}\n+\n // ProtectedHostConfig is similar to HostConfig but has additional user and password\n // Mostly used for TURN servers\n message ProtectedHostConfig {\n@@ -335,6 +351,8 @@ message SSHConfig {\n   // sshPubKey is a SSH public key of a peer to be added to authorized_hosts.\n   // This property should be ignore if SSHConfig comes from PeerConfig.\n   bytes sshPubKey = 2;\n+\n+  JWTConfig jwtConfig = 3;\n }\n \n // DeviceAuthorizationFlowRequest empty struct for future expansion\ndiff --git a/shared/relay/client/dialer/quic/quic.go b/shared/relay/client/dialer/quic/quic.go\nindex 967e18d799a..c057ef08960 100644\n--- a/shared/relay/client/dialer/quic/quic.go\n+++ b/shared/relay/client/dialer/quic/quic.go\n@@ -11,8 +11,8 @@ import (\n \t\"github.com/quic-go/quic-go\"\n \tlog \"github.com/sirupsen/logrus\"\n \n-\tquictls \"github.com/netbirdio/netbird/shared/relay/tls\"\n \tnbnet \"github.com/netbirdio/netbird/client/net\"\n+\tquictls \"github.com/netbirdio/netbird/shared/relay/tls\"\n )\n \n type Dialer struct {\ndiff --git a/shared/relay/client/dialer/ws/ws.go b/shared/relay/client/dialer/ws/ws.go\nindex 66fff344773..37b189e05c5 100644\n--- a/shared/relay/client/dialer/ws/ws.go\n+++ b/shared/relay/client/dialer/ws/ws.go\n@@ -14,9 +14,9 @@ import (\n \t\"github.com/coder/websocket\"\n \tlog \"github.com/sirupsen/logrus\"\n \n+\tnbnet \"github.com/netbirdio/netbird/client/net\"\n \t\"github.com/netbirdio/netbird/shared/relay\"\n \t\"github.com/netbirdio/netbird/util/embeddedroots\"\n-\tnbnet \"github.com/netbirdio/netbird/client/net\"\n )\n \n type Dialer struct {\ndiff --git a/shared/relay/constants.go b/shared/relay/constants.go\nindex 3c7c3cd296e..0f2a276103c 100644\n--- a/shared/relay/constants.go\n+++ b/shared/relay/constants.go\n@@ -3,4 +3,4 @@ package relay\n const (\n \t// WebSocketURLPath is the path for the websocket relay connection\n \tWebSocketURLPath = \"/relay\"\n-)\n\\ No newline at end of file\n+)\ndiff --git a/version/url_windows.go b/version/url_windows.go\nindex 14fdb7ae638..a0fb6e5dd5f 100644\n--- a/version/url_windows.go\n+++ b/version/url_windows.go\n@@ -6,7 +6,7 @@ import (\n )\n \n const (\n-\turlWinExe = \"https://pkgs.netbird.io/windows/x64\"\n+\turlWinExe    = \"https://pkgs.netbird.io/windows/x64\"\n \turlWinExeArm = \"https://pkgs.netbird.io/windows/arm64\"\n )\n \n@@ -18,11 +18,11 @@ func DownloadUrl() string {\n \tif err != nil {\n \t\treturn downloadURL\n \t}\n-\t\n+\n \turl := urlWinExe\n \tif runtime.GOARCH == \"arm64\" {\n \t\turl = urlWinExeArm\n \t}\n-\t\n+\n \treturn url\n }\n", "test_patch": "diff --git a/client/cmd/ssh_test.go b/client/cmd/ssh_test.go\nnew file mode 100644\nindex 00000000000..43291fa87c1\n--- /dev/null\n+++ b/client/cmd/ssh_test.go\n@@ -0,0 +1,717 @@\n+package cmd\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+func TestSSHCommand_FlagParsing(t *testing.T) {\n+\ttests := []struct {\n+\t\tname         string\n+\t\targs         []string\n+\t\texpectedHost string\n+\t\texpectedUser string\n+\t\texpectedPort int\n+\t\texpectedCmd  string\n+\t\texpectError  bool\n+\t}{\n+\t\t{\n+\t\t\tname:         \"basic host\",\n+\t\t\targs:         []string{\"hostname\"},\n+\t\t\texpectedHost: \"hostname\",\n+\t\t\texpectedUser: \"\",\n+\t\t\texpectedPort: 22,\n+\t\t\texpectedCmd:  \"\",\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"user@host format\",\n+\t\t\targs:         []string{\"user@hostname\"},\n+\t\t\texpectedHost: \"hostname\",\n+\t\t\texpectedUser: \"user\",\n+\t\t\texpectedPort: 22,\n+\t\t\texpectedCmd:  \"\",\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"host with command\",\n+\t\t\targs:         []string{\"hostname\", \"echo\", \"hello\"},\n+\t\t\texpectedHost: \"hostname\",\n+\t\t\texpectedUser: \"\",\n+\t\t\texpectedPort: 22,\n+\t\t\texpectedCmd:  \"echo hello\",\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"command with flags should be preserved\",\n+\t\t\targs:         []string{\"hostname\", \"ls\", \"-la\", \"/tmp\"},\n+\t\t\texpectedHost: \"hostname\",\n+\t\t\texpectedUser: \"\",\n+\t\t\texpectedPort: 22,\n+\t\t\texpectedCmd:  \"ls -la /tmp\",\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"double dash separator\",\n+\t\t\targs:         []string{\"hostname\", \"--\", \"ls\", \"-la\"},\n+\t\t\texpectedHost: \"hostname\",\n+\t\t\texpectedUser: \"\",\n+\t\t\texpectedPort: 22,\n+\t\t\texpectedCmd:  \"-- ls -la\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Reset global variables\n+\t\t\thost = \"\"\n+\t\t\tusername = \"\"\n+\t\t\tport = 22\n+\t\t\tcommand = \"\"\n+\n+\t\t\t// Mock command for testing\n+\t\t\tcmd := sshCmd\n+\t\t\tcmd.SetArgs(tt.args)\n+\n+\t\t\terr := validateSSHArgsWithoutFlagParsing(cmd, tt.args)\n+\n+\t\t\tif tt.expectError {\n+\t\t\t\tassert.Error(t, err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\trequire.NoError(t, err, \"SSH args validation should succeed for valid input\")\n+\t\t\tassert.Equal(t, tt.expectedHost, host, \"host mismatch\")\n+\t\t\tif tt.expectedUser != \"\" {\n+\t\t\t\tassert.Equal(t, tt.expectedUser, username, \"username mismatch\")\n+\t\t\t}\n+\t\t\tassert.Equal(t, tt.expectedPort, port, \"port mismatch\")\n+\t\t\tassert.Equal(t, tt.expectedCmd, command, \"command mismatch\")\n+\t\t})\n+\t}\n+}\n+\n+func TestSSHCommand_FlagConflictPrevention(t *testing.T) {\n+\t// Test that SSH flags don't conflict with command flags\n+\ttests := []struct {\n+\t\tname        string\n+\t\targs        []string\n+\t\texpectedCmd string\n+\t\tdescription string\n+\t}{\n+\t\t{\n+\t\t\tname:        \"ls with -la flags\",\n+\t\t\targs:        []string{\"hostname\", \"ls\", \"-la\"},\n+\t\t\texpectedCmd: \"ls -la\",\n+\t\t\tdescription: \"ls flags should be passed to remote command\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"grep with -r flag\",\n+\t\t\targs:        []string{\"hostname\", \"grep\", \"-r\", \"pattern\", \"/path\"},\n+\t\t\texpectedCmd: \"grep -r pattern /path\",\n+\t\t\tdescription: \"grep flags should be passed to remote command\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"ps with aux flags\",\n+\t\t\targs:        []string{\"hostname\", \"ps\", \"aux\"},\n+\t\t\texpectedCmd: \"ps aux\",\n+\t\t\tdescription: \"ps flags should be passed to remote command\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"command with double dash\",\n+\t\t\targs:        []string{\"hostname\", \"--\", \"ls\", \"-la\"},\n+\t\t\texpectedCmd: \"-- ls -la\",\n+\t\t\tdescription: \"double dash should be preserved in command\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Reset global variables\n+\t\t\thost = \"\"\n+\t\t\tusername = \"\"\n+\t\t\tport = 22\n+\t\t\tcommand = \"\"\n+\n+\t\t\tcmd := sshCmd\n+\t\t\terr := validateSSHArgsWithoutFlagParsing(cmd, tt.args)\n+\t\t\trequire.NoError(t, err, \"SSH args validation should succeed for valid input\")\n+\n+\t\t\tassert.Equal(t, tt.expectedCmd, command, tt.description)\n+\t\t})\n+\t}\n+}\n+\n+func TestSSHCommand_NonInteractiveExecution(t *testing.T) {\n+\t// Test that commands with arguments should execute the command and exit,\n+\t// not drop to an interactive shell\n+\ttests := []struct {\n+\t\tname        string\n+\t\targs        []string\n+\t\texpectedCmd string\n+\t\tshouldExit  bool\n+\t\tdescription string\n+\t}{\n+\t\t{\n+\t\t\tname:        \"ls command should execute and exit\",\n+\t\t\targs:        []string{\"hostname\", \"ls\"},\n+\t\t\texpectedCmd: \"ls\",\n+\t\t\tshouldExit:  true,\n+\t\t\tdescription: \"ls command should execute and exit, not drop to shell\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"ls with flags should execute and exit\",\n+\t\t\targs:        []string{\"hostname\", \"ls\", \"-la\"},\n+\t\t\texpectedCmd: \"ls -la\",\n+\t\t\tshouldExit:  true,\n+\t\t\tdescription: \"ls with flags should execute and exit, not drop to shell\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"pwd command should execute and exit\",\n+\t\t\targs:        []string{\"hostname\", \"pwd\"},\n+\t\t\texpectedCmd: \"pwd\",\n+\t\t\tshouldExit:  true,\n+\t\t\tdescription: \"pwd command should execute and exit, not drop to shell\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"echo command should execute and exit\",\n+\t\t\targs:        []string{\"hostname\", \"echo\", \"hello\"},\n+\t\t\texpectedCmd: \"echo hello\",\n+\t\t\tshouldExit:  true,\n+\t\t\tdescription: \"echo command should execute and exit, not drop to shell\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"no command should open shell\",\n+\t\t\targs:        []string{\"hostname\"},\n+\t\t\texpectedCmd: \"\",\n+\t\t\tshouldExit:  false,\n+\t\t\tdescription: \"no command should open interactive shell\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Reset global variables\n+\t\t\thost = \"\"\n+\t\t\tusername = \"\"\n+\t\t\tport = 22\n+\t\t\tcommand = \"\"\n+\n+\t\t\tcmd := sshCmd\n+\t\t\terr := validateSSHArgsWithoutFlagParsing(cmd, tt.args)\n+\t\t\trequire.NoError(t, err, \"SSH args validation should succeed for valid input\")\n+\n+\t\t\tassert.Equal(t, tt.expectedCmd, command, tt.description)\n+\n+\t\t\t// When command is present, it should execute the command and exit\n+\t\t\t// When command is empty, it should open interactive shell\n+\t\t\thasCommand := command != \"\"\n+\t\t\tassert.Equal(t, tt.shouldExit, hasCommand, \"Command presence should match expected behavior\")\n+\t\t})\n+\t}\n+}\n+\n+func TestSSHCommand_FlagHandling(t *testing.T) {\n+\t// Test that flags after hostname are not parsed by netbird but passed to SSH command\n+\ttests := []struct {\n+\t\tname         string\n+\t\targs         []string\n+\t\texpectedHost string\n+\t\texpectedCmd  string\n+\t\texpectError  bool\n+\t\tdescription  string\n+\t}{\n+\t\t{\n+\t\t\tname:         \"ls with -la flag should not be parsed by netbird\",\n+\t\t\targs:         []string{\"debian2\", \"ls\", \"-la\"},\n+\t\t\texpectedHost: \"debian2\",\n+\t\t\texpectedCmd:  \"ls -la\",\n+\t\t\texpectError:  false,\n+\t\t\tdescription:  \"ls -la should be passed as SSH command, not parsed as netbird flags\",\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"command with netbird-like flags should be passed through\",\n+\t\t\targs:         []string{\"hostname\", \"echo\", \"--help\"},\n+\t\t\texpectedHost: \"hostname\",\n+\t\t\texpectedCmd:  \"echo --help\",\n+\t\t\texpectError:  false,\n+\t\t\tdescription:  \"--help should be passed to echo, not parsed by netbird\",\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"command with -p flag should not conflict with SSH port flag\",\n+\t\t\targs:         []string{\"hostname\", \"ps\", \"-p\", \"1234\"},\n+\t\t\texpectedHost: \"hostname\",\n+\t\t\texpectedCmd:  \"ps -p 1234\",\n+\t\t\texpectError:  false,\n+\t\t\tdescription:  \"ps -p should be passed to ps command, not parsed as port\",\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"tar with flags should be passed through\",\n+\t\t\targs:         []string{\"hostname\", \"tar\", \"-czf\", \"backup.tar.gz\", \"/home\"},\n+\t\t\texpectedHost: \"hostname\",\n+\t\t\texpectedCmd:  \"tar -czf backup.tar.gz /home\",\n+\t\t\texpectError:  false,\n+\t\t\tdescription:  \"tar flags should be passed to tar command\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Reset global variables\n+\t\t\thost = \"\"\n+\t\t\tusername = \"\"\n+\t\t\tport = 22\n+\t\t\tcommand = \"\"\n+\n+\t\t\tcmd := sshCmd\n+\t\t\terr := validateSSHArgsWithoutFlagParsing(cmd, tt.args)\n+\n+\t\t\tif tt.expectError {\n+\t\t\t\tassert.Error(t, err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\trequire.NoError(t, err, \"SSH args validation should succeed for valid input\")\n+\t\t\tassert.Equal(t, tt.expectedHost, host, \"host mismatch\")\n+\t\t\tassert.Equal(t, tt.expectedCmd, command, tt.description)\n+\t\t})\n+\t}\n+}\n+\n+func TestSSHCommand_RegressionFlagParsing(t *testing.T) {\n+\t// Regression test for the specific issue: \"sudo ./netbird ssh debian2 ls -la\"\n+\t// should not parse -la as netbird flags but pass them to the SSH command\n+\ttests := []struct {\n+\t\tname         string\n+\t\targs         []string\n+\t\texpectedHost string\n+\t\texpectedCmd  string\n+\t\texpectError  bool\n+\t\tdescription  string\n+\t}{\n+\t\t{\n+\t\t\tname:         \"original issue: ls -la should be preserved\",\n+\t\t\targs:         []string{\"debian2\", \"ls\", \"-la\"},\n+\t\t\texpectedHost: \"debian2\",\n+\t\t\texpectedCmd:  \"ls -la\",\n+\t\t\texpectError:  false,\n+\t\t\tdescription:  \"The original failing case should now work\",\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"ls -l should be preserved\",\n+\t\t\targs:         []string{\"hostname\", \"ls\", \"-l\"},\n+\t\t\texpectedHost: \"hostname\",\n+\t\t\texpectedCmd:  \"ls -l\",\n+\t\t\texpectError:  false,\n+\t\t\tdescription:  \"Single letter flags should be preserved\",\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"SSH port flag should work\",\n+\t\t\targs:         []string{\"-p\", \"2222\", \"hostname\", \"ls\", \"-la\"},\n+\t\t\texpectedHost: \"hostname\",\n+\t\t\texpectedCmd:  \"ls -la\",\n+\t\t\texpectError:  false,\n+\t\t\tdescription:  \"SSH -p flag should be parsed, command flags preserved\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Reset global variables\n+\t\t\thost = \"\"\n+\t\t\tusername = \"\"\n+\t\t\tport = 22\n+\t\t\tcommand = \"\"\n+\n+\t\t\tcmd := sshCmd\n+\t\t\terr := validateSSHArgsWithoutFlagParsing(cmd, tt.args)\n+\n+\t\t\tif tt.expectError {\n+\t\t\t\tassert.Error(t, err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\trequire.NoError(t, err, \"SSH args validation should succeed for valid input\")\n+\t\t\tassert.Equal(t, tt.expectedHost, host, \"host mismatch\")\n+\t\t\tassert.Equal(t, tt.expectedCmd, command, tt.description)\n+\n+\t\t\t// Check port for the test case with -p flag\n+\t\t\tif len(tt.args) > 0 && tt.args[0] == \"-p\" {\n+\t\t\t\tassert.Equal(t, 2222, port, \"port should be parsed from -p flag\")\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestSSHCommand_PortForwardingFlagParsing(t *testing.T) {\n+\ttests := []struct {\n+\t\tname           string\n+\t\targs           []string\n+\t\texpectedHost   string\n+\t\texpectedLocal  []string\n+\t\texpectedRemote []string\n+\t\texpectError    bool\n+\t\tdescription    string\n+\t}{\n+\t\t{\n+\t\t\tname:           \"local port forwarding -L\",\n+\t\t\targs:           []string{\"-L\", \"8080:localhost:80\", \"hostname\"},\n+\t\t\texpectedHost:   \"hostname\",\n+\t\t\texpectedLocal:  []string{\"8080:localhost:80\"},\n+\t\t\texpectedRemote: []string{},\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Single -L flag should be parsed correctly\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"remote port forwarding -R\",\n+\t\t\targs:           []string{\"-R\", \"8080:localhost:80\", \"hostname\"},\n+\t\t\texpectedHost:   \"hostname\",\n+\t\t\texpectedLocal:  []string{},\n+\t\t\texpectedRemote: []string{\"8080:localhost:80\"},\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Single -R flag should be parsed correctly\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"multiple local port forwards\",\n+\t\t\targs:           []string{\"-L\", \"8080:localhost:80\", \"-L\", \"9090:localhost:443\", \"hostname\"},\n+\t\t\texpectedHost:   \"hostname\",\n+\t\t\texpectedLocal:  []string{\"8080:localhost:80\", \"9090:localhost:443\"},\n+\t\t\texpectedRemote: []string{},\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Multiple -L flags should be parsed correctly\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"multiple remote port forwards\",\n+\t\t\targs:           []string{\"-R\", \"8080:localhost:80\", \"-R\", \"9090:localhost:443\", \"hostname\"},\n+\t\t\texpectedHost:   \"hostname\",\n+\t\t\texpectedLocal:  []string{},\n+\t\t\texpectedRemote: []string{\"8080:localhost:80\", \"9090:localhost:443\"},\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Multiple -R flags should be parsed correctly\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"mixed local and remote forwards\",\n+\t\t\targs:           []string{\"-L\", \"8080:localhost:80\", \"-R\", \"9090:localhost:443\", \"hostname\"},\n+\t\t\texpectedHost:   \"hostname\",\n+\t\t\texpectedLocal:  []string{\"8080:localhost:80\"},\n+\t\t\texpectedRemote: []string{\"9090:localhost:443\"},\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Mixed -L and -R flags should be parsed correctly\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"port forwarding with bind address\",\n+\t\t\targs:           []string{\"-L\", \"127.0.0.1:8080:localhost:80\", \"hostname\"},\n+\t\t\texpectedHost:   \"hostname\",\n+\t\t\texpectedLocal:  []string{\"127.0.0.1:8080:localhost:80\"},\n+\t\t\texpectedRemote: []string{},\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Port forwarding with bind address should work\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"port forwarding with command\",\n+\t\t\targs:           []string{\"-L\", \"8080:localhost:80\", \"hostname\", \"ls\", \"-la\"},\n+\t\t\texpectedHost:   \"hostname\",\n+\t\t\texpectedLocal:  []string{\"8080:localhost:80\"},\n+\t\t\texpectedRemote: []string{},\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Port forwarding with command should work\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Reset global variables\n+\t\t\thost = \"\"\n+\t\t\tusername = \"\"\n+\t\t\tport = 22\n+\t\t\tcommand = \"\"\n+\t\t\tlocalForwards = nil\n+\t\t\tremoteForwards = nil\n+\n+\t\t\tcmd := sshCmd\n+\t\t\terr := validateSSHArgsWithoutFlagParsing(cmd, tt.args)\n+\n+\t\t\tif tt.expectError {\n+\t\t\t\tassert.Error(t, err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\trequire.NoError(t, err, \"SSH args validation should succeed for valid input\")\n+\t\t\tassert.Equal(t, tt.expectedHost, host, \"host mismatch\")\n+\t\t\t// Handle nil vs empty slice comparison\n+\t\t\tif len(tt.expectedLocal) == 0 {\n+\t\t\t\tassert.True(t, len(localForwards) == 0, tt.description+\" - local forwards should be empty\")\n+\t\t\t} else {\n+\t\t\t\tassert.Equal(t, tt.expectedLocal, localForwards, tt.description+\" - local forwards\")\n+\t\t\t}\n+\t\t\tif len(tt.expectedRemote) == 0 {\n+\t\t\t\tassert.True(t, len(remoteForwards) == 0, tt.description+\" - remote forwards should be empty\")\n+\t\t\t} else {\n+\t\t\t\tassert.Equal(t, tt.expectedRemote, remoteForwards, tt.description+\" - remote forwards\")\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestParsePortForward(t *testing.T) {\n+\ttests := []struct {\n+\t\tname           string\n+\t\tspec           string\n+\t\texpectedLocal  string\n+\t\texpectedRemote string\n+\t\texpectError    bool\n+\t\tdescription    string\n+\t}{\n+\t\t{\n+\t\t\tname:           \"simple port forward\",\n+\t\t\tspec:           \"8080:localhost:80\",\n+\t\t\texpectedLocal:  \"localhost:8080\",\n+\t\t\texpectedRemote: \"localhost:80\",\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Simple port:host:port format should work\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"port forward with bind address\",\n+\t\t\tspec:           \"127.0.0.1:8080:localhost:80\",\n+\t\t\texpectedLocal:  \"127.0.0.1:8080\",\n+\t\t\texpectedRemote: \"localhost:80\",\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"bind_address:port:host:port format should work\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"port forward to different host\",\n+\t\t\tspec:           \"8080:example.com:443\",\n+\t\t\texpectedLocal:  \"localhost:8080\",\n+\t\t\texpectedRemote: \"example.com:443\",\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Forwarding to different host should work\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"port forward with IPv6 (needs bracket support)\",\n+\t\t\tspec:        \"::1:8080:localhost:80\",\n+\t\t\texpectError: true,\n+\t\t\tdescription: \"IPv6 without brackets fails as expected (feature to implement)\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"invalid format - too few parts\",\n+\t\t\tspec:        \"8080:localhost\",\n+\t\t\texpectError: true,\n+\t\t\tdescription: \"Invalid format with too few parts should fail\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"invalid format - too many parts\",\n+\t\t\tspec:        \"127.0.0.1:8080:localhost:80:extra\",\n+\t\t\texpectError: true,\n+\t\t\tdescription: \"Invalid format with too many parts should fail\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"empty spec\",\n+\t\t\tspec:        \"\",\n+\t\t\texpectError: true,\n+\t\t\tdescription: \"Empty spec should fail\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"unix socket local forward\",\n+\t\t\tspec:           \"8080:/tmp/socket\",\n+\t\t\texpectedLocal:  \"localhost:8080\",\n+\t\t\texpectedRemote: \"/tmp/socket\",\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Unix socket forwarding should work\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"unix socket with bind address\",\n+\t\t\tspec:           \"127.0.0.1:8080:/tmp/socket\",\n+\t\t\texpectedLocal:  \"127.0.0.1:8080\",\n+\t\t\texpectedRemote: \"/tmp/socket\",\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Unix socket with bind address should work\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"wildcard bind all interfaces\",\n+\t\t\tspec:           \"*:8080:localhost:80\",\n+\t\t\texpectedLocal:  \"0.0.0.0:8080\",\n+\t\t\texpectedRemote: \"localhost:80\",\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Wildcard * should bind to all interfaces (0.0.0.0)\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"wildcard for port only\",\n+\t\t\tspec:           \"8080:*:80\",\n+\t\t\texpectedLocal:  \"localhost:8080\",\n+\t\t\texpectedRemote: \"*:80\",\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Wildcard in remote host should be preserved\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tlocalAddr, remoteAddr, err := parsePortForwardSpec(tt.spec)\n+\n+\t\t\tif tt.expectError {\n+\t\t\t\tassert.Error(t, err, tt.description)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\trequire.NoError(t, err, tt.description)\n+\t\t\tassert.Equal(t, tt.expectedLocal, localAddr, tt.description+\" - local address\")\n+\t\t\tassert.Equal(t, tt.expectedRemote, remoteAddr, tt.description+\" - remote address\")\n+\t\t})\n+\t}\n+}\n+\n+func TestSSHCommand_IntegrationPortForwarding(t *testing.T) {\n+\t// Integration test for port forwarding with the actual SSH command implementation\n+\ttests := []struct {\n+\t\tname           string\n+\t\targs           []string\n+\t\texpectedHost   string\n+\t\texpectedLocal  []string\n+\t\texpectedRemote []string\n+\t\texpectedCmd    string\n+\t\tdescription    string\n+\t}{\n+\t\t{\n+\t\t\tname:           \"local forward with command\",\n+\t\t\targs:           []string{\"-L\", \"8080:localhost:80\", \"hostname\", \"echo\", \"test\"},\n+\t\t\texpectedHost:   \"hostname\",\n+\t\t\texpectedLocal:  []string{\"8080:localhost:80\"},\n+\t\t\texpectedRemote: []string{},\n+\t\t\texpectedCmd:    \"echo test\",\n+\t\t\tdescription:    \"Local forwarding should work with commands\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"remote forward with command\",\n+\t\t\targs:           []string{\"-R\", \"8080:localhost:80\", \"hostname\", \"ls\", \"-la\"},\n+\t\t\texpectedHost:   \"hostname\",\n+\t\t\texpectedLocal:  []string{},\n+\t\t\texpectedRemote: []string{\"8080:localhost:80\"},\n+\t\t\texpectedCmd:    \"ls -la\",\n+\t\t\tdescription:    \"Remote forwarding should work with commands\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"multiple forwards with user and command\",\n+\t\t\targs:           []string{\"-L\", \"8080:localhost:80\", \"-R\", \"9090:localhost:443\", \"user@hostname\", \"ps\", \"aux\"},\n+\t\t\texpectedHost:   \"hostname\",\n+\t\t\texpectedLocal:  []string{\"8080:localhost:80\"},\n+\t\t\texpectedRemote: []string{\"9090:localhost:443\"},\n+\t\t\texpectedCmd:    \"ps aux\",\n+\t\t\tdescription:    \"Complex case with multiple forwards, user, and command\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Reset global variables\n+\t\t\thost = \"\"\n+\t\t\tusername = \"\"\n+\t\t\tport = 22\n+\t\t\tcommand = \"\"\n+\t\t\tlocalForwards = nil\n+\t\t\tremoteForwards = nil\n+\n+\t\t\tcmd := sshCmd\n+\t\t\terr := validateSSHArgsWithoutFlagParsing(cmd, tt.args)\n+\t\t\trequire.NoError(t, err, \"SSH args validation should succeed for valid input\")\n+\n+\t\t\tassert.Equal(t, tt.expectedHost, host, \"host mismatch\")\n+\t\t\t// Handle nil vs empty slice comparison\n+\t\t\tif len(tt.expectedLocal) == 0 {\n+\t\t\t\tassert.True(t, len(localForwards) == 0, tt.description+\" - local forwards should be empty\")\n+\t\t\t} else {\n+\t\t\t\tassert.Equal(t, tt.expectedLocal, localForwards, tt.description+\" - local forwards\")\n+\t\t\t}\n+\t\t\tif len(tt.expectedRemote) == 0 {\n+\t\t\t\tassert.True(t, len(remoteForwards) == 0, tt.description+\" - remote forwards should be empty\")\n+\t\t\t} else {\n+\t\t\t\tassert.Equal(t, tt.expectedRemote, remoteForwards, tt.description+\" - remote forwards\")\n+\t\t\t}\n+\t\t\tassert.Equal(t, tt.expectedCmd, command, tt.description+\" - command\")\n+\t\t})\n+\t}\n+}\n+\n+func TestSSHCommand_ParameterIsolation(t *testing.T) {\n+\ttests := []struct {\n+\t\tname        string\n+\t\targs        []string\n+\t\texpectedCmd string\n+\t}{\n+\t\t{\n+\t\t\tname:        \"cmd flag passed as command\",\n+\t\t\targs:        []string{\"hostname\", \"--cmd\", \"echo test\"},\n+\t\t\texpectedCmd: \"--cmd echo test\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"uid flag passed as command\",\n+\t\t\targs:        []string{\"hostname\", \"--uid\", \"1000\"},\n+\t\t\texpectedCmd: \"--uid 1000\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"shell flag passed as command\",\n+\t\t\targs:        []string{\"hostname\", \"--shell\", \"/bin/bash\"},\n+\t\t\texpectedCmd: \"--shell /bin/bash\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\thost = \"\"\n+\t\t\tusername = \"\"\n+\t\t\tport = 22\n+\t\t\tcommand = \"\"\n+\n+\t\t\terr := validateSSHArgsWithoutFlagParsing(sshCmd, tt.args)\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\tassert.Equal(t, \"hostname\", host)\n+\t\t\tassert.Equal(t, tt.expectedCmd, command)\n+\t\t})\n+\t}\n+}\n+\n+func TestSSHCommand_InvalidFlagRejection(t *testing.T) {\n+\t// Test that invalid flags are properly rejected and not misinterpreted as hostnames\n+\ttests := []struct {\n+\t\tname        string\n+\t\targs        []string\n+\t\tdescription string\n+\t}{\n+\t\t{\n+\t\t\tname:        \"invalid long flag before hostname\",\n+\t\t\targs:        []string{\"--invalid-flag\", \"hostname\"},\n+\t\t\tdescription: \"Invalid flag should return parse error, not treat flag as hostname\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"invalid short flag before hostname\",\n+\t\t\targs:        []string{\"-x\", \"hostname\"},\n+\t\t\tdescription: \"Invalid short flag should return parse error\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"invalid flag with value before hostname\",\n+\t\t\targs:        []string{\"--invalid-option=value\", \"hostname\"},\n+\t\t\tdescription: \"Invalid flag with value should return parse error\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"typo in known flag\",\n+\t\t\targs:        []string{\"--por\", \"2222\", \"hostname\"},\n+\t\t\tdescription: \"Typo in flag name should return parse error (not silently ignored)\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Reset global variables\n+\t\t\thost = \"\"\n+\t\t\tusername = \"\"\n+\t\t\tport = 22\n+\t\t\tcommand = \"\"\n+\n+\t\t\terr := validateSSHArgsWithoutFlagParsing(sshCmd, tt.args)\n+\n+\t\t\t// Should return an error for invalid flags\n+\t\t\tassert.Error(t, err, tt.description)\n+\n+\t\t\t// Should not have set host to the invalid flag\n+\t\t\tassert.NotEqual(t, tt.args[0], host, \"Invalid flag should not be interpreted as hostname\")\n+\t\t})\n+\t}\n+}\ndiff --git a/client/cmd/testutil_test.go b/client/cmd/testutil_test.go\nindex 78bb0476bfd..e7b0279e8a1 100644\n--- a/client/cmd/testutil_test.go\n+++ b/client/cmd/testutil_test.go\n@@ -12,6 +12,7 @@ import (\n \t\"google.golang.org/grpc\"\n \n \t\"github.com/netbirdio/management-integrations/integrations\"\n+\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map/controller\"\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map/update_channel\"\n \tnbgrpc \"github.com/netbirdio/netbird/management/internals/shared/grpc\"\n@@ -117,7 +118,7 @@ func startManagement(t *testing.T, config *config.Config, testFile string) (*grp\n \trequestBuffer := mgmt.NewAccountRequestBuffer(ctx, store)\n \tnetworkMapController := controller.NewController(ctx, store, metrics, updateManager, requestBuffer, mgmt.MockIntegratedValidator{}, settingsMockManager, \"netbird.cloud\", port_forwarding.NewControllerMock())\n \n-\taccountManager, err := mgmt.BuildManager(context.Background(), store, networkMapController, nil, \"\", eventStore, nil, false, iv, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManagerMock, false)\n+\taccountManager, err := mgmt.BuildManager(context.Background(), config, store, networkMapController, nil, \"\", eventStore, nil, false, iv, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManagerMock, false)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\ndiff --git a/client/firewall/uspfilter/filter_test.go b/client/firewall/uspfilter/filter_test.go\nindex c56a078fcf5..120a9f41887 100644\n--- a/client/firewall/uspfilter/filter_test.go\n+++ b/client/firewall/uspfilter/filter_test.go\n@@ -22,6 +22,7 @@ import (\n \t\"github.com/netbirdio/netbird/client/iface/device\"\n \t\"github.com/netbirdio/netbird/client/iface/wgaddr\"\n \t\"github.com/netbirdio/netbird/client/internal/netflow\"\n+\tnftypes \"github.com/netbirdio/netbird/client/internal/netflow/types\"\n \t\"github.com/netbirdio/netbird/shared/management/domain\"\n )\n \n@@ -1114,3 +1115,138 @@ func generateTCPPacketWithFlags(tb testing.TB, srcIP, dstIP net.IP, srcPort, dst\n \n \treturn buf.Bytes()\n }\n+\n+func TestShouldForward(t *testing.T) {\n+\t// Set up test addresses\n+\twgIP := netip.MustParseAddr(\"100.10.0.1\")\n+\totherIP := netip.MustParseAddr(\"100.10.0.2\")\n+\n+\t// Create test manager with mock interface\n+\tifaceMock := &IFaceMock{\n+\t\tSetFilterFunc: func(device.PacketFilter) error { return nil },\n+\t}\n+\t// Set the mock to return our test WG IP\n+\tifaceMock.AddressFunc = func() wgaddr.Address {\n+\t\treturn wgaddr.Address{IP: wgIP, Network: netip.PrefixFrom(wgIP, 24)}\n+\t}\n+\n+\tmanager, err := Create(ifaceMock, false, flowLogger, nbiface.DefaultMTU)\n+\trequire.NoError(t, err)\n+\tdefer func() {\n+\t\trequire.NoError(t, manager.Close(nil))\n+\t}()\n+\n+\t// Helper to create decoder with TCP packet\n+\tcreateTCPDecoder := func(dstPort uint16) *decoder {\n+\t\tipv4 := &layers.IPv4{\n+\t\t\tVersion:  4,\n+\t\t\tProtocol: layers.IPProtocolTCP,\n+\t\t\tSrcIP:    net.ParseIP(\"192.168.1.100\"),\n+\t\t\tDstIP:    wgIP.AsSlice(),\n+\t\t}\n+\t\ttcp := &layers.TCP{\n+\t\t\tSrcPort: 54321,\n+\t\t\tDstPort: layers.TCPPort(dstPort),\n+\t\t}\n+\n+\t\terr := tcp.SetNetworkLayerForChecksum(ipv4)\n+\t\trequire.NoError(t, err)\n+\n+\t\tbuf := gopacket.NewSerializeBuffer()\n+\t\topts := gopacket.SerializeOptions{ComputeChecksums: true, FixLengths: true}\n+\t\terr = gopacket.SerializeLayers(buf, opts, ipv4, tcp, gopacket.Payload(\"test\"))\n+\t\trequire.NoError(t, err)\n+\n+\t\td := &decoder{\n+\t\t\tdecoded: []gopacket.LayerType{},\n+\t\t}\n+\t\td.parser = gopacket.NewDecodingLayerParser(\n+\t\t\tlayers.LayerTypeIPv4,\n+\t\t\t&d.eth, &d.ip4, &d.ip6, &d.icmp4, &d.icmp6, &d.tcp, &d.udp,\n+\t\t)\n+\t\td.parser.IgnoreUnsupported = true\n+\n+\t\terr = d.parser.DecodeLayers(buf.Bytes(), &d.decoded)\n+\t\trequire.NoError(t, err)\n+\n+\t\treturn d\n+\t}\n+\n+\ttests := []struct {\n+\t\tname              string\n+\t\tlocalForwarding   bool\n+\t\tnetstack          bool\n+\t\tdstIP             netip.Addr\n+\t\tserviceRegistered bool\n+\t\tservicePort       uint16\n+\t\texpected          bool\n+\t\tdescription       string\n+\t}{\n+\t\t{\n+\t\t\tname:            \"no local forwarding\",\n+\t\t\tlocalForwarding: false,\n+\t\t\tnetstack:        true,\n+\t\t\tdstIP:           wgIP,\n+\t\t\texpected:        false,\n+\t\t\tdescription:     \"should never forward when local forwarding disabled\",\n+\t\t},\n+\t\t{\n+\t\t\tname:            \"traffic to other local interface\",\n+\t\t\tlocalForwarding: true,\n+\t\t\tnetstack:        false,\n+\t\t\tdstIP:           otherIP,\n+\t\t\texpected:        true,\n+\t\t\tdescription:     \"should forward traffic to our other local interfaces (not NetBird IP)\",\n+\t\t},\n+\t\t{\n+\t\t\tname:            \"traffic to NetBird IP, no netstack\",\n+\t\t\tlocalForwarding: true,\n+\t\t\tnetstack:        false,\n+\t\t\tdstIP:           wgIP,\n+\t\t\texpected:        false,\n+\t\t\tdescription:     \"should send to netstack listeners (final return false path)\",\n+\t\t},\n+\t\t{\n+\t\t\tname:            \"traffic to our IP, netstack mode, no service\",\n+\t\t\tlocalForwarding: true,\n+\t\t\tnetstack:        true,\n+\t\t\tdstIP:           wgIP,\n+\t\t\texpected:        true,\n+\t\t\tdescription:     \"should forward when in netstack mode with no matching service\",\n+\t\t},\n+\t\t{\n+\t\t\tname:              \"traffic to our IP, netstack mode, with service\",\n+\t\t\tlocalForwarding:   true,\n+\t\t\tnetstack:          true,\n+\t\t\tdstIP:             wgIP,\n+\t\t\tserviceRegistered: true,\n+\t\t\tservicePort:       22,\n+\t\t\texpected:          false,\n+\t\t\tdescription:       \"should send to netstack listeners when service is registered\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Configure manager\n+\t\t\tmanager.localForwarding = tt.localForwarding\n+\t\t\tmanager.netstack = tt.netstack\n+\n+\t\t\t// Register service if needed\n+\t\t\tif tt.serviceRegistered {\n+\t\t\t\tmanager.RegisterNetstackService(nftypes.TCP, tt.servicePort)\n+\t\t\t\tdefer manager.UnregisterNetstackService(nftypes.TCP, tt.servicePort)\n+\t\t\t}\n+\n+\t\t\t// Create decoder for the test\n+\t\t\tdecoder := createTCPDecoder(tt.servicePort)\n+\t\t\tif !tt.serviceRegistered {\n+\t\t\t\tdecoder = createTCPDecoder(8080) // Use non-registered port\n+\t\t\t}\n+\n+\t\t\t// Test the method\n+\t\t\tresult := manager.shouldForward(decoder, tt.dstIP)\n+\t\t\trequire.Equal(t, tt.expected, result, tt.description)\n+\t\t})\n+\t}\n+}\ndiff --git a/client/firewall/uspfilter/nat_stateful_test.go b/client/firewall/uspfilter/nat_stateful_test.go\nnew file mode 100644\nindex 00000000000..21c6da06e32\n--- /dev/null\n+++ b/client/firewall/uspfilter/nat_stateful_test.go\n@@ -0,0 +1,85 @@\n+package uspfilter\n+\n+import (\n+\t\"net/netip\"\n+\t\"testing\"\n+\n+\t\"github.com/google/gopacket/layers\"\n+\t\"github.com/stretchr/testify/require\"\n+\n+\t\"github.com/netbirdio/netbird/client/iface\"\n+\t\"github.com/netbirdio/netbird/client/iface/device\"\n+)\n+\n+// TestPortDNATBasic tests basic port DNAT functionality\n+func TestPortDNATBasic(t *testing.T) {\n+\tmanager, err := Create(&IFaceMock{\n+\t\tSetFilterFunc: func(device.PacketFilter) error { return nil },\n+\t}, false, flowLogger, iface.DefaultMTU)\n+\trequire.NoError(t, err)\n+\tdefer func() {\n+\t\trequire.NoError(t, manager.Close(nil))\n+\t}()\n+\n+\t// Define peer IPs\n+\tpeerA := netip.MustParseAddr(\"100.10.0.50\")\n+\tpeerB := netip.MustParseAddr(\"100.10.0.51\")\n+\n+\t// Add SSH port redirection rule for peer B (the target)\n+\terr = manager.addPortRedirection(peerB, layers.LayerTypeTCP, 22, 22022)\n+\trequire.NoError(t, err)\n+\n+\t// Scenario: Peer A connects to Peer B on port 22 (should get NAT)\n+\tpacketAtoB := generateDNATTestPacket(t, peerA, peerB, layers.IPProtocolTCP, 54321, 22)\n+\td := parsePacket(t, packetAtoB)\n+\ttranslatedAtoB := manager.translateInboundPortDNAT(packetAtoB, d, peerA, peerB)\n+\trequire.True(t, translatedAtoB, \"Peer A to Peer B should be translated (NAT applied)\")\n+\n+\t// Verify port was translated to 22022\n+\td = parsePacket(t, packetAtoB)\n+\trequire.Equal(t, uint16(22022), uint16(d.tcp.DstPort), \"Port should be rewritten to 22022\")\n+\n+\t// Scenario: Return traffic from Peer B to Peer A should NOT be translated\n+\t// (prevents double NAT - original port stored in conntrack)\n+\treturnPacket := generateDNATTestPacket(t, peerB, peerA, layers.IPProtocolTCP, 22022, 54321)\n+\td2 := parsePacket(t, returnPacket)\n+\ttranslatedReturn := manager.translateInboundPortDNAT(returnPacket, d2, peerB, peerA)\n+\trequire.False(t, translatedReturn, \"Return traffic from same IP should not be translated\")\n+}\n+\n+// TestPortDNATMultipleRules tests multiple port DNAT rules\n+func TestPortDNATMultipleRules(t *testing.T) {\n+\tmanager, err := Create(&IFaceMock{\n+\t\tSetFilterFunc: func(device.PacketFilter) error { return nil },\n+\t}, false, flowLogger, iface.DefaultMTU)\n+\trequire.NoError(t, err)\n+\tdefer func() {\n+\t\trequire.NoError(t, manager.Close(nil))\n+\t}()\n+\n+\t// Define peer IPs\n+\tpeerA := netip.MustParseAddr(\"100.10.0.50\")\n+\tpeerB := netip.MustParseAddr(\"100.10.0.51\")\n+\n+\t// Add SSH port redirection rules for both peers\n+\terr = manager.addPortRedirection(peerA, layers.LayerTypeTCP, 22, 22022)\n+\trequire.NoError(t, err)\n+\terr = manager.addPortRedirection(peerB, layers.LayerTypeTCP, 22, 22022)\n+\trequire.NoError(t, err)\n+\n+\t// Test traffic to peer B gets translated\n+\tpacketToB := generateDNATTestPacket(t, peerA, peerB, layers.IPProtocolTCP, 54321, 22)\n+\td1 := parsePacket(t, packetToB)\n+\ttranslatedToB := manager.translateInboundPortDNAT(packetToB, d1, peerA, peerB)\n+\trequire.True(t, translatedToB, \"Traffic to peer B should be translated\")\n+\td1 = parsePacket(t, packetToB)\n+\trequire.Equal(t, uint16(22022), uint16(d1.tcp.DstPort), \"Port should be 22022\")\n+\n+\t// Test traffic to peer A gets translated\n+\tpacketToA := generateDNATTestPacket(t, peerB, peerA, layers.IPProtocolTCP, 54322, 22)\n+\td2 := parsePacket(t, packetToA)\n+\ttranslatedToA := manager.translateInboundPortDNAT(packetToA, d2, peerB, peerA)\n+\trequire.True(t, translatedToA, \"Traffic to peer A should be translated\")\n+\td2 = parsePacket(t, packetToA)\n+\trequire.Equal(t, uint16(22022), uint16(d2.tcp.DstPort), \"Port should be 22022\")\n+}\ndiff --git a/client/internal/acl/manager_test.go b/client/internal/acl/manager_test.go\nindex 638245bf72b..4bc0fd800e3 100644\n--- a/client/internal/acl/manager_test.go\n+++ b/client/internal/acl/manager_test.go\n@@ -272,70 +272,3 @@ func TestPortInfoEmpty(t *testing.T) {\n \t\t})\n \t}\n }\n-\n-func TestDefaultManagerEnableSSHRules(t *testing.T) {\n-\tnetworkMap := &mgmProto.NetworkMap{\n-\t\tPeerConfig: &mgmProto.PeerConfig{\n-\t\t\tSshConfig: &mgmProto.SSHConfig{\n-\t\t\t\tSshEnabled: true,\n-\t\t\t},\n-\t\t},\n-\t\tRemotePeers: []*mgmProto.RemotePeerConfig{\n-\t\t\t{AllowedIps: []string{\"10.93.0.1\"}},\n-\t\t\t{AllowedIps: []string{\"10.93.0.2\"}},\n-\t\t\t{AllowedIps: []string{\"10.93.0.3\"}},\n-\t\t},\n-\t\tFirewallRules: []*mgmProto.FirewallRule{\n-\t\t\t{\n-\t\t\t\tPeerIP:    \"10.93.0.1\",\n-\t\t\t\tDirection: mgmProto.RuleDirection_IN,\n-\t\t\t\tAction:    mgmProto.RuleAction_ACCEPT,\n-\t\t\t\tProtocol:  mgmProto.RuleProtocol_TCP,\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tPeerIP:    \"10.93.0.2\",\n-\t\t\t\tDirection: mgmProto.RuleDirection_IN,\n-\t\t\t\tAction:    mgmProto.RuleAction_ACCEPT,\n-\t\t\t\tProtocol:  mgmProto.RuleProtocol_TCP,\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tPeerIP:    \"10.93.0.3\",\n-\t\t\t\tDirection: mgmProto.RuleDirection_OUT,\n-\t\t\t\tAction:    mgmProto.RuleAction_ACCEPT,\n-\t\t\t\tProtocol:  mgmProto.RuleProtocol_UDP,\n-\t\t\t},\n-\t\t},\n-\t}\n-\n-\tctrl := gomock.NewController(t)\n-\tdefer ctrl.Finish()\n-\n-\tifaceMock := mocks.NewMockIFaceMapper(ctrl)\n-\tifaceMock.EXPECT().IsUserspaceBind().Return(true).AnyTimes()\n-\tifaceMock.EXPECT().SetFilter(gomock.Any())\n-\tnetwork := netip.MustParsePrefix(\"172.0.0.1/32\")\n-\n-\tifaceMock.EXPECT().Name().Return(\"lo\").AnyTimes()\n-\tifaceMock.EXPECT().Address().Return(wgaddr.Address{\n-\t\tIP:      network.Addr(),\n-\t\tNetwork: network,\n-\t}).AnyTimes()\n-\tifaceMock.EXPECT().GetWGDevice().Return(nil).AnyTimes()\n-\n-\tfw, err := firewall.NewFirewall(ifaceMock, nil, flowLogger, false, iface.DefaultMTU)\n-\trequire.NoError(t, err)\n-\tdefer func() {\n-\t\terr = fw.Close(nil)\n-\t\trequire.NoError(t, err)\n-\t}()\n-\n-\tacl := NewDefaultManager(fw)\n-\n-\tacl.ApplyFiltering(networkMap, false)\n-\n-\texpectedRules := 3\n-\tif fw.IsStateful() {\n-\t\texpectedRules = 3 // 2 inbound rules + SSH rule\n-\t}\n-\tassert.Equal(t, expectedRules, len(acl.peerRulesPairs))\n-}\ndiff --git a/client/internal/engine_test.go b/client/internal/engine_test.go\nindex d15a07f9d27..3b7ff0eba5d 100644\n--- a/client/internal/engine_test.go\n+++ b/client/internal/engine_test.go\n@@ -14,7 +14,6 @@ import (\n \n \t\"github.com/golang/mock/gomock\"\n \t\"github.com/google/uuid\"\n-\t\"github.com/netbirdio/netbird/client/internal/stdnet\"\n \tlog \"github.com/sirupsen/logrus\"\n \t\"github.com/stretchr/testify/assert\"\n \t\"github.com/stretchr/testify/require\"\n@@ -25,7 +24,10 @@ import (\n \t\"google.golang.org/grpc\"\n \t\"google.golang.org/grpc/keepalive\"\n \n+\t\"github.com/netbirdio/netbird/client/internal/stdnet\"\n+\n \t\"github.com/netbirdio/management-integrations/integrations\"\n+\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map/controller\"\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map/update_channel\"\n \tnbgrpc \"github.com/netbirdio/netbird/management/internals/shared/grpc\"\n@@ -46,7 +48,7 @@ import (\n \ticemaker \"github.com/netbirdio/netbird/client/internal/peer/ice\"\n \t\"github.com/netbirdio/netbird/client/internal/profilemanager\"\n \t\"github.com/netbirdio/netbird/client/internal/routemanager\"\n-\t\"github.com/netbirdio/netbird/client/ssh\"\n+\tnbssh \"github.com/netbirdio/netbird/client/ssh\"\n \t\"github.com/netbirdio/netbird/client/system\"\n \tnbdns \"github.com/netbirdio/netbird/dns\"\n \t\"github.com/netbirdio/netbird/management/server\"\n@@ -214,11 +216,13 @@ func TestMain(m *testing.M) {\n }\n \n func TestEngine_SSH(t *testing.T) {\n-\tif runtime.GOOS == \"windows\" {\n-\t\tt.Skip(\"skipping TestEngine_SSH\")\n+\tkey, err := wgtypes.GeneratePrivateKey()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t\treturn\n \t}\n \n-\tkey, err := wgtypes.GeneratePrivateKey()\n+\tsshKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t\treturn\n@@ -240,6 +244,7 @@ func TestEngine_SSH(t *testing.T) {\n \t\t\tWgPort:           33100,\n \t\t\tServerSSHAllowed: true,\n \t\t\tMTU:              iface.DefaultMTU,\n+\t\t\tSSHKey:           sshKey,\n \t\t},\n \t\tMobileDependency{},\n \t\tpeer.NewRecorder(\"https://mgm\"),\n@@ -250,35 +255,8 @@ func TestEngine_SSH(t *testing.T) {\n \t\tUpdateDNSServerFunc: func(serial uint64, update nbdns.Config) error { return nil },\n \t}\n \n-\tvar sshKeysAdded []string\n-\tvar sshPeersRemoved []string\n-\n-\tsshCtx, cancel := context.WithCancel(context.Background())\n-\n-\tengine.sshServerFunc = func(hostKeyPEM []byte, addr string) (ssh.Server, error) {\n-\t\treturn &ssh.MockServer{\n-\t\t\tCtx: sshCtx,\n-\t\t\tStopFunc: func() error {\n-\t\t\t\tcancel()\n-\t\t\t\treturn nil\n-\t\t\t},\n-\t\t\tStartFunc: func() error {\n-\t\t\t\t<-ctx.Done()\n-\t\t\t\treturn ctx.Err()\n-\t\t\t},\n-\t\t\tAddAuthorizedKeyFunc: func(peer, newKey string) error {\n-\t\t\t\tsshKeysAdded = append(sshKeysAdded, newKey)\n-\t\t\t\treturn nil\n-\t\t\t},\n-\t\t\tRemoveAuthorizedKeyFunc: func(peer string) {\n-\t\t\t\tsshPeersRemoved = append(sshPeersRemoved, peer)\n-\t\t\t},\n-\t\t}, nil\n-\t}\n \terr = engine.Start(nil, nil)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n+\trequire.NoError(t, err)\n \n \tdefer func() {\n \t\terr := engine.Stop()\n@@ -304,9 +282,7 @@ func TestEngine_SSH(t *testing.T) {\n \t}\n \n \terr = engine.updateNetworkMap(networkMap)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n+\trequire.NoError(t, err)\n \n \tassert.Nil(t, engine.sshServer)\n \n@@ -314,19 +290,24 @@ func TestEngine_SSH(t *testing.T) {\n \tnetworkMap = &mgmtProto.NetworkMap{\n \t\tSerial: 7,\n \t\tPeerConfig: &mgmtProto.PeerConfig{Address: \"100.64.0.1/24\",\n-\t\t\tSshConfig: &mgmtProto.SSHConfig{SshEnabled: true}},\n+\t\t\tSshConfig: &mgmtProto.SSHConfig{\n+\t\t\t\tSshEnabled: true,\n+\t\t\t\tJwtConfig: &mgmtProto.JWTConfig{\n+\t\t\t\t\tIssuer:       \"test-issuer\",\n+\t\t\t\t\tAudience:     \"test-audience\",\n+\t\t\t\t\tKeysLocation: \"test-keys\",\n+\t\t\t\t\tMaxTokenAge:  3600,\n+\t\t\t\t},\n+\t\t\t}},\n \t\tRemotePeers:        []*mgmtProto.RemotePeerConfig{peerWithSSH},\n \t\tRemotePeersIsEmpty: false,\n \t}\n \n \terr = engine.updateNetworkMap(networkMap)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n+\trequire.NoError(t, err)\n \n \ttime.Sleep(250 * time.Millisecond)\n \tassert.NotNil(t, engine.sshServer)\n-\tassert.Contains(t, sshKeysAdded, \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFATYCqaQw/9id1Qkq3n16JYhDhXraI6Pc1fgB8ynEfQ\")\n \n \t// now remove peer\n \tnetworkMap = &mgmtProto.NetworkMap{\n@@ -336,13 +317,10 @@ func TestEngine_SSH(t *testing.T) {\n \t}\n \n \terr = engine.updateNetworkMap(networkMap)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n+\trequire.NoError(t, err)\n \n \t// time.Sleep(250 * time.Millisecond)\n \tassert.NotNil(t, engine.sshServer)\n-\tassert.Contains(t, sshPeersRemoved, \"MNHf3Ma6z6mdLbriAJbqhX7+nM/B71lgw2+91q3LfhU=\")\n \n \t// now disable SSH server\n \tnetworkMap = &mgmtProto.NetworkMap{\n@@ -354,12 +332,70 @@ func TestEngine_SSH(t *testing.T) {\n \t}\n \n \terr = engine.updateNetworkMap(networkMap)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n+\trequire.NoError(t, err)\n+\n+\tassert.Nil(t, engine.sshServer)\n+}\n+\n+func TestEngine_SSHUpdateLogic(t *testing.T) {\n+\t// Test that SSH server start/stop logic works based on config\n+\tengine := &Engine{\n+\t\tconfig: &EngineConfig{\n+\t\t\tServerSSHAllowed: false, // Start with SSH disabled\n+\t\t},\n+\t\tsyncMsgMux: &sync.Mutex{},\n \t}\n \n+\t// Test SSH disabled config\n+\tsshConfig := &mgmtProto.SSHConfig{SshEnabled: false}\n+\terr := engine.updateSSH(sshConfig)\n+\tassert.NoError(t, err)\n \tassert.Nil(t, engine.sshServer)\n \n+\t// Test inbound blocked\n+\tengine.config.BlockInbound = true\n+\terr = engine.updateSSH(&mgmtProto.SSHConfig{SshEnabled: true})\n+\tassert.NoError(t, err)\n+\tassert.Nil(t, engine.sshServer)\n+\tengine.config.BlockInbound = false\n+\n+\t// Test with server SSH not allowed\n+\terr = engine.updateSSH(&mgmtProto.SSHConfig{SshEnabled: true})\n+\tassert.NoError(t, err)\n+\tassert.Nil(t, engine.sshServer)\n+}\n+\n+func TestEngine_SSHServerConsistency(t *testing.T) {\n+\n+\tt.Run(\"server set only on successful creation\", func(t *testing.T) {\n+\t\tengine := &Engine{\n+\t\t\tconfig: &EngineConfig{\n+\t\t\t\tServerSSHAllowed: true,\n+\t\t\t\tSSHKey:           []byte(\"test-key\"),\n+\t\t\t},\n+\t\t\tsyncMsgMux: &sync.Mutex{},\n+\t\t}\n+\n+\t\tengine.wgInterface = nil\n+\n+\t\terr := engine.updateSSH(&mgmtProto.SSHConfig{SshEnabled: true})\n+\n+\t\tassert.Error(t, err)\n+\t\tassert.Nil(t, engine.sshServer)\n+\t})\n+\n+\tt.Run(\"cleanup handles nil gracefully\", func(t *testing.T) {\n+\t\tengine := &Engine{\n+\t\t\tconfig: &EngineConfig{\n+\t\t\t\tServerSSHAllowed: false,\n+\t\t\t},\n+\t\t\tsyncMsgMux: &sync.Mutex{},\n+\t\t}\n+\n+\t\terr := engine.stopSSHServer()\n+\t\tassert.NoError(t, err)\n+\t\tassert.Nil(t, engine.sshServer)\n+\t})\n }\n \n func TestEngine_UpdateNetworkMap(t *testing.T) {\n@@ -1589,7 +1625,7 @@ func startManagement(t *testing.T, dataDir, testFile string) (*grpc.Server, stri\n \tupdateManager := update_channel.NewPeersUpdateManager(metrics)\n \trequestBuffer := server.NewAccountRequestBuffer(context.Background(), store)\n \tnetworkMapController := controller.NewController(context.Background(), store, metrics, updateManager, requestBuffer, server.MockIntegratedValidator{}, settingsMockManager, \"netbird.selfhosted\", port_forwarding.NewControllerMock())\n-\taccountManager, err := server.BuildManager(context.Background(), store, networkMapController, nil, \"\", eventStore, nil, false, ia, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n+\taccountManager, err := server.BuildManager(context.Background(), config, store, networkMapController, nil, \"\", eventStore, nil, false, ia, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n \tif err != nil {\n \t\treturn nil, \"\", err\n \t}\ndiff --git a/client/internal/profilemanager/config_test.go b/client/internal/profilemanager/config_test.go\nindex 90bde7707f9..ab13cf3895f 100644\n--- a/client/internal/profilemanager/config_test.go\n+++ b/client/internal/profilemanager/config_test.go\n@@ -193,10 +193,10 @@ func TestWireguardPortZeroExplicit(t *testing.T) {\n \n func TestWireguardPortDefaultVsExplicit(t *testing.T) {\n \ttests := []struct {\n-\t\tname           string\n-\t\twireguardPort  *int\n-\t\texpectedPort   int\n-\t\tdescription    string\n+\t\tname          string\n+\t\twireguardPort *int\n+\t\texpectedPort  int\n+\t\tdescription   string\n \t}{\n \t\t{\n \t\t\tname:          \"no port specified uses default\",\ndiff --git a/client/server/server_test.go b/client/server/server_test.go\nindex ae5f759ee04..96d4c0af0d6 100644\n--- a/client/server/server_test.go\n+++ b/client/server/server_test.go\n@@ -14,6 +14,7 @@ import (\n \t\"go.opentelemetry.io/otel\"\n \n \t\"github.com/netbirdio/management-integrations/integrations\"\n+\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map/controller\"\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map/update_channel\"\n \tnbgrpc \"github.com/netbirdio/netbird/management/internals/shared/grpc\"\n@@ -316,7 +317,7 @@ func startManagement(t *testing.T, signalAddr string, counter *int) (*grpc.Serve\n \trequestBuffer := server.NewAccountRequestBuffer(context.Background(), store)\n \tpeersUpdateManager := update_channel.NewPeersUpdateManager(metrics)\n \tnetworkMapController := controller.NewController(context.Background(), store, metrics, peersUpdateManager, requestBuffer, server.MockIntegratedValidator{}, settingsMockManager, \"netbird.selfhosted\", port_forwarding.NewControllerMock())\n-\taccountManager, err := server.BuildManager(context.Background(), store, networkMapController, nil, \"\", eventStore, nil, false, ia, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManagerMock, false)\n+\taccountManager, err := server.BuildManager(context.Background(), config, store, networkMapController, nil, \"\", eventStore, nil, false, ia, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManagerMock, false)\n \tif err != nil {\n \t\treturn nil, \"\", err\n \t}\ndiff --git a/client/server/setconfig_test.go b/client/server/setconfig_test.go\nindex 1260bcc7835..8e360175d45 100644\n--- a/client/server/setconfig_test.go\n+++ b/client/server/setconfig_test.go\n@@ -72,6 +72,7 @@ func TestSetConfig_AllFieldsSaved(t *testing.T) {\n \tlazyConnectionEnabled := true\n \tblockInbound := true\n \tmtu := int64(1280)\n+\tsshJWTCacheTTL := int32(300)\n \n \treq := &proto.SetConfigRequest{\n \t\tProfileName:           profName,\n@@ -102,6 +103,7 @@ func TestSetConfig_AllFieldsSaved(t *testing.T) {\n \t\tCleanDNSLabels:        false,\n \t\tDnsRouteInterval:      durationpb.New(2 * time.Minute),\n \t\tMtu:                   &mtu,\n+\t\tSshJWTCacheTTL:        &sshJWTCacheTTL,\n \t}\n \n \t_, err = s.SetConfig(ctx, req)\n@@ -146,6 +148,8 @@ func TestSetConfig_AllFieldsSaved(t *testing.T) {\n \trequire.Equal(t, []string{\"label1\", \"label2\"}, cfg.DNSLabels.ToPunycodeList())\n \trequire.Equal(t, 2*time.Minute, cfg.DNSRouteInterval)\n \trequire.Equal(t, uint16(mtu), cfg.MTU)\n+\trequire.NotNil(t, cfg.SSHJWTCacheTTL)\n+\trequire.Equal(t, int(sshJWTCacheTTL), *cfg.SSHJWTCacheTTL)\n \n \tverifyAllFieldsCovered(t, req)\n }\n@@ -167,30 +171,36 @@ func verifyAllFieldsCovered(t *testing.T, req *proto.SetConfigRequest) {\n \t}\n \n \texpectedFields := map[string]bool{\n-\t\t\"ManagementUrl\":         true,\n-\t\t\"AdminURL\":              true,\n-\t\t\"RosenpassEnabled\":      true,\n-\t\t\"RosenpassPermissive\":   true,\n-\t\t\"ServerSSHAllowed\":      true,\n-\t\t\"InterfaceName\":         true,\n-\t\t\"WireguardPort\":         true,\n-\t\t\"OptionalPreSharedKey\":  true,\n-\t\t\"DisableAutoConnect\":    true,\n-\t\t\"NetworkMonitor\":        true,\n-\t\t\"DisableClientRoutes\":   true,\n-\t\t\"DisableServerRoutes\":   true,\n-\t\t\"DisableDns\":            true,\n-\t\t\"DisableFirewall\":       true,\n-\t\t\"BlockLanAccess\":        true,\n-\t\t\"DisableNotifications\":  true,\n-\t\t\"LazyConnectionEnabled\": true,\n-\t\t\"BlockInbound\":          true,\n-\t\t\"NatExternalIPs\":        true,\n-\t\t\"CustomDNSAddress\":      true,\n-\t\t\"ExtraIFaceBlacklist\":   true,\n-\t\t\"DnsLabels\":             true,\n-\t\t\"DnsRouteInterval\":      true,\n-\t\t\"Mtu\":                   true,\n+\t\t\"ManagementUrl\":                 true,\n+\t\t\"AdminURL\":                      true,\n+\t\t\"RosenpassEnabled\":              true,\n+\t\t\"RosenpassPermissive\":           true,\n+\t\t\"ServerSSHAllowed\":              true,\n+\t\t\"InterfaceName\":                 true,\n+\t\t\"WireguardPort\":                 true,\n+\t\t\"OptionalPreSharedKey\":          true,\n+\t\t\"DisableAutoConnect\":            true,\n+\t\t\"NetworkMonitor\":                true,\n+\t\t\"DisableClientRoutes\":           true,\n+\t\t\"DisableServerRoutes\":           true,\n+\t\t\"DisableDns\":                    true,\n+\t\t\"DisableFirewall\":               true,\n+\t\t\"BlockLanAccess\":                true,\n+\t\t\"DisableNotifications\":          true,\n+\t\t\"LazyConnectionEnabled\":         true,\n+\t\t\"BlockInbound\":                  true,\n+\t\t\"NatExternalIPs\":                true,\n+\t\t\"CustomDNSAddress\":              true,\n+\t\t\"ExtraIFaceBlacklist\":           true,\n+\t\t\"DnsLabels\":                     true,\n+\t\t\"DnsRouteInterval\":              true,\n+\t\t\"Mtu\":                           true,\n+\t\t\"EnableSSHRoot\":                 true,\n+\t\t\"EnableSSHSFTP\":                 true,\n+\t\t\"EnableSSHLocalPortForwarding\":  true,\n+\t\t\"EnableSSHRemotePortForwarding\": true,\n+\t\t\"DisableSSHAuth\":                true,\n+\t\t\"SshJWTCacheTTL\":                true,\n \t}\n \n \tval := reflect.ValueOf(req).Elem()\n@@ -221,29 +231,35 @@ func TestCLIFlags_MappedToSetConfig(t *testing.T) {\n \t// Map of CLI flag names to their corresponding SetConfigRequest field names.\n \t// This map must be updated when adding new config-related CLI flags.\n \tflagToField := map[string]string{\n-\t\t\"management-url\":         \"ManagementUrl\",\n-\t\t\"admin-url\":              \"AdminURL\",\n-\t\t\"enable-rosenpass\":       \"RosenpassEnabled\",\n-\t\t\"rosenpass-permissive\":   \"RosenpassPermissive\",\n-\t\t\"allow-server-ssh\":       \"ServerSSHAllowed\",\n-\t\t\"interface-name\":         \"InterfaceName\",\n-\t\t\"wireguard-port\":         \"WireguardPort\",\n-\t\t\"preshared-key\":          \"OptionalPreSharedKey\",\n-\t\t\"disable-auto-connect\":   \"DisableAutoConnect\",\n-\t\t\"network-monitor\":        \"NetworkMonitor\",\n-\t\t\"disable-client-routes\":  \"DisableClientRoutes\",\n-\t\t\"disable-server-routes\":  \"DisableServerRoutes\",\n-\t\t\"disable-dns\":            \"DisableDns\",\n-\t\t\"disable-firewall\":       \"DisableFirewall\",\n-\t\t\"block-lan-access\":       \"BlockLanAccess\",\n-\t\t\"block-inbound\":          \"BlockInbound\",\n-\t\t\"enable-lazy-connection\": \"LazyConnectionEnabled\",\n-\t\t\"external-ip-map\":        \"NatExternalIPs\",\n-\t\t\"dns-resolver-address\":   \"CustomDNSAddress\",\n-\t\t\"extra-iface-blacklist\":  \"ExtraIFaceBlacklist\",\n-\t\t\"extra-dns-labels\":       \"DnsLabels\",\n-\t\t\"dns-router-interval\":    \"DnsRouteInterval\",\n-\t\t\"mtu\":                    \"Mtu\",\n+\t\t\"management-url\":                    \"ManagementUrl\",\n+\t\t\"admin-url\":                         \"AdminURL\",\n+\t\t\"enable-rosenpass\":                  \"RosenpassEnabled\",\n+\t\t\"rosenpass-permissive\":              \"RosenpassPermissive\",\n+\t\t\"allow-server-ssh\":                  \"ServerSSHAllowed\",\n+\t\t\"interface-name\":                    \"InterfaceName\",\n+\t\t\"wireguard-port\":                    \"WireguardPort\",\n+\t\t\"preshared-key\":                     \"OptionalPreSharedKey\",\n+\t\t\"disable-auto-connect\":              \"DisableAutoConnect\",\n+\t\t\"network-monitor\":                   \"NetworkMonitor\",\n+\t\t\"disable-client-routes\":             \"DisableClientRoutes\",\n+\t\t\"disable-server-routes\":             \"DisableServerRoutes\",\n+\t\t\"disable-dns\":                       \"DisableDns\",\n+\t\t\"disable-firewall\":                  \"DisableFirewall\",\n+\t\t\"block-lan-access\":                  \"BlockLanAccess\",\n+\t\t\"block-inbound\":                     \"BlockInbound\",\n+\t\t\"enable-lazy-connection\":            \"LazyConnectionEnabled\",\n+\t\t\"external-ip-map\":                   \"NatExternalIPs\",\n+\t\t\"dns-resolver-address\":              \"CustomDNSAddress\",\n+\t\t\"extra-iface-blacklist\":             \"ExtraIFaceBlacklist\",\n+\t\t\"extra-dns-labels\":                  \"DnsLabels\",\n+\t\t\"dns-router-interval\":               \"DnsRouteInterval\",\n+\t\t\"mtu\":                               \"Mtu\",\n+\t\t\"enable-ssh-root\":                   \"EnableSSHRoot\",\n+\t\t\"enable-ssh-sftp\":                   \"EnableSSHSFTP\",\n+\t\t\"enable-ssh-local-port-forwarding\":  \"EnableSSHLocalPortForwarding\",\n+\t\t\"enable-ssh-remote-port-forwarding\": \"EnableSSHRemotePortForwarding\",\n+\t\t\"disable-ssh-auth\":                  \"DisableSSHAuth\",\n+\t\t\"ssh-jwt-cache-ttl\":                 \"SshJWTCacheTTL\",\n \t}\n \n \t// SetConfigRequest fields that don't have CLI flags (settable only via UI or other means).\ndiff --git a/client/ssh/client/client_test.go b/client/ssh/client/client_test.go\nnew file mode 100644\nindex 00000000000..e38e02a866b\n--- /dev/null\n+++ b/client/ssh/client/client_test.go\n@@ -0,0 +1,512 @@\n+package client\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net\"\n+\t\"os\"\n+\t\"os/user\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\tcryptossh \"golang.org/x/crypto/ssh\"\n+\n+\t\"github.com/netbirdio/netbird/client/ssh\"\n+\tsshserver \"github.com/netbirdio/netbird/client/ssh/server\"\n+\t\"github.com/netbirdio/netbird/client/ssh/testutil\"\n+)\n+\n+// TestMain handles package-level setup and cleanup\n+func TestMain(m *testing.M) {\n+\t// Guard against infinite recursion when test binary is called as \"netbird ssh exec\"\n+\t// This happens when running tests as non-privileged user with fallback\n+\tif len(os.Args) > 2 && os.Args[1] == \"ssh\" && os.Args[2] == \"exec\" {\n+\t\t// Just exit with error to break the recursion\n+\t\tfmt.Fprintf(os.Stderr, \"Test binary called as 'ssh exec' - preventing infinite recursion\\n\")\n+\t\tos.Exit(1)\n+\t}\n+\n+\t// Run tests\n+\tcode := m.Run()\n+\n+\t// Cleanup any created test users\n+\ttestutil.CleanupTestUsers()\n+\n+\tos.Exit(code)\n+}\n+\n+func TestSSHClient_DialWithKey(t *testing.T) {\n+\t// Generate host key for server\n+\thostKey, err := ssh.GeneratePrivateKey(ssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\t// Create and start server\n+\tserverConfig := &sshserver.Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := sshserver.New(serverConfig)\n+\tserver.SetAllowRootLogin(true) // Allow root/admin login for tests\n+\n+\tserverAddr := sshserver.StartTestServer(t, server)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\t// Test Dial\n+\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n+\tdefer cancel()\n+\n+\tcurrentUser := testutil.GetTestUsername(t)\n+\tclient, err := Dial(ctx, serverAddr, currentUser, DialOptions{\n+\t\tInsecureSkipVerify: true,\n+\t})\n+\trequire.NoError(t, err)\n+\tdefer func() {\n+\t\terr := client.Close()\n+\t\tassert.NoError(t, err)\n+\t}()\n+\n+\t// Verify client is connected\n+\tassert.NotNil(t, client.client)\n+}\n+\n+func TestSSHClient_CommandExecution(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" && testutil.IsCI() {\n+\t\tt.Skip(\"Skipping Windows command execution tests in CI due to S4U authentication issues\")\n+\t}\n+\n+\tserver, _, client := setupTestSSHServerAndClient(t)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\tdefer func() {\n+\t\terr := client.Close()\n+\t\tassert.NoError(t, err)\n+\t}()\n+\n+\tctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)\n+\tdefer cancel()\n+\n+\tt.Run(\"ExecuteCommand captures output\", func(t *testing.T) {\n+\t\toutput, err := client.ExecuteCommand(ctx, \"echo hello\")\n+\t\tassert.NoError(t, err)\n+\t\tassert.Contains(t, string(output), \"hello\")\n+\t})\n+\n+\tt.Run(\"ExecuteCommandWithIO streams output\", func(t *testing.T) {\n+\t\terr := client.ExecuteCommandWithIO(ctx, \"echo world\")\n+\t\tassert.NoError(t, err)\n+\t})\n+\n+\tt.Run(\"commands with flags work\", func(t *testing.T) {\n+\t\toutput, err := client.ExecuteCommand(ctx, \"echo -n test_flag\")\n+\t\tassert.NoError(t, err)\n+\t\tassert.Equal(t, \"test_flag\", strings.TrimSpace(string(output)))\n+\t})\n+\n+\tt.Run(\"non-zero exit codes don't return errors\", func(t *testing.T) {\n+\t\tvar testCmd string\n+\t\tif runtime.GOOS == \"windows\" {\n+\t\t\ttestCmd = \"echo hello | Select-String notfound\"\n+\t\t} else {\n+\t\t\ttestCmd = \"echo 'hello' | grep 'notfound'\"\n+\t\t}\n+\t\t_, err := client.ExecuteCommand(ctx, testCmd)\n+\t\tassert.NoError(t, err)\n+\t})\n+}\n+\n+func TestSSHClient_ConnectionHandling(t *testing.T) {\n+\tserver, serverAddr, _ := setupTestSSHServerAndClient(t)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\t// Generate client key for multiple connections\n+\n+\tconst numClients = 3\n+\tclients := make([]*Client, numClients)\n+\n+\tcurrentUser := testutil.GetTestUsername(t)\n+\tfor i := 0; i < numClients; i++ {\n+\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n+\t\tclient, err := Dial(ctx, serverAddr, currentUser, DialOptions{\n+\t\t\tInsecureSkipVerify: true,\n+\t\t})\n+\t\tcancel()\n+\t\trequire.NoError(t, err, \"Client %d should connect successfully\", i)\n+\t\tclients[i] = client\n+\t}\n+\n+\tfor i, client := range clients {\n+\t\terr := client.Close()\n+\t\tassert.NoError(t, err, \"Client %d should close without error\", i)\n+\t}\n+}\n+\n+func TestSSHClient_ContextCancellation(t *testing.T) {\n+\tserver, serverAddr, _ := setupTestSSHServerAndClient(t)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\tt.Run(\"connection with short timeout\", func(t *testing.T) {\n+\t\tctx, cancel := context.WithTimeout(context.Background(), 1*time.Millisecond)\n+\t\tdefer cancel()\n+\n+\t\tcurrentUser := testutil.GetTestUsername(t)\n+\t\t_, err := Dial(ctx, serverAddr, currentUser, DialOptions{\n+\t\t\tInsecureSkipVerify: true,\n+\t\t})\n+\t\tif err != nil {\n+\t\t\t// Check for actual timeout-related errors rather than string matching\n+\t\t\tassert.True(t,\n+\t\t\t\terrors.Is(err, context.DeadlineExceeded) ||\n+\t\t\t\t\terrors.Is(err, context.Canceled) ||\n+\t\t\t\t\tstrings.Contains(err.Error(), \"timeout\"),\n+\t\t\t\t\"Expected timeout-related error, got: %v\", err)\n+\t\t}\n+\t})\n+\n+\tt.Run(\"command execution cancellation\", func(t *testing.T) {\n+\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n+\t\tdefer cancel()\n+\t\tcurrentUser := testutil.GetTestUsername(t)\n+\t\tclient, err := Dial(ctx, serverAddr, currentUser, DialOptions{\n+\t\t\tInsecureSkipVerify: true,\n+\t\t})\n+\t\trequire.NoError(t, err)\n+\t\tdefer func() {\n+\t\t\tif err := client.Close(); err != nil {\n+\t\t\t\tt.Logf(\"client close error: %v\", err)\n+\t\t\t}\n+\t\t}()\n+\n+\t\tcmdCtx, cmdCancel := context.WithTimeout(context.Background(), 100*time.Millisecond)\n+\t\tdefer cmdCancel()\n+\n+\t\terr = client.ExecuteCommandWithPTY(cmdCtx, \"sleep 10\")\n+\t\tif err != nil {\n+\t\t\tvar exitMissingErr *cryptossh.ExitMissingError\n+\t\t\tisValidCancellation := errors.Is(err, context.DeadlineExceeded) ||\n+\t\t\t\terrors.Is(err, context.Canceled) ||\n+\t\t\t\terrors.As(err, &exitMissingErr)\n+\t\t\tassert.True(t, isValidCancellation, \"Should handle command cancellation properly\")\n+\t\t}\n+\t})\n+}\n+\n+func TestSSHClient_NoAuthMode(t *testing.T) {\n+\thostKey, err := ssh.GeneratePrivateKey(ssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tserverConfig := &sshserver.Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := sshserver.New(serverConfig)\n+\tserver.SetAllowRootLogin(true) // Allow root/admin login for tests\n+\n+\tserverAddr := sshserver.StartTestServer(t, server)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n+\tdefer cancel()\n+\n+\tcurrentUser := testutil.GetTestUsername(t)\n+\n+\tt.Run(\"any key succeeds in no-auth mode\", func(t *testing.T) {\n+\t\tclient, err := Dial(ctx, serverAddr, currentUser, DialOptions{\n+\t\t\tInsecureSkipVerify: true,\n+\t\t})\n+\t\tassert.NoError(t, err)\n+\t\tif client != nil {\n+\t\t\trequire.NoError(t, client.Close(), \"Client should close without error\")\n+\t\t}\n+\t})\n+}\n+\n+func TestSSHClient_TerminalState(t *testing.T) {\n+\tserver, _, client := setupTestSSHServerAndClient(t)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\tdefer func() {\n+\t\terr := client.Close()\n+\t\tassert.NoError(t, err)\n+\t}()\n+\n+\tassert.Nil(t, client.terminalState)\n+\tassert.Equal(t, 0, client.terminalFd)\n+\n+\tclient.restoreTerminal()\n+\tassert.Nil(t, client.terminalState)\n+\n+\tctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)\n+\tdefer cancel()\n+\n+\terr := client.OpenTerminal(ctx)\n+\t// In test environment without a real terminal, this may complete quickly or timeout\n+\t// Both behaviors are acceptable for testing terminal state management\n+\tif err != nil {\n+\t\tif runtime.GOOS == \"windows\" {\n+\t\t\tassert.True(t,\n+\t\t\t\tstrings.Contains(err.Error(), \"context deadline exceeded\") ||\n+\t\t\t\t\tstrings.Contains(err.Error(), \"console\"),\n+\t\t\t\t\"Should timeout or have console error on Windows\")\n+\t\t} else {\n+\t\t\t// On Unix systems in test environment, we may get various errors\n+\t\t\t// including timeouts or terminal-related errors\n+\t\t\tassert.True(t,\n+\t\t\t\tstrings.Contains(err.Error(), \"context deadline exceeded\") ||\n+\t\t\t\t\tstrings.Contains(err.Error(), \"terminal\") ||\n+\t\t\t\t\tstrings.Contains(err.Error(), \"pty\"),\n+\t\t\t\t\"Expected timeout or terminal-related error, got: %v\", err)\n+\t\t}\n+\t}\n+}\n+\n+func setupTestSSHServerAndClient(t *testing.T) (*sshserver.Server, string, *Client) {\n+\thostKey, err := ssh.GeneratePrivateKey(ssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tserverConfig := &sshserver.Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := sshserver.New(serverConfig)\n+\tserver.SetAllowRootLogin(true) // Allow root/admin login for tests\n+\n+\tserverAddr := sshserver.StartTestServer(t, server)\n+\n+\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n+\tdefer cancel()\n+\n+\tcurrentUser := testutil.GetTestUsername(t)\n+\tclient, err := Dial(ctx, serverAddr, currentUser, DialOptions{\n+\t\tInsecureSkipVerify: true,\n+\t})\n+\trequire.NoError(t, err)\n+\n+\treturn server, serverAddr, client\n+}\n+\n+func TestSSHClient_PortForwarding(t *testing.T) {\n+\tserver, _, client := setupTestSSHServerAndClient(t)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\tdefer func() {\n+\t\terr := client.Close()\n+\t\tassert.NoError(t, err)\n+\t}()\n+\n+\tt.Run(\"local forwarding times out gracefully\", func(t *testing.T) {\n+\t\tctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)\n+\t\tdefer cancel()\n+\n+\t\terr := client.LocalPortForward(ctx, \"127.0.0.1:0\", \"127.0.0.1:8080\")\n+\t\tassert.Error(t, err)\n+\t\tassert.True(t,\n+\t\t\terrors.Is(err, context.DeadlineExceeded) ||\n+\t\t\t\terrors.Is(err, context.Canceled) ||\n+\t\t\t\tstrings.Contains(err.Error(), \"connection\"),\n+\t\t\t\"Expected context or connection error\")\n+\t})\n+\n+\tt.Run(\"remote forwarding denied\", func(t *testing.T) {\n+\t\tctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)\n+\t\tdefer cancel()\n+\n+\t\terr := client.RemotePortForward(ctx, \"127.0.0.1:0\", \"127.0.0.1:8080\")\n+\t\tassert.Error(t, err)\n+\t\tassert.True(t,\n+\t\t\tstrings.Contains(err.Error(), \"denied\") ||\n+\t\t\t\tstrings.Contains(err.Error(), \"disabled\"),\n+\t\t\t\"Should be denied by default\")\n+\t})\n+\n+\tt.Run(\"invalid addresses fail\", func(t *testing.T) {\n+\t\tctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)\n+\t\tdefer cancel()\n+\n+\t\terr := client.LocalPortForward(ctx, \"invalid:address\", \"127.0.0.1:8080\")\n+\t\tassert.Error(t, err)\n+\n+\t\terr = client.LocalPortForward(ctx, \"127.0.0.1:0\", \"invalid:address\")\n+\t\tassert.Error(t, err)\n+\t})\n+}\n+\n+func TestSSHClient_PortForwardingDataTransfer(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping data transfer test in short mode\")\n+\t}\n+\n+\thostKey, err := ssh.GeneratePrivateKey(ssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tserverConfig := &sshserver.Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := sshserver.New(serverConfig)\n+\tserver.SetAllowLocalPortForwarding(true)\n+\tserver.SetAllowRootLogin(true) // Allow root/admin login for tests\n+\n+\tserverAddr := sshserver.StartTestServer(t, server)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n+\tdefer cancel()\n+\n+\t// Port forwarding requires the actual current user, not test user\n+\trealUser, err := getRealCurrentUser()\n+\trequire.NoError(t, err)\n+\n+\t// Skip if running as system account that can't do port forwarding\n+\tif testutil.IsSystemAccount(realUser) {\n+\t\tt.Skipf(\"Skipping port forwarding test - running as system account: %s\", realUser)\n+\t}\n+\n+\tclient, err := Dial(ctx, serverAddr, realUser, DialOptions{\n+\t\tInsecureSkipVerify: true, // Skip host key verification for test\n+\t})\n+\trequire.NoError(t, err)\n+\tdefer func() {\n+\t\tif err := client.Close(); err != nil {\n+\t\t\tt.Logf(\"client close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\ttestServer, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n+\trequire.NoError(t, err)\n+\tdefer func() {\n+\t\tif err := testServer.Close(); err != nil {\n+\t\t\tt.Logf(\"test server close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\ttestServerAddr := testServer.Addr().String()\n+\texpectedResponse := \"Hello, World!\"\n+\n+\tgo func() {\n+\t\tfor {\n+\t\t\tconn, err := testServer.Accept()\n+\t\t\tif err != nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tgo func(c net.Conn) {\n+\t\t\t\tdefer func() {\n+\t\t\t\t\tif err := c.Close(); err != nil {\n+\t\t\t\t\t\tt.Logf(\"connection close error: %v\", err)\n+\t\t\t\t\t}\n+\t\t\t\t}()\n+\t\t\t\tbuf := make([]byte, 1024)\n+\t\t\t\tif _, err := c.Read(buf); err != nil {\n+\t\t\t\t\tt.Logf(\"connection read error: %v\", err)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tif _, err := c.Write([]byte(expectedResponse)); err != nil {\n+\t\t\t\t\tt.Logf(\"connection write error: %v\", err)\n+\t\t\t\t}\n+\t\t\t}(conn)\n+\t\t}\n+\t}()\n+\n+\tlocalListener, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n+\trequire.NoError(t, err)\n+\tlocalAddr := localListener.Addr().String()\n+\tif err := localListener.Close(); err != nil {\n+\t\tt.Logf(\"local listener close error: %v\", err)\n+\t}\n+\n+\tctx, cancel = context.WithTimeout(context.Background(), 5*time.Second)\n+\tdefer cancel()\n+\n+\tgo func() {\n+\t\terr := client.LocalPortForward(ctx, localAddr, testServerAddr)\n+\t\tif err != nil && !errors.Is(err, context.Canceled) {\n+\t\t\tif isWindowsPrivilegeError(err) {\n+\t\t\t\tt.Logf(\"Port forward failed due to Windows privilege restrictions: %v\", err)\n+\t\t\t} else {\n+\t\t\t\tt.Logf(\"Port forward error: %v\", err)\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n+\ttime.Sleep(100 * time.Millisecond)\n+\n+\tconn, err := net.DialTimeout(\"tcp\", localAddr, 2*time.Second)\n+\trequire.NoError(t, err)\n+\tdefer func() {\n+\t\tif err := conn.Close(); err != nil {\n+\t\t\tt.Logf(\"connection close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\t_, err = conn.Write([]byte(\"test\"))\n+\trequire.NoError(t, err)\n+\n+\tif err := conn.SetReadDeadline(time.Now().Add(2 * time.Second)); err != nil {\n+\t\tt.Logf(\"set read deadline error: %v\", err)\n+\t}\n+\tresponse := make([]byte, len(expectedResponse))\n+\tn, err := io.ReadFull(conn, response)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, len(expectedResponse), n)\n+\tassert.Equal(t, expectedResponse, string(response))\n+}\n+\n+// getRealCurrentUser returns the actual current user (not test user) for features like port forwarding\n+func getRealCurrentUser() (string, error) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\tif currentUser, err := user.Current(); err == nil {\n+\t\t\treturn currentUser.Username, nil\n+\t\t}\n+\t}\n+\n+\tif username := os.Getenv(\"USER\"); username != \"\" {\n+\t\treturn username, nil\n+\t}\n+\n+\tif currentUser, err := user.Current(); err == nil {\n+\t\treturn currentUser.Username, nil\n+\t}\n+\n+\treturn \"\", fmt.Errorf(\"unable to determine current user\")\n+}\n+\n+// isWindowsPrivilegeError checks if an error is related to Windows privilege restrictions\n+func isWindowsPrivilegeError(err error) bool {\n+\tif err == nil {\n+\t\treturn false\n+\t}\n+\n+\terrStr := strings.ToLower(err.Error())\n+\treturn strings.Contains(errStr, \"ntstatus=0xc0000062\") || // STATUS_PRIVILEGE_NOT_HELD\n+\t\tstrings.Contains(errStr, \"0xc0000041\") || // STATUS_PRIVILEGE_NOT_HELD (LsaRegisterLogonProcess)\n+\t\tstrings.Contains(errStr, \"0xc0000062\") || // STATUS_PRIVILEGE_NOT_HELD (LsaLogonUser)\n+\t\tstrings.Contains(errStr, \"privilege\") ||\n+\t\tstrings.Contains(errStr, \"access denied\") ||\n+\t\tstrings.Contains(errStr, \"user authentication failed\")\n+}\ndiff --git a/client/ssh/config/manager_test.go b/client/ssh/config/manager_test.go\nnew file mode 100644\nindex 00000000000..dc3ad95b35f\n--- /dev/null\n+++ b/client/ssh/config/manager_test.go\n@@ -0,0 +1,159 @@\n+package config\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+func TestManager_SetupSSHClientConfig(t *testing.T) {\n+\t// Create temporary directory for test\n+\ttempDir, err := os.MkdirTemp(\"\", \"netbird-ssh-config-test\")\n+\trequire.NoError(t, err)\n+\tdefer func() { assert.NoError(t, os.RemoveAll(tempDir)) }()\n+\n+\t// Override manager paths to use temp directory\n+\tmanager := &Manager{\n+\t\tsshConfigDir:  filepath.Join(tempDir, \"ssh_config.d\"),\n+\t\tsshConfigFile: \"99-netbird.conf\",\n+\t}\n+\n+\t// Test SSH config generation with peers\n+\tpeers := []PeerSSHInfo{\n+\t\t{\n+\t\t\tHostname: \"peer1\",\n+\t\t\tIP:       \"100.125.1.1\",\n+\t\t\tFQDN:     \"peer1.nb.internal\",\n+\t\t},\n+\t\t{\n+\t\t\tHostname: \"peer2\",\n+\t\t\tIP:       \"100.125.1.2\",\n+\t\t\tFQDN:     \"peer2.nb.internal\",\n+\t\t},\n+\t}\n+\n+\terr = manager.SetupSSHClientConfig(peers)\n+\trequire.NoError(t, err)\n+\n+\t// Read generated config\n+\tconfigPath := filepath.Join(manager.sshConfigDir, manager.sshConfigFile)\n+\tcontent, err := os.ReadFile(configPath)\n+\trequire.NoError(t, err)\n+\n+\tconfigStr := string(content)\n+\n+\t// Verify the basic SSH config structure exists\n+\tassert.Contains(t, configStr, \"# NetBird SSH client configuration\")\n+\tassert.Contains(t, configStr, \"Generated automatically - do not edit manually\")\n+\n+\t// Check that peer hostnames are included\n+\tassert.Contains(t, configStr, \"100.125.1.1\")\n+\tassert.Contains(t, configStr, \"100.125.1.2\")\n+\tassert.Contains(t, configStr, \"peer1.nb.internal\")\n+\tassert.Contains(t, configStr, \"peer2.nb.internal\")\n+\n+\t// Check platform-specific UserKnownHostsFile\n+\tif runtime.GOOS == \"windows\" {\n+\t\tassert.Contains(t, configStr, \"UserKnownHostsFile NUL\")\n+\t} else {\n+\t\tassert.Contains(t, configStr, \"UserKnownHostsFile /dev/null\")\n+\t}\n+}\n+\n+func TestGetSystemSSHConfigDir(t *testing.T) {\n+\tconfigDir := getSystemSSHConfigDir()\n+\n+\t// Path should not be empty\n+\tassert.NotEmpty(t, configDir)\n+\n+\t// Should be an absolute path\n+\tassert.True(t, filepath.IsAbs(configDir))\n+\n+\t// On Unix systems, should start with /etc\n+\t// On Windows, should contain ProgramData\n+\tif runtime.GOOS == \"windows\" {\n+\t\tassert.Contains(t, strings.ToLower(configDir), \"programdata\")\n+\t} else {\n+\t\tassert.Contains(t, configDir, \"/etc/ssh\")\n+\t}\n+}\n+\n+func TestManager_PeerLimit(t *testing.T) {\n+\t// Create temporary directory for test\n+\ttempDir, err := os.MkdirTemp(\"\", \"netbird-ssh-config-test\")\n+\trequire.NoError(t, err)\n+\tdefer func() { assert.NoError(t, os.RemoveAll(tempDir)) }()\n+\n+\t// Override manager paths to use temp directory\n+\tmanager := &Manager{\n+\t\tsshConfigDir:  filepath.Join(tempDir, \"ssh_config.d\"),\n+\t\tsshConfigFile: \"99-netbird.conf\",\n+\t}\n+\n+\t// Generate many peers (more than limit)\n+\tvar peers []PeerSSHInfo\n+\tfor i := 0; i < MaxPeersForSSHConfig+10; i++ {\n+\t\tpeers = append(peers, PeerSSHInfo{\n+\t\t\tHostname: fmt.Sprintf(\"peer%d\", i),\n+\t\t\tIP:       fmt.Sprintf(\"100.125.1.%d\", i%254+1),\n+\t\t\tFQDN:     fmt.Sprintf(\"peer%d.nb.internal\", i),\n+\t\t})\n+\t}\n+\n+\t// Test that SSH config generation is skipped when too many peers\n+\terr = manager.SetupSSHClientConfig(peers)\n+\trequire.NoError(t, err)\n+\n+\t// Config should not be created due to peer limit\n+\tconfigPath := filepath.Join(manager.sshConfigDir, manager.sshConfigFile)\n+\t_, err = os.Stat(configPath)\n+\tassert.True(t, os.IsNotExist(err), \"SSH config should not be created with too many peers\")\n+}\n+\n+func TestManager_ForcedSSHConfig(t *testing.T) {\n+\t// Set force environment variable\n+\tt.Setenv(EnvForceSSHConfig, \"true\")\n+\n+\t// Create temporary directory for test\n+\ttempDir, err := os.MkdirTemp(\"\", \"netbird-ssh-config-test\")\n+\trequire.NoError(t, err)\n+\tdefer func() { assert.NoError(t, os.RemoveAll(tempDir)) }()\n+\n+\t// Override manager paths to use temp directory\n+\tmanager := &Manager{\n+\t\tsshConfigDir:  filepath.Join(tempDir, \"ssh_config.d\"),\n+\t\tsshConfigFile: \"99-netbird.conf\",\n+\t}\n+\n+\t// Generate many peers (more than limit)\n+\tvar peers []PeerSSHInfo\n+\tfor i := 0; i < MaxPeersForSSHConfig+10; i++ {\n+\t\tpeers = append(peers, PeerSSHInfo{\n+\t\t\tHostname: fmt.Sprintf(\"peer%d\", i),\n+\t\t\tIP:       fmt.Sprintf(\"100.125.1.%d\", i%254+1),\n+\t\t\tFQDN:     fmt.Sprintf(\"peer%d.nb.internal\", i),\n+\t\t})\n+\t}\n+\n+\t// Test that SSH config generation is forced despite many peers\n+\terr = manager.SetupSSHClientConfig(peers)\n+\trequire.NoError(t, err)\n+\n+\t// Config should be created despite peer limit due to force flag\n+\tconfigPath := filepath.Join(manager.sshConfigDir, manager.sshConfigFile)\n+\t_, err = os.Stat(configPath)\n+\trequire.NoError(t, err, \"SSH config should be created when forced\")\n+\n+\t// Verify config contains peer hostnames\n+\tcontent, err := os.ReadFile(configPath)\n+\trequire.NoError(t, err)\n+\tconfigStr := string(content)\n+\tassert.Contains(t, configStr, \"peer0.nb.internal\")\n+\tassert.Contains(t, configStr, \"peer1.nb.internal\")\n+}\ndiff --git a/client/ssh/proxy/proxy_test.go b/client/ssh/proxy/proxy_test.go\nnew file mode 100644\nindex 00000000000..c5036da37af\n--- /dev/null\n+++ b/client/ssh/proxy/proxy_test.go\n@@ -0,0 +1,367 @@\n+package proxy\n+\n+import (\n+\t\"context\"\n+\t\"crypto/rand\"\n+\t\"crypto/rsa\"\n+\t\"encoding/base64\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"math/big\"\n+\t\"net\"\n+\t\"net/http\"\n+\t\"net/http/httptest\"\n+\t\"os\"\n+\t\"runtime\"\n+\t\"strconv\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/golang-jwt/jwt/v5\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\tcryptossh \"golang.org/x/crypto/ssh\"\n+\t\"google.golang.org/grpc\"\n+\t\"google.golang.org/grpc/credentials/insecure\"\n+\n+\t\"github.com/netbirdio/netbird/client/proto\"\n+\tnbssh \"github.com/netbirdio/netbird/client/ssh\"\n+\t\"github.com/netbirdio/netbird/client/ssh/server\"\n+\t\"github.com/netbirdio/netbird/client/ssh/testutil\"\n+\tnbjwt \"github.com/netbirdio/netbird/shared/auth/jwt\"\n+)\n+\n+func TestMain(m *testing.M) {\n+\tif len(os.Args) > 2 && os.Args[1] == \"ssh\" {\n+\t\tif os.Args[2] == \"exec\" {\n+\t\t\tif len(os.Args) > 3 {\n+\t\t\t\tcmd := os.Args[3]\n+\t\t\t\tif cmd == \"echo\" && len(os.Args) > 4 {\n+\t\t\t\t\tfmt.Fprintln(os.Stdout, os.Args[4])\n+\t\t\t\t\tos.Exit(0)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfmt.Fprintf(os.Stderr, \"Test binary called as 'ssh exec' with args: %v - preventing infinite recursion\\n\", os.Args)\n+\t\t\tos.Exit(1)\n+\t\t}\n+\t}\n+\n+\tcode := m.Run()\n+\n+\ttestutil.CleanupTestUsers()\n+\n+\tos.Exit(code)\n+}\n+\n+func TestSSHProxy_verifyHostKey(t *testing.T) {\n+\tt.Run(\"calls daemon to verify host key\", func(t *testing.T) {\n+\t\tmockDaemon := startMockDaemon(t)\n+\t\tdefer mockDaemon.stop()\n+\n+\t\tgrpcConn, err := grpc.NewClient(mockDaemon.addr, grpc.WithTransportCredentials(insecure.NewCredentials()))\n+\t\trequire.NoError(t, err)\n+\t\tdefer func() { _ = grpcConn.Close() }()\n+\n+\t\tproxy := &SSHProxy{\n+\t\t\tdaemonAddr:   mockDaemon.addr,\n+\t\t\tdaemonClient: proto.NewDaemonServiceClient(grpcConn),\n+\t\t}\n+\n+\t\ttestKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\t\trequire.NoError(t, err)\n+\t\ttestPubKey, err := nbssh.GeneratePublicKey(testKey)\n+\t\trequire.NoError(t, err)\n+\n+\t\tmockDaemon.setHostKey(\"test-host\", testPubKey)\n+\n+\t\terr = proxy.verifyHostKey(\"test-host\", &net.TCPAddr{IP: net.ParseIP(\"127.0.0.1\"), Port: 22}, mustParsePublicKey(t, testPubKey))\n+\t\tassert.NoError(t, err)\n+\t})\n+\n+\tt.Run(\"rejects unknown host key\", func(t *testing.T) {\n+\t\tmockDaemon := startMockDaemon(t)\n+\t\tdefer mockDaemon.stop()\n+\n+\t\tgrpcConn, err := grpc.NewClient(mockDaemon.addr, grpc.WithTransportCredentials(insecure.NewCredentials()))\n+\t\trequire.NoError(t, err)\n+\t\tdefer func() { _ = grpcConn.Close() }()\n+\n+\t\tproxy := &SSHProxy{\n+\t\t\tdaemonAddr:   mockDaemon.addr,\n+\t\t\tdaemonClient: proto.NewDaemonServiceClient(grpcConn),\n+\t\t}\n+\n+\t\tunknownKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\t\trequire.NoError(t, err)\n+\t\tunknownPubKey, err := nbssh.GeneratePublicKey(unknownKey)\n+\t\trequire.NoError(t, err)\n+\n+\t\terr = proxy.verifyHostKey(\"unknown-host\", &net.TCPAddr{IP: net.ParseIP(\"127.0.0.1\"), Port: 22}, mustParsePublicKey(t, unknownPubKey))\n+\t\tassert.Error(t, err)\n+\t\tassert.Contains(t, err.Error(), \"peer unknown-host not found in network\")\n+\t})\n+}\n+\n+func TestSSHProxy_Connect(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping integration test in short mode\")\n+\t}\n+\n+\t// TODO: Windows test times out - user switching and command execution tested on Linux\n+\tif runtime.GOOS == \"windows\" {\n+\t\tt.Skip(\"Skipping on Windows - covered by Linux tests\")\n+\t}\n+\n+\tconst (\n+\t\tissuer   = \"https://test-issuer.example.com\"\n+\t\taudience = \"test-audience\"\n+\t)\n+\n+\tjwksServer, privateKey, jwksURL := setupJWKSServer(t)\n+\tdefer jwksServer.Close()\n+\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\thostPubKey, err := nbssh.GeneratePublicKey(hostKey)\n+\trequire.NoError(t, err)\n+\n+\tserverConfig := &server.Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT: &server.JWTConfig{\n+\t\t\tIssuer:       issuer,\n+\t\t\tAudience:     audience,\n+\t\t\tKeysLocation: jwksURL,\n+\t\t},\n+\t}\n+\tsshServer := server.New(serverConfig)\n+\tsshServer.SetAllowRootLogin(true)\n+\n+\tsshServerAddr := server.StartTestServer(t, sshServer)\n+\tdefer func() { _ = sshServer.Stop() }()\n+\n+\tmockDaemon := startMockDaemon(t)\n+\tdefer mockDaemon.stop()\n+\n+\thost, portStr, err := net.SplitHostPort(sshServerAddr)\n+\trequire.NoError(t, err)\n+\tport, err := strconv.Atoi(portStr)\n+\trequire.NoError(t, err)\n+\n+\tmockDaemon.setHostKey(host, hostPubKey)\n+\n+\tvalidToken := generateValidJWT(t, privateKey, issuer, audience)\n+\tmockDaemon.setJWTToken(validToken)\n+\n+\tproxyInstance, err := New(mockDaemon.addr, host, port, nil)\n+\trequire.NoError(t, err)\n+\n+\tclientConn, proxyConn := net.Pipe()\n+\tdefer func() { _ = clientConn.Close() }()\n+\n+\torigStdin := os.Stdin\n+\torigStdout := os.Stdout\n+\tdefer func() {\n+\t\tos.Stdin = origStdin\n+\t\tos.Stdout = origStdout\n+\t}()\n+\n+\tstdinReader, stdinWriter, err := os.Pipe()\n+\trequire.NoError(t, err)\n+\tstdoutReader, stdoutWriter, err := os.Pipe()\n+\trequire.NoError(t, err)\n+\n+\tos.Stdin = stdinReader\n+\tos.Stdout = stdoutWriter\n+\n+\tgo func() {\n+\t\t_, _ = io.Copy(stdinWriter, proxyConn)\n+\t}()\n+\tgo func() {\n+\t\t_, _ = io.Copy(proxyConn, stdoutReader)\n+\t}()\n+\n+\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n+\tdefer cancel()\n+\n+\tconnectErrCh := make(chan error, 1)\n+\tgo func() {\n+\t\tconnectErrCh <- proxyInstance.Connect(ctx)\n+\t}()\n+\n+\tsshConfig := &cryptossh.ClientConfig{\n+\t\tUser:            testutil.GetTestUsername(t),\n+\t\tAuth:            []cryptossh.AuthMethod{},\n+\t\tHostKeyCallback: cryptossh.InsecureIgnoreHostKey(),\n+\t\tTimeout:         3 * time.Second,\n+\t}\n+\n+\tsshClientConn, chans, reqs, err := cryptossh.NewClientConn(clientConn, \"test\", sshConfig)\n+\trequire.NoError(t, err, \"Should connect to proxy server\")\n+\tdefer func() { _ = sshClientConn.Close() }()\n+\n+\tsshClient := cryptossh.NewClient(sshClientConn, chans, reqs)\n+\n+\tsession, err := sshClient.NewSession()\n+\trequire.NoError(t, err, \"Should create session through full proxy to backend\")\n+\n+\toutputCh := make(chan []byte, 1)\n+\terrCh := make(chan error, 1)\n+\tgo func() {\n+\t\toutput, err := session.Output(\"echo hello-from-proxy\")\n+\t\toutputCh <- output\n+\t\terrCh <- err\n+\t}()\n+\n+\tselect {\n+\tcase output := <-outputCh:\n+\t\terr := <-errCh\n+\t\trequire.NoError(t, err, \"Command should execute successfully through proxy\")\n+\t\tassert.Contains(t, string(output), \"hello-from-proxy\", \"Should receive command output through proxy\")\n+\tcase <-time.After(3 * time.Second):\n+\t\tt.Fatal(\"Command execution timed out\")\n+\t}\n+\n+\t_ = session.Close()\n+\t_ = sshClient.Close()\n+\t_ = clientConn.Close()\n+\tcancel()\n+}\n+\n+type mockDaemonServer struct {\n+\tproto.UnimplementedDaemonServiceServer\n+\thostKeys map[string][]byte\n+\tjwtToken string\n+}\n+\n+func (m *mockDaemonServer) GetPeerSSHHostKey(ctx context.Context, req *proto.GetPeerSSHHostKeyRequest) (*proto.GetPeerSSHHostKeyResponse, error) {\n+\tkey, found := m.hostKeys[req.PeerAddress]\n+\treturn &proto.GetPeerSSHHostKeyResponse{\n+\t\tFound:      found,\n+\t\tSshHostKey: key,\n+\t}, nil\n+}\n+\n+func (m *mockDaemonServer) RequestJWTAuth(ctx context.Context, req *proto.RequestJWTAuthRequest) (*proto.RequestJWTAuthResponse, error) {\n+\treturn &proto.RequestJWTAuthResponse{\n+\t\tCachedToken: m.jwtToken,\n+\t}, nil\n+}\n+\n+func (m *mockDaemonServer) WaitJWTToken(ctx context.Context, req *proto.WaitJWTTokenRequest) (*proto.WaitJWTTokenResponse, error) {\n+\treturn &proto.WaitJWTTokenResponse{\n+\t\tToken: m.jwtToken,\n+\t}, nil\n+}\n+\n+type mockDaemon struct {\n+\taddr   string\n+\tserver *grpc.Server\n+\timpl   *mockDaemonServer\n+}\n+\n+func startMockDaemon(t *testing.T) *mockDaemon {\n+\tt.Helper()\n+\n+\tlistener, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n+\trequire.NoError(t, err)\n+\n+\timpl := &mockDaemonServer{\n+\t\thostKeys: make(map[string][]byte),\n+\t\tjwtToken: \"test-jwt-token\",\n+\t}\n+\n+\tgrpcServer := grpc.NewServer()\n+\tproto.RegisterDaemonServiceServer(grpcServer, impl)\n+\n+\tgo func() {\n+\t\t_ = grpcServer.Serve(listener)\n+\t}()\n+\n+\treturn &mockDaemon{\n+\t\taddr:   listener.Addr().String(),\n+\t\tserver: grpcServer,\n+\t\timpl:   impl,\n+\t}\n+}\n+\n+func (m *mockDaemon) setHostKey(addr string, pubKey []byte) {\n+\tm.impl.hostKeys[addr] = pubKey\n+}\n+\n+func (m *mockDaemon) setJWTToken(token string) {\n+\tm.impl.jwtToken = token\n+}\n+\n+func (m *mockDaemon) stop() {\n+\tif m.server != nil {\n+\t\tm.server.Stop()\n+\t}\n+}\n+\n+func mustParsePublicKey(t *testing.T, pubKeyBytes []byte) cryptossh.PublicKey {\n+\tt.Helper()\n+\tpubKey, _, _, _, err := cryptossh.ParseAuthorizedKey(pubKeyBytes)\n+\trequire.NoError(t, err)\n+\treturn pubKey\n+}\n+\n+func setupJWKSServer(t *testing.T) (*httptest.Server, *rsa.PrivateKey, string) {\n+\tt.Helper()\n+\tprivateKey, jwksJSON := generateTestJWKS(t)\n+\n+\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n+\t\tif _, err := w.Write(jwksJSON); err != nil {\n+\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n+\t\t}\n+\t}))\n+\n+\treturn server, privateKey, server.URL\n+}\n+\n+func generateTestJWKS(t *testing.T) (*rsa.PrivateKey, []byte) {\n+\tt.Helper()\n+\tprivateKey, err := rsa.GenerateKey(rand.Reader, 2048)\n+\trequire.NoError(t, err)\n+\n+\tpublicKey := &privateKey.PublicKey\n+\tn := publicKey.N.Bytes()\n+\te := publicKey.E\n+\n+\tjwk := nbjwt.JSONWebKey{\n+\t\tKty: \"RSA\",\n+\t\tKid: \"test-key-id\",\n+\t\tUse: \"sig\",\n+\t\tN:   base64.RawURLEncoding.EncodeToString(n),\n+\t\tE:   base64.RawURLEncoding.EncodeToString(big.NewInt(int64(e)).Bytes()),\n+\t}\n+\n+\tjwks := nbjwt.Jwks{\n+\t\tKeys: []nbjwt.JSONWebKey{jwk},\n+\t}\n+\n+\tjwksJSON, err := json.Marshal(jwks)\n+\trequire.NoError(t, err)\n+\n+\treturn privateKey, jwksJSON\n+}\n+\n+func generateValidJWT(t *testing.T, privateKey *rsa.PrivateKey, issuer, audience string) string {\n+\tt.Helper()\n+\tclaims := jwt.MapClaims{\n+\t\t\"iss\": issuer,\n+\t\t\"aud\": audience,\n+\t\t\"sub\": \"test-user\",\n+\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n+\t\t\"iat\": time.Now().Unix(),\n+\t}\n+\n+\ttoken := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)\n+\ttoken.Header[\"kid\"] = \"test-key-id\"\n+\n+\ttokenString, err := token.SignedString(privateKey)\n+\trequire.NoError(t, err)\n+\n+\treturn tokenString\n+}\ndiff --git a/client/ssh/server/compatibility_test.go b/client/ssh/server/compatibility_test.go\nnew file mode 100644\nindex 00000000000..34ffccfd22a\n--- /dev/null\n+++ b/client/ssh/server/compatibility_test.go\n@@ -0,0 +1,722 @@\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"crypto/ed25519\"\n+\t\"crypto/rand\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\t\"golang.org/x/crypto/ssh\"\n+\n+\tnbssh \"github.com/netbirdio/netbird/client/ssh\"\n+\t\"github.com/netbirdio/netbird/client/ssh/testutil\"\n+)\n+\n+// TestMain handles package-level setup and cleanup\n+func TestMain(m *testing.M) {\n+\t// Guard against infinite recursion when test binary is called as \"netbird ssh exec\"\n+\t// This happens when running tests as non-privileged user with fallback\n+\tif len(os.Args) > 2 && os.Args[1] == \"ssh\" && os.Args[2] == \"exec\" {\n+\t\t// Just exit with error to break the recursion\n+\t\tfmt.Fprintf(os.Stderr, \"Test binary called as 'ssh exec' - preventing infinite recursion\\n\")\n+\t\tos.Exit(1)\n+\t}\n+\n+\t// Run tests\n+\tcode := m.Run()\n+\n+\t// Cleanup any created test users\n+\ttestutil.CleanupTestUsers()\n+\n+\tos.Exit(code)\n+}\n+\n+// TestSSHServerCompatibility tests that our SSH server is compatible with the system SSH client\n+func TestSSHServerCompatibility(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping SSH compatibility tests in short mode\")\n+\t}\n+\n+\t// Check if ssh binary is available\n+\tif !isSSHClientAvailable() {\n+\t\tt.Skip(\"SSH client not available on this system\")\n+\t}\n+\n+\t// Set up SSH server - use our existing key generation for server\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\t// Generate OpenSSH-compatible keys for client\n+\tclientPrivKeyOpenSSH, _, err := generateOpenSSHKey(t)\n+\trequire.NoError(t, err)\n+\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := New(serverConfig)\n+\tserver.SetAllowRootLogin(true)\n+\n+\tserverAddr := StartTestServer(t, server)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\t// Create temporary key files for SSH client\n+\tclientKeyFile, cleanupKey := createTempKeyFileFromBytes(t, clientPrivKeyOpenSSH)\n+\tdefer cleanupKey()\n+\n+\t// Extract host and port from server address\n+\thost, portStr, err := net.SplitHostPort(serverAddr)\n+\trequire.NoError(t, err)\n+\n+\t// Get appropriate user for SSH connection (handle system accounts)\n+\tusername := testutil.GetTestUsername(t)\n+\n+\tt.Run(\"basic command execution\", func(t *testing.T) {\n+\t\ttestSSHCommandExecutionWithUser(t, host, portStr, clientKeyFile, username)\n+\t})\n+\n+\tt.Run(\"interactive command\", func(t *testing.T) {\n+\t\ttestSSHInteractiveCommand(t, host, portStr, clientKeyFile)\n+\t})\n+\n+\tt.Run(\"port forwarding\", func(t *testing.T) {\n+\t\ttestSSHPortForwarding(t, host, portStr, clientKeyFile)\n+\t})\n+}\n+\n+// testSSHCommandExecutionWithUser tests basic command execution with system SSH client using specified user.\n+func testSSHCommandExecutionWithUser(t *testing.T, host, port, keyFile, username string) {\n+\tcmd := exec.Command(\"ssh\",\n+\t\t\"-i\", keyFile,\n+\t\t\"-p\", port,\n+\t\t\"-o\", \"StrictHostKeyChecking=no\",\n+\t\t\"-o\", \"UserKnownHostsFile=/dev/null\",\n+\t\t\"-o\", \"ConnectTimeout=5\",\n+\t\tfmt.Sprintf(\"%s@%s\", username, host),\n+\t\t\"echo\", \"hello_world\")\n+\n+\toutput, err := cmd.CombinedOutput()\n+\n+\tif err != nil {\n+\t\tt.Logf(\"SSH command failed: %v\", err)\n+\t\tt.Logf(\"Output: %s\", string(output))\n+\t\treturn\n+\t}\n+\n+\tassert.Contains(t, string(output), \"hello_world\", \"SSH command should execute successfully\")\n+}\n+\n+// testSSHInteractiveCommand tests interactive shell session.\n+func testSSHInteractiveCommand(t *testing.T, host, port, keyFile string) {\n+\t// Get appropriate user for SSH connection\n+\tusername := testutil.GetTestUsername(t)\n+\n+\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n+\tdefer cancel()\n+\n+\tcmd := exec.CommandContext(ctx, \"ssh\",\n+\t\t\"-i\", keyFile,\n+\t\t\"-p\", port,\n+\t\t\"-o\", \"StrictHostKeyChecking=no\",\n+\t\t\"-o\", \"UserKnownHostsFile=/dev/null\",\n+\t\t\"-o\", \"ConnectTimeout=5\",\n+\t\tfmt.Sprintf(\"%s@%s\", username, host))\n+\n+\tstdin, err := cmd.StdinPipe()\n+\tif err != nil {\n+\t\tt.Skipf(\"Cannot create stdin pipe: %v\", err)\n+\t\treturn\n+\t}\n+\n+\tstdout, err := cmd.StdoutPipe()\n+\tif err != nil {\n+\t\tt.Skipf(\"Cannot create stdout pipe: %v\", err)\n+\t\treturn\n+\t}\n+\n+\terr = cmd.Start()\n+\tif err != nil {\n+\t\tt.Logf(\"Cannot start SSH session: %v\", err)\n+\t\treturn\n+\t}\n+\n+\tgo func() {\n+\t\tdefer func() {\n+\t\t\tif err := stdin.Close(); err != nil {\n+\t\t\t\tt.Logf(\"stdin close error: %v\", err)\n+\t\t\t}\n+\t\t}()\n+\t\ttime.Sleep(100 * time.Millisecond)\n+\t\tif _, err := stdin.Write([]byte(\"echo interactive_test\\n\")); err != nil {\n+\t\t\tt.Logf(\"stdin write error: %v\", err)\n+\t\t}\n+\t\ttime.Sleep(100 * time.Millisecond)\n+\t\tif _, err := stdin.Write([]byte(\"exit\\n\")); err != nil {\n+\t\t\tt.Logf(\"stdin write error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\toutput, err := io.ReadAll(stdout)\n+\tif err != nil {\n+\t\tt.Logf(\"Cannot read SSH output: %v\", err)\n+\t}\n+\n+\terr = cmd.Wait()\n+\tif err != nil {\n+\t\tt.Logf(\"SSH interactive session error: %v\", err)\n+\t\tt.Logf(\"Output: %s\", string(output))\n+\t\treturn\n+\t}\n+\n+\tassert.Contains(t, string(output), \"interactive_test\", \"Interactive SSH session should work\")\n+}\n+\n+// testSSHPortForwarding tests port forwarding compatibility.\n+func testSSHPortForwarding(t *testing.T, host, port, keyFile string) {\n+\t// Get appropriate user for SSH connection\n+\tusername := testutil.GetTestUsername(t)\n+\n+\ttestServer, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n+\trequire.NoError(t, err)\n+\tdefer testServer.Close()\n+\n+\ttestServerAddr := testServer.Addr().String()\n+\texpectedResponse := \"HTTP/1.1 200 OK\\r\\nContent-Length: 21\\r\\n\\r\\nCompatibility Test OK\"\n+\n+\tgo func() {\n+\t\tfor {\n+\t\t\tconn, err := testServer.Accept()\n+\t\t\tif err != nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tgo func(c net.Conn) {\n+\t\t\t\tdefer func() {\n+\t\t\t\t\tif err := c.Close(); err != nil {\n+\t\t\t\t\t\tt.Logf(\"test server connection close error: %v\", err)\n+\t\t\t\t\t}\n+\t\t\t\t}()\n+\t\t\t\tbuf := make([]byte, 1024)\n+\t\t\t\tif _, err := c.Read(buf); err != nil {\n+\t\t\t\t\tt.Logf(\"Test server read error: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif _, err := c.Write([]byte(expectedResponse)); err != nil {\n+\t\t\t\t\tt.Logf(\"Test server write error: %v\", err)\n+\t\t\t\t}\n+\t\t\t}(conn)\n+\t\t}\n+\t}()\n+\n+\tlocalListener, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n+\trequire.NoError(t, err)\n+\tlocalAddr := localListener.Addr().String()\n+\tlocalListener.Close()\n+\n+\t_, localPort, err := net.SplitHostPort(localAddr)\n+\trequire.NoError(t, err)\n+\n+\tctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)\n+\tdefer cancel()\n+\n+\tforwardSpec := fmt.Sprintf(\"%s:%s\", localPort, testServerAddr)\n+\tcmd := exec.CommandContext(ctx, \"ssh\",\n+\t\t\"-i\", keyFile,\n+\t\t\"-p\", port,\n+\t\t\"-L\", forwardSpec,\n+\t\t\"-o\", \"StrictHostKeyChecking=no\",\n+\t\t\"-o\", \"UserKnownHostsFile=/dev/null\",\n+\t\t\"-o\", \"ConnectTimeout=5\",\n+\t\t\"-N\",\n+\t\tfmt.Sprintf(\"%s@%s\", username, host))\n+\n+\terr = cmd.Start()\n+\tif err != nil {\n+\t\tt.Logf(\"Cannot start SSH port forwarding: %v\", err)\n+\t\treturn\n+\t}\n+\n+\tdefer func() {\n+\t\tif cmd.Process != nil {\n+\t\t\tif err := cmd.Process.Kill(); err != nil {\n+\t\t\t\tt.Logf(\"process kill error: %v\", err)\n+\t\t\t}\n+\t\t}\n+\t\tif err := cmd.Wait(); err != nil {\n+\t\t\tt.Logf(\"process wait after kill: %v\", err)\n+\t\t}\n+\t}()\n+\n+\ttime.Sleep(500 * time.Millisecond)\n+\n+\tconn, err := net.DialTimeout(\"tcp\", localAddr, 3*time.Second)\n+\tif err != nil {\n+\t\tt.Logf(\"Cannot connect to forwarded port: %v\", err)\n+\t\treturn\n+\t}\n+\tdefer func() {\n+\t\tif err := conn.Close(); err != nil {\n+\t\t\tt.Logf(\"forwarded connection close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\trequest := \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n\"\n+\t_, err = conn.Write([]byte(request))\n+\trequire.NoError(t, err)\n+\n+\tif err := conn.SetReadDeadline(time.Now().Add(3 * time.Second)); err != nil {\n+\t\tlog.Debugf(\"failed to set read deadline: %v\", err)\n+\t}\n+\tresponse := make([]byte, len(expectedResponse))\n+\tn, err := io.ReadFull(conn, response)\n+\tif err != nil {\n+\t\tt.Logf(\"Cannot read forwarded response: %v\", err)\n+\t\treturn\n+\t}\n+\n+\tassert.Equal(t, len(expectedResponse), n, \"Should read expected number of bytes\")\n+\tassert.Equal(t, expectedResponse, string(response), \"Should get correct HTTP response through SSH port forwarding\")\n+}\n+\n+// isSSHClientAvailable checks if the ssh binary is available\n+func isSSHClientAvailable() bool {\n+\t_, err := exec.LookPath(\"ssh\")\n+\treturn err == nil\n+}\n+\n+// generateOpenSSHKey generates an ED25519 key in OpenSSH format that the system SSH client can use.\n+func generateOpenSSHKey(t *testing.T) ([]byte, []byte, error) {\n+\t// Check if ssh-keygen is available\n+\tif _, err := exec.LookPath(\"ssh-keygen\"); err != nil {\n+\t\t// Fall back to our existing key generation and try to convert\n+\t\treturn generateOpenSSHKeyFallback()\n+\t}\n+\n+\t// Create temporary file for ssh-keygen\n+\ttempFile, err := os.CreateTemp(\"\", \"ssh_keygen_*\")\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"create temp file: %w\", err)\n+\t}\n+\tkeyPath := tempFile.Name()\n+\ttempFile.Close()\n+\n+\t// Remove the temp file so ssh-keygen can create it\n+\tif err := os.Remove(keyPath); err != nil {\n+\t\tt.Logf(\"failed to remove key file: %v\", err)\n+\t}\n+\n+\t// Clean up temp files\n+\tdefer func() {\n+\t\tif err := os.Remove(keyPath); err != nil {\n+\t\t\tt.Logf(\"failed to cleanup key file: %v\", err)\n+\t\t}\n+\t\tif err := os.Remove(keyPath + \".pub\"); err != nil {\n+\t\t\tt.Logf(\"failed to cleanup public key file: %v\", err)\n+\t\t}\n+\t}()\n+\n+\t// Generate key using ssh-keygen\n+\tcmd := exec.Command(\"ssh-keygen\", \"-t\", \"ed25519\", \"-f\", keyPath, \"-N\", \"\", \"-q\")\n+\toutput, err := cmd.CombinedOutput()\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"ssh-keygen failed: %w, output: %s\", err, string(output))\n+\t}\n+\n+\t// Read private key\n+\tprivKeyBytes, err := os.ReadFile(keyPath)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"read private key: %w\", err)\n+\t}\n+\n+\t// Read public key\n+\tpubKeyBytes, err := os.ReadFile(keyPath + \".pub\")\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"read public key: %w\", err)\n+\t}\n+\n+\treturn privKeyBytes, pubKeyBytes, nil\n+}\n+\n+// generateOpenSSHKeyFallback falls back to generating keys using our existing method\n+func generateOpenSSHKeyFallback() ([]byte, []byte, error) {\n+\t// Generate shared.ED25519 key pair using our existing method\n+\t_, privKey, err := ed25519.GenerateKey(rand.Reader)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"generate key: %w\", err)\n+\t}\n+\n+\t// Convert to SSH format\n+\tsshPrivKey, err := ssh.NewSignerFromKey(privKey)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"create signer: %w\", err)\n+\t}\n+\n+\t// For the fallback, just use our PKCS#8 format and hope it works\n+\t// This won't be in OpenSSH format but might still work with some SSH clients\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"generate fallback key: %w\", err)\n+\t}\n+\n+\t// Get public key in SSH format\n+\tsshPubKey := ssh.MarshalAuthorizedKey(sshPrivKey.PublicKey())\n+\n+\treturn hostKey, sshPubKey, nil\n+}\n+\n+// createTempKeyFileFromBytes creates a temporary SSH private key file from raw bytes\n+func createTempKeyFileFromBytes(t *testing.T, keyBytes []byte) (string, func()) {\n+\tt.Helper()\n+\n+\ttempFile, err := os.CreateTemp(\"\", \"ssh_test_key_*\")\n+\trequire.NoError(t, err)\n+\n+\t_, err = tempFile.Write(keyBytes)\n+\trequire.NoError(t, err)\n+\n+\terr = tempFile.Close()\n+\trequire.NoError(t, err)\n+\n+\t// Set proper permissions for SSH key (readable by owner only)\n+\terr = os.Chmod(tempFile.Name(), 0600)\n+\trequire.NoError(t, err)\n+\n+\tcleanup := func() {\n+\t\t_ = os.Remove(tempFile.Name())\n+\t}\n+\n+\treturn tempFile.Name(), cleanup\n+}\n+\n+// createTempKeyFile creates a temporary SSH private key file (for backward compatibility)\n+func createTempKeyFile(t *testing.T, privateKey []byte) (string, func()) {\n+\treturn createTempKeyFileFromBytes(t, privateKey)\n+}\n+\n+// TestSSHServerFeatureCompatibility tests specific SSH features for compatibility\n+func TestSSHServerFeatureCompatibility(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping SSH feature compatibility tests in short mode\")\n+\t}\n+\n+\tif runtime.GOOS == \"windows\" && testutil.IsCI() {\n+\t\tt.Skip(\"Skipping Windows SSH compatibility tests in CI due to S4U authentication issues\")\n+\t}\n+\n+\tif !isSSHClientAvailable() {\n+\t\tt.Skip(\"SSH client not available on this system\")\n+\t}\n+\n+\t// Test various SSH features\n+\ttestCases := []struct {\n+\t\tname        string\n+\t\ttestFunc    func(t *testing.T, host, port, keyFile string)\n+\t\tdescription string\n+\t}{\n+\t\t{\n+\t\t\tname:        \"command_with_flags\",\n+\t\t\ttestFunc:    testCommandWithFlags,\n+\t\t\tdescription: \"Commands with flags should work like standard SSH\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"environment_variables\",\n+\t\t\ttestFunc:    testEnvironmentVariables,\n+\t\t\tdescription: \"Environment variables should be available\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"exit_codes\",\n+\t\t\ttestFunc:    testExitCodes,\n+\t\t\tdescription: \"Exit codes should be properly handled\",\n+\t\t},\n+\t}\n+\n+\t// Set up SSH server\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tclientPrivKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := New(serverConfig)\n+\tserver.SetAllowRootLogin(true)\n+\n+\tserverAddr := StartTestServer(t, server)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\tclientKeyFile, cleanupKey := createTempKeyFile(t, clientPrivKey)\n+\tdefer cleanupKey()\n+\n+\thost, portStr, err := net.SplitHostPort(serverAddr)\n+\trequire.NoError(t, err)\n+\n+\tfor _, tc := range testCases {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\ttc.testFunc(t, host, portStr, clientKeyFile)\n+\t\t})\n+\t}\n+}\n+\n+// testCommandWithFlags tests that commands with flags work properly\n+func testCommandWithFlags(t *testing.T, host, port, keyFile string) {\n+\t// Get appropriate user for SSH connection\n+\tusername := testutil.GetTestUsername(t)\n+\n+\t// Test ls with flags\n+\tcmd := exec.Command(\"ssh\",\n+\t\t\"-i\", keyFile,\n+\t\t\"-p\", port,\n+\t\t\"-o\", \"StrictHostKeyChecking=no\",\n+\t\t\"-o\", \"UserKnownHostsFile=/dev/null\",\n+\t\t\"-o\", \"ConnectTimeout=5\",\n+\t\tfmt.Sprintf(\"%s@%s\", username, host),\n+\t\t\"ls\", \"-la\", \"/tmp\")\n+\n+\toutput, err := cmd.CombinedOutput()\n+\tif err != nil {\n+\t\tt.Logf(\"Command with flags failed: %v\", err)\n+\t\tt.Logf(\"Output: %s\", string(output))\n+\t\treturn\n+\t}\n+\n+\t// Should not be empty and should not contain error messages\n+\tassert.NotEmpty(t, string(output), \"ls -la should produce output\")\n+\tassert.NotContains(t, strings.ToLower(string(output)), \"command not found\", \"Command should be executed\")\n+}\n+\n+// testEnvironmentVariables tests that environment is properly set up\n+func testEnvironmentVariables(t *testing.T, host, port, keyFile string) {\n+\t// Get appropriate user for SSH connection\n+\tusername := testutil.GetTestUsername(t)\n+\n+\tcmd := exec.Command(\"ssh\",\n+\t\t\"-i\", keyFile,\n+\t\t\"-p\", port,\n+\t\t\"-o\", \"StrictHostKeyChecking=no\",\n+\t\t\"-o\", \"UserKnownHostsFile=/dev/null\",\n+\t\t\"-o\", \"ConnectTimeout=5\",\n+\t\tfmt.Sprintf(\"%s@%s\", username, host),\n+\t\t\"echo\", \"$HOME\")\n+\n+\toutput, err := cmd.CombinedOutput()\n+\tif err != nil {\n+\t\tt.Logf(\"Environment test failed: %v\", err)\n+\t\tt.Logf(\"Output: %s\", string(output))\n+\t\treturn\n+\t}\n+\n+\t// HOME environment variable should be available\n+\thomeOutput := strings.TrimSpace(string(output))\n+\tassert.NotEmpty(t, homeOutput, \"HOME environment variable should be set\")\n+\tassert.NotEqual(t, \"$HOME\", homeOutput, \"Environment variable should be expanded\")\n+}\n+\n+// testExitCodes tests that exit codes are properly handled\n+func testExitCodes(t *testing.T, host, port, keyFile string) {\n+\t// Get appropriate user for SSH connection\n+\tusername := testutil.GetTestUsername(t)\n+\n+\t// Test successful command (exit code 0)\n+\tcmd := exec.Command(\"ssh\",\n+\t\t\"-i\", keyFile,\n+\t\t\"-p\", port,\n+\t\t\"-o\", \"StrictHostKeyChecking=no\",\n+\t\t\"-o\", \"UserKnownHostsFile=/dev/null\",\n+\t\t\"-o\", \"ConnectTimeout=5\",\n+\t\tfmt.Sprintf(\"%s@%s\", username, host),\n+\t\t\"true\") // always succeeds\n+\n+\terr := cmd.Run()\n+\tassert.NoError(t, err, \"Command with exit code 0 should succeed\")\n+\n+\t// Test failing command (exit code 1)\n+\tcmd = exec.Command(\"ssh\",\n+\t\t\"-i\", keyFile,\n+\t\t\"-p\", port,\n+\t\t\"-o\", \"StrictHostKeyChecking=no\",\n+\t\t\"-o\", \"UserKnownHostsFile=/dev/null\",\n+\t\t\"-o\", \"ConnectTimeout=5\",\n+\t\tfmt.Sprintf(\"%s@%s\", username, host),\n+\t\t\"false\") // always fails\n+\n+\terr = cmd.Run()\n+\tassert.Error(t, err, \"Command with exit code 1 should fail\")\n+\n+\t// Check if it's the right kind of error\n+\tif exitError, ok := err.(*exec.ExitError); ok {\n+\t\tassert.Equal(t, 1, exitError.ExitCode(), \"Exit code should be preserved\")\n+\t}\n+}\n+\n+// TestSSHServerSecurityFeatures tests security-related SSH features\n+func TestSSHServerSecurityFeatures(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping SSH security tests in short mode\")\n+\t}\n+\n+\tif !isSSHClientAvailable() {\n+\t\tt.Skip(\"SSH client not available on this system\")\n+\t}\n+\n+\t// Get appropriate user for SSH connection\n+\tusername := testutil.GetTestUsername(t)\n+\n+\t// Set up SSH server with specific security settings\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tclientPrivKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := New(serverConfig)\n+\tserver.SetAllowRootLogin(true)\n+\n+\tserverAddr := StartTestServer(t, server)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\tclientKeyFile, cleanupKey := createTempKeyFile(t, clientPrivKey)\n+\tdefer cleanupKey()\n+\n+\thost, portStr, err := net.SplitHostPort(serverAddr)\n+\trequire.NoError(t, err)\n+\n+\tt.Run(\"key_authentication\", func(t *testing.T) {\n+\t\t// Test that key authentication works\n+\t\tcmd := exec.Command(\"ssh\",\n+\t\t\t\"-i\", clientKeyFile,\n+\t\t\t\"-p\", portStr,\n+\t\t\t\"-o\", \"StrictHostKeyChecking=no\",\n+\t\t\t\"-o\", \"UserKnownHostsFile=/dev/null\",\n+\t\t\t\"-o\", \"ConnectTimeout=5\",\n+\t\t\t\"-o\", \"PasswordAuthentication=no\",\n+\t\t\tfmt.Sprintf(\"%s@%s\", username, host),\n+\t\t\t\"echo\", \"auth_success\")\n+\n+\t\toutput, err := cmd.CombinedOutput()\n+\t\tif err != nil {\n+\t\t\tt.Logf(\"Key authentication failed: %v\", err)\n+\t\t\tt.Logf(\"Output: %s\", string(output))\n+\t\t\treturn\n+\t\t}\n+\n+\t\tassert.Contains(t, string(output), \"auth_success\", \"Key authentication should work\")\n+\t})\n+\n+\tt.Run(\"any_key_accepted_in_no_auth_mode\", func(t *testing.T) {\n+\t\t// Create a different key that shouldn't be accepted\n+\t\twrongKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\t\trequire.NoError(t, err)\n+\n+\t\twrongKeyFile, cleanupWrongKey := createTempKeyFile(t, wrongKey)\n+\t\tdefer cleanupWrongKey()\n+\n+\t\t// Test that wrong key is rejected\n+\t\tcmd := exec.Command(\"ssh\",\n+\t\t\t\"-i\", wrongKeyFile,\n+\t\t\t\"-p\", portStr,\n+\t\t\t\"-o\", \"StrictHostKeyChecking=no\",\n+\t\t\t\"-o\", \"UserKnownHostsFile=/dev/null\",\n+\t\t\t\"-o\", \"ConnectTimeout=5\",\n+\t\t\t\"-o\", \"PasswordAuthentication=no\",\n+\t\t\tfmt.Sprintf(\"%s@%s\", username, host),\n+\t\t\t\"echo\", \"should_not_work\")\n+\n+\t\terr = cmd.Run()\n+\t\tassert.NoError(t, err, \"Any key should work in no-auth mode\")\n+\t})\n+}\n+\n+// TestCrossPlatformCompatibility tests cross-platform behavior\n+func TestCrossPlatformCompatibility(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping cross-platform compatibility tests in short mode\")\n+\t}\n+\n+\tif !isSSHClientAvailable() {\n+\t\tt.Skip(\"SSH client not available on this system\")\n+\t}\n+\n+\t// Get appropriate user for SSH connection\n+\tusername := testutil.GetTestUsername(t)\n+\n+\t// Set up SSH server\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tclientPrivKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := New(serverConfig)\n+\tserver.SetAllowRootLogin(true)\n+\n+\tserverAddr := StartTestServer(t, server)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\tclientKeyFile, cleanupKey := createTempKeyFile(t, clientPrivKey)\n+\tdefer cleanupKey()\n+\n+\thost, portStr, err := net.SplitHostPort(serverAddr)\n+\trequire.NoError(t, err)\n+\n+\t// Test platform-specific commands\n+\tvar testCommand string\n+\n+\tswitch runtime.GOOS {\n+\tcase \"windows\":\n+\t\ttestCommand = \"echo %OS%\"\n+\tdefault:\n+\t\ttestCommand = \"uname\"\n+\t}\n+\n+\tcmd := exec.Command(\"ssh\",\n+\t\t\"-i\", clientKeyFile,\n+\t\t\"-p\", portStr,\n+\t\t\"-o\", \"StrictHostKeyChecking=no\",\n+\t\t\"-o\", \"UserKnownHostsFile=/dev/null\",\n+\t\t\"-o\", \"ConnectTimeout=5\",\n+\t\tfmt.Sprintf(\"%s@%s\", username, host),\n+\t\ttestCommand)\n+\n+\toutput, err := cmd.CombinedOutput()\n+\tif err != nil {\n+\t\tt.Logf(\"Platform-specific command failed: %v\", err)\n+\t\tt.Logf(\"Output: %s\", string(output))\n+\t\treturn\n+\t}\n+\n+\toutputStr := strings.TrimSpace(string(output))\n+\tt.Logf(\"Platform command output: %s\", outputStr)\n+\tassert.NotEmpty(t, outputStr, \"Platform-specific command should produce output\")\n+}\ndiff --git a/client/ssh/server/executor_unix_test.go b/client/ssh/server/executor_unix_test.go\nnew file mode 100644\nindex 00000000000..0c5108f57fa\n--- /dev/null\n+++ b/client/ssh/server/executor_unix_test.go\n@@ -0,0 +1,262 @@\n+//go:build unix\n+\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"os/user\"\n+\t\"strconv\"\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+func TestPrivilegeDropper_ValidatePrivileges(t *testing.T) {\n+\tpd := NewPrivilegeDropper()\n+\n+\tcurrentUID := uint32(os.Geteuid())\n+\tcurrentGID := uint32(os.Getegid())\n+\n+\ttests := []struct {\n+\t\tname    string\n+\t\tuid     uint32\n+\t\tgid     uint32\n+\t\twantErr bool\n+\t}{\n+\t\t{\n+\t\t\tname:    \"same user - no privilege drop needed\",\n+\t\t\tuid:     currentUID,\n+\t\t\tgid:     currentGID,\n+\t\t\twantErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"non-root to different user should fail\",\n+\t\t\tuid:     currentUID + 1,  // Use a different UID to ensure it's actually different\n+\t\t\tgid:     currentGID + 1,  // Use a different GID to ensure it's actually different\n+\t\t\twantErr: currentUID != 0, // Only fail if current user is not root\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"root can drop to any user\",\n+\t\t\tuid:     1000,\n+\t\t\tgid:     1000,\n+\t\t\twantErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"root can stay as root\",\n+\t\t\tuid:     0,\n+\t\t\tgid:     0,\n+\t\t\twantErr: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Skip non-root tests when running as root, and root tests when not root\n+\t\t\tif tt.name == \"non-root to different user should fail\" && currentUID == 0 {\n+\t\t\t\tt.Skip(\"Skipping non-root test when running as root\")\n+\t\t\t}\n+\t\t\tif (tt.name == \"root can drop to any user\" || tt.name == \"root can stay as root\") && currentUID != 0 {\n+\t\t\t\tt.Skip(\"Skipping root test when not running as root\")\n+\t\t\t}\n+\n+\t\t\terr := pd.validatePrivileges(tt.uid, tt.gid)\n+\t\t\tif tt.wantErr {\n+\t\t\t\tassert.Error(t, err)\n+\t\t\t} else {\n+\t\t\t\tassert.NoError(t, err)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestPrivilegeDropper_CreateExecutorCommand(t *testing.T) {\n+\tpd := NewPrivilegeDropper()\n+\n+\tconfig := ExecutorConfig{\n+\t\tUID:        1000,\n+\t\tGID:        1000,\n+\t\tGroups:     []uint32{1000, 1001},\n+\t\tWorkingDir: \"/home/testuser\",\n+\t\tShell:      \"/bin/bash\",\n+\t\tCommand:    \"ls -la\",\n+\t}\n+\n+\tcmd, err := pd.CreateExecutorCommand(context.Background(), config)\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, cmd)\n+\n+\t// Verify the command is calling netbird ssh exec\n+\tassert.Contains(t, cmd.Args, \"ssh\")\n+\tassert.Contains(t, cmd.Args, \"exec\")\n+\tassert.Contains(t, cmd.Args, \"--uid\")\n+\tassert.Contains(t, cmd.Args, \"1000\")\n+\tassert.Contains(t, cmd.Args, \"--gid\")\n+\tassert.Contains(t, cmd.Args, \"1000\")\n+\tassert.Contains(t, cmd.Args, \"--groups\")\n+\tassert.Contains(t, cmd.Args, \"1000\")\n+\tassert.Contains(t, cmd.Args, \"1001\")\n+\tassert.Contains(t, cmd.Args, \"--working-dir\")\n+\tassert.Contains(t, cmd.Args, \"/home/testuser\")\n+\tassert.Contains(t, cmd.Args, \"--shell\")\n+\tassert.Contains(t, cmd.Args, \"/bin/bash\")\n+\tassert.Contains(t, cmd.Args, \"--cmd\")\n+\tassert.Contains(t, cmd.Args, \"ls -la\")\n+}\n+\n+func TestPrivilegeDropper_CreateExecutorCommandInteractive(t *testing.T) {\n+\tpd := NewPrivilegeDropper()\n+\n+\tconfig := ExecutorConfig{\n+\t\tUID:        1000,\n+\t\tGID:        1000,\n+\t\tGroups:     []uint32{1000},\n+\t\tWorkingDir: \"/home/testuser\",\n+\t\tShell:      \"/bin/bash\",\n+\t\tCommand:    \"\",\n+\t}\n+\n+\tcmd, err := pd.CreateExecutorCommand(context.Background(), config)\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, cmd)\n+\n+\t// Verify no command mode (command is empty so no --cmd flag)\n+\tassert.NotContains(t, cmd.Args, \"--cmd\")\n+\tassert.NotContains(t, cmd.Args, \"--interactive\")\n+}\n+\n+// TestPrivilegeDropper_ActualPrivilegeDrop tests actual privilege dropping\n+// This test requires root privileges and will be skipped if not running as root\n+func TestPrivilegeDropper_ActualPrivilegeDrop(t *testing.T) {\n+\tif os.Geteuid() != 0 {\n+\t\tt.Skip(\"This test requires root privileges\")\n+\t}\n+\n+\t// Find a non-root user to test with\n+\ttestUser, err := findNonRootUser()\n+\tif err != nil {\n+\t\tt.Skip(\"No suitable non-root user found for testing\")\n+\t}\n+\n+\t// Verify the user actually exists by looking it up again\n+\t_, err = user.LookupId(testUser.Uid)\n+\tif err != nil {\n+\t\tt.Skipf(\"Test user %s (UID %s) does not exist on this system: %v\", testUser.Username, testUser.Uid, err)\n+\t}\n+\n+\tuid64, err := strconv.ParseUint(testUser.Uid, 10, 32)\n+\trequire.NoError(t, err)\n+\ttargetUID := uint32(uid64)\n+\n+\tgid64, err := strconv.ParseUint(testUser.Gid, 10, 32)\n+\trequire.NoError(t, err)\n+\ttargetGID := uint32(gid64)\n+\n+\t// Test in a child process to avoid affecting the test runner\n+\tif os.Getenv(\"TEST_PRIVILEGE_DROP\") == \"1\" {\n+\t\tpd := NewPrivilegeDropper()\n+\n+\t\t// This should succeed\n+\t\terr := pd.DropPrivileges(targetUID, targetGID, []uint32{targetGID})\n+\t\trequire.NoError(t, err)\n+\n+\t\t// Verify we are now running as the target user\n+\t\tcurrentUID := uint32(os.Geteuid())\n+\t\tcurrentGID := uint32(os.Getegid())\n+\n+\t\tassert.Equal(t, targetUID, currentUID, \"UID should match target\")\n+\t\tassert.Equal(t, targetGID, currentGID, \"GID should match target\")\n+\t\tassert.NotEqual(t, uint32(0), currentUID, \"Should not be running as root\")\n+\t\tassert.NotEqual(t, uint32(0), currentGID, \"Should not be running as root group\")\n+\n+\t\treturn\n+\t}\n+\n+\t// Fork a child process to test privilege dropping\n+\tcmd := os.Args[0]\n+\targs := []string{\"-test.run=TestPrivilegeDropper_ActualPrivilegeDrop\"}\n+\n+\tenv := append(os.Environ(), \"TEST_PRIVILEGE_DROP=1\")\n+\n+\texecCmd := exec.Command(cmd, args...)\n+\texecCmd.Env = env\n+\n+\terr = execCmd.Run()\n+\trequire.NoError(t, err, \"Child process should succeed\")\n+}\n+\n+// findNonRootUser finds any non-root user on the system for testing\n+func findNonRootUser() (*user.User, error) {\n+\t// Try common non-root users, but avoid \"nobody\" on macOS due to negative UID issues\n+\tcommonUsers := []string{\"daemon\", \"bin\", \"sys\", \"sync\", \"games\", \"man\", \"lp\", \"mail\", \"news\", \"uucp\", \"proxy\", \"www-data\", \"backup\", \"list\", \"irc\"}\n+\n+\tfor _, username := range commonUsers {\n+\t\tif u, err := user.Lookup(username); err == nil {\n+\t\t\t// Parse as signed integer first to handle negative UIDs\n+\t\t\tuid64, err := strconv.ParseInt(u.Uid, 10, 32)\n+\t\t\tif err != nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\t// Skip negative UIDs (like nobody=-2 on macOS) and root\n+\t\t\tif uid64 > 0 && uid64 != 0 {\n+\t\t\t\treturn u, nil\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// If no common users found, try to find any regular user with UID > 100\n+\t// This helps on macOS where regular users start at UID 501\n+\tallUsers := []string{\"vma\", \"user\", \"test\", \"admin\"}\n+\tfor _, username := range allUsers {\n+\t\tif u, err := user.Lookup(username); err == nil {\n+\t\t\tuid64, err := strconv.ParseInt(u.Uid, 10, 32)\n+\t\t\tif err != nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif uid64 > 100 { // Regular user\n+\t\t\t\treturn u, nil\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// If no common users found, return an error\n+\treturn nil, fmt.Errorf(\"no suitable non-root user found on this system\")\n+}\n+\n+func TestPrivilegeDropper_ExecuteWithPrivilegeDrop_Validation(t *testing.T) {\n+\tpd := NewPrivilegeDropper()\n+\tcurrentUID := uint32(os.Geteuid())\n+\n+\tif currentUID == 0 {\n+\t\t// When running as root, test that root can create commands for any user\n+\t\tconfig := ExecutorConfig{\n+\t\t\tUID:        1000, // Target non-root user\n+\t\t\tGID:        1000,\n+\t\t\tGroups:     []uint32{1000},\n+\t\t\tWorkingDir: \"/tmp\",\n+\t\t\tShell:      \"/bin/sh\",\n+\t\t\tCommand:    \"echo test\",\n+\t\t}\n+\n+\t\tcmd, err := pd.CreateExecutorCommand(context.Background(), config)\n+\t\tassert.NoError(t, err, \"Root should be able to create commands for any user\")\n+\t\tassert.NotNil(t, cmd)\n+\t} else {\n+\t\t// When running as non-root, test that we can't drop to a different user\n+\t\tconfig := ExecutorConfig{\n+\t\t\tUID:        0, // Try to target root\n+\t\t\tGID:        0,\n+\t\t\tGroups:     []uint32{0},\n+\t\t\tWorkingDir: \"/tmp\",\n+\t\t\tShell:      \"/bin/sh\",\n+\t\t\tCommand:    \"echo test\",\n+\t\t}\n+\n+\t\t_, err := pd.CreateExecutorCommand(context.Background(), config)\n+\t\tassert.Error(t, err)\n+\t\tassert.Contains(t, err.Error(), \"cannot drop privileges\")\n+\t}\n+}\ndiff --git a/client/ssh/server/jwt_test.go b/client/ssh/server/jwt_test.go\nnew file mode 100644\nindex 00000000000..e22bdfb06c4\n--- /dev/null\n+++ b/client/ssh/server/jwt_test.go\n@@ -0,0 +1,629 @@\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"crypto/rand\"\n+\t\"crypto/rsa\"\n+\t\"encoding/base64\"\n+\t\"encoding/json\"\n+\t\"io\"\n+\t\"math/big\"\n+\t\"net\"\n+\t\"net/http\"\n+\t\"net/http/httptest\"\n+\t\"runtime\"\n+\t\"strconv\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/golang-jwt/jwt/v5\"\n+\tcryptossh \"golang.org/x/crypto/ssh\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\n+\tnbssh \"github.com/netbirdio/netbird/client/ssh\"\n+\t\"github.com/netbirdio/netbird/client/ssh/client\"\n+\t\"github.com/netbirdio/netbird/client/ssh/detection\"\n+\t\"github.com/netbirdio/netbird/client/ssh/testutil\"\n+\tnbjwt \"github.com/netbirdio/netbird/shared/auth/jwt\"\n+)\n+\n+func TestJWTEnforcement(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping JWT enforcement tests in short mode\")\n+\t}\n+\n+\t// Set up SSH server\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tt.Run(\"blocks_without_jwt\", func(t *testing.T) {\n+\t\tjwtConfig := &JWTConfig{\n+\t\t\tIssuer:       \"test-issuer\",\n+\t\t\tAudience:     \"test-audience\",\n+\t\t\tKeysLocation: \"test-keys\",\n+\t\t}\n+\t\tserverConfig := &Config{\n+\t\t\tHostKeyPEM: hostKey,\n+\t\t\tJWT:        jwtConfig,\n+\t\t}\n+\t\tserver := New(serverConfig)\n+\t\tserver.SetAllowRootLogin(true)\n+\n+\t\tserverAddr := StartTestServer(t, server)\n+\t\tdefer require.NoError(t, server.Stop())\n+\n+\t\thost, portStr, err := net.SplitHostPort(serverAddr)\n+\t\trequire.NoError(t, err)\n+\t\tport, err := strconv.Atoi(portStr)\n+\t\trequire.NoError(t, err)\n+\t\tdialer := &net.Dialer{Timeout: detection.Timeout}\n+\t\tserverType, err := detection.DetectSSHServerType(context.Background(), dialer, host, port)\n+\t\tif err != nil {\n+\t\t\tt.Logf(\"Detection failed: %v\", err)\n+\t\t}\n+\t\tt.Logf(\"Detected server type: %s\", serverType)\n+\n+\t\tconfig := &cryptossh.ClientConfig{\n+\t\t\tUser:            testutil.GetTestUsername(t),\n+\t\t\tAuth:            []cryptossh.AuthMethod{},\n+\t\t\tHostKeyCallback: cryptossh.InsecureIgnoreHostKey(),\n+\t\t\tTimeout:         2 * time.Second,\n+\t\t}\n+\n+\t\t_, err = cryptossh.Dial(\"tcp\", net.JoinHostPort(host, portStr), config)\n+\t\tassert.Error(t, err, \"SSH connection should fail when JWT is required but not provided\")\n+\t})\n+\n+\tt.Run(\"allows_when_disabled\", func(t *testing.T) {\n+\t\tserverConfigNoJWT := &Config{\n+\t\t\tHostKeyPEM: hostKey,\n+\t\t\tJWT:        nil,\n+\t\t}\n+\t\tserverNoJWT := New(serverConfigNoJWT)\n+\t\trequire.False(t, serverNoJWT.jwtEnabled, \"JWT should be disabled without config\")\n+\t\tserverNoJWT.SetAllowRootLogin(true)\n+\n+\t\tserverAddrNoJWT := StartTestServer(t, serverNoJWT)\n+\t\tdefer require.NoError(t, serverNoJWT.Stop())\n+\n+\t\thostNoJWT, portStrNoJWT, err := net.SplitHostPort(serverAddrNoJWT)\n+\t\trequire.NoError(t, err)\n+\t\tportNoJWT, err := strconv.Atoi(portStrNoJWT)\n+\t\trequire.NoError(t, err)\n+\n+\t\tdialer := &net.Dialer{Timeout: detection.Timeout}\n+\t\tserverType, err := detection.DetectSSHServerType(context.Background(), dialer, hostNoJWT, portNoJWT)\n+\t\trequire.NoError(t, err)\n+\t\tassert.Equal(t, detection.ServerTypeNetBirdNoJWT, serverType)\n+\t\tassert.False(t, serverType.RequiresJWT())\n+\n+\t\tclient, err := connectWithNetBirdClient(t, hostNoJWT, portNoJWT)\n+\t\trequire.NoError(t, err)\n+\t\tdefer client.Close()\n+\t})\n+\n+}\n+\n+// setupJWKSServer creates a test HTTP server serving JWKS and returns the server, private key, and URL\n+func setupJWKSServer(t *testing.T) (*httptest.Server, *rsa.PrivateKey, string) {\n+\tprivateKey, jwksJSON := generateTestJWKS(t)\n+\n+\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n+\t\tif _, err := w.Write(jwksJSON); err != nil {\n+\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n+\t\t}\n+\t}))\n+\n+\treturn server, privateKey, server.URL\n+}\n+\n+// generateTestJWKS creates a test RSA key pair and returns private key and JWKS JSON\n+func generateTestJWKS(t *testing.T) (*rsa.PrivateKey, []byte) {\n+\tprivateKey, err := rsa.GenerateKey(rand.Reader, 2048)\n+\trequire.NoError(t, err)\n+\n+\tpublicKey := &privateKey.PublicKey\n+\tn := publicKey.N.Bytes()\n+\te := publicKey.E\n+\n+\tjwk := nbjwt.JSONWebKey{\n+\t\tKty: \"RSA\",\n+\t\tKid: \"test-key-id\",\n+\t\tUse: \"sig\",\n+\t\tN:   base64RawURLEncode(n),\n+\t\tE:   base64RawURLEncode(big.NewInt(int64(e)).Bytes()),\n+\t}\n+\n+\tjwks := nbjwt.Jwks{\n+\t\tKeys: []nbjwt.JSONWebKey{jwk},\n+\t}\n+\n+\tjwksJSON, err := json.Marshal(jwks)\n+\trequire.NoError(t, err)\n+\n+\treturn privateKey, jwksJSON\n+}\n+\n+func base64RawURLEncode(data []byte) string {\n+\treturn base64.RawURLEncoding.EncodeToString(data)\n+}\n+\n+// generateValidJWT creates a valid JWT token for testing\n+func generateValidJWT(t *testing.T, privateKey *rsa.PrivateKey, issuer, audience string) string {\n+\tclaims := jwt.MapClaims{\n+\t\t\"iss\": issuer,\n+\t\t\"aud\": audience,\n+\t\t\"sub\": \"test-user\",\n+\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n+\t\t\"iat\": time.Now().Unix(),\n+\t}\n+\n+\ttoken := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)\n+\ttoken.Header[\"kid\"] = \"test-key-id\"\n+\n+\ttokenString, err := token.SignedString(privateKey)\n+\trequire.NoError(t, err)\n+\n+\treturn tokenString\n+}\n+\n+// connectWithNetBirdClient connects to SSH server using NetBird's SSH client\n+func connectWithNetBirdClient(t *testing.T, host string, port int) (*client.Client, error) {\n+\tt.Helper()\n+\taddr := net.JoinHostPort(host, strconv.Itoa(port))\n+\n+\tctx := context.Background()\n+\treturn client.Dial(ctx, addr, testutil.GetTestUsername(t), client.DialOptions{\n+\t\tInsecureSkipVerify: true,\n+\t})\n+}\n+\n+// TestJWTDetection tests that server detection correctly identifies JWT-enabled servers\n+func TestJWTDetection(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping JWT detection test in short mode\")\n+\t}\n+\n+\tjwksServer, _, jwksURL := setupJWKSServer(t)\n+\tdefer jwksServer.Close()\n+\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tconst (\n+\t\tissuer   = \"https://test-issuer.example.com\"\n+\t\taudience = \"test-audience\"\n+\t)\n+\n+\tjwtConfig := &JWTConfig{\n+\t\tIssuer:       issuer,\n+\t\tAudience:     audience,\n+\t\tKeysLocation: jwksURL,\n+\t}\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        jwtConfig,\n+\t}\n+\tserver := New(serverConfig)\n+\tserver.SetAllowRootLogin(true)\n+\n+\tserverAddr := StartTestServer(t, server)\n+\tdefer require.NoError(t, server.Stop())\n+\n+\thost, portStr, err := net.SplitHostPort(serverAddr)\n+\trequire.NoError(t, err)\n+\tport, err := strconv.Atoi(portStr)\n+\trequire.NoError(t, err)\n+\n+\tdialer := &net.Dialer{Timeout: detection.Timeout}\n+\tserverType, err := detection.DetectSSHServerType(context.Background(), dialer, host, port)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, detection.ServerTypeNetBirdJWT, serverType)\n+\tassert.True(t, serverType.RequiresJWT())\n+}\n+\n+func TestJWTFailClose(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping JWT fail-close tests in short mode\")\n+\t}\n+\n+\tjwksServer, privateKey, jwksURL := setupJWKSServer(t)\n+\tdefer jwksServer.Close()\n+\n+\tconst (\n+\t\tissuer   = \"https://test-issuer.example.com\"\n+\t\taudience = \"test-audience\"\n+\t)\n+\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\ttestCases := []struct {\n+\t\tname        string\n+\t\ttokenClaims jwt.MapClaims\n+\t}{\n+\t\t{\n+\t\t\tname: \"blocks_token_missing_iat\",\n+\t\t\ttokenClaims: jwt.MapClaims{\n+\t\t\t\t\"iss\": issuer,\n+\t\t\t\t\"aud\": audience,\n+\t\t\t\t\"sub\": \"test-user\",\n+\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"blocks_token_missing_sub\",\n+\t\t\ttokenClaims: jwt.MapClaims{\n+\t\t\t\t\"iss\": issuer,\n+\t\t\t\t\"aud\": audience,\n+\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n+\t\t\t\t\"iat\": time.Now().Unix(),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"blocks_token_missing_iss\",\n+\t\t\ttokenClaims: jwt.MapClaims{\n+\t\t\t\t\"aud\": audience,\n+\t\t\t\t\"sub\": \"test-user\",\n+\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n+\t\t\t\t\"iat\": time.Now().Unix(),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"blocks_token_missing_aud\",\n+\t\t\ttokenClaims: jwt.MapClaims{\n+\t\t\t\t\"iss\": issuer,\n+\t\t\t\t\"sub\": \"test-user\",\n+\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n+\t\t\t\t\"iat\": time.Now().Unix(),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"blocks_token_wrong_issuer\",\n+\t\t\ttokenClaims: jwt.MapClaims{\n+\t\t\t\t\"iss\": \"wrong-issuer\",\n+\t\t\t\t\"aud\": audience,\n+\t\t\t\t\"sub\": \"test-user\",\n+\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n+\t\t\t\t\"iat\": time.Now().Unix(),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"blocks_token_wrong_audience\",\n+\t\t\ttokenClaims: jwt.MapClaims{\n+\t\t\t\t\"iss\": issuer,\n+\t\t\t\t\"aud\": \"wrong-audience\",\n+\t\t\t\t\"sub\": \"test-user\",\n+\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n+\t\t\t\t\"iat\": time.Now().Unix(),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"blocks_expired_token\",\n+\t\t\ttokenClaims: jwt.MapClaims{\n+\t\t\t\t\"iss\": issuer,\n+\t\t\t\t\"aud\": audience,\n+\t\t\t\t\"sub\": \"test-user\",\n+\t\t\t\t\"exp\": time.Now().Add(-time.Hour).Unix(),\n+\t\t\t\t\"iat\": time.Now().Add(-2 * time.Hour).Unix(),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"blocks_token_exceeding_max_age\",\n+\t\t\ttokenClaims: jwt.MapClaims{\n+\t\t\t\t\"iss\": issuer,\n+\t\t\t\t\"aud\": audience,\n+\t\t\t\t\"sub\": \"test-user\",\n+\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n+\t\t\t\t\"iat\": time.Now().Add(-2 * time.Hour).Unix(),\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tjwtConfig := &JWTConfig{\n+\t\t\t\tIssuer:       issuer,\n+\t\t\t\tAudience:     audience,\n+\t\t\t\tKeysLocation: jwksURL,\n+\t\t\t\tMaxTokenAge:  3600,\n+\t\t\t}\n+\t\t\tserverConfig := &Config{\n+\t\t\t\tHostKeyPEM: hostKey,\n+\t\t\t\tJWT:        jwtConfig,\n+\t\t\t}\n+\t\t\tserver := New(serverConfig)\n+\t\t\tserver.SetAllowRootLogin(true)\n+\n+\t\t\tserverAddr := StartTestServer(t, server)\n+\t\t\tdefer require.NoError(t, server.Stop())\n+\n+\t\t\thost, portStr, err := net.SplitHostPort(serverAddr)\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\ttoken := jwt.NewWithClaims(jwt.SigningMethodRS256, tc.tokenClaims)\n+\t\t\ttoken.Header[\"kid\"] = \"test-key-id\"\n+\t\t\ttokenString, err := token.SignedString(privateKey)\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\tconfig := &cryptossh.ClientConfig{\n+\t\t\t\tUser: testutil.GetTestUsername(t),\n+\t\t\t\tAuth: []cryptossh.AuthMethod{\n+\t\t\t\t\tcryptossh.Password(tokenString),\n+\t\t\t\t},\n+\t\t\t\tHostKeyCallback: cryptossh.InsecureIgnoreHostKey(),\n+\t\t\t\tTimeout:         2 * time.Second,\n+\t\t\t}\n+\n+\t\t\tconn, err := cryptossh.Dial(\"tcp\", net.JoinHostPort(host, portStr), config)\n+\t\t\tif conn != nil {\n+\t\t\t\tdefer func() {\n+\t\t\t\t\tif err := conn.Close(); err != nil {\n+\t\t\t\t\t\tt.Logf(\"close connection: %v\", err)\n+\t\t\t\t\t}\n+\t\t\t\t}()\n+\t\t\t}\n+\n+\t\t\tassert.Error(t, err, \"Authentication should fail (fail-close)\")\n+\t\t})\n+\t}\n+}\n+\n+// TestJWTAuthentication tests JWT authentication with valid/invalid tokens and enforcement for various connection types\n+func TestJWTAuthentication(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping JWT authentication tests in short mode\")\n+\t}\n+\n+\tjwksServer, privateKey, jwksURL := setupJWKSServer(t)\n+\tdefer jwksServer.Close()\n+\n+\tconst (\n+\t\tissuer   = \"https://test-issuer.example.com\"\n+\t\taudience = \"test-audience\"\n+\t)\n+\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\ttestCases := []struct {\n+\t\tname          string\n+\t\ttoken         string\n+\t\twantAuthOK    bool\n+\t\tsetupServer   func(*Server)\n+\t\ttestOperation func(*testing.T, *cryptossh.Client, string) error\n+\t\twantOpSuccess bool\n+\t}{\n+\t\t{\n+\t\t\tname:       \"allows_shell_with_jwt\",\n+\t\t\ttoken:      \"valid\",\n+\t\t\twantAuthOK: true,\n+\t\t\tsetupServer: func(s *Server) {\n+\t\t\t\ts.SetAllowRootLogin(true)\n+\t\t\t},\n+\t\t\ttestOperation: func(t *testing.T, conn *cryptossh.Client, _ string) error {\n+\t\t\t\tsession, err := conn.NewSession()\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\tdefer session.Close()\n+\t\t\t\treturn session.Shell()\n+\t\t\t},\n+\t\t\twantOpSuccess: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:       \"rejects_invalid_token\",\n+\t\t\ttoken:      \"invalid\",\n+\t\t\twantAuthOK: false,\n+\t\t\tsetupServer: func(s *Server) {\n+\t\t\t\ts.SetAllowRootLogin(true)\n+\t\t\t},\n+\t\t\ttestOperation: func(t *testing.T, conn *cryptossh.Client, _ string) error {\n+\t\t\t\tsession, err := conn.NewSession()\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\tdefer session.Close()\n+\n+\t\t\t\toutput, err := session.CombinedOutput(\"echo test\")\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Logf(\"Command output: %s\", string(output))\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\t\t\t\treturn nil\n+\t\t\t},\n+\t\t\twantOpSuccess: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:       \"blocks_shell_without_jwt\",\n+\t\t\ttoken:      \"\",\n+\t\t\twantAuthOK: false,\n+\t\t\tsetupServer: func(s *Server) {\n+\t\t\t\ts.SetAllowRootLogin(true)\n+\t\t\t},\n+\t\t\ttestOperation: func(t *testing.T, conn *cryptossh.Client, _ string) error {\n+\t\t\t\tsession, err := conn.NewSession()\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\tdefer session.Close()\n+\n+\t\t\t\toutput, err := session.CombinedOutput(\"echo test\")\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Logf(\"Command output: %s\", string(output))\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\t\t\t\treturn nil\n+\t\t\t},\n+\t\t\twantOpSuccess: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:       \"blocks_command_without_jwt\",\n+\t\t\ttoken:      \"\",\n+\t\t\twantAuthOK: false,\n+\t\t\tsetupServer: func(s *Server) {\n+\t\t\t\ts.SetAllowRootLogin(true)\n+\t\t\t},\n+\t\t\ttestOperation: func(t *testing.T, conn *cryptossh.Client, _ string) error {\n+\t\t\t\tsession, err := conn.NewSession()\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\tdefer session.Close()\n+\n+\t\t\t\toutput, err := session.CombinedOutput(\"ls\")\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Logf(\"Command output: %s\", string(output))\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\t\t\t\treturn nil\n+\t\t\t},\n+\t\t\twantOpSuccess: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:       \"allows_sftp_with_jwt\",\n+\t\t\ttoken:      \"valid\",\n+\t\t\twantAuthOK: true,\n+\t\t\tsetupServer: func(s *Server) {\n+\t\t\t\ts.SetAllowRootLogin(true)\n+\t\t\t\ts.SetAllowSFTP(true)\n+\t\t\t},\n+\t\t\ttestOperation: func(t *testing.T, conn *cryptossh.Client, _ string) error {\n+\t\t\t\tsession, err := conn.NewSession()\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\tdefer session.Close()\n+\n+\t\t\t\tsession.Stdout = io.Discard\n+\t\t\t\tsession.Stderr = io.Discard\n+\t\t\t\treturn session.RequestSubsystem(\"sftp\")\n+\t\t\t},\n+\t\t\twantOpSuccess: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:       \"blocks_sftp_without_jwt\",\n+\t\t\ttoken:      \"\",\n+\t\t\twantAuthOK: false,\n+\t\t\tsetupServer: func(s *Server) {\n+\t\t\t\ts.SetAllowRootLogin(true)\n+\t\t\t\ts.SetAllowSFTP(true)\n+\t\t\t},\n+\t\t\ttestOperation: func(t *testing.T, conn *cryptossh.Client, _ string) error {\n+\t\t\t\tsession, err := conn.NewSession()\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\tdefer session.Close()\n+\n+\t\t\t\tsession.Stdout = io.Discard\n+\t\t\t\tsession.Stderr = io.Discard\n+\t\t\t\terr = session.RequestSubsystem(\"sftp\")\n+\t\t\t\tif err == nil {\n+\t\t\t\t\terr = session.Wait()\n+\t\t\t\t}\n+\t\t\t\treturn err\n+\t\t\t},\n+\t\t\twantOpSuccess: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:       \"allows_port_forward_with_jwt\",\n+\t\t\ttoken:      \"valid\",\n+\t\t\twantAuthOK: true,\n+\t\t\tsetupServer: func(s *Server) {\n+\t\t\t\ts.SetAllowRootLogin(true)\n+\t\t\t\ts.SetAllowRemotePortForwarding(true)\n+\t\t\t},\n+\t\t\ttestOperation: func(t *testing.T, conn *cryptossh.Client, _ string) error {\n+\t\t\t\tln, err := conn.Listen(\"tcp\", \"127.0.0.1:0\")\n+\t\t\t\tif ln != nil {\n+\t\t\t\t\tdefer ln.Close()\n+\t\t\t\t}\n+\t\t\t\treturn err\n+\t\t\t},\n+\t\t\twantOpSuccess: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:       \"blocks_port_forward_without_jwt\",\n+\t\t\ttoken:      \"\",\n+\t\t\twantAuthOK: false,\n+\t\t\tsetupServer: func(s *Server) {\n+\t\t\t\ts.SetAllowRootLogin(true)\n+\t\t\t\ts.SetAllowLocalPortForwarding(true)\n+\t\t\t},\n+\t\t\ttestOperation: func(t *testing.T, conn *cryptossh.Client, _ string) error {\n+\t\t\t\tln, err := conn.Listen(\"tcp\", \"127.0.0.1:0\")\n+\t\t\t\tif ln != nil {\n+\t\t\t\t\tdefer ln.Close()\n+\t\t\t\t}\n+\t\t\t\treturn err\n+\t\t\t},\n+\t\t\twantOpSuccess: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\t// TODO: Skip port forwarding tests on Windows - user switching not supported\n+\t\t\t// These features are tested on Linux/Unix platforms\n+\t\t\tif runtime.GOOS == \"windows\" &&\n+\t\t\t\t(tc.name == \"allows_port_forward_with_jwt\" ||\n+\t\t\t\t\ttc.name == \"blocks_port_forward_without_jwt\") {\n+\t\t\t\tt.Skip(\"Skipping port forwarding test on Windows - covered by Linux tests\")\n+\t\t\t}\n+\n+\t\t\tjwtConfig := &JWTConfig{\n+\t\t\t\tIssuer:       issuer,\n+\t\t\t\tAudience:     audience,\n+\t\t\t\tKeysLocation: jwksURL,\n+\t\t\t}\n+\t\t\tserverConfig := &Config{\n+\t\t\t\tHostKeyPEM: hostKey,\n+\t\t\t\tJWT:        jwtConfig,\n+\t\t\t}\n+\t\t\tserver := New(serverConfig)\n+\t\t\tif tc.setupServer != nil {\n+\t\t\t\ttc.setupServer(server)\n+\t\t\t}\n+\n+\t\t\tserverAddr := StartTestServer(t, server)\n+\t\t\tdefer require.NoError(t, server.Stop())\n+\n+\t\t\thost, portStr, err := net.SplitHostPort(serverAddr)\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\tvar authMethods []cryptossh.AuthMethod\n+\t\t\tif tc.token == \"valid\" {\n+\t\t\t\ttoken := generateValidJWT(t, privateKey, issuer, audience)\n+\t\t\t\tauthMethods = []cryptossh.AuthMethod{\n+\t\t\t\t\tcryptossh.Password(token),\n+\t\t\t\t}\n+\t\t\t} else if tc.token == \"invalid\" {\n+\t\t\t\tinvalidToken := \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.invalid\"\n+\t\t\t\tauthMethods = []cryptossh.AuthMethod{\n+\t\t\t\t\tcryptossh.Password(invalidToken),\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tconfig := &cryptossh.ClientConfig{\n+\t\t\t\tUser:            testutil.GetTestUsername(t),\n+\t\t\t\tAuth:            authMethods,\n+\t\t\t\tHostKeyCallback: cryptossh.InsecureIgnoreHostKey(),\n+\t\t\t\tTimeout:         2 * time.Second,\n+\t\t\t}\n+\n+\t\t\tconn, err := cryptossh.Dial(\"tcp\", net.JoinHostPort(host, portStr), config)\n+\t\t\tif tc.wantAuthOK {\n+\t\t\t\trequire.NoError(t, err, \"JWT authentication should succeed\")\n+\t\t\t} else if err != nil {\n+\t\t\t\tt.Logf(\"Connection failed as expected: %v\", err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif conn != nil {\n+\t\t\t\tdefer func() {\n+\t\t\t\t\tif err := conn.Close(); err != nil {\n+\t\t\t\t\t\tt.Logf(\"close connection: %v\", err)\n+\t\t\t\t\t}\n+\t\t\t\t}()\n+\t\t\t}\n+\n+\t\t\terr = tc.testOperation(t, conn, serverAddr)\n+\t\t\tif tc.wantOpSuccess {\n+\t\t\t\trequire.NoError(t, err, \"Operation should succeed\")\n+\t\t\t} else {\n+\t\t\t\tassert.Error(t, err, \"Operation should fail\")\n+\t\t\t}\n+\t\t})\n+\t}\n+}\ndiff --git a/client/ssh/server/server_config_test.go b/client/ssh/server/server_config_test.go\nnew file mode 100644\nindex 00000000000..24e455025be\n--- /dev/null\n+++ b/client/ssh/server/server_config_test.go\n@@ -0,0 +1,394 @@\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"net\"\n+\t\"os/user\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\n+\t\"github.com/netbirdio/netbird/client/ssh\"\n+\tsshclient \"github.com/netbirdio/netbird/client/ssh/client\"\n+)\n+\n+func TestServer_RootLoginRestriction(t *testing.T) {\n+\t// Generate host key for server\n+\thostKey, err := ssh.GeneratePrivateKey(ssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\ttests := []struct {\n+\t\tname        string\n+\t\tallowRoot   bool\n+\t\tusername    string\n+\t\texpectError bool\n+\t\tdescription string\n+\t}{\n+\t\t{\n+\t\t\tname:        \"root login allowed\",\n+\t\t\tallowRoot:   true,\n+\t\t\tusername:    \"root\",\n+\t\t\texpectError: false,\n+\t\t\tdescription: \"Root login should succeed when allowed\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"root login denied\",\n+\t\t\tallowRoot:   false,\n+\t\t\tusername:    \"root\",\n+\t\t\texpectError: true,\n+\t\t\tdescription: \"Root login should fail when disabled\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"regular user login always allowed\",\n+\t\t\tallowRoot:   false,\n+\t\t\tusername:    \"testuser\",\n+\t\t\texpectError: false,\n+\t\t\tdescription: \"Regular user login should work regardless of root setting\",\n+\t\t},\n+\t}\n+\n+\t// Add Windows Administrator tests if on Windows\n+\tif runtime.GOOS == \"windows\" {\n+\t\ttests = append(tests, []struct {\n+\t\t\tname        string\n+\t\t\tallowRoot   bool\n+\t\t\tusername    string\n+\t\t\texpectError bool\n+\t\t\tdescription string\n+\t\t}{\n+\t\t\t{\n+\t\t\t\tname:        \"Administrator login allowed\",\n+\t\t\t\tallowRoot:   true,\n+\t\t\t\tusername:    \"Administrator\",\n+\t\t\t\texpectError: false,\n+\t\t\t\tdescription: \"Administrator login should succeed when allowed\",\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tname:        \"Administrator login denied\",\n+\t\t\t\tallowRoot:   false,\n+\t\t\t\tusername:    \"Administrator\",\n+\t\t\t\texpectError: true,\n+\t\t\t\tdescription: \"Administrator login should fail when disabled\",\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tname:        \"administrator login denied (lowercase)\",\n+\t\t\t\tallowRoot:   false,\n+\t\t\t\tusername:    \"administrator\",\n+\t\t\t\texpectError: true,\n+\t\t\t\tdescription: \"administrator login should fail when disabled (case insensitive)\",\n+\t\t\t},\n+\t\t}...)\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Mock privileged environment to test root access controls\n+\t\t\t// Set up mock users based on platform\n+\t\t\tmockUsers := map[string]*user.User{\n+\t\t\t\t\"root\":     createTestUser(\"root\", \"0\", \"0\", \"/root\"),\n+\t\t\t\t\"testuser\": createTestUser(\"testuser\", \"1000\", \"1000\", \"/home/testuser\"),\n+\t\t\t}\n+\n+\t\t\t// Add Windows-specific users for Administrator tests\n+\t\t\tif runtime.GOOS == \"windows\" {\n+\t\t\t\tmockUsers[\"Administrator\"] = createTestUser(\"Administrator\", \"500\", \"544\", \"C:\\\\Users\\\\Administrator\")\n+\t\t\t\tmockUsers[\"administrator\"] = createTestUser(\"administrator\", \"500\", \"544\", \"C:\\\\Users\\\\administrator\")\n+\t\t\t}\n+\n+\t\t\tcleanup := setupTestDependencies(\n+\t\t\t\tcreateTestUser(\"root\", \"0\", \"0\", \"/root\"), // Running as root\n+\t\t\t\tnil,\n+\t\t\t\truntime.GOOS,\n+\t\t\t\t0, // euid 0 (root)\n+\t\t\t\tmockUsers,\n+\t\t\t\tnil,\n+\t\t\t)\n+\t\t\tdefer cleanup()\n+\n+\t\t\t// Create server with specific configuration\n+\t\t\tserverConfig := &Config{\n+\t\t\t\tHostKeyPEM: hostKey,\n+\t\t\t\tJWT:        nil,\n+\t\t\t}\n+\t\t\tserver := New(serverConfig)\n+\t\t\tserver.SetAllowRootLogin(tt.allowRoot)\n+\n+\t\t\t// Test the userNameLookup method directly\n+\t\t\tuser, err := server.userNameLookup(tt.username)\n+\n+\t\t\tif tt.expectError {\n+\t\t\t\tassert.Error(t, err, tt.description)\n+\t\t\t\tif tt.username == \"root\" || strings.ToLower(tt.username) == \"administrator\" {\n+\t\t\t\t\t// Check for appropriate error message based on platform capabilities\n+\t\t\t\t\terrorMsg := err.Error()\n+\t\t\t\t\t// Either privileged user restriction OR user switching limitation\n+\t\t\t\t\thasPrivilegedError := strings.Contains(errorMsg, \"privileged user\")\n+\t\t\t\t\thasSwitchingError := strings.Contains(errorMsg, \"cannot switch\") || strings.Contains(errorMsg, \"user switching not supported\")\n+\t\t\t\t\tassert.True(t, hasPrivilegedError || hasSwitchingError,\n+\t\t\t\t\t\t\"Expected privileged user or user switching error, got: %s\", errorMsg)\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif tt.username == \"root\" || strings.ToLower(tt.username) == \"administrator\" {\n+\t\t\t\t\t// For privileged users, we expect either success or a different error\n+\t\t\t\t\t// (like user not found), but not the \"login disabled\" error\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\tassert.NotContains(t, err.Error(), \"privileged user login is disabled\")\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\t// For regular users, lookup should generally succeed or fall back gracefully\n+\t\t\t\t\t// Note: may return current user as fallback\n+\t\t\t\t\tassert.NotNil(t, user)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestServer_PortForwardingRestriction(t *testing.T) {\n+\t// Test that the port forwarding callbacks properly respect configuration flags\n+\t// This is a unit test of the callback logic, not a full integration test\n+\n+\t// Generate host key for server\n+\thostKey, err := ssh.GeneratePrivateKey(ssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\ttests := []struct {\n+\t\tname                  string\n+\t\tallowLocalForwarding  bool\n+\t\tallowRemoteForwarding bool\n+\t\tdescription           string\n+\t}{\n+\t\t{\n+\t\t\tname:                  \"all forwarding allowed\",\n+\t\t\tallowLocalForwarding:  true,\n+\t\t\tallowRemoteForwarding: true,\n+\t\t\tdescription:           \"Both local and remote forwarding should be allowed\",\n+\t\t},\n+\t\t{\n+\t\t\tname:                  \"local forwarding disabled\",\n+\t\t\tallowLocalForwarding:  false,\n+\t\t\tallowRemoteForwarding: true,\n+\t\t\tdescription:           \"Local forwarding should be denied when disabled\",\n+\t\t},\n+\t\t{\n+\t\t\tname:                  \"remote forwarding disabled\",\n+\t\t\tallowLocalForwarding:  true,\n+\t\t\tallowRemoteForwarding: false,\n+\t\t\tdescription:           \"Remote forwarding should be denied when disabled\",\n+\t\t},\n+\t\t{\n+\t\t\tname:                  \"all forwarding disabled\",\n+\t\t\tallowLocalForwarding:  false,\n+\t\t\tallowRemoteForwarding: false,\n+\t\t\tdescription:           \"Both forwarding types should be denied when disabled\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Create server with specific configuration\n+\t\t\tserverConfig := &Config{\n+\t\t\t\tHostKeyPEM: hostKey,\n+\t\t\t\tJWT:        nil,\n+\t\t\t}\n+\t\t\tserver := New(serverConfig)\n+\t\t\tserver.SetAllowLocalPortForwarding(tt.allowLocalForwarding)\n+\t\t\tserver.SetAllowRemotePortForwarding(tt.allowRemoteForwarding)\n+\n+\t\t\t// We need to access the internal configuration to simulate the callback tests\n+\t\t\t// Since the callbacks are created inside the Start method, we'll test the logic directly\n+\n+\t\t\t// Test the configuration values are set correctly\n+\t\t\tserver.mu.RLock()\n+\t\t\tallowLocal := server.allowLocalPortForwarding\n+\t\t\tallowRemote := server.allowRemotePortForwarding\n+\t\t\tserver.mu.RUnlock()\n+\n+\t\t\tassert.Equal(t, tt.allowLocalForwarding, allowLocal, \"Local forwarding configuration should be set correctly\")\n+\t\t\tassert.Equal(t, tt.allowRemoteForwarding, allowRemote, \"Remote forwarding configuration should be set correctly\")\n+\n+\t\t\t// Simulate the callback logic\n+\t\t\tlocalResult := allowLocal   // This would be the callback return value\n+\t\t\tremoteResult := allowRemote // This would be the callback return value\n+\n+\t\t\tassert.Equal(t, tt.allowLocalForwarding, localResult,\n+\t\t\t\t\"Local port forwarding callback should return correct value\")\n+\t\t\tassert.Equal(t, tt.allowRemoteForwarding, remoteResult,\n+\t\t\t\t\"Remote port forwarding callback should return correct value\")\n+\t\t})\n+\t}\n+}\n+\n+func TestServer_PortConflictHandling(t *testing.T) {\n+\t// Test that multiple sessions requesting the same local port are handled naturally by the OS\n+\t// Get current user for SSH connection\n+\tcurrentUser, err := user.Current()\n+\trequire.NoError(t, err, \"Should be able to get current user\")\n+\n+\t// Generate host key for server\n+\thostKey, err := ssh.GeneratePrivateKey(ssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\t// Create server\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := New(serverConfig)\n+\tserver.SetAllowRootLogin(true)\n+\n+\tserverAddr := StartTestServer(t, server)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\t// Get a free port for testing\n+\tln, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n+\trequire.NoError(t, err)\n+\ttestPort := ln.Addr().(*net.TCPAddr).Port\n+\terr = ln.Close()\n+\trequire.NoError(t, err)\n+\n+\t// Connect first client\n+\tctx1, cancel1 := context.WithTimeout(context.Background(), 5*time.Second)\n+\tdefer cancel1()\n+\n+\tclient1, err := sshclient.Dial(ctx1, serverAddr, currentUser.Username, sshclient.DialOptions{\n+\t\tInsecureSkipVerify: true,\n+\t})\n+\trequire.NoError(t, err)\n+\tdefer func() {\n+\t\terr := client1.Close()\n+\t\tassert.NoError(t, err)\n+\t}()\n+\n+\t// Connect second client\n+\tctx2, cancel2 := context.WithTimeout(context.Background(), 5*time.Second)\n+\tdefer cancel2()\n+\n+\tclient2, err := sshclient.Dial(ctx2, serverAddr, currentUser.Username, sshclient.DialOptions{\n+\t\tInsecureSkipVerify: true,\n+\t})\n+\trequire.NoError(t, err)\n+\tdefer func() {\n+\t\terr := client2.Close()\n+\t\tassert.NoError(t, err)\n+\t}()\n+\n+\t// First client binds to the test port\n+\tlocalAddr1 := fmt.Sprintf(\"127.0.0.1:%d\", testPort)\n+\tremoteAddr := \"127.0.0.1:80\"\n+\n+\t// Start first client's port forwarding\n+\tdone1 := make(chan error, 1)\n+\tgo func() {\n+\t\t// This should succeed and hold the port\n+\t\terr := client1.LocalPortForward(ctx1, localAddr1, remoteAddr)\n+\t\tdone1 <- err\n+\t}()\n+\n+\t// Give first client time to bind\n+\ttime.Sleep(200 * time.Millisecond)\n+\n+\t// Second client tries to bind to same port\n+\tlocalAddr2 := fmt.Sprintf(\"127.0.0.1:%d\", testPort)\n+\n+\tshortCtx, shortCancel := context.WithTimeout(context.Background(), 1*time.Second)\n+\tdefer shortCancel()\n+\n+\terr = client2.LocalPortForward(shortCtx, localAddr2, remoteAddr)\n+\t// Second client should fail due to \"address already in use\"\n+\tassert.Error(t, err, \"Second client should fail to bind to same port\")\n+\tif err != nil {\n+\t\t// The error should indicate the address is already in use\n+\t\terrMsg := strings.ToLower(err.Error())\n+\t\tif runtime.GOOS == \"windows\" {\n+\t\t\tassert.Contains(t, errMsg, \"only one usage of each socket address\",\n+\t\t\t\t\"Error should indicate port conflict\")\n+\t\t} else {\n+\t\t\tassert.Contains(t, errMsg, \"address already in use\",\n+\t\t\t\t\"Error should indicate port conflict\")\n+\t\t}\n+\t}\n+\n+\t// Cancel first client's context and wait for it to finish\n+\tcancel1()\n+\tselect {\n+\tcase err1 := <-done1:\n+\t\t// Should get context cancelled or deadline exceeded\n+\t\tassert.Error(t, err1, \"First client should exit when context cancelled\")\n+\tcase <-time.After(2 * time.Second):\n+\t\tt.Error(\"First client did not exit within timeout\")\n+\t}\n+}\n+\n+func TestServer_IsPrivilegedUser(t *testing.T) {\n+\n+\ttests := []struct {\n+\t\tusername    string\n+\t\texpected    bool\n+\t\tdescription string\n+\t}{\n+\t\t{\n+\t\t\tusername:    \"root\",\n+\t\t\texpected:    true,\n+\t\t\tdescription: \"root should be considered privileged\",\n+\t\t},\n+\t\t{\n+\t\t\tusername:    \"regular\",\n+\t\t\texpected:    false,\n+\t\t\tdescription: \"regular user should not be privileged\",\n+\t\t},\n+\t\t{\n+\t\t\tusername:    \"\",\n+\t\t\texpected:    false,\n+\t\t\tdescription: \"empty username should not be privileged\",\n+\t\t},\n+\t}\n+\n+\t// Add Windows-specific tests\n+\tif runtime.GOOS == \"windows\" {\n+\t\ttests = append(tests, []struct {\n+\t\t\tusername    string\n+\t\t\texpected    bool\n+\t\t\tdescription string\n+\t\t}{\n+\t\t\t{\n+\t\t\t\tusername:    \"Administrator\",\n+\t\t\t\texpected:    true,\n+\t\t\t\tdescription: \"Administrator should be considered privileged on Windows\",\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tusername:    \"administrator\",\n+\t\t\t\texpected:    true,\n+\t\t\t\tdescription: \"administrator should be considered privileged on Windows (case insensitive)\",\n+\t\t\t},\n+\t\t}...)\n+\t} else {\n+\t\t// On non-Windows systems, Administrator should not be privileged\n+\t\ttests = append(tests, []struct {\n+\t\t\tusername    string\n+\t\t\texpected    bool\n+\t\t\tdescription string\n+\t\t}{\n+\t\t\t{\n+\t\t\t\tusername:    \"Administrator\",\n+\t\t\t\texpected:    false,\n+\t\t\t\tdescription: \"Administrator should not be privileged on non-Windows systems\",\n+\t\t\t},\n+\t\t}...)\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.description, func(t *testing.T) {\n+\t\t\tresult := isPrivilegedUsername(tt.username)\n+\t\t\tassert.Equal(t, tt.expected, result, tt.description)\n+\t\t})\n+\t}\n+}\ndiff --git a/client/ssh/server/server_test.go b/client/ssh/server/server_test.go\nnew file mode 100644\nindex 00000000000..6610685393d\n--- /dev/null\n+++ b/client/ssh/server/server_test.go\n@@ -0,0 +1,441 @@\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"net\"\n+\t\"net/netip\"\n+\t\"os/user\"\n+\t\"runtime\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\tcryptossh \"golang.org/x/crypto/ssh\"\n+\n+\tnbssh \"github.com/netbirdio/netbird/client/ssh\"\n+)\n+\n+func TestServer_StartStop(t *testing.T) {\n+\tkey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: key,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := New(serverConfig)\n+\n+\terr = server.Stop()\n+\tassert.NoError(t, err)\n+}\n+\n+func TestSSHServerIntegration(t *testing.T) {\n+\t// Generate host key for server\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\t// Generate client key pair\n+\tclientPrivKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\t// Create server with random port\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := New(serverConfig)\n+\n+\t// Start server in background\n+\tserverAddr := \"127.0.0.1:0\"\n+\tstarted := make(chan string, 1)\n+\terrChan := make(chan error, 1)\n+\n+\tgo func() {\n+\t\t// Get a free port\n+\t\tln, err := net.Listen(\"tcp\", serverAddr)\n+\t\tif err != nil {\n+\t\t\terrChan <- err\n+\t\t\treturn\n+\t\t}\n+\t\tactualAddr := ln.Addr().String()\n+\t\tif err := ln.Close(); err != nil {\n+\t\t\terrChan <- fmt.Errorf(\"close temp listener: %w\", err)\n+\t\t\treturn\n+\t\t}\n+\n+\t\taddrPort, _ := netip.ParseAddrPort(actualAddr)\n+\t\tif err := server.Start(context.Background(), addrPort); err != nil {\n+\t\t\terrChan <- err\n+\t\t\treturn\n+\t\t}\n+\t\tstarted <- actualAddr\n+\t}()\n+\n+\tselect {\n+\tcase actualAddr := <-started:\n+\t\tserverAddr = actualAddr\n+\tcase err := <-errChan:\n+\t\tt.Fatalf(\"Server failed to start: %v\", err)\n+\tcase <-time.After(5 * time.Second):\n+\t\tt.Fatal(\"Server start timeout\")\n+\t}\n+\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\t// Parse client private key\n+\tsigner, err := cryptossh.ParsePrivateKey(clientPrivKey)\n+\trequire.NoError(t, err)\n+\n+\t// Parse server host key for verification\n+\thostPrivParsed, err := cryptossh.ParsePrivateKey(hostKey)\n+\trequire.NoError(t, err)\n+\thostPubKey := hostPrivParsed.PublicKey()\n+\n+\t// Get current user for SSH connection\n+\tcurrentUser, err := user.Current()\n+\trequire.NoError(t, err, \"Should be able to get current user for test\")\n+\n+\t// Create SSH client config\n+\tconfig := &cryptossh.ClientConfig{\n+\t\tUser: currentUser.Username,\n+\t\tAuth: []cryptossh.AuthMethod{\n+\t\t\tcryptossh.PublicKeys(signer),\n+\t\t},\n+\t\tHostKeyCallback: cryptossh.FixedHostKey(hostPubKey),\n+\t\tTimeout:         3 * time.Second,\n+\t}\n+\n+\t// Connect to SSH server\n+\tclient, err := cryptossh.Dial(\"tcp\", serverAddr, config)\n+\trequire.NoError(t, err)\n+\tdefer func() {\n+\t\tif err := client.Close(); err != nil {\n+\t\t\tt.Logf(\"close client: %v\", err)\n+\t\t}\n+\t}()\n+\n+\t// Test creating a session\n+\tsession, err := client.NewSession()\n+\trequire.NoError(t, err)\n+\tdefer func() {\n+\t\tif err := session.Close(); err != nil {\n+\t\t\tt.Logf(\"close session: %v\", err)\n+\t\t}\n+\t}()\n+\n+\t// Note: Since we don't have a real shell environment in tests,\n+\t// we can't test actual command execution, but we can verify\n+\t// the connection and authentication work\n+\tt.Log(\"SSH connection and authentication successful\")\n+}\n+\n+func TestSSHServerMultipleConnections(t *testing.T) {\n+\t// Generate host key for server\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\t// Generate client key pair\n+\tclientPrivKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\t// Create server\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := New(serverConfig)\n+\n+\t// Start server\n+\tserverAddr := \"127.0.0.1:0\"\n+\tstarted := make(chan string, 1)\n+\terrChan := make(chan error, 1)\n+\n+\tgo func() {\n+\t\tln, err := net.Listen(\"tcp\", serverAddr)\n+\t\tif err != nil {\n+\t\t\terrChan <- err\n+\t\t\treturn\n+\t\t}\n+\t\tactualAddr := ln.Addr().String()\n+\t\tif err := ln.Close(); err != nil {\n+\t\t\terrChan <- fmt.Errorf(\"close temp listener: %w\", err)\n+\t\t\treturn\n+\t\t}\n+\n+\t\taddrPort, _ := netip.ParseAddrPort(actualAddr)\n+\t\tif err := server.Start(context.Background(), addrPort); err != nil {\n+\t\t\terrChan <- err\n+\t\t\treturn\n+\t\t}\n+\t\tstarted <- actualAddr\n+\t}()\n+\n+\tselect {\n+\tcase actualAddr := <-started:\n+\t\tserverAddr = actualAddr\n+\tcase err := <-errChan:\n+\t\tt.Fatalf(\"Server failed to start: %v\", err)\n+\tcase <-time.After(5 * time.Second):\n+\t\tt.Fatal(\"Server start timeout\")\n+\t}\n+\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\t// Parse client private key\n+\tsigner, err := cryptossh.ParsePrivateKey(clientPrivKey)\n+\trequire.NoError(t, err)\n+\n+\t// Parse server host key\n+\thostPrivParsed, err := cryptossh.ParsePrivateKey(hostKey)\n+\trequire.NoError(t, err)\n+\thostPubKey := hostPrivParsed.PublicKey()\n+\n+\t// Get current user for SSH connection\n+\tcurrentUser, err := user.Current()\n+\trequire.NoError(t, err, \"Should be able to get current user for test\")\n+\n+\tconfig := &cryptossh.ClientConfig{\n+\t\tUser: currentUser.Username,\n+\t\tAuth: []cryptossh.AuthMethod{\n+\t\t\tcryptossh.PublicKeys(signer),\n+\t\t},\n+\t\tHostKeyCallback: cryptossh.FixedHostKey(hostPubKey),\n+\t\tTimeout:         3 * time.Second,\n+\t}\n+\n+\t// Test multiple concurrent connections\n+\tconst numConnections = 5\n+\tresults := make(chan error, numConnections)\n+\n+\tfor i := 0; i < numConnections; i++ {\n+\t\tgo func(id int) {\n+\t\t\tclient, err := cryptossh.Dial(\"tcp\", serverAddr, config)\n+\t\t\tif err != nil {\n+\t\t\t\tresults <- fmt.Errorf(\"connection %d failed: %w\", id, err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tdefer func() {\n+\t\t\t\t_ = client.Close() // Ignore error in test goroutine\n+\t\t\t}()\n+\n+\t\t\tsession, err := client.NewSession()\n+\t\t\tif err != nil {\n+\t\t\t\tresults <- fmt.Errorf(\"session %d failed: %w\", id, err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tdefer func() {\n+\t\t\t\t_ = session.Close() // Ignore error in test goroutine\n+\t\t\t}()\n+\n+\t\t\tresults <- nil\n+\t\t}(i)\n+\t}\n+\n+\t// Wait for all connections to complete\n+\tfor i := 0; i < numConnections; i++ {\n+\t\tselect {\n+\t\tcase err := <-results:\n+\t\t\tassert.NoError(t, err)\n+\t\tcase <-time.After(10 * time.Second):\n+\t\t\tt.Fatalf(\"Connection %d timed out\", i)\n+\t\t}\n+\t}\n+}\n+\n+func TestSSHServerNoAuthMode(t *testing.T) {\n+\t// Generate host key for server\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\t// Create server\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := New(serverConfig)\n+\n+\t// Start server\n+\tserverAddr := \"127.0.0.1:0\"\n+\tstarted := make(chan string, 1)\n+\terrChan := make(chan error, 1)\n+\n+\tgo func() {\n+\t\tln, err := net.Listen(\"tcp\", serverAddr)\n+\t\tif err != nil {\n+\t\t\terrChan <- err\n+\t\t\treturn\n+\t\t}\n+\t\tactualAddr := ln.Addr().String()\n+\t\tif err := ln.Close(); err != nil {\n+\t\t\terrChan <- fmt.Errorf(\"close temp listener: %w\", err)\n+\t\t\treturn\n+\t\t}\n+\n+\t\taddrPort, _ := netip.ParseAddrPort(actualAddr)\n+\t\tif err := server.Start(context.Background(), addrPort); err != nil {\n+\t\t\terrChan <- err\n+\t\t\treturn\n+\t\t}\n+\t\tstarted <- actualAddr\n+\t}()\n+\n+\tselect {\n+\tcase actualAddr := <-started:\n+\t\tserverAddr = actualAddr\n+\tcase err := <-errChan:\n+\t\tt.Fatalf(\"Server failed to start: %v\", err)\n+\tcase <-time.After(5 * time.Second):\n+\t\tt.Fatal(\"Server start timeout\")\n+\t}\n+\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\t// Generate a client private key for SSH protocol (server doesn't check it)\n+\tclientPrivKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\tclientSigner, err := cryptossh.ParsePrivateKey(clientPrivKey)\n+\trequire.NoError(t, err)\n+\n+\t// Parse server host key\n+\thostPrivParsed, err := cryptossh.ParsePrivateKey(hostKey)\n+\trequire.NoError(t, err)\n+\thostPubKey := hostPrivParsed.PublicKey()\n+\n+\t// Get current user for SSH connection\n+\tcurrentUser, err := user.Current()\n+\trequire.NoError(t, err, \"Should be able to get current user for test\")\n+\n+\t// Try to connect with client key\n+\tconfig := &cryptossh.ClientConfig{\n+\t\tUser: currentUser.Username,\n+\t\tAuth: []cryptossh.AuthMethod{\n+\t\t\tcryptossh.PublicKeys(clientSigner),\n+\t\t},\n+\t\tHostKeyCallback: cryptossh.FixedHostKey(hostPubKey),\n+\t\tTimeout:         3 * time.Second,\n+\t}\n+\n+\t// This should succeed in no-auth mode (server doesn't verify keys)\n+\tconn, err := cryptossh.Dial(\"tcp\", serverAddr, config)\n+\tassert.NoError(t, err, \"Connection should succeed in no-auth mode\")\n+\tif conn != nil {\n+\t\tassert.NoError(t, conn.Close())\n+\t}\n+}\n+\n+func TestSSHServerStartStopCycle(t *testing.T) {\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := New(serverConfig)\n+\tserverAddr := \"127.0.0.1:0\"\n+\n+\t// Test multiple start/stop cycles\n+\tfor i := 0; i < 3; i++ {\n+\t\tt.Logf(\"Start/stop cycle %d\", i+1)\n+\n+\t\tstarted := make(chan string, 1)\n+\t\terrChan := make(chan error, 1)\n+\n+\t\tgo func() {\n+\t\t\tln, err := net.Listen(\"tcp\", serverAddr)\n+\t\t\tif err != nil {\n+\t\t\t\terrChan <- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tactualAddr := ln.Addr().String()\n+\t\t\tif err := ln.Close(); err != nil {\n+\t\t\t\terrChan <- fmt.Errorf(\"close temp listener: %w\", err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\taddrPort, _ := netip.ParseAddrPort(actualAddr)\n+\t\t\tif err := server.Start(context.Background(), addrPort); err != nil {\n+\t\t\t\terrChan <- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tstarted <- actualAddr\n+\t\t}()\n+\n+\t\tselect {\n+\t\tcase <-started:\n+\t\tcase err := <-errChan:\n+\t\t\tt.Fatalf(\"Cycle %d: Server failed to start: %v\", i+1, err)\n+\t\tcase <-time.After(5 * time.Second):\n+\t\t\tt.Fatalf(\"Cycle %d: Server start timeout\", i+1)\n+\t\t}\n+\n+\t\terr = server.Stop()\n+\t\trequire.NoError(t, err, \"Cycle %d: Stop should succeed\", i+1)\n+\t}\n+}\n+\n+func TestSSHServer_WindowsShellHandling(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping Windows shell test in short mode\")\n+\t}\n+\n+\tserver := &Server{}\n+\n+\tif runtime.GOOS == \"windows\" {\n+\t\t// Test Windows cmd.exe shell behavior\n+\t\targs := server.getShellCommandArgs(\"cmd.exe\", \"echo test\")\n+\t\tassert.Equal(t, \"cmd.exe\", args[0])\n+\t\tassert.Equal(t, \"-Command\", args[1])\n+\t\tassert.Equal(t, \"echo test\", args[2])\n+\n+\t\t// Test PowerShell behavior\n+\t\targs = server.getShellCommandArgs(\"powershell.exe\", \"echo test\")\n+\t\tassert.Equal(t, \"powershell.exe\", args[0])\n+\t\tassert.Equal(t, \"-Command\", args[1])\n+\t\tassert.Equal(t, \"echo test\", args[2])\n+\t} else {\n+\t\t// Test Unix shell behavior\n+\t\targs := server.getShellCommandArgs(\"/bin/sh\", \"echo test\")\n+\t\tassert.Equal(t, \"/bin/sh\", args[0])\n+\t\tassert.Equal(t, \"-l\", args[1])\n+\t\tassert.Equal(t, \"-c\", args[2])\n+\t\tassert.Equal(t, \"echo test\", args[3])\n+\t}\n+}\n+\n+func TestSSHServer_PortForwardingConfiguration(t *testing.T) {\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tserverConfig1 := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver1 := New(serverConfig1)\n+\n+\tserverConfig2 := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver2 := New(serverConfig2)\n+\n+\tassert.False(t, server1.allowLocalPortForwarding, \"Local port forwarding should be disabled by default for security\")\n+\tassert.False(t, server1.allowRemotePortForwarding, \"Remote port forwarding should be disabled by default for security\")\n+\n+\tserver2.SetAllowLocalPortForwarding(true)\n+\tserver2.SetAllowRemotePortForwarding(true)\n+\n+\tassert.True(t, server2.allowLocalPortForwarding, \"Local port forwarding should be enabled when explicitly set\")\n+\tassert.True(t, server2.allowRemotePortForwarding, \"Remote port forwarding should be enabled when explicitly set\")\n+}\ndiff --git a/client/ssh/server/sftp_test.go b/client/ssh/server/sftp_test.go\nnew file mode 100644\nindex 00000000000..32a3643e487\n--- /dev/null\n+++ b/client/ssh/server/sftp_test.go\n@@ -0,0 +1,228 @@\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"net\"\n+\t\"net/netip\"\n+\t\"os\"\n+\t\"os/user\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/pkg/sftp\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\tcryptossh \"golang.org/x/crypto/ssh\"\n+\n+\t\"github.com/netbirdio/netbird/client/ssh\"\n+)\n+\n+func TestSSHServer_SFTPSubsystem(t *testing.T) {\n+\t// Skip SFTP test when running as root due to protocol issues in some environments\n+\tif os.Geteuid() == 0 {\n+\t\tt.Skip(\"Skipping SFTP test when running as root - may have protocol compatibility issues\")\n+\t}\n+\n+\t// Get current user for SSH connection\n+\tcurrentUser, err := user.Current()\n+\trequire.NoError(t, err, \"Should be able to get current user\")\n+\n+\t// Generate host key for server\n+\thostKey, err := ssh.GeneratePrivateKey(ssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\t// Generate client key pair\n+\tclientPrivKey, err := ssh.GeneratePrivateKey(ssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\t// Create server with SFTP enabled\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := New(serverConfig)\n+\tserver.SetAllowSFTP(true)\n+\tserver.SetAllowRootLogin(true)\n+\n+\t// Start server\n+\tserverAddr := \"127.0.0.1:0\"\n+\tstarted := make(chan string, 1)\n+\terrChan := make(chan error, 1)\n+\n+\tgo func() {\n+\t\tln, err := net.Listen(\"tcp\", serverAddr)\n+\t\tif err != nil {\n+\t\t\terrChan <- err\n+\t\t\treturn\n+\t\t}\n+\t\tactualAddr := ln.Addr().String()\n+\t\tif err := ln.Close(); err != nil {\n+\t\t\terrChan <- fmt.Errorf(\"close temp listener: %w\", err)\n+\t\t\treturn\n+\t\t}\n+\n+\t\taddrPort, _ := netip.ParseAddrPort(actualAddr)\n+\t\tif err := server.Start(context.Background(), addrPort); err != nil {\n+\t\t\terrChan <- err\n+\t\t\treturn\n+\t\t}\n+\t\tstarted <- actualAddr\n+\t}()\n+\n+\tselect {\n+\tcase actualAddr := <-started:\n+\t\tserverAddr = actualAddr\n+\tcase err := <-errChan:\n+\t\tt.Fatalf(\"Server failed to start: %v\", err)\n+\tcase <-time.After(5 * time.Second):\n+\t\tt.Fatal(\"Server start timeout\")\n+\t}\n+\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\t// Parse client private key\n+\tsigner, err := cryptossh.ParsePrivateKey(clientPrivKey)\n+\trequire.NoError(t, err)\n+\n+\t// Parse server host key\n+\thostPrivParsed, err := cryptossh.ParsePrivateKey(hostKey)\n+\trequire.NoError(t, err)\n+\thostPubKey := hostPrivParsed.PublicKey()\n+\n+\t// (currentUser already obtained at function start)\n+\n+\t// Create SSH client connection\n+\tclientConfig := &cryptossh.ClientConfig{\n+\t\tUser: currentUser.Username,\n+\t\tAuth: []cryptossh.AuthMethod{\n+\t\t\tcryptossh.PublicKeys(signer),\n+\t\t},\n+\t\tHostKeyCallback: cryptossh.FixedHostKey(hostPubKey),\n+\t\tTimeout:         5 * time.Second,\n+\t}\n+\n+\tconn, err := cryptossh.Dial(\"tcp\", serverAddr, clientConfig)\n+\trequire.NoError(t, err, \"SSH connection should succeed\")\n+\tdefer func() {\n+\t\tif err := conn.Close(); err != nil {\n+\t\t\tt.Logf(\"connection close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\t// Create SFTP client\n+\tsftpClient, err := sftp.NewClient(conn)\n+\trequire.NoError(t, err, \"SFTP client creation should succeed\")\n+\tdefer func() {\n+\t\tif err := sftpClient.Close(); err != nil {\n+\t\t\tt.Logf(\"SFTP client close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\t// Test basic SFTP operations\n+\tworkingDir, err := sftpClient.Getwd()\n+\tassert.NoError(t, err, \"Should be able to get working directory\")\n+\tassert.NotEmpty(t, workingDir, \"Working directory should not be empty\")\n+\n+\t// Test directory listing\n+\tfiles, err := sftpClient.ReadDir(\".\")\n+\tassert.NoError(t, err, \"Should be able to list current directory\")\n+\tassert.NotNil(t, files, \"File list should not be nil\")\n+}\n+\n+func TestSSHServer_SFTPDisabled(t *testing.T) {\n+\t// Get current user for SSH connection\n+\tcurrentUser, err := user.Current()\n+\trequire.NoError(t, err, \"Should be able to get current user\")\n+\n+\t// Generate host key for server\n+\thostKey, err := ssh.GeneratePrivateKey(ssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\t// Generate client key pair\n+\tclientPrivKey, err := ssh.GeneratePrivateKey(ssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\t// Create server with SFTP disabled\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := New(serverConfig)\n+\tserver.SetAllowSFTP(false)\n+\n+\t// Start server\n+\tserverAddr := \"127.0.0.1:0\"\n+\tstarted := make(chan string, 1)\n+\terrChan := make(chan error, 1)\n+\n+\tgo func() {\n+\t\tln, err := net.Listen(\"tcp\", serverAddr)\n+\t\tif err != nil {\n+\t\t\terrChan <- err\n+\t\t\treturn\n+\t\t}\n+\t\tactualAddr := ln.Addr().String()\n+\t\tif err := ln.Close(); err != nil {\n+\t\t\terrChan <- fmt.Errorf(\"close temp listener: %w\", err)\n+\t\t\treturn\n+\t\t}\n+\n+\t\taddrPort, _ := netip.ParseAddrPort(actualAddr)\n+\t\tif err := server.Start(context.Background(), addrPort); err != nil {\n+\t\t\terrChan <- err\n+\t\t\treturn\n+\t\t}\n+\t\tstarted <- actualAddr\n+\t}()\n+\n+\tselect {\n+\tcase actualAddr := <-started:\n+\t\tserverAddr = actualAddr\n+\tcase err := <-errChan:\n+\t\tt.Fatalf(\"Server failed to start: %v\", err)\n+\tcase <-time.After(5 * time.Second):\n+\t\tt.Fatal(\"Server start timeout\")\n+\t}\n+\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\t// Parse client private key\n+\tsigner, err := cryptossh.ParsePrivateKey(clientPrivKey)\n+\trequire.NoError(t, err)\n+\n+\t// Parse server host key\n+\thostPrivParsed, err := cryptossh.ParsePrivateKey(hostKey)\n+\trequire.NoError(t, err)\n+\thostPubKey := hostPrivParsed.PublicKey()\n+\n+\t// (currentUser already obtained at function start)\n+\n+\t// Create SSH client connection\n+\tclientConfig := &cryptossh.ClientConfig{\n+\t\tUser: currentUser.Username,\n+\t\tAuth: []cryptossh.AuthMethod{\n+\t\t\tcryptossh.PublicKeys(signer),\n+\t\t},\n+\t\tHostKeyCallback: cryptossh.FixedHostKey(hostPubKey),\n+\t\tTimeout:         5 * time.Second,\n+\t}\n+\n+\tconn, err := cryptossh.Dial(\"tcp\", serverAddr, clientConfig)\n+\trequire.NoError(t, err, \"SSH connection should succeed\")\n+\tdefer func() {\n+\t\tif err := conn.Close(); err != nil {\n+\t\t\tt.Logf(\"connection close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\t// Try to create SFTP client - should fail when SFTP is disabled\n+\t_, err = sftp.NewClient(conn)\n+\tassert.Error(t, err, \"SFTP client creation should fail when SFTP is disabled\")\n+}\ndiff --git a/client/ssh/server/test.go b/client/ssh/server/test.go\nnew file mode 100644\nindex 00000000000..20930c72199\n--- /dev/null\n+++ b/client/ssh/server/test.go\n@@ -0,0 +1,45 @@\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"net\"\n+\t\"net/netip\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func StartTestServer(t *testing.T, server *Server) string {\n+\tstarted := make(chan string, 1)\n+\terrChan := make(chan error, 1)\n+\n+\tgo func() {\n+\t\tln, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n+\t\tif err != nil {\n+\t\t\terrChan <- err\n+\t\t\treturn\n+\t\t}\n+\t\tactualAddr := ln.Addr().String()\n+\t\tif err := ln.Close(); err != nil {\n+\t\t\terrChan <- fmt.Errorf(\"close temp listener: %w\", err)\n+\t\t\treturn\n+\t\t}\n+\n+\t\taddrPort := netip.MustParseAddrPort(actualAddr)\n+\t\tif err := server.Start(context.Background(), addrPort); err != nil {\n+\t\t\terrChan <- err\n+\t\t\treturn\n+\t\t}\n+\t\tstarted <- actualAddr\n+\t}()\n+\n+\tselect {\n+\tcase actualAddr := <-started:\n+\t\treturn actualAddr\n+\tcase err := <-errChan:\n+\t\tt.Fatalf(\"Server failed to start: %v\", err)\n+\tcase <-time.After(5 * time.Second):\n+\t\tt.Fatal(\"Server start timeout\")\n+\t}\n+\treturn \"\"\n+}\ndiff --git a/client/ssh/server/user_utils_test.go b/client/ssh/server/user_utils_test.go\nnew file mode 100644\nindex 00000000000..637dc10d0a6\n--- /dev/null\n+++ b/client/ssh/server/user_utils_test.go\n@@ -0,0 +1,908 @@\n+package server\n+\n+import (\n+\t\"errors\"\n+\t\"os/user\"\n+\t\"runtime\"\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+// Test helper functions\n+func createTestUser(username, uid, gid, homeDir string) *user.User {\n+\treturn &user.User{\n+\t\tUid:      uid,\n+\t\tGid:      gid,\n+\t\tUsername: username,\n+\t\tName:     username,\n+\t\tHomeDir:  homeDir,\n+\t}\n+}\n+\n+// Test dependency injection setup - injects platform dependencies to test real logic\n+func setupTestDependencies(currentUser *user.User, currentUserErr error, os string, euid int, lookupUsers map[string]*user.User, lookupErrors map[string]error) func() {\n+\t// Store originals\n+\toriginalGetCurrentUser := getCurrentUser\n+\toriginalLookupUser := lookupUser\n+\toriginalGetCurrentOS := getCurrentOS\n+\toriginalGetEuid := getEuid\n+\n+\t// Reset caches to ensure clean test state\n+\n+\t// Set test values - inject platform dependencies\n+\tgetCurrentUser = func() (*user.User, error) {\n+\t\treturn currentUser, currentUserErr\n+\t}\n+\n+\tlookupUser = func(username string) (*user.User, error) {\n+\t\tif err, exists := lookupErrors[username]; exists {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif userObj, exists := lookupUsers[username]; exists {\n+\t\t\treturn userObj, nil\n+\t\t}\n+\t\treturn nil, errors.New(\"user: unknown user \" + username)\n+\t}\n+\n+\tgetCurrentOS = func() string {\n+\t\treturn os\n+\t}\n+\n+\tgetEuid = func() int {\n+\t\treturn euid\n+\t}\n+\n+\t// Mock privilege detection based on the test user\n+\tgetIsProcessPrivileged = func() bool {\n+\t\tif currentUser == nil {\n+\t\t\treturn false\n+\t\t}\n+\t\t// Check both username and SID for Windows systems\n+\t\tif os == \"windows\" && isWindowsPrivilegedSID(currentUser.Uid) {\n+\t\t\treturn true\n+\t\t}\n+\t\treturn isPrivilegedUsername(currentUser.Username)\n+\t}\n+\n+\t// Return cleanup function\n+\treturn func() {\n+\t\tgetCurrentUser = originalGetCurrentUser\n+\t\tlookupUser = originalLookupUser\n+\t\tgetCurrentOS = originalGetCurrentOS\n+\t\tgetEuid = originalGetEuid\n+\n+\t\tgetIsProcessPrivileged = isCurrentProcessPrivileged\n+\n+\t\t// Reset caches after test\n+\t}\n+}\n+\n+func TestCheckPrivileges_ComprehensiveMatrix(t *testing.T) {\n+\ttests := []struct {\n+\t\tname                      string\n+\t\tos                        string\n+\t\teuid                      int\n+\t\tcurrentUser               *user.User\n+\t\trequestedUsername         string\n+\t\tfeatureSupportsUserSwitch bool\n+\t\tallowRoot                 bool\n+\t\tlookupUsers               map[string]*user.User\n+\t\texpectedAllowed           bool\n+\t\texpectedRequiresSwitch    bool\n+\t}{\n+\t\t{\n+\t\t\tname:                      \"linux_root_can_switch_to_alice\",\n+\t\t\tos:                        \"linux\",\n+\t\t\teuid:                      0, // Root process\n+\t\t\tcurrentUser:               createTestUser(\"root\", \"0\", \"0\", \"/root\"),\n+\t\t\trequestedUsername:         \"alice\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 true,\n+\t\t\tlookupUsers: map[string]*user.User{\n+\t\t\t\t\"alice\": createTestUser(\"alice\", \"1000\", \"1000\", \"/home/alice\"),\n+\t\t\t},\n+\t\t\texpectedAllowed:        true,\n+\t\t\texpectedRequiresSwitch: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:                      \"linux_non_root_fallback_to_current_user\",\n+\t\t\tos:                        \"linux\",\n+\t\t\teuid:                      1000, // Non-root process\n+\t\t\tcurrentUser:               createTestUser(\"alice\", \"1000\", \"1000\", \"/home/alice\"),\n+\t\t\trequestedUsername:         \"bob\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 true,\n+\t\t\texpectedAllowed:           true,  // Should fallback to current user (alice)\n+\t\t\texpectedRequiresSwitch:    false, // Fallback means no actual switching\n+\t\t},\n+\t\t{\n+\t\t\tname:                      \"windows_admin_can_switch_to_alice\",\n+\t\t\tos:                        \"windows\",\n+\t\t\teuid:                      1000, // Irrelevant on Windows\n+\t\t\tcurrentUser:               createTestUser(\"Administrator\", \"S-1-5-21-123456789-123456789-123456789-500\", \"S-1-5-32-544\", \"C:\\\\Users\\\\Administrator\"),\n+\t\t\trequestedUsername:         \"alice\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 true,\n+\t\t\tlookupUsers: map[string]*user.User{\n+\t\t\t\t\"alice\": createTestUser(\"alice\", \"S-1-5-21-123456789-123456789-123456789-1001\", \"S-1-5-21-123456789-123456789-123456789-513\", \"C:\\\\Users\\\\alice\"),\n+\t\t\t},\n+\t\t\texpectedAllowed:        true,\n+\t\t\texpectedRequiresSwitch: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:                      \"windows_non_admin_no_fallback_hard_failure\",\n+\t\t\tos:                        \"windows\",\n+\t\t\teuid:                      1000, // Irrelevant on Windows\n+\t\t\tcurrentUser:               createTestUser(\"alice\", \"1001\", \"1001\", \"C:\\\\Users\\\\alice\"),\n+\t\t\trequestedUsername:         \"bob\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 true,\n+\t\t\tlookupUsers: map[string]*user.User{\n+\t\t\t\t\"bob\": createTestUser(\"bob\", \"S-1-5-21-123456789-123456789-123456789-1002\", \"S-1-5-21-123456789-123456789-123456789-513\", \"C:\\\\Users\\\\bob\"),\n+\t\t\t},\n+\t\t\texpectedAllowed:        true, // Let OS decide - deferred security check\n+\t\t\texpectedRequiresSwitch: true, // Different user was requested\n+\t\t},\n+\t\t// Comprehensive test matrix: non-root linux with different allowRoot settings\n+\t\t{\n+\t\t\tname:                      \"linux_non_root_request_root_allowRoot_false\",\n+\t\t\tos:                        \"linux\",\n+\t\t\teuid:                      1000,\n+\t\t\tcurrentUser:               createTestUser(\"alice\", \"1000\", \"1000\", \"/home/alice\"),\n+\t\t\trequestedUsername:         \"root\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 false,\n+\t\t\texpectedAllowed:           true,  // Fallback allows access regardless of root setting\n+\t\t\texpectedRequiresSwitch:    false, // Fallback case, no switching\n+\t\t},\n+\t\t{\n+\t\t\tname:                      \"linux_non_root_request_root_allowRoot_true\",\n+\t\t\tos:                        \"linux\",\n+\t\t\teuid:                      1000,\n+\t\t\tcurrentUser:               createTestUser(\"alice\", \"1000\", \"1000\", \"/home/alice\"),\n+\t\t\trequestedUsername:         \"root\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 true,\n+\t\t\texpectedAllowed:           true,  // Should fallback to alice (non-privileged process)\n+\t\t\texpectedRequiresSwitch:    false, // Fallback means no actual switching\n+\t\t},\n+\t\t// Windows admin test matrix\n+\t\t{\n+\t\t\tname:                      \"windows_admin_request_root_allowRoot_false\",\n+\t\t\tos:                        \"windows\",\n+\t\t\teuid:                      1000,\n+\t\t\tcurrentUser:               createTestUser(\"Administrator\", \"S-1-5-21-123456789-123456789-123456789-500\", \"S-1-5-32-544\", \"C:\\\\Users\\\\Administrator\"),\n+\t\t\trequestedUsername:         \"root\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 false,\n+\t\t\texpectedAllowed:           false, // Root not allowed\n+\t\t\texpectedRequiresSwitch:    true,\n+\t\t},\n+\t\t{\n+\t\t\tname:                      \"windows_admin_request_root_allowRoot_true\",\n+\t\t\tos:                        \"windows\",\n+\t\t\teuid:                      1000,\n+\t\t\tcurrentUser:               createTestUser(\"Administrator\", \"S-1-5-21-123456789-123456789-123456789-500\", \"S-1-5-32-544\", \"C:\\\\Users\\\\Administrator\"),\n+\t\t\trequestedUsername:         \"root\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 true,\n+\t\t\tlookupUsers: map[string]*user.User{\n+\t\t\t\t\"root\": createTestUser(\"root\", \"0\", \"0\", \"/root\"),\n+\t\t\t},\n+\t\t\texpectedAllowed:        true, // Windows user switching should work like Unix\n+\t\t\texpectedRequiresSwitch: true,\n+\t\t},\n+\t\t// Windows non-admin test matrix\n+\t\t{\n+\t\t\tname:                      \"windows_non_admin_request_root_allowRoot_false\",\n+\t\t\tos:                        \"windows\",\n+\t\t\teuid:                      1000,\n+\t\t\tcurrentUser:               createTestUser(\"alice\", \"S-1-5-21-123456789-123456789-123456789-1001\", \"S-1-5-21-123456789-123456789-123456789-513\", \"C:\\\\Users\\\\alice\"),\n+\t\t\trequestedUsername:         \"root\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 false,\n+\t\t\texpectedAllowed:           false, // Root not allowed (allowRoot=false takes precedence)\n+\t\t\texpectedRequiresSwitch:    true,\n+\t\t},\n+\t\t{\n+\t\t\tname:                      \"windows_system_account_allowRoot_false\",\n+\t\t\tos:                        \"windows\",\n+\t\t\teuid:                      1000,\n+\t\t\tcurrentUser:               createTestUser(\"NETBIRD\\\\WIN2K19-C2$\", \"S-1-5-18\", \"S-1-5-18\", \"C:\\\\Windows\\\\System32\"),\n+\t\t\trequestedUsername:         \"root\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 false,\n+\t\t\texpectedAllowed:           false, // Root not allowed\n+\t\t\texpectedRequiresSwitch:    true,\n+\t\t},\n+\t\t{\n+\t\t\tname:                      \"windows_system_account_allowRoot_true\",\n+\t\t\tos:                        \"windows\",\n+\t\t\teuid:                      1000,\n+\t\t\tcurrentUser:               createTestUser(\"NETBIRD\\\\WIN2K19-C2$\", \"S-1-5-18\", \"S-1-5-18\", \"C:\\\\Windows\\\\System32\"),\n+\t\t\trequestedUsername:         \"root\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 true,\n+\t\t\tlookupUsers: map[string]*user.User{\n+\t\t\t\t\"root\": createTestUser(\"root\", \"0\", \"0\", \"/root\"),\n+\t\t\t},\n+\t\t\texpectedAllowed:        true, // SYSTEM can switch to root\n+\t\t\texpectedRequiresSwitch: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:                      \"windows_non_admin_request_root_allowRoot_true\",\n+\t\t\tos:                        \"windows\",\n+\t\t\teuid:                      1000,\n+\t\t\tcurrentUser:               createTestUser(\"alice\", \"S-1-5-21-123456789-123456789-123456789-1001\", \"S-1-5-21-123456789-123456789-123456789-513\", \"C:\\\\Users\\\\alice\"),\n+\t\t\trequestedUsername:         \"root\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 true,\n+\t\t\tlookupUsers: map[string]*user.User{\n+\t\t\t\t\"root\": createTestUser(\"root\", \"0\", \"0\", \"/root\"),\n+\t\t\t},\n+\t\t\texpectedAllowed:        true, // Let OS decide - deferred security check\n+\t\t\texpectedRequiresSwitch: true,\n+\t\t},\n+\n+\t\t// Feature doesn't support user switching scenarios\n+\t\t{\n+\t\t\tname:                      \"linux_root_feature_no_user_switching_same_user\",\n+\t\t\tos:                        \"linux\",\n+\t\t\teuid:                      0,\n+\t\t\tcurrentUser:               createTestUser(\"root\", \"0\", \"0\", \"/root\"),\n+\t\t\trequestedUsername:         \"root\", // Same user\n+\t\t\tfeatureSupportsUserSwitch: false,\n+\t\t\tallowRoot:                 true,\n+\t\t\tlookupUsers: map[string]*user.User{\n+\t\t\t\t\"root\": createTestUser(\"root\", \"0\", \"0\", \"/root\"),\n+\t\t\t},\n+\t\t\texpectedAllowed:        true, // Same user should work regardless of feature support\n+\t\t\texpectedRequiresSwitch: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:                      \"linux_root_feature_no_user_switching_different_user\",\n+\t\t\tos:                        \"linux\",\n+\t\t\teuid:                      0,\n+\t\t\tcurrentUser:               createTestUser(\"root\", \"0\", \"0\", \"/root\"),\n+\t\t\trequestedUsername:         \"alice\",\n+\t\t\tfeatureSupportsUserSwitch: false, // Feature doesn't support switching\n+\t\t\tallowRoot:                 true,\n+\t\t\tlookupUsers: map[string]*user.User{\n+\t\t\t\t\"alice\": createTestUser(\"alice\", \"1000\", \"1000\", \"/home/alice\"),\n+\t\t\t},\n+\t\t\texpectedAllowed:        false, // Should deny because feature doesn't support switching\n+\t\t\texpectedRequiresSwitch: true,\n+\t\t},\n+\n+\t\t// Empty username (current user) scenarios\n+\t\t{\n+\t\t\tname:                      \"linux_non_root_current_user_empty_username\",\n+\t\t\tos:                        \"linux\",\n+\t\t\teuid:                      1000,\n+\t\t\tcurrentUser:               createTestUser(\"alice\", \"1000\", \"1000\", \"/home/alice\"),\n+\t\t\trequestedUsername:         \"\", // Empty = current user\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 false,\n+\t\t\texpectedAllowed:           true, // Current user should always work\n+\t\t\texpectedRequiresSwitch:    false,\n+\t\t},\n+\t\t{\n+\t\t\tname:                      \"linux_root_current_user_empty_username_root_not_allowed\",\n+\t\t\tos:                        \"linux\",\n+\t\t\teuid:                      0,\n+\t\t\tcurrentUser:               createTestUser(\"root\", \"0\", \"0\", \"/root\"),\n+\t\t\trequestedUsername:         \"\", // Empty = current user (root)\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 false, // Root not allowed\n+\t\t\texpectedAllowed:           false, // Should deny root even when it's current user\n+\t\t\texpectedRequiresSwitch:    false,\n+\t\t},\n+\n+\t\t// User not found scenarios\n+\t\t{\n+\t\t\tname:                      \"linux_root_user_not_found\",\n+\t\t\tos:                        \"linux\",\n+\t\t\teuid:                      0,\n+\t\t\tcurrentUser:               createTestUser(\"root\", \"0\", \"0\", \"/root\"),\n+\t\t\trequestedUsername:         \"nonexistent\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 true,\n+\t\t\tlookupUsers:               map[string]*user.User{}, // No users defined = user not found\n+\t\t\texpectedAllowed:           false,                   // Should fail due to user not found\n+\t\t\texpectedRequiresSwitch:    true,\n+\t\t},\n+\n+\t\t// Windows feature doesn't support user switching\n+\t\t{\n+\t\t\tname:                      \"windows_admin_feature_no_user_switching_different_user\",\n+\t\t\tos:                        \"windows\",\n+\t\t\teuid:                      1000,\n+\t\t\tcurrentUser:               createTestUser(\"Administrator\", \"S-1-5-21-123456789-123456789-123456789-500\", \"S-1-5-32-544\", \"C:\\\\Users\\\\Administrator\"),\n+\t\t\trequestedUsername:         \"alice\",\n+\t\t\tfeatureSupportsUserSwitch: false, // Feature doesn't support switching\n+\t\t\tallowRoot:                 true,\n+\t\t\tlookupUsers: map[string]*user.User{\n+\t\t\t\t\"alice\": createTestUser(\"alice\", \"S-1-5-21-123456789-123456789-123456789-1001\", \"S-1-5-21-123456789-123456789-123456789-513\", \"C:\\\\Users\\\\alice\"),\n+\t\t\t},\n+\t\t\texpectedAllowed:        false, // Should deny because feature doesn't support switching\n+\t\t\texpectedRequiresSwitch: true,\n+\t\t},\n+\n+\t\t// Windows regular user scenarios (non-admin)\n+\t\t{\n+\t\t\tname:                      \"windows_regular_user_same_user\",\n+\t\t\tos:                        \"windows\",\n+\t\t\teuid:                      1000,\n+\t\t\tcurrentUser:               createTestUser(\"alice\", \"S-1-5-21-123456789-123456789-123456789-1001\", \"S-1-5-21-123456789-123456789-123456789-513\", \"C:\\\\Users\\\\alice\"),\n+\t\t\trequestedUsername:         \"alice\", // Same user\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 false,\n+\t\t\tlookupUsers: map[string]*user.User{\n+\t\t\t\t\"alice\": createTestUser(\"alice\", \"S-1-5-21-123456789-123456789-123456789-1001\", \"S-1-5-21-123456789-123456789-123456789-513\", \"C:\\\\Users\\\\alice\"),\n+\t\t\t},\n+\t\t\texpectedAllowed:        true,  // Regular user accessing themselves should work\n+\t\t\texpectedRequiresSwitch: false, // No switching for same user\n+\t\t},\n+\t\t{\n+\t\t\tname:                      \"windows_regular_user_empty_username\",\n+\t\t\tos:                        \"windows\",\n+\t\t\teuid:                      1000,\n+\t\t\tcurrentUser:               createTestUser(\"alice\", \"S-1-5-21-123456789-123456789-123456789-1001\", \"S-1-5-21-123456789-123456789-123456789-513\", \"C:\\\\Users\\\\alice\"),\n+\t\t\trequestedUsername:         \"\", // Empty = current user\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 false,\n+\t\t\texpectedAllowed:           true,  // Current user should always work\n+\t\t\texpectedRequiresSwitch:    false, // No switching for current user\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Inject platform dependencies to test real logic\n+\t\t\tcleanup := setupTestDependencies(tt.currentUser, nil, tt.os, tt.euid, tt.lookupUsers, nil)\n+\t\t\tdefer cleanup()\n+\n+\t\t\tserver := &Server{allowRootLogin: tt.allowRoot}\n+\n+\t\t\tresult := server.CheckPrivileges(PrivilegeCheckRequest{\n+\t\t\t\tRequestedUsername:         tt.requestedUsername,\n+\t\t\t\tFeatureSupportsUserSwitch: tt.featureSupportsUserSwitch,\n+\t\t\t\tFeatureName:               \"SSH login\",\n+\t\t\t})\n+\n+\t\t\tassert.Equal(t, tt.expectedAllowed, result.Allowed)\n+\t\t\tassert.Equal(t, tt.expectedRequiresSwitch, result.RequiresUserSwitching)\n+\t\t})\n+\t}\n+}\n+\n+func TestUsedFallback_MeansNoPrivilegeDropping(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\tt.Skip(\"Fallback mechanism is Unix-specific\")\n+\t}\n+\n+\t// Create test scenario where fallback should occur\n+\tserver := &Server{allowRootLogin: true}\n+\n+\t// Mock dependencies to simulate non-privileged user\n+\toriginalGetCurrentUser := getCurrentUser\n+\toriginalGetIsProcessPrivileged := getIsProcessPrivileged\n+\n+\tdefer func() {\n+\t\tgetCurrentUser = originalGetCurrentUser\n+\t\tgetIsProcessPrivileged = originalGetIsProcessPrivileged\n+\n+\t}()\n+\n+\t// Set up mocks for fallback scenario\n+\tgetCurrentUser = func() (*user.User, error) {\n+\t\treturn createTestUser(\"netbird\", \"1000\", \"1000\", \"/var/lib/netbird\"), nil\n+\t}\n+\tgetIsProcessPrivileged = func() bool { return false } // Non-privileged\n+\n+\t// Request different user - should fallback\n+\tresult := server.CheckPrivileges(PrivilegeCheckRequest{\n+\t\tRequestedUsername:         \"alice\",\n+\t\tFeatureSupportsUserSwitch: true,\n+\t\tFeatureName:               \"SSH login\",\n+\t})\n+\n+\t// Verify fallback occurred\n+\tassert.True(t, result.Allowed, \"Should allow with fallback\")\n+\tassert.True(t, result.UsedFallback, \"Should indicate fallback was used\")\n+\tassert.Equal(t, \"netbird\", result.User.Username, \"Should return current user\")\n+\tassert.False(t, result.RequiresUserSwitching, \"Should not require switching when fallback is used\")\n+\n+\t// Key assertion: When UsedFallback is true, no privilege dropping should be needed\n+\t// because all privilege checks have already been performed and we're using current user\n+\tt.Logf(\"UsedFallback=true means: current user (%s) is the target, no privilege dropping needed\",\n+\t\tresult.User.Username)\n+}\n+\n+func TestPrivilegedUsernameDetection(t *testing.T) {\n+\ttests := []struct {\n+\t\tname       string\n+\t\tusername   string\n+\t\tplatform   string\n+\t\tprivileged bool\n+\t}{\n+\t\t// Unix/Linux tests\n+\t\t{\"unix_root\", \"root\", \"linux\", true},\n+\t\t{\"unix_regular_user\", \"alice\", \"linux\", false},\n+\t\t{\"unix_root_capital\", \"Root\", \"linux\", false}, // Case-sensitive\n+\n+\t\t// Windows tests\n+\t\t{\"windows_administrator\", \"Administrator\", \"windows\", true},\n+\t\t{\"windows_system\", \"SYSTEM\", \"windows\", true},\n+\t\t{\"windows_admin\", \"admin\", \"windows\", true},\n+\t\t{\"windows_admin_lowercase\", \"administrator\", \"windows\", true}, // Case-insensitive\n+\t\t{\"windows_domain_admin\", \"DOMAIN\\\\Administrator\", \"windows\", true},\n+\t\t{\"windows_email_admin\", \"admin@domain.com\", \"windows\", true},\n+\t\t{\"windows_regular_user\", \"alice\", \"windows\", false},\n+\t\t{\"windows_domain_user\", \"DOMAIN\\\\alice\", \"windows\", false},\n+\t\t{\"windows_localsystem\", \"localsystem\", \"windows\", true},\n+\t\t{\"windows_networkservice\", \"networkservice\", \"windows\", true},\n+\t\t{\"windows_localservice\", \"localservice\", \"windows\", true},\n+\n+\t\t// Computer accounts (these depend on current user context in real implementation)\n+\t\t{\"windows_computer_account\", \"WIN2K19-C2$\", \"windows\", false},      // Computer account by itself not privileged\n+\t\t{\"windows_domain_computer\", \"DOMAIN\\\\COMPUTER$\", \"windows\", false}, // Domain computer account\n+\n+\t\t// Cross-platform\n+\t\t{\"root_on_windows\", \"root\", \"windows\", true}, // Root should be privileged everywhere\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Mock the platform for this test\n+\t\t\tcleanup := setupTestDependencies(nil, nil, tt.platform, 1000, nil, nil)\n+\t\t\tdefer cleanup()\n+\n+\t\t\tresult := isPrivilegedUsername(tt.username)\n+\t\t\tassert.Equal(t, tt.privileged, result)\n+\t\t})\n+\t}\n+}\n+\n+func TestWindowsPrivilegedSIDDetection(t *testing.T) {\n+\ttests := []struct {\n+\t\tname        string\n+\t\tsid         string\n+\t\tprivileged  bool\n+\t\tdescription string\n+\t}{\n+\t\t// Well-known system accounts\n+\t\t{\"system_account\", \"S-1-5-18\", true, \"Local System (SYSTEM)\"},\n+\t\t{\"local_service\", \"S-1-5-19\", true, \"Local Service\"},\n+\t\t{\"network_service\", \"S-1-5-20\", true, \"Network Service\"},\n+\t\t{\"administrators_group\", \"S-1-5-32-544\", true, \"Administrators group\"},\n+\t\t{\"builtin_administrator\", \"S-1-5-500\", true, \"Built-in Administrator\"},\n+\n+\t\t// Domain accounts\n+\t\t{\"domain_administrator\", \"S-1-5-21-1234567890-1234567890-1234567890-500\", true, \"Domain Administrator (RID 500)\"},\n+\t\t{\"domain_admins_group\", \"S-1-5-21-1234567890-1234567890-1234567890-512\", true, \"Domain Admins group\"},\n+\t\t{\"domain_controllers_group\", \"S-1-5-21-1234567890-1234567890-1234567890-516\", true, \"Domain Controllers group\"},\n+\t\t{\"enterprise_admins_group\", \"S-1-5-21-1234567890-1234567890-1234567890-519\", true, \"Enterprise Admins group\"},\n+\n+\t\t// Regular users\n+\t\t{\"regular_user\", \"S-1-5-21-1234567890-1234567890-1234567890-1001\", false, \"Regular domain user\"},\n+\t\t{\"another_regular_user\", \"S-1-5-21-1234567890-1234567890-1234567890-1234\", false, \"Another regular user\"},\n+\t\t{\"local_user\", \"S-1-5-21-1234567890-1234567890-1234567890-1000\", false, \"Local regular user\"},\n+\n+\t\t// Groups that are not privileged\n+\t\t{\"domain_users\", \"S-1-5-21-1234567890-1234567890-1234567890-513\", false, \"Domain Users group\"},\n+\t\t{\"power_users\", \"S-1-5-32-547\", false, \"Power Users group\"},\n+\n+\t\t// Invalid SIDs\n+\t\t{\"malformed_sid\", \"S-1-5-invalid\", false, \"Malformed SID\"},\n+\t\t{\"empty_sid\", \"\", false, \"Empty SID\"},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tresult := isWindowsPrivilegedSID(tt.sid)\n+\t\t\tassert.Equal(t, tt.privileged, result, \"Failed for %s: %s\", tt.description, tt.sid)\n+\t\t})\n+\t}\n+}\n+\n+func TestIsSameUser(t *testing.T) {\n+\ttests := []struct {\n+\t\tname     string\n+\t\tuser1    string\n+\t\tuser2    string\n+\t\tos       string\n+\t\texpected bool\n+\t}{\n+\t\t// Basic cases\n+\t\t{\"same_username\", \"alice\", \"alice\", \"linux\", true},\n+\t\t{\"different_username\", \"alice\", \"bob\", \"linux\", false},\n+\n+\t\t// Linux (no domain processing)\n+\t\t{\"linux_domain_vs_bare\", \"DOMAIN\\\\alice\", \"alice\", \"linux\", false},\n+\t\t{\"linux_email_vs_bare\", \"alice@domain.com\", \"alice\", \"linux\", false},\n+\t\t{\"linux_same_literal\", \"DOMAIN\\\\alice\", \"DOMAIN\\\\alice\", \"linux\", true},\n+\n+\t\t// Windows (with domain processing) - Note: parameter order is (requested, current, os, expected)\n+\t\t{\"windows_domain_vs_bare\", \"alice\", \"DOMAIN\\\\alice\", \"windows\", true},                         // bare username matches domain current user\n+\t\t{\"windows_email_vs_bare\", \"alice\", \"alice@domain.com\", \"windows\", true},                       // bare username matches email current user\n+\t\t{\"windows_different_domains_same_user\", \"DOMAIN1\\\\alice\", \"DOMAIN2\\\\alice\", \"windows\", false}, // SECURITY: different domains = different users\n+\t\t{\"windows_case_insensitive\", \"Alice\", \"alice\", \"windows\", true},\n+\t\t{\"windows_different_users\", \"DOMAIN\\\\alice\", \"DOMAIN\\\\bob\", \"windows\", false},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Set up OS mock\n+\t\t\tcleanup := setupTestDependencies(nil, nil, tt.os, 1000, nil, nil)\n+\t\t\tdefer cleanup()\n+\n+\t\t\tresult := isSameUser(tt.user1, tt.user2)\n+\t\t\tassert.Equal(t, tt.expected, result)\n+\t\t})\n+\t}\n+}\n+\n+func TestUsernameValidation_Unix(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\tt.Skip(\"Unix-specific username validation tests\")\n+\t}\n+\n+\ttests := []struct {\n+\t\tname     string\n+\t\tusername string\n+\t\twantErr  bool\n+\t\terrMsg   string\n+\t}{\n+\t\t// Valid usernames (Unix/POSIX)\n+\t\t{\"valid_alphanumeric\", \"user123\", false, \"\"},\n+\t\t{\"valid_with_dots\", \"user.name\", false, \"\"},\n+\t\t{\"valid_with_hyphens\", \"user-name\", false, \"\"},\n+\t\t{\"valid_with_underscores\", \"user_name\", false, \"\"},\n+\t\t{\"valid_uppercase\", \"UserName\", false, \"\"},\n+\t\t{\"valid_starting_with_digit\", \"123user\", false, \"\"},\n+\t\t{\"valid_starting_with_dot\", \".hidden\", false, \"\"},\n+\n+\t\t// Invalid usernames (Unix/POSIX)\n+\t\t{\"empty_username\", \"\", true, \"username cannot be empty\"},\n+\t\t{\"username_too_long\", \"thisusernameiswaytoolongandexceedsthe32characterlimit\", true, \"username too long\"},\n+\t\t{\"username_starting_with_hyphen\", \"-user\", true, \"invalid characters\"}, // POSIX restriction\n+\t\t{\"username_with_spaces\", \"user name\", true, \"invalid characters\"},\n+\t\t{\"username_with_shell_metacharacters\", \"user;rm\", true, \"invalid characters\"},\n+\t\t{\"username_with_command_injection\", \"user`rm -rf /`\", true, \"invalid characters\"},\n+\t\t{\"username_with_pipe\", \"user|rm\", true, \"invalid characters\"},\n+\t\t{\"username_with_ampersand\", \"user&rm\", true, \"invalid characters\"},\n+\t\t{\"username_with_quotes\", \"user\\\"name\", true, \"invalid characters\"},\n+\t\t{\"username_with_newline\", \"user\\nname\", true, \"invalid characters\"},\n+\t\t{\"reserved_dot\", \".\", true, \"cannot be '.' or '..'\"},\n+\t\t{\"reserved_dotdot\", \"..\", true, \"cannot be '.' or '..'\"},\n+\t\t{\"username_with_at_symbol\", \"user@domain\", true, \"invalid characters\"}, // Not allowed in bare Unix usernames\n+\t\t{\"username_with_backslash\", \"user\\\\name\", true, \"invalid characters\"},  // Not allowed in Unix usernames\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\terr := validateUsername(tt.username)\n+\t\t\tif tt.wantErr {\n+\t\t\t\tassert.Error(t, err, \"Should reject invalid username\")\n+\t\t\t\tif tt.errMsg != \"\" {\n+\t\t\t\t\tassert.Contains(t, err.Error(), tt.errMsg, \"Error message should contain expected text\")\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tassert.NoError(t, err, \"Should accept valid username\")\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestUsernameValidation_Windows(t *testing.T) {\n+\tif runtime.GOOS != \"windows\" {\n+\t\tt.Skip(\"Windows-specific username validation tests\")\n+\t}\n+\n+\ttests := []struct {\n+\t\tname     string\n+\t\tusername string\n+\t\twantErr  bool\n+\t\terrMsg   string\n+\t}{\n+\t\t// Valid usernames (Windows)\n+\t\t{\"valid_alphanumeric\", \"user123\", false, \"\"},\n+\t\t{\"valid_with_dots\", \"user.name\", false, \"\"},\n+\t\t{\"valid_with_hyphens\", \"user-name\", false, \"\"},\n+\t\t{\"valid_with_underscores\", \"user_name\", false, \"\"},\n+\t\t{\"valid_uppercase\", \"UserName\", false, \"\"},\n+\t\t{\"valid_starting_with_digit\", \"123user\", false, \"\"},\n+\t\t{\"valid_starting_with_dot\", \".hidden\", false, \"\"},\n+\t\t{\"valid_starting_with_hyphen\", \"-user\", false, \"\"},     // Windows allows this\n+\t\t{\"valid_domain_username\", \"DOMAIN\\\\user\", false, \"\"},   // Windows domain format\n+\t\t{\"valid_email_username\", \"user@domain.com\", false, \"\"}, // Windows email format\n+\t\t{\"valid_machine_username\", \"MACHINE\\\\user\", false, \"\"}, // Windows machine format\n+\n+\t\t// Invalid usernames (Windows)\n+\t\t{\"empty_username\", \"\", true, \"username cannot be empty\"},\n+\t\t{\"username_too_long\", \"thisusernameiswaytoolongandexceedsthe32characterlimit\", true, \"username too long\"},\n+\t\t{\"username_with_spaces\", \"user name\", true, \"invalid characters\"},\n+\t\t{\"username_with_shell_metacharacters\", \"user;rm\", true, \"invalid characters\"},\n+\t\t{\"username_with_command_injection\", \"user`rm -rf /`\", true, \"invalid characters\"},\n+\t\t{\"username_with_pipe\", \"user|rm\", true, \"invalid characters\"},\n+\t\t{\"username_with_ampersand\", \"user&rm\", true, \"invalid characters\"},\n+\t\t{\"username_with_quotes\", \"user\\\"name\", true, \"invalid characters\"},\n+\t\t{\"username_with_newline\", \"user\\nname\", true, \"invalid characters\"},\n+\t\t{\"username_with_brackets\", \"user[name]\", true, \"invalid characters\"},\n+\t\t{\"username_with_colon\", \"user:name\", true, \"invalid characters\"},\n+\t\t{\"username_with_semicolon\", \"user;name\", true, \"invalid characters\"},\n+\t\t{\"username_with_equals\", \"user=name\", true, \"invalid characters\"},\n+\t\t{\"username_with_comma\", \"user,name\", true, \"invalid characters\"},\n+\t\t{\"username_with_plus\", \"user+name\", true, \"invalid characters\"},\n+\t\t{\"username_with_asterisk\", \"user*name\", true, \"invalid characters\"},\n+\t\t{\"username_with_question\", \"user?name\", true, \"invalid characters\"},\n+\t\t{\"username_with_angles\", \"user<name>\", true, \"invalid characters\"},\n+\t\t{\"reserved_dot\", \".\", true, \"cannot be '.' or '..'\"},\n+\t\t{\"reserved_dotdot\", \"..\", true, \"cannot be '.' or '..'\"},\n+\t\t{\"username_ending_with_period\", \"user.\", true, \"cannot end with a period\"},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\terr := validateUsername(tt.username)\n+\t\t\tif tt.wantErr {\n+\t\t\t\tassert.Error(t, err, \"Should reject invalid username\")\n+\t\t\t\tif tt.errMsg != \"\" {\n+\t\t\t\t\tassert.Contains(t, err.Error(), tt.errMsg, \"Error message should contain expected text\")\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tassert.NoError(t, err, \"Should accept valid username\")\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+// Test real-world integration scenarios with actual platform capabilities\n+func TestCheckPrivileges_RealWorldScenarios(t *testing.T) {\n+\ttests := []struct {\n+\t\tname                      string\n+\t\tfeature                   string\n+\t\tfeatureSupportsUserSwitch bool\n+\t\trequestedUsername         string\n+\t\tallowRoot                 bool\n+\t\texpectedBehaviorPattern   string\n+\t}{\n+\t\t{\"SSH_login_current_user\", \"SSH login\", true, \"\", true, \"should_allow_current_user\"},\n+\t\t{\"SFTP_current_user\", \"SFTP\", true, \"\", true, \"should_allow_current_user\"},\n+\t\t{\"port_forwarding_current_user\", \"port forwarding\", false, \"\", true, \"should_allow_current_user\"},\n+\t\t{\"SSH_login_root_not_allowed\", \"SSH login\", true, \"root\", false, \"should_deny_root\"},\n+\t\t{\"port_forwarding_different_user\", \"port forwarding\", false, \"differentuser\", true, \"should_deny_switching\"},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Mock privileged environment to ensure consistent test behavior across environments\n+\t\t\tcleanup := setupTestDependencies(\n+\t\t\t\tcreateTestUser(\"root\", \"0\", \"0\", \"/root\"), // Running as root\n+\t\t\t\tnil,\n+\t\t\t\truntime.GOOS,\n+\t\t\t\t0, // euid 0 (root)\n+\t\t\t\tmap[string]*user.User{\n+\t\t\t\t\t\"root\":          createTestUser(\"root\", \"0\", \"0\", \"/root\"),\n+\t\t\t\t\t\"differentuser\": createTestUser(\"differentuser\", \"1000\", \"1000\", \"/home/differentuser\"),\n+\t\t\t\t},\n+\t\t\t\tnil,\n+\t\t\t)\n+\t\t\tdefer cleanup()\n+\n+\t\t\tserver := &Server{allowRootLogin: tt.allowRoot}\n+\n+\t\t\tresult := server.CheckPrivileges(PrivilegeCheckRequest{\n+\t\t\t\tRequestedUsername:         tt.requestedUsername,\n+\t\t\t\tFeatureSupportsUserSwitch: tt.featureSupportsUserSwitch,\n+\t\t\t\tFeatureName:               tt.feature,\n+\t\t\t})\n+\n+\t\t\tswitch tt.expectedBehaviorPattern {\n+\t\t\tcase \"should_allow_current_user\":\n+\t\t\t\tassert.True(t, result.Allowed, \"Should allow current user access\")\n+\t\t\t\tassert.False(t, result.RequiresUserSwitching, \"Current user should not require switching\")\n+\t\t\tcase \"should_deny_root\":\n+\t\t\t\tassert.False(t, result.Allowed, \"Should deny root when not allowed\")\n+\t\t\t\tassert.Contains(t, result.Error.Error(), \"root\", \"Should mention root in error\")\n+\t\t\tcase \"should_deny_switching\":\n+\t\t\t\tassert.False(t, result.Allowed, \"Should deny when feature doesn't support switching\")\n+\t\t\t\tassert.Contains(t, result.Error.Error(), \"user switching not supported\", \"Should mention switching in error\")\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+// Test with actual platform capabilities - no mocking\n+func TestCheckPrivileges_ActualPlatform(t *testing.T) {\n+\t// This test uses the REAL platform capabilities\n+\tserver := &Server{allowRootLogin: true}\n+\n+\t// Test current user access - should always work\n+\tresult := server.CheckPrivileges(PrivilegeCheckRequest{\n+\t\tRequestedUsername:         \"\", // Current user\n+\t\tFeatureSupportsUserSwitch: true,\n+\t\tFeatureName:               \"SSH login\",\n+\t})\n+\n+\tassert.True(t, result.Allowed, \"Current user should always be allowed\")\n+\tassert.False(t, result.RequiresUserSwitching, \"Current user should not require switching\")\n+\tassert.NotNil(t, result.User, \"Should return current user\")\n+\n+\t// Test user switching capability based on actual platform\n+\tactualIsPrivileged := isCurrentProcessPrivileged() // REAL check\n+\tactualOS := runtime.GOOS                           // REAL check\n+\n+\tt.Logf(\"Platform capabilities: OS=%s, isPrivileged=%v, supportsUserSwitching=%v\",\n+\t\tactualOS, actualIsPrivileged, actualIsPrivileged)\n+\n+\t// Test requesting different user\n+\tresult = server.CheckPrivileges(PrivilegeCheckRequest{\n+\t\tRequestedUsername:         \"nonexistentuser\",\n+\t\tFeatureSupportsUserSwitch: true,\n+\t\tFeatureName:               \"SSH login\",\n+\t})\n+\n+\tswitch {\n+\tcase actualOS == \"windows\":\n+\t\t// Windows supports user switching but should fail on nonexistent user\n+\t\tassert.False(t, result.Allowed, \"Windows should deny nonexistent user\")\n+\t\tassert.True(t, result.RequiresUserSwitching, \"Should indicate switching is needed\")\n+\t\tassert.Contains(t, result.Error.Error(), \"not found\",\n+\t\t\t\"Should indicate user not found\")\n+\tcase !actualIsPrivileged:\n+\t\t// Non-privileged Unix processes should fallback to current user\n+\t\tassert.True(t, result.Allowed, \"Non-privileged Unix process should fallback to current user\")\n+\t\tassert.False(t, result.RequiresUserSwitching, \"Fallback means no switching actually happens\")\n+\t\tassert.True(t, result.UsedFallback, \"Should indicate fallback was used\")\n+\t\tassert.NotNil(t, result.User, \"Should return current user\")\n+\tdefault:\n+\t\t// Privileged Unix processes should attempt user lookup\n+\t\tassert.False(t, result.Allowed, \"Should fail due to nonexistent user\")\n+\t\tassert.True(t, result.RequiresUserSwitching, \"Should indicate switching is needed\")\n+\t\tassert.Contains(t, result.Error.Error(), \"nonexistentuser\",\n+\t\t\t\"Should indicate user not found\")\n+\t}\n+}\n+\n+// Test platform detection logic with dependency injection\n+func TestPlatformLogic_DependencyInjection(t *testing.T) {\n+\ttests := []struct {\n+\t\tname                          string\n+\t\tos                            string\n+\t\teuid                          int\n+\t\tcurrentUser                   *user.User\n+\t\texpectedIsProcessPrivileged   bool\n+\t\texpectedSupportsUserSwitching bool\n+\t}{\n+\t\t{\n+\t\t\tname:                          \"linux_root_process\",\n+\t\t\tos:                            \"linux\",\n+\t\t\teuid:                          0,\n+\t\t\tcurrentUser:                   createTestUser(\"root\", \"0\", \"0\", \"/root\"),\n+\t\t\texpectedIsProcessPrivileged:   true,\n+\t\t\texpectedSupportsUserSwitching: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:                          \"linux_non_root_process\",\n+\t\t\tos:                            \"linux\",\n+\t\t\teuid:                          1000,\n+\t\t\tcurrentUser:                   createTestUser(\"alice\", \"1000\", \"1000\", \"/home/alice\"),\n+\t\t\texpectedIsProcessPrivileged:   false,\n+\t\t\texpectedSupportsUserSwitching: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:                          \"windows_admin_process\",\n+\t\t\tos:                            \"windows\",\n+\t\t\teuid:                          1000, // euid ignored on Windows\n+\t\t\tcurrentUser:                   createTestUser(\"Administrator\", \"S-1-5-21-123456789-123456789-123456789-500\", \"S-1-5-32-544\", \"C:\\\\Users\\\\Administrator\"),\n+\t\t\texpectedIsProcessPrivileged:   true,\n+\t\t\texpectedSupportsUserSwitching: true, // Windows supports user switching when privileged\n+\t\t},\n+\t\t{\n+\t\t\tname:                          \"windows_regular_process\",\n+\t\t\tos:                            \"windows\",\n+\t\t\teuid:                          1000, // euid ignored on Windows\n+\t\t\tcurrentUser:                   createTestUser(\"alice\", \"1001\", \"1001\", \"C:\\\\Users\\\\alice\"),\n+\t\t\texpectedIsProcessPrivileged:   false,\n+\t\t\texpectedSupportsUserSwitching: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Inject platform dependencies and test REAL logic\n+\t\t\tcleanup := setupTestDependencies(tt.currentUser, nil, tt.os, tt.euid, nil, nil)\n+\t\t\tdefer cleanup()\n+\n+\t\t\t// Test the actual functions with injected dependencies\n+\t\t\tactualIsPrivileged := isCurrentProcessPrivileged()\n+\t\t\tactualSupportsUserSwitching := actualIsPrivileged\n+\n+\t\t\tassert.Equal(t, tt.expectedIsProcessPrivileged, actualIsPrivileged,\n+\t\t\t\t\"isCurrentProcessPrivileged() result mismatch\")\n+\t\t\tassert.Equal(t, tt.expectedSupportsUserSwitching, actualSupportsUserSwitching,\n+\t\t\t\t\"supportsUserSwitching() result mismatch\")\n+\n+\t\t\tt.Logf(\"Platform: %s, EUID: %d, User: %s\", tt.os, tt.euid, tt.currentUser.Username)\n+\t\t\tt.Logf(\"Results: isPrivileged=%v, supportsUserSwitching=%v\",\n+\t\t\t\tactualIsPrivileged, actualSupportsUserSwitching)\n+\t\t})\n+\t}\n+}\n+\n+func TestCheckPrivileges_WindowsElevatedUserSwitching(t *testing.T) {\n+\t// Test Windows elevated user switching scenarios with simplified privilege logic\n+\ttests := []struct {\n+\t\tname                  string\n+\t\tcurrentUser           *user.User\n+\t\trequestedUsername     string\n+\t\tallowRoot             bool\n+\t\texpectedAllowed       bool\n+\t\texpectedErrorContains string\n+\t}{\n+\t\t{\n+\t\t\tname:              \"windows_admin_can_switch_to_alice\",\n+\t\t\tcurrentUser:       createTestUser(\"administrator\", \"S-1-5-21-123456789-123456789-123456789-500\", \"S-1-5-32-544\", \"C:\\\\\\\\Users\\\\\\\\Administrator\"),\n+\t\t\trequestedUsername: \"alice\",\n+\t\t\tallowRoot:         true,\n+\t\t\texpectedAllowed:   true,\n+\t\t},\n+\t\t{\n+\t\t\tname:              \"windows_non_admin_can_try_switch\",\n+\t\t\tcurrentUser:       createTestUser(\"alice\", \"S-1-5-21-123456789-123456789-123456789-1001\", \"S-1-5-21-123456789-123456789-123456789-513\", \"C:\\\\\\\\Users\\\\\\\\alice\"),\n+\t\t\trequestedUsername: \"bob\",\n+\t\t\tallowRoot:         true,\n+\t\t\texpectedAllowed:   true, // Privilege check allows it, OS will reject during execution\n+\t\t},\n+\t\t{\n+\t\t\tname:              \"windows_system_can_switch_to_alice\",\n+\t\t\tcurrentUser:       createTestUser(\"SYSTEM\", \"S-1-5-18\", \"S-1-5-18\", \"C:\\\\\\\\Windows\\\\\\\\system32\\\\\\\\config\\\\\\\\systemprofile\"),\n+\t\t\trequestedUsername: \"alice\",\n+\t\t\tallowRoot:         true,\n+\t\t\texpectedAllowed:   true,\n+\t\t},\n+\t\t{\n+\t\t\tname:                  \"windows_admin_root_not_allowed\",\n+\t\t\tcurrentUser:           createTestUser(\"administrator\", \"S-1-5-21-123456789-123456789-123456789-500\", \"S-1-5-32-544\", \"C:\\\\\\\\Users\\\\\\\\Administrator\"),\n+\t\t\trequestedUsername:     \"root\",\n+\t\t\tallowRoot:             false,\n+\t\t\texpectedAllowed:       false,\n+\t\t\texpectedErrorContains: \"privileged user login is disabled\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Setup test dependencies with Windows OS and specified privileges\n+\t\t\tlookupUsers := map[string]*user.User{\n+\t\t\t\ttt.requestedUsername: createTestUser(tt.requestedUsername, \"1002\", \"1002\", \"C:\\\\\\\\Users\\\\\\\\\"+tt.requestedUsername),\n+\t\t\t}\n+\t\t\tcleanup := setupTestDependencies(tt.currentUser, nil, \"windows\", 1000, lookupUsers, nil)\n+\t\t\tdefer cleanup()\n+\n+\t\t\tserver := &Server{allowRootLogin: tt.allowRoot}\n+\n+\t\t\tresult := server.CheckPrivileges(PrivilegeCheckRequest{\n+\t\t\t\tRequestedUsername:         tt.requestedUsername,\n+\t\t\t\tFeatureSupportsUserSwitch: true,\n+\t\t\t\tFeatureName:               \"SSH login\",\n+\t\t\t})\n+\n+\t\t\tassert.Equal(t, tt.expectedAllowed, result.Allowed,\n+\t\t\t\t\"Privilege check result should match expected for %s\", tt.name)\n+\n+\t\t\tif !tt.expectedAllowed && tt.expectedErrorContains != \"\" {\n+\t\t\t\tassert.NotNil(t, result.Error, \"Should have error when not allowed\")\n+\t\t\t\tassert.Contains(t, result.Error.Error(), tt.expectedErrorContains,\n+\t\t\t\t\t\"Error should contain expected message\")\n+\t\t\t}\n+\n+\t\t\tif tt.expectedAllowed && tt.requestedUsername != \"\" && tt.currentUser.Username != tt.requestedUsername {\n+\t\t\t\tassert.True(t, result.RequiresUserSwitching, \"Should require user switching for different user\")\n+\t\t\t}\n+\t\t})\n+\t}\n+}\ndiff --git a/client/ssh/server/winpty/conpty_test.go b/client/ssh/server/winpty/conpty_test.go\nnew file mode 100644\nindex 00000000000..4f04e1fad97\n--- /dev/null\n+++ b/client/ssh/server/winpty/conpty_test.go\n@@ -0,0 +1,290 @@\n+//go:build windows\n+\n+package winpty\n+\n+import (\n+\t\"testing\"\n+\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\t\"golang.org/x/sys/windows\"\n+)\n+\n+func TestBuildShellArgs(t *testing.T) {\n+\ttests := []struct {\n+\t\tname     string\n+\t\tshell    string\n+\t\tcommand  string\n+\t\texpected []string\n+\t}{\n+\t\t{\n+\t\t\tname:     \"Shell with command\",\n+\t\t\tshell:    \"powershell.exe\",\n+\t\t\tcommand:  \"Get-Process\",\n+\t\t\texpected: []string{\"powershell.exe\", \"-Command\", \"Get-Process\"},\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"CMD with command\",\n+\t\t\tshell:    \"cmd.exe\",\n+\t\t\tcommand:  \"dir\",\n+\t\t\texpected: []string{\"cmd.exe\", \"-Command\", \"dir\"},\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"Shell interactive\",\n+\t\t\tshell:    \"powershell.exe\",\n+\t\t\tcommand:  \"\",\n+\t\t\texpected: []string{\"powershell.exe\"},\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"CMD interactive\",\n+\t\t\tshell:    \"cmd.exe\",\n+\t\t\tcommand:  \"\",\n+\t\t\texpected: []string{\"cmd.exe\"},\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tresult := buildShellArgs(tt.shell, tt.command)\n+\t\t\tassert.Equal(t, tt.expected, result)\n+\t\t})\n+\t}\n+}\n+\n+func TestBuildCommandLine(t *testing.T) {\n+\ttests := []struct {\n+\t\tname     string\n+\t\targs     []string\n+\t\texpected string\n+\t}{\n+\t\t{\n+\t\t\tname:     \"Simple args\",\n+\t\t\targs:     []string{\"cmd.exe\", \"/c\", \"echo\"},\n+\t\t\texpected: \"cmd.exe /c echo\",\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"Args with spaces\",\n+\t\t\targs:     []string{\"Program Files\\\\app.exe\", \"arg with spaces\"},\n+\t\t\texpected: `\"Program Files\\app.exe\" \"arg with spaces\"`,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"Args with quotes\",\n+\t\t\targs:     []string{\"cmd.exe\", \"/c\", `echo \"hello world\"`},\n+\t\t\texpected: `cmd.exe /c \"echo \\\"hello world\\\"\"`,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"PowerShell calling PowerShell\",\n+\t\t\targs:     []string{\"powershell.exe\", \"-Command\", `powershell.exe -Command \"Get-Process | Where-Object {$_.Name -eq 'notepad'}\"`},\n+\t\t\texpected: `powershell.exe -Command \"powershell.exe -Command \\\"Get-Process | Where-Object {$_.Name -eq 'notepad'}\\\"\"`,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"Complex nested quotes\",\n+\t\t\targs:     []string{\"cmd.exe\", \"/c\", `echo \"He said \\\"Hello\\\" to me\"`},\n+\t\t\texpected: `cmd.exe /c \"echo \\\"He said \\\\\\\"Hello\\\\\\\" to me\\\"\"`,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"Path with spaces and args\",\n+\t\t\targs:     []string{`C:\\Program Files\\MyApp\\app.exe`, \"--config\", `C:\\My Config\\settings.json`},\n+\t\t\texpected: `\"C:\\Program Files\\MyApp\\app.exe\" --config \"C:\\My Config\\settings.json\"`,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"Empty argument\",\n+\t\t\targs:     []string{\"cmd.exe\", \"/c\", \"echo\", \"\"},\n+\t\t\texpected: `cmd.exe /c echo \"\"`,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"Argument with backslashes\",\n+\t\t\targs:     []string{\"robocopy\", `C:\\Source\\`, `C:\\Dest\\`, \"/E\"},\n+\t\t\texpected: `robocopy C:\\Source\\ C:\\Dest\\ /E`,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"Empty args\",\n+\t\t\targs:     []string{},\n+\t\t\texpected: \"\",\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"Single arg with space\",\n+\t\t\targs:     []string{\"path with spaces\"},\n+\t\t\texpected: `\"path with spaces\"`,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tresult := buildCommandLine(tt.args)\n+\t\t\tassert.Equal(t, tt.expected, result)\n+\t\t})\n+\t}\n+}\n+\n+func TestCreateConPtyPipes(t *testing.T) {\n+\tinputRead, inputWrite, outputRead, outputWrite, err := createConPtyPipes()\n+\trequire.NoError(t, err, \"Should create ConPty pipes successfully\")\n+\n+\t// Verify all handles are valid\n+\tassert.NotEqual(t, windows.InvalidHandle, inputRead, \"Input read handle should be valid\")\n+\tassert.NotEqual(t, windows.InvalidHandle, inputWrite, \"Input write handle should be valid\")\n+\tassert.NotEqual(t, windows.InvalidHandle, outputRead, \"Output read handle should be valid\")\n+\tassert.NotEqual(t, windows.InvalidHandle, outputWrite, \"Output write handle should be valid\")\n+\n+\t// Clean up handles\n+\tcloseHandles(inputRead, inputWrite, outputRead, outputWrite)\n+}\n+\n+func TestCreateConPty(t *testing.T) {\n+\tinputRead, inputWrite, outputRead, outputWrite, err := createConPtyPipes()\n+\trequire.NoError(t, err, \"Should create ConPty pipes successfully\")\n+\tdefer closeHandles(inputRead, inputWrite, outputRead, outputWrite)\n+\n+\thPty, err := createConPty(80, 24, inputRead, outputWrite)\n+\trequire.NoError(t, err, \"Should create ConPty successfully\")\n+\tassert.NotEqual(t, windows.InvalidHandle, hPty, \"ConPty handle should be valid\")\n+\n+\t// Clean up ConPty\n+\tret, _, _ := procClosePseudoConsole.Call(uintptr(hPty))\n+\tassert.NotEqual(t, uintptr(0), ret, \"Should close ConPty successfully\")\n+}\n+\n+func TestConvertEnvironmentToUTF16(t *testing.T) {\n+\ttests := []struct {\n+\t\tname     string\n+\t\tuserEnv  []string\n+\t\thasError bool\n+\t}{\n+\t\t{\n+\t\t\tname:     \"Valid environment variables\",\n+\t\t\tuserEnv:  []string{\"PATH=C:\\\\Windows\", \"USER=testuser\", \"HOME=C:\\\\Users\\\\testuser\"},\n+\t\t\thasError: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"Empty environment\",\n+\t\t\tuserEnv:  []string{},\n+\t\t\thasError: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"Environment with empty strings\",\n+\t\t\tuserEnv:  []string{\"PATH=C:\\\\Windows\", \"\", \"USER=testuser\"},\n+\t\t\thasError: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tresult, err := convertEnvironmentToUTF16(tt.userEnv)\n+\t\t\tif tt.hasError {\n+\t\t\t\tassert.Error(t, err)\n+\t\t\t} else {\n+\t\t\t\tassert.NoError(t, err)\n+\t\t\t\tif len(tt.userEnv) == 0 {\n+\t\t\t\t\tassert.Nil(t, result, \"Empty environment should return nil\")\n+\t\t\t\t} else {\n+\t\t\t\t\tassert.NotNil(t, result, \"Non-empty environment should return valid pointer\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestDuplicateToPrimaryToken(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping token tests in short mode\")\n+\t}\n+\n+\t// Get current process token for testing\n+\tvar token windows.Token\n+\terr := windows.OpenProcessToken(windows.CurrentProcess(), windows.TOKEN_ALL_ACCESS, &token)\n+\trequire.NoError(t, err, \"Should open current process token\")\n+\tdefer func() {\n+\t\tif err := windows.CloseHandle(windows.Handle(token)); err != nil {\n+\t\t\tt.Logf(\"Failed to close token: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tprimaryToken, err := duplicateToPrimaryToken(windows.Handle(token))\n+\trequire.NoError(t, err, \"Should duplicate token to primary\")\n+\tassert.NotEqual(t, windows.InvalidHandle, primaryToken, \"Primary token should be valid\")\n+\n+\t// Clean up\n+\terr = windows.CloseHandle(primaryToken)\n+\tassert.NoError(t, err, \"Should close primary token\")\n+}\n+\n+func TestWindowsHandleReader(t *testing.T) {\n+\t// Create a pipe for testing\n+\tvar readHandle, writeHandle windows.Handle\n+\terr := windows.CreatePipe(&readHandle, &writeHandle, nil, 0)\n+\trequire.NoError(t, err, \"Should create pipe for testing\")\n+\tdefer closeHandles(readHandle, writeHandle)\n+\n+\t// Write test data\n+\ttestData := []byte(\"Hello, Windows Handle Reader!\")\n+\tvar bytesWritten uint32\n+\terr = windows.WriteFile(writeHandle, testData, &bytesWritten, nil)\n+\trequire.NoError(t, err, \"Should write test data\")\n+\trequire.Equal(t, uint32(len(testData)), bytesWritten, \"Should write all test data\")\n+\n+\t// Close write handle to signal EOF\n+\tif err := windows.CloseHandle(writeHandle); err != nil {\n+\t\tt.Fatalf(\"Should close write handle: %v\", err)\n+\t}\n+\twriteHandle = windows.InvalidHandle\n+\n+\t// Test reading\n+\treader := &windowsHandleReader{handle: readHandle}\n+\tbuffer := make([]byte, len(testData))\n+\tn, err := reader.Read(buffer)\n+\trequire.NoError(t, err, \"Should read from handle\")\n+\tassert.Equal(t, len(testData), n, \"Should read expected number of bytes\")\n+\tassert.Equal(t, testData, buffer, \"Should read expected data\")\n+}\n+\n+func TestWindowsHandleWriter(t *testing.T) {\n+\t// Create a pipe for testing\n+\tvar readHandle, writeHandle windows.Handle\n+\terr := windows.CreatePipe(&readHandle, &writeHandle, nil, 0)\n+\trequire.NoError(t, err, \"Should create pipe for testing\")\n+\tdefer closeHandles(readHandle, writeHandle)\n+\n+\t// Test writing\n+\ttestData := []byte(\"Hello, Windows Handle Writer!\")\n+\twriter := &windowsHandleWriter{handle: writeHandle}\n+\tn, err := writer.Write(testData)\n+\trequire.NoError(t, err, \"Should write to handle\")\n+\tassert.Equal(t, len(testData), n, \"Should write expected number of bytes\")\n+\n+\t// Close write handle\n+\tif err := windows.CloseHandle(writeHandle); err != nil {\n+\t\tt.Fatalf(\"Should close write handle: %v\", err)\n+\t}\n+\n+\t// Verify data was written by reading it back\n+\tbuffer := make([]byte, len(testData))\n+\tvar bytesRead uint32\n+\terr = windows.ReadFile(readHandle, buffer, &bytesRead, nil)\n+\trequire.NoError(t, err, \"Should read back written data\")\n+\tassert.Equal(t, uint32(len(testData)), bytesRead, \"Should read back expected number of bytes\")\n+\tassert.Equal(t, testData, buffer, \"Should read back expected data\")\n+}\n+\n+// BenchmarkConPtyCreation benchmarks ConPty creation performance\n+func BenchmarkConPtyCreation(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tinputRead, inputWrite, outputRead, outputWrite, err := createConPtyPipes()\n+\t\tif err != nil {\n+\t\t\tb.Fatal(err)\n+\t\t}\n+\n+\t\thPty, err := createConPty(80, 24, inputRead, outputWrite)\n+\t\tif err != nil {\n+\t\t\tcloseHandles(inputRead, inputWrite, outputRead, outputWrite)\n+\t\t\tb.Fatal(err)\n+\t\t}\n+\n+\t\t// Clean up\n+\t\tif ret, _, err := procClosePseudoConsole.Call(uintptr(hPty)); ret == 0 {\n+\t\t\tlog.Debugf(\"ClosePseudoConsole failed: %v\", err)\n+\t\t}\n+\t\tcloseHandles(inputRead, inputWrite, outputRead, outputWrite)\n+\t}\n+}\ndiff --git a/client/ssh/server_test.go b/client/ssh/server_test.go\ndeleted file mode 100644\nindex 1f310c2bb6e..00000000000\n--- a/client/ssh/server_test.go\n+++ /dev/null\n@@ -1,123 +0,0 @@\n-//go:build !js\n-\n-package ssh\n-\n-import (\n-\t\"fmt\"\n-\t\"github.com/stretchr/testify/assert\"\n-\t\"golang.org/x/crypto/ssh\"\n-\t\"strings\"\n-\t\"testing\"\n-)\n-\n-func TestServer_AddAuthorizedKey(t *testing.T) {\n-\tkey, err := GeneratePrivateKey(ED25519)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tserver, err := newDefaultServer(key, \"localhost:\")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\n-\t// add multiple keys\n-\tkeys := map[string][]byte{}\n-\tfor i := 0; i < 10; i++ {\n-\t\tpeer := fmt.Sprintf(\"%s-%d\", \"remotePeer\", i)\n-\t\tremotePrivKey, err := GeneratePrivateKey(ED25519)\n-\t\tif err != nil {\n-\t\t\tt.Fatal(err)\n-\t\t}\n-\t\tremotePubKey, err := GeneratePublicKey(remotePrivKey)\n-\t\tif err != nil {\n-\t\t\tt.Fatal(err)\n-\t\t}\n-\n-\t\terr = server.AddAuthorizedKey(peer, string(remotePubKey))\n-\t\tif err != nil {\n-\t\t\tt.Error(err)\n-\t\t}\n-\t\tkeys[peer] = remotePubKey\n-\t}\n-\n-\t// make sure that all keys have been added\n-\tfor peer, remotePubKey := range keys {\n-\t\tk, ok := server.authorizedKeys[peer]\n-\t\tassert.True(t, ok, \"expecting remotePeer key to be found in authorizedKeys\")\n-\n-\t\tassert.Equal(t, string(remotePubKey), strings.TrimSpace(string(ssh.MarshalAuthorizedKey(k))))\n-\t}\n-\n-}\n-\n-func TestServer_RemoveAuthorizedKey(t *testing.T) {\n-\tkey, err := GeneratePrivateKey(ED25519)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tserver, err := newDefaultServer(key, \"localhost:\")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\n-\tremotePrivKey, err := GeneratePrivateKey(ED25519)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tremotePubKey, err := GeneratePublicKey(remotePrivKey)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\n-\terr = server.AddAuthorizedKey(\"remotePeer\", string(remotePubKey))\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t}\n-\n-\tserver.RemoveAuthorizedKey(\"remotePeer\")\n-\n-\t_, ok := server.authorizedKeys[\"remotePeer\"]\n-\tassert.False(t, ok, \"expecting remotePeer's SSH key to be removed\")\n-}\n-\n-func TestServer_PubKeyHandler(t *testing.T) {\n-\tkey, err := GeneratePrivateKey(ED25519)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tserver, err := newDefaultServer(key, \"localhost:\")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\n-\tvar keys []ssh.PublicKey\n-\tfor i := 0; i < 10; i++ {\n-\t\tpeer := fmt.Sprintf(\"%s-%d\", \"remotePeer\", i)\n-\t\tremotePrivKey, err := GeneratePrivateKey(ED25519)\n-\t\tif err != nil {\n-\t\t\tt.Fatal(err)\n-\t\t}\n-\t\tremotePubKey, err := GeneratePublicKey(remotePrivKey)\n-\t\tif err != nil {\n-\t\t\tt.Fatal(err)\n-\t\t}\n-\n-\t\tremoteParsedPubKey, _, _, _, err := ssh.ParseAuthorizedKey(remotePubKey)\n-\t\tif err != nil {\n-\t\t\tt.Fatal(err)\n-\t\t}\n-\n-\t\terr = server.AddAuthorizedKey(peer, string(remotePubKey))\n-\t\tif err != nil {\n-\t\t\tt.Error(err)\n-\t\t}\n-\t\tkeys = append(keys, remoteParsedPubKey)\n-\t}\n-\n-\tfor _, key := range keys {\n-\t\taccepted := server.publicKeyHandler(nil, key)\n-\n-\t\tassert.Truef(t, accepted, \"expecting SSH connection to be accepted for a given SSH key %s\", string(ssh.MarshalAuthorizedKey(key)))\n-\t}\n-\n-}\ndiff --git a/client/ssh/testutil/user_helpers.go b/client/ssh/testutil/user_helpers.go\nnew file mode 100644\nindex 00000000000..0c122207884\n--- /dev/null\n+++ b/client/ssh/testutil/user_helpers.go\n@@ -0,0 +1,172 @@\n+package testutil\n+\n+import (\n+\t\"fmt\"\n+\t\"log\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"os/user\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+var testCreatedUsers = make(map[string]bool)\n+var testUsersToCleanup []string\n+\n+// GetTestUsername returns an appropriate username for testing\n+func GetTestUsername(t *testing.T) string {\n+\tif runtime.GOOS == \"windows\" {\n+\t\tcurrentUser, err := user.Current()\n+\t\trequire.NoError(t, err, \"Should be able to get current user\")\n+\n+\t\tif IsSystemAccount(currentUser.Username) {\n+\t\t\tif IsCI() {\n+\t\t\t\tif testUser := GetOrCreateTestUser(t); testUser != \"\" {\n+\t\t\t\t\treturn testUser\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif _, err := user.Lookup(\"Administrator\"); err == nil {\n+\t\t\t\t\treturn \"Administrator\"\n+\t\t\t\t}\n+\t\t\t\tif testUser := GetOrCreateTestUser(t); testUser != \"\" {\n+\t\t\t\t\treturn testUser\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn currentUser.Username\n+\t}\n+\n+\tcurrentUser, err := user.Current()\n+\trequire.NoError(t, err, \"Should be able to get current user\")\n+\treturn currentUser.Username\n+}\n+\n+// IsCI checks if we're running in a CI environment\n+func IsCI() bool {\n+\tif os.Getenv(\"GITHUB_ACTIONS\") == \"true\" || os.Getenv(\"CI\") == \"true\" {\n+\t\treturn true\n+\t}\n+\n+\thostname, err := os.Hostname()\n+\tif err == nil && strings.HasPrefix(hostname, \"runner\") {\n+\t\treturn true\n+\t}\n+\n+\treturn false\n+}\n+\n+// IsSystemAccount checks if the user is a system account that can't authenticate\n+func IsSystemAccount(username string) bool {\n+\tsystemAccounts := []string{\n+\t\t\"system\",\n+\t\t\"NT AUTHORITY\\\\SYSTEM\",\n+\t\t\"NT AUTHORITY\\\\LOCAL SERVICE\",\n+\t\t\"NT AUTHORITY\\\\NETWORK SERVICE\",\n+\t}\n+\n+\tfor _, sysAccount := range systemAccounts {\n+\t\tif strings.EqualFold(username, sysAccount) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+// RegisterTestUserCleanup registers a test user for cleanup\n+func RegisterTestUserCleanup(username string) {\n+\tif !testCreatedUsers[username] {\n+\t\ttestCreatedUsers[username] = true\n+\t\ttestUsersToCleanup = append(testUsersToCleanup, username)\n+\t}\n+}\n+\n+// CleanupTestUsers removes all created test users\n+func CleanupTestUsers() {\n+\tfor _, username := range testUsersToCleanup {\n+\t\tRemoveWindowsTestUser(username)\n+\t}\n+\ttestUsersToCleanup = nil\n+\ttestCreatedUsers = make(map[string]bool)\n+}\n+\n+// GetOrCreateTestUser creates a test user on Windows if needed\n+func GetOrCreateTestUser(t *testing.T) string {\n+\ttestUsername := \"netbird-test-user\"\n+\n+\tif _, err := user.Lookup(testUsername); err == nil {\n+\t\treturn testUsername\n+\t}\n+\n+\tif CreateWindowsTestUser(t, testUsername) {\n+\t\tRegisterTestUserCleanup(testUsername)\n+\t\treturn testUsername\n+\t}\n+\n+\treturn \"\"\n+}\n+\n+// RemoveWindowsTestUser removes a local user on Windows using PowerShell\n+func RemoveWindowsTestUser(username string) {\n+\tif runtime.GOOS != \"windows\" {\n+\t\treturn\n+\t}\n+\n+\tpsCmd := fmt.Sprintf(`\n+\t\ttry {\n+\t\t\tRemove-LocalUser -Name \"%s\" -ErrorAction Stop\n+\t\t\tWrite-Output \"User removed successfully\"\n+\t\t} catch {\n+\t\t\tif ($_.Exception.Message -like \"*cannot be found*\") {\n+\t\t\t\tWrite-Output \"User not found (already removed)\"\n+\t\t\t} else {\n+\t\t\t\tWrite-Error $_.Exception.Message\n+\t\t\t}\n+\t\t}\n+\t`, username)\n+\n+\tcmd := exec.Command(\"powershell\", \"-Command\", psCmd)\n+\toutput, err := cmd.CombinedOutput()\n+\n+\tif err != nil {\n+\t\tlog.Printf(\"Failed to remove test user %s: %v, output: %s\", username, err, string(output))\n+\t} else {\n+\t\tlog.Printf(\"Test user %s cleanup result: %s\", username, string(output))\n+\t}\n+}\n+\n+// CreateWindowsTestUser creates a local user on Windows using PowerShell\n+func CreateWindowsTestUser(t *testing.T, username string) bool {\n+\tif runtime.GOOS != \"windows\" {\n+\t\treturn false\n+\t}\n+\n+\tpsCmd := fmt.Sprintf(`\n+\t\ttry {\n+\t\t\t$password = ConvertTo-SecureString \"TestPassword123!\" -AsPlainText -Force\n+\t\t\tNew-LocalUser -Name \"%s\" -Password $password -Description \"NetBird test user\" -UserMayNotChangePassword -PasswordNeverExpires\n+\t\t\tAdd-LocalGroupMember -Group \"Users\" -Member \"%s\"\n+\t\t\tWrite-Output \"User created successfully\"\n+\t\t} catch {\n+\t\t\tif ($_.Exception.Message -like \"*already exists*\") {\n+\t\t\t\tWrite-Output \"User already exists\"\n+\t\t\t} else {\n+\t\t\t\tWrite-Error $_.Exception.Message\n+\t\t\t\texit 1\n+\t\t\t}\n+\t\t}\n+\t`, username, username)\n+\n+\tcmd := exec.Command(\"powershell\", \"-Command\", psCmd)\n+\toutput, err := cmd.CombinedOutput()\n+\n+\tif err != nil {\n+\t\tt.Logf(\"Failed to create test user: %v, output: %s\", err, string(output))\n+\t\treturn false\n+\t}\n+\n+\tt.Logf(\"Test user creation result: %s\", string(output))\n+\treturn true\n+}\ndiff --git a/client/status/status_test.go b/client/status/status_test.go\nindex 660efd9ef04..1dca1e5b16d 100644\n--- a/client/status/status_test.go\n+++ b/client/status/status_test.go\n@@ -231,6 +231,10 @@ var overview = OutputOverview{\n \tNetworks: []string{\n \t\t\"10.10.0.0/24\",\n \t},\n+\tSSHServerState: SSHServerStateOutput{\n+\t\tEnabled:  false,\n+\t\tSessions: []SSHSessionOutput{},\n+\t},\n }\n \n func TestConversionFromFullStatusToOutputOverview(t *testing.T) {\n@@ -385,7 +389,11 @@ func TestParsingToJSON(t *testing.T) {\n           ],\n           \"events\": [],\n           \"lazyConnectionEnabled\": false,\n-\t\t  \"profileName\":\"\"\n+\t\t  \"profileName\":\"\",\n+\t\t  \"sshServer\":{\n+\t\t    \"enabled\":false,\n+\t\t\t\"sessions\":[]\n+\t\t  }\n         }`\n \t// @formatter:on\n \n@@ -488,6 +496,9 @@ dnsServers:\n events: []\n lazyConnectionEnabled: false\n profileName: \"\"\n+sshServer:\n+    enabled: false\n+    sessions: []\n `\n \n \tassert.Equal(t, expectedYAML, yaml)\n@@ -554,6 +565,7 @@ NetBird IP: 192.168.178.100/16\n Interface type: Kernel\n Quantum resistance: false\n Lazy connection: false\n+SSH Server: Disabled\n Networks: 10.10.0.0/24\n Forwarding rules: 0\n Peers count: 2/2 Connected\n@@ -563,7 +575,7 @@ Peers count: 2/2 Connected\n }\n \n func TestParsingToShortVersion(t *testing.T) {\n-\tshortVersion := ParseGeneralSummary(overview, false, false, false)\n+\tshortVersion := ParseGeneralSummary(overview, false, false, false, false)\n \n \texpectedString := fmt.Sprintf(\"OS: %s/%s\", runtime.GOOS, runtime.GOARCH) + `\n Daemon version: 0.14.1\n@@ -578,6 +590,7 @@ NetBird IP: 192.168.178.100/16\n Interface type: Kernel\n Quantum resistance: false\n Lazy connection: false\n+SSH Server: Disabled\n Networks: 10.10.0.0/24\n Forwarding rules: 0\n Peers count: 2/2 Connected\ndiff --git a/management/server/account_test.go b/management/server/account_test.go\nindex ee9950796e0..10d718bbf6a 100644\n--- a/management/server/account_test.go\n+++ b/management/server/account_test.go\n@@ -28,7 +28,6 @@ import (\n \tnbAccount \"github.com/netbirdio/netbird/management/server/account\"\n \t\"github.com/netbirdio/netbird/management/server/activity\"\n \t\"github.com/netbirdio/netbird/management/server/cache\"\n-\tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/http/testing/testing_tools\"\n \t\"github.com/netbirdio/netbird/management/server/idp\"\n \t\"github.com/netbirdio/netbird/management/server/integrations/port_forwarding\"\n@@ -45,6 +44,7 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/types\"\n \t\"github.com/netbirdio/netbird/management/server/util\"\n \t\"github.com/netbirdio/netbird/route\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n )\n \n func verifyCanAddPeerToAccount(t *testing.T, manager nbAccount.Manager, account *types.Account, userID string) {\n@@ -445,7 +445,7 @@ func TestAccountManager_GetOrCreateAccountByUser(t *testing.T) {\n }\n \n func TestDefaultAccountManager_GetAccountIDFromToken(t *testing.T) {\n-\ttype initUserParams nbcontext.UserAuth\n+\ttype initUserParams auth.UserAuth\n \n \tvar (\n \t\tpublicDomain  = \"public.com\"\n@@ -468,7 +468,7 @@ func TestDefaultAccountManager_GetAccountIDFromToken(t *testing.T) {\n \n \ttestCases := []struct {\n \t\tname                        string\n-\t\tinputClaims                 nbcontext.UserAuth\n+\t\tinputClaims                 auth.UserAuth\n \t\tinputInitUserParams         initUserParams\n \t\tinputUpdateAttrs            bool\n \t\tinputUpdateClaimAccount     bool\n@@ -483,7 +483,7 @@ func TestDefaultAccountManager_GetAccountIDFromToken(t *testing.T) {\n \t}{\n \t\t{\n \t\t\tname: \"New User With Public Domain\",\n-\t\t\tinputClaims: nbcontext.UserAuth{\n+\t\t\tinputClaims: auth.UserAuth{\n \t\t\t\tDomain:         publicDomain,\n \t\t\t\tUserId:         \"pub-domain-user\",\n \t\t\t\tDomainCategory: types.PublicCategory,\n@@ -500,7 +500,7 @@ func TestDefaultAccountManager_GetAccountIDFromToken(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname: \"New User With Unknown Domain\",\n-\t\t\tinputClaims: nbcontext.UserAuth{\n+\t\t\tinputClaims: auth.UserAuth{\n \t\t\t\tDomain:         unknownDomain,\n \t\t\t\tUserId:         \"unknown-domain-user\",\n \t\t\t\tDomainCategory: types.UnknownCategory,\n@@ -517,7 +517,7 @@ func TestDefaultAccountManager_GetAccountIDFromToken(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname: \"New User With Private Domain\",\n-\t\t\tinputClaims: nbcontext.UserAuth{\n+\t\t\tinputClaims: auth.UserAuth{\n \t\t\t\tDomain:         privateDomain,\n \t\t\t\tUserId:         \"pvt-domain-user\",\n \t\t\t\tDomainCategory: types.PrivateCategory,\n@@ -534,7 +534,7 @@ func TestDefaultAccountManager_GetAccountIDFromToken(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname: \"New Regular User With Existing Private Domain\",\n-\t\t\tinputClaims: nbcontext.UserAuth{\n+\t\t\tinputClaims: auth.UserAuth{\n \t\t\t\tDomain:         privateDomain,\n \t\t\t\tUserId:         \"new-pvt-domain-user\",\n \t\t\t\tDomainCategory: types.PrivateCategory,\n@@ -552,7 +552,7 @@ func TestDefaultAccountManager_GetAccountIDFromToken(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname: \"Existing User With Existing Reclassified Private Domain\",\n-\t\t\tinputClaims: nbcontext.UserAuth{\n+\t\t\tinputClaims: auth.UserAuth{\n \t\t\t\tDomain:         defaultInitAccount.Domain,\n \t\t\t\tUserId:         defaultInitAccount.UserId,\n \t\t\t\tDomainCategory: types.PrivateCategory,\n@@ -569,7 +569,7 @@ func TestDefaultAccountManager_GetAccountIDFromToken(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname: \"Existing Account Id With Existing Reclassified Private Domain\",\n-\t\t\tinputClaims: nbcontext.UserAuth{\n+\t\t\tinputClaims: auth.UserAuth{\n \t\t\t\tDomain:         defaultInitAccount.Domain,\n \t\t\t\tUserId:         defaultInitAccount.UserId,\n \t\t\t\tDomainCategory: types.PrivateCategory,\n@@ -587,7 +587,7 @@ func TestDefaultAccountManager_GetAccountIDFromToken(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname: \"User With Private Category And Empty Domain\",\n-\t\t\tinputClaims: nbcontext.UserAuth{\n+\t\t\tinputClaims: auth.UserAuth{\n \t\t\t\tDomain:         \"\",\n \t\t\t\tUserId:         \"pvt-domain-user\",\n \t\t\t\tDomainCategory: types.PrivateCategory,\n@@ -616,7 +616,7 @@ func TestDefaultAccountManager_GetAccountIDFromToken(t *testing.T) {\n \t\t\trequire.NoError(t, err, \"get init account failed\")\n \n \t\t\tif testCase.inputUpdateAttrs {\n-\t\t\t\terr = manager.updateAccountDomainAttributesIfNotUpToDate(context.Background(), initAccount.Id, nbcontext.UserAuth{UserId: testCase.inputInitUserParams.UserId, Domain: testCase.inputInitUserParams.Domain, DomainCategory: testCase.inputInitUserParams.DomainCategory}, true)\n+\t\t\t\terr = manager.updateAccountDomainAttributesIfNotUpToDate(context.Background(), initAccount.Id, auth.UserAuth{UserId: testCase.inputInitUserParams.UserId, Domain: testCase.inputInitUserParams.Domain, DomainCategory: testCase.inputInitUserParams.DomainCategory}, true)\n \t\t\t\trequire.NoError(t, err, \"update init user failed\")\n \t\t\t}\n \n@@ -656,7 +656,7 @@ func TestDefaultAccountManager_SyncUserJWTGroups(t *testing.T) {\n \t// it is important to set the id as it help to avoid creating additional account with empty Id and re-pointing indices to it\n \tinitAccount, err := manager.Store.GetAccount(context.Background(), accountID)\n \trequire.NoError(t, err, \"get init account failed\")\n-\tclaims := nbcontext.UserAuth{\n+\tclaims := auth.UserAuth{\n \t\tAccountId:      accountID, // is empty as it is based on accountID right after initialization of initAccount\n \t\tDomain:         domain,\n \t\tUserId:         userId,\n@@ -915,13 +915,13 @@ func TestAccountManager_DeleteAccount(t *testing.T) {\n }\n \n func BenchmarkTest_GetAccountWithclaims(b *testing.B) {\n-\tclaims := nbcontext.UserAuth{\n+\tclaims := auth.UserAuth{\n \t\tDomain:         \"example.com\",\n \t\tUserId:         \"pvt-domain-user\",\n \t\tDomainCategory: types.PrivateCategory,\n \t}\n \n-\tpublicClaims := nbcontext.UserAuth{\n+\tpublicClaims := auth.UserAuth{\n \t\tDomain:         \"test.com\",\n \t\tUserId:         \"public-domain-user\",\n \t\tDomainCategory: types.PublicCategory,\n@@ -2709,7 +2709,7 @@ func TestAccount_SetJWTGroups(t *testing.T) {\n \tassert.NoError(t, manager.Store.SaveAccount(context.Background(), account), \"unable to save account\")\n \n \tt.Run(\"skip sync for token auth type\", func(t *testing.T) {\n-\t\tclaims := nbcontext.UserAuth{\n+\t\tclaims := auth.UserAuth{\n \t\t\tUserId:    \"user1\",\n \t\t\tAccountId: \"accountID\",\n \t\t\tGroups:    []string{\"group3\"},\n@@ -2724,7 +2724,7 @@ func TestAccount_SetJWTGroups(t *testing.T) {\n \t})\n \n \tt.Run(\"empty jwt groups\", func(t *testing.T) {\n-\t\tclaims := nbcontext.UserAuth{\n+\t\tclaims := auth.UserAuth{\n \t\t\tUserId:    \"user1\",\n \t\t\tAccountId: \"accountID\",\n \t\t\tGroups:    []string{},\n@@ -2738,7 +2738,7 @@ func TestAccount_SetJWTGroups(t *testing.T) {\n \t})\n \n \tt.Run(\"jwt match existing api group\", func(t *testing.T) {\n-\t\tclaims := nbcontext.UserAuth{\n+\t\tclaims := auth.UserAuth{\n \t\t\tUserId:    \"user1\",\n \t\t\tAccountId: \"accountID\",\n \t\t\tGroups:    []string{\"group1\"},\n@@ -2759,7 +2759,7 @@ func TestAccount_SetJWTGroups(t *testing.T) {\n \t\taccount.Users[\"user1\"].AutoGroups = []string{\"group1\"}\n \t\tassert.NoError(t, manager.Store.SaveUser(context.Background(), account.Users[\"user1\"]))\n \n-\t\tclaims := nbcontext.UserAuth{\n+\t\tclaims := auth.UserAuth{\n \t\t\tUserId:    \"user1\",\n \t\t\tAccountId: \"accountID\",\n \t\t\tGroups:    []string{\"group1\"},\n@@ -2777,7 +2777,7 @@ func TestAccount_SetJWTGroups(t *testing.T) {\n \t})\n \n \tt.Run(\"add jwt group\", func(t *testing.T) {\n-\t\tclaims := nbcontext.UserAuth{\n+\t\tclaims := auth.UserAuth{\n \t\t\tUserId:    \"user1\",\n \t\t\tAccountId: \"accountID\",\n \t\t\tGroups:    []string{\"group1\", \"group2\"},\n@@ -2791,7 +2791,7 @@ func TestAccount_SetJWTGroups(t *testing.T) {\n \t})\n \n \tt.Run(\"existed group not update\", func(t *testing.T) {\n-\t\tclaims := nbcontext.UserAuth{\n+\t\tclaims := auth.UserAuth{\n \t\t\tUserId:    \"user1\",\n \t\t\tAccountId: \"accountID\",\n \t\t\tGroups:    []string{\"group2\"},\n@@ -2805,7 +2805,7 @@ func TestAccount_SetJWTGroups(t *testing.T) {\n \t})\n \n \tt.Run(\"add new group\", func(t *testing.T) {\n-\t\tclaims := nbcontext.UserAuth{\n+\t\tclaims := auth.UserAuth{\n \t\t\tUserId:    \"user2\",\n \t\t\tAccountId: \"accountID\",\n \t\t\tGroups:    []string{\"group1\", \"group3\"},\n@@ -2823,7 +2823,7 @@ func TestAccount_SetJWTGroups(t *testing.T) {\n \t})\n \n \tt.Run(\"remove all JWT groups when list is empty\", func(t *testing.T) {\n-\t\tclaims := nbcontext.UserAuth{\n+\t\tclaims := auth.UserAuth{\n \t\t\tUserId:    \"user1\",\n \t\t\tAccountId: \"accountID\",\n \t\t\tGroups:    []string{},\n@@ -2838,7 +2838,7 @@ func TestAccount_SetJWTGroups(t *testing.T) {\n \t})\n \n \tt.Run(\"remove all JWT groups when claim does not exist\", func(t *testing.T) {\n-\t\tclaims := nbcontext.UserAuth{\n+\t\tclaims := auth.UserAuth{\n \t\t\tUserId:    \"user2\",\n \t\t\tAccountId: \"accountID\",\n \t\t\tGroups:    []string{},\n@@ -2959,7 +2959,7 @@ func createManager(t testing.TB) (*DefaultAccountManager, *update_channel.PeersU\n \tupdateManager := update_channel.NewPeersUpdateManager(metrics)\n \trequestBuffer := NewAccountRequestBuffer(ctx, store)\n \tnetworkMapController := controller.NewController(ctx, store, metrics, updateManager, requestBuffer, MockIntegratedValidator{}, settingsMockManager, \"netbird.cloud\", port_forwarding.NewControllerMock())\n-\tmanager, err := BuildManager(ctx, store, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n+\tmanager, err := BuildManager(ctx, nil, store, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n \tif err != nil {\n \t\treturn nil, nil, err\n \t}\n@@ -3692,7 +3692,7 @@ func TestAddNewUserToDomainAccountWithApproval(t *testing.T) {\n \n \t// Test adding new user to existing account with approval required\n \tnewUserID := \"new-user-id\"\n-\tuserAuth := nbcontext.UserAuth{\n+\tuserAuth := auth.UserAuth{\n \t\tUserId:         newUserID,\n \t\tDomain:         \"example.com\",\n \t\tDomainCategory: types.PrivateCategory,\n@@ -3722,7 +3722,7 @@ func TestAddNewUserToDomainAccountWithoutApproval(t *testing.T) {\n \t}\n \n \t// Create a domain-based account without user approval\n-\townerUserAuth := nbcontext.UserAuth{\n+\townerUserAuth := auth.UserAuth{\n \t\tUserId:         \"owner-user\",\n \t\tDomain:         \"example.com\",\n \t\tDomainCategory: types.PrivateCategory,\n@@ -3741,7 +3741,7 @@ func TestAddNewUserToDomainAccountWithoutApproval(t *testing.T) {\n \n \t// Test adding new user to existing account without approval required\n \tnewUserID := \"new-user-id\"\n-\tuserAuth := nbcontext.UserAuth{\n+\tuserAuth := auth.UserAuth{\n \t\tUserId:         newUserID,\n \t\tDomain:         \"example.com\",\n \t\tDomainCategory: types.PrivateCategory,\ndiff --git a/management/server/auth/manager_test.go b/management/server/auth/manager_test.go\nindex c8015eb370f..b9f091b1ee8 100644\n--- a/management/server/auth/manager_test.go\n+++ b/management/server/auth/manager_test.go\n@@ -17,10 +17,10 @@ import (\n \t\"github.com/stretchr/testify/require\"\n \n \t\"github.com/netbirdio/netbird/management/server/auth\"\n-\tnbjwt \"github.com/netbirdio/netbird/management/server/auth/jwt\"\n-\tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/store\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n+\tnbauth \"github.com/netbirdio/netbird/shared/auth\"\n+\tnbjwt \"github.com/netbirdio/netbird/shared/auth/jwt\"\n )\n \n func TestAuthManager_GetAccountInfoFromPAT(t *testing.T) {\n@@ -131,7 +131,7 @@ func TestAuthManager_EnsureUserAccessByJWTGroups(t *testing.T) {\n \t}\n \n \t// this has been validated and parsed by ValidateAndParseToken\n-\tuserAuth := nbcontext.UserAuth{\n+\tuserAuth := nbauth.UserAuth{\n \t\tAccountId:      account.Id,\n \t\tDomain:         domain,\n \t\tUserId:         userId,\n@@ -236,7 +236,7 @@ func TestAuthManager_ValidateAndParseToken(t *testing.T) {\n \ttests := []struct {\n \t\tname      string\n \t\ttokenFunc func() string\n-\t\texpected  *nbcontext.UserAuth // nil indicates expected error\n+\t\texpected  *nbauth.UserAuth // nil indicates expected error\n \t}{\n \t\t{\n \t\t\tname: \"Valid with custom claims\",\n@@ -258,7 +258,7 @@ func TestAuthManager_ValidateAndParseToken(t *testing.T) {\n \t\t\t\ttokenString, _ := token.SignedString(key)\n \t\t\t\treturn tokenString\n \t\t\t},\n-\t\t\texpected: &nbcontext.UserAuth{\n+\t\t\texpected: &nbauth.UserAuth{\n \t\t\t\tUserId:         \"user-id|123\",\n \t\t\t\tAccountId:      \"account-id|567\",\n \t\t\t\tDomain:         \"http://localhost\",\n@@ -282,7 +282,7 @@ func TestAuthManager_ValidateAndParseToken(t *testing.T) {\n \t\t\t\ttokenString, _ := token.SignedString(key)\n \t\t\t\treturn tokenString\n \t\t\t},\n-\t\t\texpected: &nbcontext.UserAuth{\n+\t\t\texpected: &nbauth.UserAuth{\n \t\t\t\tUserId: \"user-id|123\",\n \t\t\t},\n \t\t},\ndiff --git a/management/server/dns_test.go b/management/server/dns_test.go\nindex 356a2f64048..6b7a36c20d7 100644\n--- a/management/server/dns_test.go\n+++ b/management/server/dns_test.go\n@@ -224,7 +224,7 @@ func createDNSManager(t *testing.T) (*DefaultAccountManager, error) {\n \trequestBuffer := NewAccountRequestBuffer(ctx, store)\n \tnetworkMapController := controller.NewController(ctx, store, metrics, updateManager, requestBuffer, MockIntegratedValidator{}, settingsMockManager, \"netbird.test\", port_forwarding.NewControllerMock())\n \n-\treturn BuildManager(context.Background(), store, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n+\treturn BuildManager(context.Background(), nil, store, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n }\n \n func createDNSStore(t *testing.T) (store.Store, error) {\ndiff --git a/management/server/http/handlers/accounts/accounts_handler_test.go b/management/server/http/handlers/accounts/accounts_handler_test.go\nindex 4b9b79fdc18..c5c48ef3210 100644\n--- a/management/server/http/handlers/accounts/accounts_handler_test.go\n+++ b/management/server/http/handlers/accounts/accounts_handler_test.go\n@@ -18,6 +18,7 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n \t\"github.com/netbirdio/netbird/management/server/settings\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n \t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n@@ -236,7 +237,7 @@ func TestAccounts_AccountsHandler(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    adminUser.Id,\n \t\t\t\tAccountId: accountID,\n \t\t\t\tDomain:    \"hotmail.com\",\ndiff --git a/management/server/http/handlers/dns/dns_settings_handler_test.go b/management/server/http/handlers/dns/dns_settings_handler_test.go\nindex 42b519c292e..a027c067e36 100644\n--- a/management/server/http/handlers/dns/dns_settings_handler_test.go\n+++ b/management/server/http/handlers/dns/dns_settings_handler_test.go\n@@ -11,13 +11,14 @@ import (\n \n \t\"github.com/stretchr/testify/assert\"\n \n+\t\"github.com/netbirdio/netbird/management/server/types\"\n \t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n-\t\"github.com/netbirdio/netbird/management/server/types\"\n \n \t\"github.com/gorilla/mux\"\n \n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n \n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n )\n@@ -107,7 +108,7 @@ func TestDNSSettingsHandlers(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    testingDNSSettingsAccount.Users[testDNSSettingsUserID].Id,\n \t\t\t\tAccountId: testingDNSSettingsAccount.Id,\n \t\t\t\tDomain:    testingDNSSettingsAccount.Domain,\ndiff --git a/management/server/http/handlers/dns/nameservers_handler_test.go b/management/server/http/handlers/dns/nameservers_handler_test.go\nindex d49b6c7e063..4716782f3fa 100644\n--- a/management/server/http/handlers/dns/nameservers_handler_test.go\n+++ b/management/server/http/handlers/dns/nameservers_handler_test.go\n@@ -19,6 +19,7 @@ import (\n \t\"github.com/gorilla/mux\"\n \n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n \n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n )\n@@ -193,7 +194,7 @@ func TestNameserversHandlers(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"test_user\",\n \t\t\t\tAccountId: testNSGroupAccountID,\n \t\t\t\tDomain:    \"hotmail.com\",\ndiff --git a/management/server/http/handlers/events/events_handler_test.go b/management/server/http/handlers/events/events_handler_test.go\nindex a0695fa3fa4..923a24e31e5 100644\n--- a/management/server/http/handlers/events/events_handler_test.go\n+++ b/management/server/http/handlers/events/events_handler_test.go\n@@ -14,11 +14,12 @@ import (\n \t\"github.com/stretchr/testify/assert\"\n \n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n \n \t\"github.com/netbirdio/netbird/management/server/activity\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n )\n \n func initEventsTestData(account string, events ...*activity.Event) *handler {\n@@ -188,7 +189,7 @@ func TestEvents_GetEvents(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"test_user\",\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_account\",\ndiff --git a/management/server/http/handlers/groups/groups_handler_test.go b/management/server/http/handlers/groups/groups_handler_test.go\nindex 34694ec8c4a..b7dd3944a2b 100644\n--- a/management/server/http/handlers/groups/groups_handler_test.go\n+++ b/management/server/http/handlers/groups/groups_handler_test.go\n@@ -19,12 +19,13 @@ import (\n \n \t\"github.com/netbirdio/netbird/management/server\"\n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/util\"\n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n \tnbpeer \"github.com/netbirdio/netbird/management/server/peer\"\n-\t\"github.com/netbirdio/netbird/shared/management/status\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/util\"\n+\t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n \n var TestPeers = map[string]*nbpeer.Peer{\n@@ -122,7 +123,7 @@ func TestGetGroup(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"test_user\",\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_id\",\n@@ -248,7 +249,7 @@ func TestWriteGroup(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"test_user\",\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_id\",\n@@ -330,7 +331,7 @@ func TestDeleteGroup(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, nil)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"test_user\",\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_id\",\ndiff --git a/management/server/http/handlers/peers/peers_handler_test.go b/management/server/http/handlers/peers/peers_handler_test.go\nindex 7a5a6d91129..ddf2e2a7062 100644\n--- a/management/server/http/handlers/peers/peers_handler_test.go\n+++ b/management/server/http/handlers/peers/peers_handler_test.go\n@@ -21,6 +21,7 @@ import (\n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \tnbpeer \"github.com/netbirdio/netbird/management/server/peer\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n \t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \n \t\"github.com/stretchr/testify/assert\"\n@@ -296,7 +297,7 @@ func TestGetPeers(t *testing.T) {\n \n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"admin_user\",\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_id\",\n@@ -444,7 +445,7 @@ func TestGetAccessiblePeers(t *testing.T) {\n \n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(http.MethodGet, fmt.Sprintf(\"/api/peers/%s/accessible-peers\", tc.peerID), nil)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    tc.callerUserID,\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_id\",\n@@ -527,7 +528,7 @@ func TestPeersHandlerUpdatePeerIP(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\treq := httptest.NewRequest(http.MethodPut, fmt.Sprintf(\"/peers/%s\", tc.peerID), bytes.NewBuffer([]byte(tc.requestBody)))\n \t\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    tc.callerUserID,\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_id\",\ndiff --git a/management/server/http/handlers/policies/geolocation_handler_test.go b/management/server/http/handlers/policies/geolocation_handler_test.go\nindex cedd5ac8872..094a36e38f3 100644\n--- a/management/server/http/handlers/policies/geolocation_handler_test.go\n+++ b/management/server/http/handlers/policies/geolocation_handler_test.go\n@@ -16,12 +16,13 @@ import (\n \n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/geolocation\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n \t\"github.com/netbirdio/netbird/management/server/permissions\"\n \t\"github.com/netbirdio/netbird/management/server/permissions/modules\"\n \t\"github.com/netbirdio/netbird/management/server/permissions/operations\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/util\"\n )\n \n@@ -113,7 +114,7 @@ func TestGetCitiesByCountry(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, nil)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"test_user\",\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_id\",\n@@ -206,7 +207,7 @@ func TestGetAllCountries(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, nil)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"test_user\",\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_id\",\ndiff --git a/management/server/http/handlers/policies/policies_handler_test.go b/management/server/http/handlers/policies/policies_handler_test.go\nindex fd39ae2a3bc..ca5a0a6abfb 100644\n--- a/management/server/http/handlers/policies/policies_handler_test.go\n+++ b/management/server/http/handlers/policies/policies_handler_test.go\n@@ -14,10 +14,11 @@ import (\n \t\"github.com/stretchr/testify/assert\"\n \n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n-\t\"github.com/netbirdio/netbird/shared/management/status\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n+\t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n \n func initPoliciesTestData(policies ...*types.Policy) *handler {\n@@ -103,7 +104,7 @@ func TestPoliciesGetPolicy(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"test_user\",\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_id\",\n@@ -267,7 +268,7 @@ func TestPoliciesWritePolicy(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"test_user\",\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_id\",\ndiff --git a/management/server/http/handlers/policies/posture_checks_handler_test.go b/management/server/http/handlers/policies/posture_checks_handler_test.go\nindex c644b533a1a..8c60d6fe871 100644\n--- a/management/server/http/handlers/policies/posture_checks_handler_test.go\n+++ b/management/server/http/handlers/policies/posture_checks_handler_test.go\n@@ -16,9 +16,10 @@ import (\n \n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/geolocation\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n \t\"github.com/netbirdio/netbird/management/server/posture\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n \n@@ -175,7 +176,7 @@ func TestGetPostureCheck(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(http.MethodGet, \"/api/posture-checks/\"+tc.id, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"test_user\",\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_id\",\n@@ -828,7 +829,7 @@ func TestPostureCheckUpdate(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"test_user\",\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_id\",\ndiff --git a/management/server/http/handlers/routes/routes_handler_test.go b/management/server/http/handlers/routes/routes_handler_test.go\nindex 466a7987f4b..a44d81e3ec8 100644\n--- a/management/server/http/handlers/routes/routes_handler_test.go\n+++ b/management/server/http/handlers/routes/routes_handler_test.go\n@@ -19,6 +19,7 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n \t\"github.com/netbirdio/netbird/management/server/util\"\n \t\"github.com/netbirdio/netbird/route\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n \t\"github.com/netbirdio/netbird/shared/management/domain\"\n \t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n@@ -493,7 +494,7 @@ func TestRoutesHandlers(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"test_user\",\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: testAccountID,\ndiff --git a/management/server/http/handlers/setup_keys/setupkeys_handler_test.go b/management/server/http/handlers/setup_keys/setupkeys_handler_test.go\nindex 7b46b486b64..b137b6dd1e5 100644\n--- a/management/server/http/handlers/setup_keys/setupkeys_handler_test.go\n+++ b/management/server/http/handlers/setup_keys/setupkeys_handler_test.go\n@@ -15,10 +15,11 @@ import (\n \t\"github.com/stretchr/testify/assert\"\n \n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n-\t\"github.com/netbirdio/netbird/shared/management/status\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n+\t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n \n const (\n@@ -163,7 +164,7 @@ func TestSetupKeysHandlers(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    adminUser.Id,\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"testAccountId\",\ndiff --git a/management/server/http/handlers/users/pat_handler_test.go b/management/server/http/handlers/users/pat_handler_test.go\nindex 92544c56da0..7cda144686c 100644\n--- a/management/server/http/handlers/users/pat_handler_test.go\n+++ b/management/server/http/handlers/users/pat_handler_test.go\n@@ -17,10 +17,11 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/util\"\n \n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n-\t\"github.com/netbirdio/netbird/shared/management/status\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n+\t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n \n const (\n@@ -173,7 +174,7 @@ func TestTokenHandlers(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    existingUserID,\n \t\t\t\tDomain:    testDomain,\n \t\t\t\tAccountId: existingAccountID,\ndiff --git a/management/server/http/handlers/users/users_handler_test.go b/management/server/http/handlers/users/users_handler_test.go\nindex e080042187e..37f0a6c1dc8 100644\n--- a/management/server/http/handlers/users/users_handler_test.go\n+++ b/management/server/http/handlers/users/users_handler_test.go\n@@ -21,6 +21,7 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/permissions/roles\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n \t\"github.com/netbirdio/netbird/management/server/users\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n \t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n@@ -128,7 +129,7 @@ func initUsersTestData() *handler {\n \n \t\t\t\treturn nil\n \t\t\t},\n-\t\t\tGetCurrentUserInfoFunc: func(ctx context.Context, userAuth nbcontext.UserAuth) (*users.UserInfoWithPermissions, error) {\n+\t\t\tGetCurrentUserInfoFunc: func(ctx context.Context, userAuth auth.UserAuth) (*users.UserInfoWithPermissions, error) {\n \t\t\t\tswitch userAuth.UserId {\n \t\t\t\tcase \"not-found\":\n \t\t\t\t\treturn nil, status.NewUserNotFoundError(\"not-found\")\n@@ -225,7 +226,7 @@ func TestGetUsers(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, nil)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    existingUserID,\n \t\t\t\tDomain:    testDomain,\n \t\t\t\tAccountId: existingAccountID,\n@@ -335,7 +336,7 @@ func TestUpdateUser(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    existingUserID,\n \t\t\t\tDomain:    testDomain,\n \t\t\t\tAccountId: existingAccountID,\n@@ -432,7 +433,7 @@ func TestCreateUser(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n \t\t\trr := httptest.NewRecorder()\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    existingUserID,\n \t\t\t\tDomain:    testDomain,\n \t\t\t\tAccountId: existingAccountID,\n@@ -481,7 +482,7 @@ func TestInviteUser(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, nil)\n \t\t\treq = mux.SetURLVars(req, tc.requestVars)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    existingUserID,\n \t\t\t\tDomain:    testDomain,\n \t\t\t\tAccountId: existingAccountID,\n@@ -540,7 +541,7 @@ func TestDeleteUser(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, nil)\n \t\t\treq = mux.SetURLVars(req, tc.requestVars)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    existingUserID,\n \t\t\t\tDomain:    testDomain,\n \t\t\t\tAccountId: existingAccountID,\n@@ -565,7 +566,7 @@ func TestCurrentUser(t *testing.T) {\n \ttt := []struct {\n \t\tname           string\n \t\texpectedStatus int\n-\t\trequestAuth    nbcontext.UserAuth\n+\t\trequestAuth    auth.UserAuth\n \t\texpectedResult *api.User\n \t}{\n \t\t{\n@@ -574,27 +575,27 @@ func TestCurrentUser(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname:           \"user not found\",\n-\t\t\trequestAuth:    nbcontext.UserAuth{UserId: \"not-found\"},\n+\t\t\trequestAuth:    auth.UserAuth{UserId: \"not-found\"},\n \t\t\texpectedStatus: http.StatusNotFound,\n \t\t},\n \t\t{\n \t\t\tname:           \"not of account\",\n-\t\t\trequestAuth:    nbcontext.UserAuth{UserId: \"not-of-account\"},\n+\t\t\trequestAuth:    auth.UserAuth{UserId: \"not-of-account\"},\n \t\t\texpectedStatus: http.StatusForbidden,\n \t\t},\n \t\t{\n \t\t\tname:           \"blocked user\",\n-\t\t\trequestAuth:    nbcontext.UserAuth{UserId: \"blocked-user\"},\n+\t\t\trequestAuth:    auth.UserAuth{UserId: \"blocked-user\"},\n \t\t\texpectedStatus: http.StatusForbidden,\n \t\t},\n \t\t{\n \t\t\tname:           \"service user\",\n-\t\t\trequestAuth:    nbcontext.UserAuth{UserId: \"service-user\"},\n+\t\t\trequestAuth:    auth.UserAuth{UserId: \"service-user\"},\n \t\t\texpectedStatus: http.StatusForbidden,\n \t\t},\n \t\t{\n \t\t\tname:           \"owner\",\n-\t\t\trequestAuth:    nbcontext.UserAuth{UserId: \"owner\"},\n+\t\t\trequestAuth:    auth.UserAuth{UserId: \"owner\"},\n \t\t\texpectedStatus: http.StatusOK,\n \t\t\texpectedResult: &api.User{\n \t\t\t\tId:            \"owner\",\n@@ -613,7 +614,7 @@ func TestCurrentUser(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname:           \"regular user\",\n-\t\t\trequestAuth:    nbcontext.UserAuth{UserId: \"regular-user\"},\n+\t\t\trequestAuth:    auth.UserAuth{UserId: \"regular-user\"},\n \t\t\texpectedStatus: http.StatusOK,\n \t\t\texpectedResult: &api.User{\n \t\t\t\tId:            \"regular-user\",\n@@ -632,7 +633,7 @@ func TestCurrentUser(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname:           \"admin user\",\n-\t\t\trequestAuth:    nbcontext.UserAuth{UserId: \"admin-user\"},\n+\t\t\trequestAuth:    auth.UserAuth{UserId: \"admin-user\"},\n \t\t\texpectedStatus: http.StatusOK,\n \t\t\texpectedResult: &api.User{\n \t\t\t\tId:            \"admin-user\",\n@@ -651,7 +652,7 @@ func TestCurrentUser(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname:           \"restricted user\",\n-\t\t\trequestAuth:    nbcontext.UserAuth{UserId: \"restricted-user\"},\n+\t\t\trequestAuth:    auth.UserAuth{UserId: \"restricted-user\"},\n \t\t\texpectedStatus: http.StatusOK,\n \t\t\texpectedResult: &api.User{\n \t\t\t\tId:            \"restricted-user\",\n@@ -783,7 +784,7 @@ func TestApproveUserEndpoint(t *testing.T) {\n \t\t\treq, err := http.NewRequest(\"POST\", \"/users/pending-user/approve\", nil)\n \t\t\trequire.NoError(t, err)\n \n-\t\t\tuserAuth := nbcontext.UserAuth{\n+\t\t\tuserAuth := auth.UserAuth{\n \t\t\t\tAccountId: existingAccountID,\n \t\t\t\tUserId:    tc.requestingUser.Id,\n \t\t\t}\n@@ -841,7 +842,7 @@ func TestRejectUserEndpoint(t *testing.T) {\n \t\t\treq, err := http.NewRequest(\"DELETE\", \"/users/pending-user/reject\", nil)\n \t\t\trequire.NoError(t, err)\n \n-\t\t\tuserAuth := nbcontext.UserAuth{\n+\t\t\tuserAuth := auth.UserAuth{\n \t\t\t\tAccountId: existingAccountID,\n \t\t\t\tUserId:    tc.requestingUser.Id,\n \t\t\t}\ndiff --git a/management/server/http/middleware/auth_middleware_test.go b/management/server/http/middleware/auth_middleware_test.go\nindex d1bd9959f88..7badc03e493 100644\n--- a/management/server/http/middleware/auth_middleware_test.go\n+++ b/management/server/http/middleware/auth_middleware_test.go\n@@ -12,11 +12,12 @@ import (\n \t\"github.com/stretchr/testify/assert\"\n \n \t\"github.com/netbirdio/netbird/management/server/auth\"\n-\tnbjwt \"github.com/netbirdio/netbird/management/server/auth/jwt\"\n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/http/middleware/bypass\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n \t\"github.com/netbirdio/netbird/management/server/util\"\n+\tnbauth \"github.com/netbirdio/netbird/shared/auth\"\n+\tnbjwt \"github.com/netbirdio/netbird/shared/auth/jwt\"\n )\n \n const (\n@@ -75,9 +76,9 @@ func mockGetAccountInfoFromPAT(_ context.Context, token string) (user *types.Use\n \treturn nil, nil, \"\", \"\", fmt.Errorf(\"PAT invalid\")\n }\n \n-func mockValidateAndParseToken(_ context.Context, token string) (nbcontext.UserAuth, *jwt.Token, error) {\n+func mockValidateAndParseToken(_ context.Context, token string) (nbauth.UserAuth, *jwt.Token, error) {\n \tif token == JWT {\n-\t\treturn nbcontext.UserAuth{\n+\t\treturn nbauth.UserAuth{\n \t\t\t\tUserId:         userID,\n \t\t\t\tAccountId:      accountID,\n \t\t\t\tDomain:         testAccount.Domain,\n@@ -91,7 +92,7 @@ func mockValidateAndParseToken(_ context.Context, token string) (nbcontext.UserA\n \t\t\t\tValid: true,\n \t\t\t}, nil\n \t}\n-\treturn nbcontext.UserAuth{}, nil, fmt.Errorf(\"JWT invalid\")\n+\treturn nbauth.UserAuth{}, nil, fmt.Errorf(\"JWT invalid\")\n }\n \n func mockMarkPATUsed(_ context.Context, token string) error {\n@@ -101,7 +102,7 @@ func mockMarkPATUsed(_ context.Context, token string) error {\n \treturn fmt.Errorf(\"Should never get reached\")\n }\n \n-func mockEnsureUserAccessByJWTGroups(_ context.Context, userAuth nbcontext.UserAuth, token *jwt.Token) (nbcontext.UserAuth, error) {\n+func mockEnsureUserAccessByJWTGroups(_ context.Context, userAuth nbauth.UserAuth, token *jwt.Token) (nbauth.UserAuth, error) {\n \tif userAuth.IsChild || userAuth.IsPAT {\n \t\treturn userAuth, nil\n \t}\n@@ -197,13 +198,13 @@ func TestAuthMiddleware_Handler(t *testing.T) {\n \n \tauthMiddleware := NewAuthMiddleware(\n \t\tmockAuth,\n-\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (string, string, error) {\n+\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (string, string, error) {\n \t\t\treturn userAuth.AccountId, userAuth.UserId, nil\n \t\t},\n-\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) error {\n+\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) error {\n \t\t\treturn nil\n \t\t},\n-\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (*types.User, error) {\n+\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (*types.User, error) {\n \t\t\treturn &types.User{}, nil\n \t\t},\n \t\tnil,\n@@ -255,13 +256,13 @@ func TestAuthMiddleware_RateLimiting(t *testing.T) {\n \n \t\tauthMiddleware := NewAuthMiddleware(\n \t\t\tmockAuth,\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (string, string, error) {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (string, string, error) {\n \t\t\t\treturn userAuth.AccountId, userAuth.UserId, nil\n \t\t\t},\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) error {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) error {\n \t\t\t\treturn nil\n \t\t\t},\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (*types.User, error) {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (*types.User, error) {\n \t\t\t\treturn &types.User{}, nil\n \t\t\t},\n \t\t\trateLimitConfig,\n@@ -306,13 +307,13 @@ func TestAuthMiddleware_RateLimiting(t *testing.T) {\n \n \t\tauthMiddleware := NewAuthMiddleware(\n \t\t\tmockAuth,\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (string, string, error) {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (string, string, error) {\n \t\t\t\treturn userAuth.AccountId, userAuth.UserId, nil\n \t\t\t},\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) error {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) error {\n \t\t\t\treturn nil\n \t\t\t},\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (*types.User, error) {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (*types.User, error) {\n \t\t\t\treturn &types.User{}, nil\n \t\t\t},\n \t\t\trateLimitConfig,\n@@ -348,13 +349,13 @@ func TestAuthMiddleware_RateLimiting(t *testing.T) {\n \n \t\tauthMiddleware := NewAuthMiddleware(\n \t\t\tmockAuth,\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (string, string, error) {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (string, string, error) {\n \t\t\t\treturn userAuth.AccountId, userAuth.UserId, nil\n \t\t\t},\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) error {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) error {\n \t\t\t\treturn nil\n \t\t\t},\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (*types.User, error) {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (*types.User, error) {\n \t\t\t\treturn &types.User{}, nil\n \t\t\t},\n \t\t\trateLimitConfig,\n@@ -391,13 +392,13 @@ func TestAuthMiddleware_RateLimiting(t *testing.T) {\n \n \t\tauthMiddleware := NewAuthMiddleware(\n \t\t\tmockAuth,\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (string, string, error) {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (string, string, error) {\n \t\t\t\treturn userAuth.AccountId, userAuth.UserId, nil\n \t\t\t},\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) error {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) error {\n \t\t\t\treturn nil\n \t\t\t},\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (*types.User, error) {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (*types.User, error) {\n \t\t\t\treturn &types.User{}, nil\n \t\t\t},\n \t\t\trateLimitConfig,\n@@ -454,13 +455,13 @@ func TestAuthMiddleware_RateLimiting(t *testing.T) {\n \n \t\tauthMiddleware := NewAuthMiddleware(\n \t\t\tmockAuth,\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (string, string, error) {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (string, string, error) {\n \t\t\t\treturn userAuth.AccountId, userAuth.UserId, nil\n \t\t\t},\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) error {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) error {\n \t\t\t\treturn nil\n \t\t\t},\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (*types.User, error) {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (*types.User, error) {\n \t\t\t\treturn &types.User{}, nil\n \t\t\t},\n \t\t\trateLimitConfig,\n@@ -508,13 +509,13 @@ func TestAuthMiddleware_Handler_Child(t *testing.T) {\n \t\tname             string\n \t\tpath             string\n \t\tauthHeader       string\n-\t\texpectedUserAuth *nbcontext.UserAuth // nil expects 401 response status\n+\t\texpectedUserAuth *nbauth.UserAuth // nil expects 401 response status\n \t}{\n \t\t{\n \t\t\tname:       \"Valid PAT Token\",\n \t\t\tpath:       \"/test\",\n \t\t\tauthHeader: \"Token \" + PAT,\n-\t\t\texpectedUserAuth: &nbcontext.UserAuth{\n+\t\t\texpectedUserAuth: &nbauth.UserAuth{\n \t\t\t\tAccountId:      accountID,\n \t\t\t\tUserId:         userID,\n \t\t\t\tDomain:         testAccount.Domain,\n@@ -526,7 +527,7 @@ func TestAuthMiddleware_Handler_Child(t *testing.T) {\n \t\t\tname:       \"Valid PAT Token accesses child\",\n \t\t\tpath:       \"/test?account=xyz\",\n \t\t\tauthHeader: \"Token \" + PAT,\n-\t\t\texpectedUserAuth: &nbcontext.UserAuth{\n+\t\t\texpectedUserAuth: &nbauth.UserAuth{\n \t\t\t\tAccountId:      \"xyz\",\n \t\t\t\tUserId:         userID,\n \t\t\t\tDomain:         testAccount.Domain,\n@@ -539,7 +540,7 @@ func TestAuthMiddleware_Handler_Child(t *testing.T) {\n \t\t\tname:       \"Valid JWT Token\",\n \t\t\tpath:       \"/test\",\n \t\t\tauthHeader: \"Bearer \" + JWT,\n-\t\t\texpectedUserAuth: &nbcontext.UserAuth{\n+\t\t\texpectedUserAuth: &nbauth.UserAuth{\n \t\t\t\tAccountId:      accountID,\n \t\t\t\tUserId:         userID,\n \t\t\t\tDomain:         testAccount.Domain,\n@@ -551,7 +552,7 @@ func TestAuthMiddleware_Handler_Child(t *testing.T) {\n \t\t\tname:       \"Valid JWT Token with child\",\n \t\t\tpath:       \"/test?account=xyz\",\n \t\t\tauthHeader: \"Bearer \" + JWT,\n-\t\t\texpectedUserAuth: &nbcontext.UserAuth{\n+\t\t\texpectedUserAuth: &nbauth.UserAuth{\n \t\t\t\tAccountId:      \"xyz\",\n \t\t\t\tUserId:         userID,\n \t\t\t\tDomain:         testAccount.Domain,\n@@ -570,13 +571,13 @@ func TestAuthMiddleware_Handler_Child(t *testing.T) {\n \n \tauthMiddleware := NewAuthMiddleware(\n \t\tmockAuth,\n-\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (string, string, error) {\n+\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (string, string, error) {\n \t\t\treturn userAuth.AccountId, userAuth.UserId, nil\n \t\t},\n-\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) error {\n+\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) error {\n \t\t\treturn nil\n \t\t},\n-\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (*types.User, error) {\n+\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (*types.User, error) {\n \t\t\treturn &types.User{}, nil\n \t\t},\n \t\tnil,\ndiff --git a/management/server/http/testing/testing_tools/channel/channel.go b/management/server/http/testing/testing_tools/channel/channel.go\nindex ab3f5437a4a..ac165aeb207 100644\n--- a/management/server/http/testing/testing_tools/channel/channel.go\n+++ b/management/server/http/testing/testing_tools/channel/channel.go\n@@ -10,6 +10,7 @@ import (\n \t\"github.com/stretchr/testify/assert\"\n \n \t\"github.com/netbirdio/management-integrations/integrations\"\n+\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map\"\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map/controller\"\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map/update_channel\"\n@@ -18,8 +19,7 @@ import (\n \t\"github.com/netbirdio/netbird/management/server\"\n \t\"github.com/netbirdio/netbird/management/server/account\"\n \t\"github.com/netbirdio/netbird/management/server/activity\"\n-\t\"github.com/netbirdio/netbird/management/server/auth\"\n-\tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n+\tserverauth \"github.com/netbirdio/netbird/management/server/auth\"\n \t\"github.com/netbirdio/netbird/management/server/geolocation\"\n \t\"github.com/netbirdio/netbird/management/server/groups\"\n \thttp2 \"github.com/netbirdio/netbird/management/server/http\"\n@@ -33,6 +33,7 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/store\"\n \t\"github.com/netbirdio/netbird/management/server/telemetry\"\n \t\"github.com/netbirdio/netbird/management/server/users\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n )\n \n func BuildApiBlackBoxWithDBState(t testing_tools.TB, sqlFile string, expectedPeerUpdate *network_map.UpdateMessage, validateUpdate bool) (http.Handler, account.Manager, chan struct{}) {\n@@ -71,14 +72,14 @@ func BuildApiBlackBoxWithDBState(t testing_tools.TB, sqlFile string, expectedPee\n \tctx := context.Background()\n \trequestBuffer := server.NewAccountRequestBuffer(ctx, store)\n \tnetworkMapController := controller.NewController(ctx, store, metrics, peersUpdateManager, requestBuffer, server.MockIntegratedValidator{}, settingsManager, \"\", port_forwarding.NewControllerMock())\n-\tam, err := server.BuildManager(ctx, store, networkMapController, nil, \"\", &activity.InMemoryEventStore{}, geoMock, false, validatorMock, metrics, proxyController, settingsManager, permissionsManager, false)\n+\tam, err := server.BuildManager(ctx, nil, store, networkMapController, nil, \"\", &activity.InMemoryEventStore{}, geoMock, false, validatorMock, metrics, proxyController, settingsManager, permissionsManager, false)\n \tif err != nil {\n \t\tt.Fatalf(\"Failed to create manager: %v\", err)\n \t}\n \n \t// @note this is required so that PAT's validate from store, but JWT's are mocked\n-\tauthManager := auth.NewManager(store, \"\", \"\", \"\", \"\", []string{}, false)\n-\tauthManagerMock := &auth.MockManager{\n+\tauthManager := serverauth.NewManager(store, \"\", \"\", \"\", \"\", []string{}, false)\n+\tauthManagerMock := &serverauth.MockManager{\n \t\tValidateAndParseTokenFunc:       mockValidateAndParseToken,\n \t\tEnsureUserAccessByJWTGroupsFunc: authManager.EnsureUserAccessByJWTGroups,\n \t\tMarkPATUsedFunc:                 authManager.MarkPATUsed,\n@@ -123,8 +124,8 @@ func peerShouldReceiveUpdate(t testing_tools.TB, updateMessage <-chan *network_m\n \t}\n }\n \n-func mockValidateAndParseToken(_ context.Context, token string) (nbcontext.UserAuth, *jwt.Token, error) {\n-\tuserAuth := nbcontext.UserAuth{}\n+func mockValidateAndParseToken(_ context.Context, token string) (auth.UserAuth, *jwt.Token, error) {\n+\tuserAuth := auth.UserAuth{}\n \n \tswitch token {\n \tcase \"testUserId\", \"testAdminId\", \"testOwnerId\", \"testServiceUserId\", \"testServiceAdminId\", \"blockedUserId\":\ndiff --git a/management/server/idp/pocketid_test.go b/management/server/idp/pocketid_test.go\nindex 49075a0d345..126a7691900 100644\n--- a/management/server/idp/pocketid_test.go\n+++ b/management/server/idp/pocketid_test.go\n@@ -1,138 +1,137 @@\n package idp\n \n import (\n-    \"context\"\n-    \"testing\"\n+\t\"context\"\n+\t\"testing\"\n \n-    \"github.com/stretchr/testify/assert\"\n-    \"github.com/stretchr/testify/require\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n \n-    \"github.com/netbirdio/netbird/management/server/telemetry\"\n+\t\"github.com/netbirdio/netbird/management/server/telemetry\"\n )\n \n-\n func TestNewPocketIdManager(t *testing.T) {\n-    type test struct {\n-        name                 string\n-        inputConfig          PocketIdClientConfig\n-        assertErrFunc        require.ErrorAssertionFunc\n-        assertErrFuncMessage string\n-    }\n-\n-    defaultTestConfig := PocketIdClientConfig{\n-        APIToken:           \"api_token\",\n-        ManagementEndpoint: \"http://localhost\",\n-    }\n-\n-    tests := []test{\n-        {\n-            name:                 \"Good Configuration\",\n-            inputConfig:          defaultTestConfig,\n-            assertErrFunc:        require.NoError,\n-            assertErrFuncMessage: \"shouldn't return error\",\n-        },\n-        {\n-            name: \"Missing ManagementEndpoint\",\n-            inputConfig: PocketIdClientConfig{\n-                APIToken:           defaultTestConfig.APIToken,\n-                ManagementEndpoint: \"\",\n-            },\n-            assertErrFunc:        require.Error,\n-            assertErrFuncMessage: \"should return error when field empty\",\n-        },\n-        {\n-            name: \"Missing APIToken\",\n-            inputConfig: PocketIdClientConfig{\n-                APIToken:           \"\",\n-                ManagementEndpoint: defaultTestConfig.ManagementEndpoint,\n-            },\n-            assertErrFunc:        require.Error,\n-            assertErrFuncMessage: \"should return error when field empty\",\n-        },\n-    }\n-\n-    for _, tc := range tests {\n-        t.Run(tc.name, func(t *testing.T) {\n-            _, err := NewPocketIdManager(tc.inputConfig, &telemetry.MockAppMetrics{})\n-            tc.assertErrFunc(t, err, tc.assertErrFuncMessage)\n-        })\n-    }\n+\ttype test struct {\n+\t\tname                 string\n+\t\tinputConfig          PocketIdClientConfig\n+\t\tassertErrFunc        require.ErrorAssertionFunc\n+\t\tassertErrFuncMessage string\n+\t}\n+\n+\tdefaultTestConfig := PocketIdClientConfig{\n+\t\tAPIToken:           \"api_token\",\n+\t\tManagementEndpoint: \"http://localhost\",\n+\t}\n+\n+\ttests := []test{\n+\t\t{\n+\t\t\tname:                 \"Good Configuration\",\n+\t\t\tinputConfig:          defaultTestConfig,\n+\t\t\tassertErrFunc:        require.NoError,\n+\t\t\tassertErrFuncMessage: \"shouldn't return error\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Missing ManagementEndpoint\",\n+\t\t\tinputConfig: PocketIdClientConfig{\n+\t\t\t\tAPIToken:           defaultTestConfig.APIToken,\n+\t\t\t\tManagementEndpoint: \"\",\n+\t\t\t},\n+\t\t\tassertErrFunc:        require.Error,\n+\t\t\tassertErrFuncMessage: \"should return error when field empty\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Missing APIToken\",\n+\t\t\tinputConfig: PocketIdClientConfig{\n+\t\t\t\tAPIToken:           \"\",\n+\t\t\t\tManagementEndpoint: defaultTestConfig.ManagementEndpoint,\n+\t\t\t},\n+\t\t\tassertErrFunc:        require.Error,\n+\t\t\tassertErrFuncMessage: \"should return error when field empty\",\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range tests {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\t_, err := NewPocketIdManager(tc.inputConfig, &telemetry.MockAppMetrics{})\n+\t\t\ttc.assertErrFunc(t, err, tc.assertErrFuncMessage)\n+\t\t})\n+\t}\n }\n \n func TestPocketID_GetUserDataByID(t *testing.T) {\n-    client := &mockHTTPClient{code: 200, resBody: `{\"id\":\"u1\",\"email\":\"user1@example.com\",\"displayName\":\"User One\"}`}\n-\n-    mgr, err := NewPocketIdManager(PocketIdClientConfig{APIToken: \"tok\", ManagementEndpoint: \"http://localhost\"}, nil)\n-    require.NoError(t, err)\n-    mgr.httpClient = client\n-\n-    md := AppMetadata{WTAccountID: \"acc1\"}\n-    got, err := mgr.GetUserDataByID(context.Background(), \"u1\", md)\n-    require.NoError(t, err)\n-    assert.Equal(t, \"u1\", got.ID)\n-    assert.Equal(t, \"user1@example.com\", got.Email)\n-    assert.Equal(t, \"User One\", got.Name)\n-    assert.Equal(t, \"acc1\", got.AppMetadata.WTAccountID)\n+\tclient := &mockHTTPClient{code: 200, resBody: `{\"id\":\"u1\",\"email\":\"user1@example.com\",\"displayName\":\"User One\"}`}\n+\n+\tmgr, err := NewPocketIdManager(PocketIdClientConfig{APIToken: \"tok\", ManagementEndpoint: \"http://localhost\"}, nil)\n+\trequire.NoError(t, err)\n+\tmgr.httpClient = client\n+\n+\tmd := AppMetadata{WTAccountID: \"acc1\"}\n+\tgot, err := mgr.GetUserDataByID(context.Background(), \"u1\", md)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, \"u1\", got.ID)\n+\tassert.Equal(t, \"user1@example.com\", got.Email)\n+\tassert.Equal(t, \"User One\", got.Name)\n+\tassert.Equal(t, \"acc1\", got.AppMetadata.WTAccountID)\n }\n \n func TestPocketID_GetAccount_WithPagination(t *testing.T) {\n-    // Single page response with two users\n-    client := &mockHTTPClient{code: 200, resBody: `{\"data\":[{\"id\":\"u1\",\"email\":\"e1\",\"displayName\":\"n1\"},{\"id\":\"u2\",\"email\":\"e2\",\"displayName\":\"n2\"}],\"pagination\":{\"currentPage\":1,\"itemsPerPage\":100,\"totalItems\":2,\"totalPages\":1}}`}\n-\n-    mgr, err := NewPocketIdManager(PocketIdClientConfig{APIToken: \"tok\", ManagementEndpoint: \"http://localhost\"}, nil)\n-    require.NoError(t, err)\n-    mgr.httpClient = client\n-\n-    users, err := mgr.GetAccount(context.Background(), \"accX\")\n-    require.NoError(t, err)\n-    require.Len(t, users, 2)\n-    assert.Equal(t, \"u1\", users[0].ID)\n-    assert.Equal(t, \"accX\", users[0].AppMetadata.WTAccountID)\n-    assert.Equal(t, \"u2\", users[1].ID)\n+\t// Single page response with two users\n+\tclient := &mockHTTPClient{code: 200, resBody: `{\"data\":[{\"id\":\"u1\",\"email\":\"e1\",\"displayName\":\"n1\"},{\"id\":\"u2\",\"email\":\"e2\",\"displayName\":\"n2\"}],\"pagination\":{\"currentPage\":1,\"itemsPerPage\":100,\"totalItems\":2,\"totalPages\":1}}`}\n+\n+\tmgr, err := NewPocketIdManager(PocketIdClientConfig{APIToken: \"tok\", ManagementEndpoint: \"http://localhost\"}, nil)\n+\trequire.NoError(t, err)\n+\tmgr.httpClient = client\n+\n+\tusers, err := mgr.GetAccount(context.Background(), \"accX\")\n+\trequire.NoError(t, err)\n+\trequire.Len(t, users, 2)\n+\tassert.Equal(t, \"u1\", users[0].ID)\n+\tassert.Equal(t, \"accX\", users[0].AppMetadata.WTAccountID)\n+\tassert.Equal(t, \"u2\", users[1].ID)\n }\n \n func TestPocketID_GetAllAccounts_WithPagination(t *testing.T) {\n-    client := &mockHTTPClient{code: 200, resBody: `{\"data\":[{\"id\":\"u1\",\"email\":\"e1\",\"displayName\":\"n1\"},{\"id\":\"u2\",\"email\":\"e2\",\"displayName\":\"n2\"}],\"pagination\":{\"currentPage\":1,\"itemsPerPage\":100,\"totalItems\":2,\"totalPages\":1}}`}\n+\tclient := &mockHTTPClient{code: 200, resBody: `{\"data\":[{\"id\":\"u1\",\"email\":\"e1\",\"displayName\":\"n1\"},{\"id\":\"u2\",\"email\":\"e2\",\"displayName\":\"n2\"}],\"pagination\":{\"currentPage\":1,\"itemsPerPage\":100,\"totalItems\":2,\"totalPages\":1}}`}\n \n-    mgr, err := NewPocketIdManager(PocketIdClientConfig{APIToken: \"tok\", ManagementEndpoint: \"http://localhost\"}, nil)\n-    require.NoError(t, err)\n-    mgr.httpClient = client\n+\tmgr, err := NewPocketIdManager(PocketIdClientConfig{APIToken: \"tok\", ManagementEndpoint: \"http://localhost\"}, nil)\n+\trequire.NoError(t, err)\n+\tmgr.httpClient = client\n \n-    accounts, err := mgr.GetAllAccounts(context.Background())\n-    require.NoError(t, err)\n-    require.Len(t, accounts[UnsetAccountID], 2)\n+\taccounts, err := mgr.GetAllAccounts(context.Background())\n+\trequire.NoError(t, err)\n+\trequire.Len(t, accounts[UnsetAccountID], 2)\n }\n \n func TestPocketID_CreateUser(t *testing.T) {\n-    client := &mockHTTPClient{code: 201, resBody: `{\"id\":\"newid\",\"email\":\"new@example.com\",\"displayName\":\"New User\"}`}\n-\n-    mgr, err := NewPocketIdManager(PocketIdClientConfig{APIToken: \"tok\", ManagementEndpoint: \"http://localhost\"}, nil)\n-    require.NoError(t, err)\n-    mgr.httpClient = client\n-\n-    ud, err := mgr.CreateUser(context.Background(), \"new@example.com\", \"New User\", \"acc1\", \"inviter@example.com\")\n-    require.NoError(t, err)\n-    assert.Equal(t, \"newid\", ud.ID)\n-    assert.Equal(t, \"new@example.com\", ud.Email)\n-    assert.Equal(t, \"New User\", ud.Name)\n-    assert.Equal(t, \"acc1\", ud.AppMetadata.WTAccountID)\n-    if assert.NotNil(t, ud.AppMetadata.WTPendingInvite) {\n-        assert.True(t, *ud.AppMetadata.WTPendingInvite)\n-    }\n-    assert.Equal(t, \"inviter@example.com\", ud.AppMetadata.WTInvitedBy)\n+\tclient := &mockHTTPClient{code: 201, resBody: `{\"id\":\"newid\",\"email\":\"new@example.com\",\"displayName\":\"New User\"}`}\n+\n+\tmgr, err := NewPocketIdManager(PocketIdClientConfig{APIToken: \"tok\", ManagementEndpoint: \"http://localhost\"}, nil)\n+\trequire.NoError(t, err)\n+\tmgr.httpClient = client\n+\n+\tud, err := mgr.CreateUser(context.Background(), \"new@example.com\", \"New User\", \"acc1\", \"inviter@example.com\")\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, \"newid\", ud.ID)\n+\tassert.Equal(t, \"new@example.com\", ud.Email)\n+\tassert.Equal(t, \"New User\", ud.Name)\n+\tassert.Equal(t, \"acc1\", ud.AppMetadata.WTAccountID)\n+\tif assert.NotNil(t, ud.AppMetadata.WTPendingInvite) {\n+\t\tassert.True(t, *ud.AppMetadata.WTPendingInvite)\n+\t}\n+\tassert.Equal(t, \"inviter@example.com\", ud.AppMetadata.WTInvitedBy)\n }\n \n func TestPocketID_InviteAndDeleteUser(t *testing.T) {\n-    // Same mock for both calls; returns OK with empty JSON\n-    client := &mockHTTPClient{code: 200, resBody: `{}`}\n+\t// Same mock for both calls; returns OK with empty JSON\n+\tclient := &mockHTTPClient{code: 200, resBody: `{}`}\n \n-    mgr, err := NewPocketIdManager(PocketIdClientConfig{APIToken: \"tok\", ManagementEndpoint: \"http://localhost\"}, nil)\n-    require.NoError(t, err)\n-    mgr.httpClient = client\n+\tmgr, err := NewPocketIdManager(PocketIdClientConfig{APIToken: \"tok\", ManagementEndpoint: \"http://localhost\"}, nil)\n+\trequire.NoError(t, err)\n+\tmgr.httpClient = client\n \n-    err = mgr.InviteUserByID(context.Background(), \"u1\")\n-    require.NoError(t, err)\n+\terr = mgr.InviteUserByID(context.Background(), \"u1\")\n+\trequire.NoError(t, err)\n \n-    err = mgr.DeleteUser(context.Background(), \"u1\")\n-    require.NoError(t, err)\n+\terr = mgr.DeleteUser(context.Background(), \"u1\")\n+\trequire.NoError(t, err)\n }\ndiff --git a/management/server/management_proto_test.go b/management/server/management_proto_test.go\nindex fc67e01afeb..496be9caa32 100644\n--- a/management/server/management_proto_test.go\n+++ b/management/server/management_proto_test.go\n@@ -364,7 +364,7 @@ func startManagementForTest(t *testing.T, testFile string, config *config.Config\n \tupdateManager := update_channel.NewPeersUpdateManager(metrics)\n \trequestBuffer := NewAccountRequestBuffer(ctx, store)\n \tnetworkMapController := controller.NewController(ctx, store, metrics, updateManager, requestBuffer, MockIntegratedValidator{}, settingsMockManager, \"netbird.selfhosted\", port_forwarding.NewControllerMock())\n-\taccountManager, err := BuildManager(ctx, store, networkMapController, nil, \"\",\n+\taccountManager, err := BuildManager(ctx, nil, store, networkMapController, nil, \"\",\n \t\teventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n \n \tif err != nil {\ndiff --git a/management/server/management_test.go b/management/server/management_test.go\nindex 930ecfb5a74..c485f16b4a1 100644\n--- a/management/server/management_test.go\n+++ b/management/server/management_test.go\n@@ -209,6 +209,7 @@ func startServer(\n \n \taccountManager, err := server.BuildManager(\n \t\tcontext.Background(),\n+\t\tnil,\n \t\tstr,\n \t\tnetworkMapController,\n \t\tnil,\ndiff --git a/management/server/nameserver_test.go b/management/server/nameserver_test.go\nindex 35291b30c75..51738c10626 100644\n--- a/management/server/nameserver_test.go\n+++ b/management/server/nameserver_test.go\n@@ -793,7 +793,7 @@ func createNSManager(t *testing.T) (*DefaultAccountManager, error) {\n \trequestBuffer := NewAccountRequestBuffer(ctx, store)\n \tnetworkMapController := controller.NewController(ctx, store, metrics, updateManager, requestBuffer, MockIntegratedValidator{}, settingsMockManager, \"netbird.selfhosted\", port_forwarding.NewControllerMock())\n \n-\treturn BuildManager(context.Background(), store, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n+\treturn BuildManager(context.Background(), nil, store, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n }\n \n func createNSStore(t *testing.T) (store.Store, error) {\ndiff --git a/management/server/networks/resources/manager_test.go b/management/server/networks/resources/manager_test.go\nindex c6cec6f7e75..e2dea2c6bde 100644\n--- a/management/server/networks/resources/manager_test.go\n+++ b/management/server/networks/resources/manager_test.go\n@@ -10,8 +10,8 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n \t\"github.com/netbirdio/netbird/management/server/networks/resources/types\"\n \t\"github.com/netbirdio/netbird/management/server/permissions\"\n-\t\"github.com/netbirdio/netbird/shared/management/status\"\n \t\"github.com/netbirdio/netbird/management/server/store\"\n+\t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n \n func Test_GetAllResourcesInNetworkReturnsResources(t *testing.T) {\ndiff --git a/management/server/networks/routers/manager_test.go b/management/server/networks/routers/manager_test.go\nindex 8054d05c6ca..6be90baa7a9 100644\n--- a/management/server/networks/routers/manager_test.go\n+++ b/management/server/networks/routers/manager_test.go\n@@ -9,8 +9,8 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n \t\"github.com/netbirdio/netbird/management/server/networks/routers/types\"\n \t\"github.com/netbirdio/netbird/management/server/permissions\"\n-\t\"github.com/netbirdio/netbird/shared/management/status\"\n \t\"github.com/netbirdio/netbird/management/server/store\"\n+\t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n \n func Test_GetAllRoutersInNetworkReturnsRouters(t *testing.T) {\ndiff --git a/management/server/peer_test.go b/management/server/peer_test.go\nindex 95c609595c3..21a6952a9b3 100644\n--- a/management/server/peer_test.go\n+++ b/management/server/peer_test.go\n@@ -1292,7 +1292,7 @@ func Test_RegisterPeerByUser(t *testing.T) {\n \trequestBuffer := NewAccountRequestBuffer(ctx, s)\n \tnetworkMapController := controller.NewController(ctx, s, metrics, updateManager, requestBuffer, MockIntegratedValidator{}, settingsMockManager, \"netbird.cloud\", port_forwarding.NewControllerMock())\n \n-\tam, err := BuildManager(context.Background(), s, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n+\tam, err := BuildManager(context.Background(), nil, s, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n \tassert.NoError(t, err)\n \n \texistingAccountID := \"bf1c8084-ba50-4ce7-9439-34653001fc3b\"\n@@ -1377,7 +1377,7 @@ func Test_RegisterPeerBySetupKey(t *testing.T) {\n \trequestBuffer := NewAccountRequestBuffer(ctx, s)\n \tnetworkMapController := controller.NewController(ctx, s, metrics, updateManager, requestBuffer, MockIntegratedValidator{}, settingsMockManager, \"netbird.cloud\", port_forwarding.NewControllerMock())\n \n-\tam, err := BuildManager(context.Background(), s, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n+\tam, err := BuildManager(context.Background(), nil, s, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n \tassert.NoError(t, err)\n \n \texistingAccountID := \"bf1c8084-ba50-4ce7-9439-34653001fc3b\"\n@@ -1530,7 +1530,7 @@ func Test_RegisterPeerRollbackOnFailure(t *testing.T) {\n \trequestBuffer := NewAccountRequestBuffer(ctx, s)\n \tnetworkMapController := controller.NewController(ctx, s, metrics, updateManager, requestBuffer, MockIntegratedValidator{}, settingsMockManager, \"netbird.cloud\", port_forwarding.NewControllerMock())\n \n-\tam, err := BuildManager(context.Background(), s, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n+\tam, err := BuildManager(context.Background(), nil, s, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n \tassert.NoError(t, err)\n \n \texistingAccountID := \"bf1c8084-ba50-4ce7-9439-34653001fc3b\"\n@@ -1610,7 +1610,7 @@ func Test_LoginPeer(t *testing.T) {\n \trequestBuffer := NewAccountRequestBuffer(ctx, s)\n \tnetworkMapController := controller.NewController(ctx, s, metrics, updateManager, requestBuffer, MockIntegratedValidator{}, settingsMockManager, \"netbird.cloud\", port_forwarding.NewControllerMock())\n \n-\tam, err := BuildManager(context.Background(), s, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n+\tam, err := BuildManager(context.Background(), nil, s, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n \tassert.NoError(t, err)\n \n \texistingAccountID := \"bf1c8084-ba50-4ce7-9439-34653001fc3b\"\ndiff --git a/management/server/route_test.go b/management/server/route_test.go\nindex 27fe033c867..7ff362bc6f3 100644\n--- a/management/server/route_test.go\n+++ b/management/server/route_test.go\n@@ -1292,7 +1292,7 @@ func createRouterManager(t *testing.T) (*DefaultAccountManager, *update_channel.\n \trequestBuffer := NewAccountRequestBuffer(ctx, store)\n \tnetworkMapController := controller.NewController(ctx, store, metrics, updateManager, requestBuffer, MockIntegratedValidator{}, settingsMockManager, \"netbird.selfhosted\", port_forwarding.NewControllerMock())\n \n-\tam, err := BuildManager(context.Background(), store, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n+\tam, err := BuildManager(context.Background(), nil, store, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n \tif err != nil {\n \t\treturn nil, nil, err\n \t}\ndiff --git a/management/server/user_test.go b/management/server/user_test.go\nindex 69b8c85eeba..5ce15621eb2 100644\n--- a/management/server/user_test.go\n+++ b/management/server/user_test.go\n@@ -11,12 +11,12 @@ import (\n \t\"golang.org/x/exp/maps\"\n \n \tnbcache \"github.com/netbirdio/netbird/management/server/cache\"\n-\tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/permissions\"\n \t\"github.com/netbirdio/netbird/management/server/permissions/modules\"\n \t\"github.com/netbirdio/netbird/management/server/permissions/roles\"\n \t\"github.com/netbirdio/netbird/management/server/users\"\n \t\"github.com/netbirdio/netbird/management/server/util\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n \n \tnbpeer \"github.com/netbirdio/netbird/management/server/peer\"\n@@ -966,7 +966,7 @@ func TestDefaultAccountManager_GetUser(t *testing.T) {\n \t\tpermissionsManager: permissionsManager,\n \t}\n \n-\tclaims := nbcontext.UserAuth{\n+\tclaims := auth.UserAuth{\n \t\tUserId:    mockUserID,\n \t\tAccountId: mockAccountID,\n \t}\n@@ -1573,33 +1573,33 @@ func TestDefaultAccountManager_GetCurrentUserInfo(t *testing.T) {\n \n \ttt := []struct {\n \t\tname           string\n-\t\tuserAuth       nbcontext.UserAuth\n+\t\tuserAuth       auth.UserAuth\n \t\texpectedErr    error\n \t\texpectedResult *users.UserInfoWithPermissions\n \t}{\n \t\t{\n \t\t\tname:        \"not found\",\n-\t\t\tuserAuth:    nbcontext.UserAuth{AccountId: account1.Id, UserId: \"not-found\"},\n+\t\t\tuserAuth:    auth.UserAuth{AccountId: account1.Id, UserId: \"not-found\"},\n \t\t\texpectedErr: status.NewUserNotFoundError(\"not-found\"),\n \t\t},\n \t\t{\n \t\t\tname:        \"not part of account\",\n-\t\t\tuserAuth:    nbcontext.UserAuth{AccountId: account1.Id, UserId: \"account2Owner\"},\n+\t\t\tuserAuth:    auth.UserAuth{AccountId: account1.Id, UserId: \"account2Owner\"},\n \t\t\texpectedErr: status.NewUserNotPartOfAccountError(),\n \t\t},\n \t\t{\n \t\t\tname:        \"blocked\",\n-\t\t\tuserAuth:    nbcontext.UserAuth{AccountId: account1.Id, UserId: \"blocked-user\"},\n+\t\t\tuserAuth:    auth.UserAuth{AccountId: account1.Id, UserId: \"blocked-user\"},\n \t\t\texpectedErr: status.NewUserBlockedError(),\n \t\t},\n \t\t{\n \t\t\tname:        \"service user\",\n-\t\t\tuserAuth:    nbcontext.UserAuth{AccountId: account1.Id, UserId: \"service-user\"},\n+\t\t\tuserAuth:    auth.UserAuth{AccountId: account1.Id, UserId: \"service-user\"},\n \t\t\texpectedErr: status.NewPermissionDeniedError(),\n \t\t},\n \t\t{\n \t\t\tname:     \"owner user\",\n-\t\t\tuserAuth: nbcontext.UserAuth{AccountId: account1.Id, UserId: \"account1Owner\"},\n+\t\t\tuserAuth: auth.UserAuth{AccountId: account1.Id, UserId: \"account1Owner\"},\n \t\t\texpectedResult: &users.UserInfoWithPermissions{\n \t\t\t\tUserInfo: &types.UserInfo{\n \t\t\t\t\tID:                   \"account1Owner\",\n@@ -1619,7 +1619,7 @@ func TestDefaultAccountManager_GetCurrentUserInfo(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname:     \"regular user\",\n-\t\t\tuserAuth: nbcontext.UserAuth{AccountId: account1.Id, UserId: \"regular-user\"},\n+\t\t\tuserAuth: auth.UserAuth{AccountId: account1.Id, UserId: \"regular-user\"},\n \t\t\texpectedResult: &users.UserInfoWithPermissions{\n \t\t\t\tUserInfo: &types.UserInfo{\n \t\t\t\t\tID:                   \"regular-user\",\n@@ -1638,7 +1638,7 @@ func TestDefaultAccountManager_GetCurrentUserInfo(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname:     \"admin user\",\n-\t\t\tuserAuth: nbcontext.UserAuth{AccountId: account1.Id, UserId: \"admin-user\"},\n+\t\t\tuserAuth: auth.UserAuth{AccountId: account1.Id, UserId: \"admin-user\"},\n \t\t\texpectedResult: &users.UserInfoWithPermissions{\n \t\t\t\tUserInfo: &types.UserInfo{\n \t\t\t\t\tID:                   \"admin-user\",\n@@ -1657,7 +1657,7 @@ func TestDefaultAccountManager_GetCurrentUserInfo(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname:     \"settings blocked regular user\",\n-\t\t\tuserAuth: nbcontext.UserAuth{AccountId: account2.Id, UserId: \"settings-blocked-user\"},\n+\t\t\tuserAuth: auth.UserAuth{AccountId: account2.Id, UserId: \"settings-blocked-user\"},\n \t\t\texpectedResult: &users.UserInfoWithPermissions{\n \t\t\t\tUserInfo: &types.UserInfo{\n \t\t\t\t\tID:                   \"settings-blocked-user\",\n@@ -1678,7 +1678,7 @@ func TestDefaultAccountManager_GetCurrentUserInfo(t *testing.T) {\n \n \t\t{\n \t\t\tname:     \"settings blocked regular user child account\",\n-\t\t\tuserAuth: nbcontext.UserAuth{AccountId: account2.Id, UserId: \"settings-blocked-user\", IsChild: true},\n+\t\t\tuserAuth: auth.UserAuth{AccountId: account2.Id, UserId: \"settings-blocked-user\", IsChild: true},\n \t\t\texpectedResult: &users.UserInfoWithPermissions{\n \t\t\t\tUserInfo: &types.UserInfo{\n \t\t\t\t\tID:                   \"settings-blocked-user\",\n@@ -1698,7 +1698,7 @@ func TestDefaultAccountManager_GetCurrentUserInfo(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname:     \"settings blocked owner user\",\n-\t\t\tuserAuth: nbcontext.UserAuth{AccountId: account2.Id, UserId: \"account2Owner\"},\n+\t\t\tuserAuth: auth.UserAuth{AccountId: account2.Id, UserId: \"account2Owner\"},\n \t\t\texpectedResult: &users.UserInfoWithPermissions{\n \t\t\t\tUserInfo: &types.UserInfo{\n \t\t\t\t\tID:                   \"account2Owner\",\ndiff --git a/shared/management/client/client_test.go b/shared/management/client/client_test.go\nindex d3f341529fd..f98e76ce751 100644\n--- a/shared/management/client/client_test.go\n+++ b/shared/management/client/client_test.go\n@@ -18,6 +18,7 @@ import (\n \t\"google.golang.org/grpc/status\"\n \n \t\"github.com/netbirdio/management-integrations/integrations\"\n+\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map/controller\"\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map/update_channel\"\n \tnbgrpc \"github.com/netbirdio/netbird/management/internals/shared/grpc\"\n@@ -117,7 +118,7 @@ func startManagement(t *testing.T) (*grpc.Server, net.Listener) {\n \tupdateManager := update_channel.NewPeersUpdateManager(metrics)\n \trequestBuffer := mgmt.NewAccountRequestBuffer(ctx, store)\n \tnetworkMapController := controller.NewController(ctx, store, metrics, updateManager, requestBuffer, mgmt.MockIntegratedValidator{}, settingsMockManager, \"netbird.selfhosted\", port_forwarding.NewControllerMock())\n-\taccountManager, err := mgmt.BuildManager(context.Background(), store, networkMapController, nil, \"\", eventStore, nil, false, ia, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManagerMock, false)\n+\taccountManager, err := mgmt.BuildManager(context.Background(), config, store, networkMapController, nil, \"\", eventStore, nil, false, ia, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManagerMock, false)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n"}
