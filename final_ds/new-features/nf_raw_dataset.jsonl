{"org": "netbirdio", "repo": "netbird", "number": 4987, "state": "closed", "title": "Feature/ssh fine grained access nmap", "body": "## Describe your changes\r\n\r\n## Issue ticket number and link\r\n\r\n## Stack\r\n\r\n<!-- branch-stack -->\r\n\r\n### Checklist\r\n- [ ] Is it a bug fix\r\n- [ ] Is a typo/documentation fix\r\n- [ ] Is a feature enhancement\r\n- [ ] It is a refactor\r\n- [ ] Created tests that fail without the change (if possible)\r\n\r\n> By submitting this pull request, you confirm that you have read and agree to the terms of the [Contributor License Agreement](https://github.com/netbirdio/netbird/blob/main/CONTRIBUTOR_LICENSE_AGREEMENT.md).\r\n\r\n## Documentation\r\nSelect exactly one:\r\n\r\n- [ ] I added/updated documentation for this change\r\n- [x] Documentation is **not needed** for this change (explain why)\r\n\r\n### Docs PR URL (required if \"docs added\" is checked)\r\nPaste the PR link from https://github.com/netbirdio/docs here:\r\n\r\nhttps://github.com/netbirdio/docs/pull/__\r\n\n\n<!-- This is an auto-generated comment: release notes by coderabbit.ai -->\n\n## Summary by CodeRabbit\n\n* **New Features**\n  * Added SSH authorization system with wildcard support for flexible access management\n  * Introduced group-based SSH authentication capabilities enabling group-level access control\n\n* **Improvements**\n  * Enhanced peer network mapping to include SSH configuration and authorization data\n  * Improved consistency in peer network updates when user group memberships and policies change\n\n<sub>✏️ Tip: You can customize this high-level summary in your review settings.</sub>\n\n<!-- end of auto-generated comment: release notes by coderabbit.ai -->", "url": "https://api.github.com/repos/netbirdio/netbird/pulls/4987", "id": 3123901560, "node_id": "PR_kwDOFVUT7866MvR4", "html_url": "https://github.com/netbirdio/netbird/pull/4987", "diff_url": "https://github.com/netbirdio/netbird/pull/4987.diff", "patch_url": "https://github.com/netbirdio/netbird/pull/4987.patch", "issue_url": "https://api.github.com/repos/netbirdio/netbird/issues/4987", "created_at": "2025-12-22T18:58:01+00:00", "updated_at": "2025-12-23T11:34:44+00:00", "closed_at": "2025-12-23T11:34:42+00:00", "merged_at": "2025-12-23T11:34:42+00:00", "merge_commit_sha": "1bdaa4002cd8207e8f920dfcaea618dac4fff584", "labels": [], "draft": false, "commits_url": "https://api.github.com/repos/netbirdio/netbird/pulls/4987/commits", "review_comments_url": "https://api.github.com/repos/netbirdio/netbird/pulls/4987/comments", "review_comment_url": "https://api.github.com/repos/netbirdio/netbird/pulls/comments{/number}", "comments_url": "https://api.github.com/repos/netbirdio/netbird/issues/4987/comments", "base": {"label": "netbirdio:feature/ssh-fine-grained-access", "ref": "feature/ssh-fine-grained-access", "sha": "3b28834454fab6d26975d3dd828151c667e8505b", "user": {"login": "netbirdio", "id": 100464677, "node_id": "O_kgDOBfz4JQ", "avatar_url": "https://avatars.githubusercontent.com/u/100464677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/netbirdio", "html_url": "https://github.com/netbirdio", "followers_url": "https://api.github.com/users/netbirdio/followers", "following_url": "https://api.github.com/users/netbirdio/following{/other_user}", "gists_url": "https://api.github.com/users/netbirdio/gists{/gist_id}", "starred_url": "https://api.github.com/users/netbirdio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/netbirdio/subscriptions", "organizations_url": "https://api.github.com/users/netbirdio/orgs", "repos_url": "https://api.github.com/users/netbirdio/repos", "events_url": "https://api.github.com/users/netbirdio/events{/privacy}", "received_events_url": "https://api.github.com/users/netbirdio/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "repo": {"id": 357897199, "node_id": "MDEwOlJlcG9zaXRvcnkzNTc4OTcxOTk=", "name": "netbird", "full_name": "netbirdio/netbird", "private": false, "owner": {"login": "netbirdio", "id": 100464677, "node_id": "O_kgDOBfz4JQ", "avatar_url": "https://avatars.githubusercontent.com/u/100464677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/netbirdio", "html_url": "https://github.com/netbirdio", "followers_url": "https://api.github.com/users/netbirdio/followers", "following_url": "https://api.github.com/users/netbirdio/following{/other_user}", "gists_url": "https://api.github.com/users/netbirdio/gists{/gist_id}", "starred_url": "https://api.github.com/users/netbirdio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/netbirdio/subscriptions", "organizations_url": "https://api.github.com/users/netbirdio/orgs", "repos_url": "https://api.github.com/users/netbirdio/repos", "events_url": "https://api.github.com/users/netbirdio/events{/privacy}", "received_events_url": "https://api.github.com/users/netbirdio/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "html_url": "https://github.com/netbirdio/netbird", "description": "Connect your devices into a secure WireGuard®-based overlay network with SSO, MFA and granular access controls.", "fork": false, "url": "https://api.github.com/repos/netbirdio/netbird", "forks_url": "https://api.github.com/repos/netbirdio/netbird/forks", "keys_url": "https://api.github.com/repos/netbirdio/netbird/keys{/key_id}", "collaborators_url": "https://api.github.com/repos/netbirdio/netbird/collaborators{/collaborator}", "teams_url": "https://api.github.com/repos/netbirdio/netbird/teams", "hooks_url": "https://api.github.com/repos/netbirdio/netbird/hooks", "issue_events_url": "https://api.github.com/repos/netbirdio/netbird/issues/events{/number}", "events_url": "https://api.github.com/repos/netbirdio/netbird/events", "assignees_url": "https://api.github.com/repos/netbirdio/netbird/assignees{/user}", "branches_url": "https://api.github.com/repos/netbirdio/netbird/branches{/branch}", "tags_url": "https://api.github.com/repos/netbirdio/netbird/tags", "blobs_url": "https://api.github.com/repos/netbirdio/netbird/git/blobs{/sha}", "git_tags_url": "https://api.github.com/repos/netbirdio/netbird/git/tags{/sha}", "git_refs_url": "https://api.github.com/repos/netbirdio/netbird/git/refs{/sha}", "trees_url": "https://api.github.com/repos/netbirdio/netbird/git/trees{/sha}", "statuses_url": "https://api.github.com/repos/netbirdio/netbird/statuses/{sha}", "languages_url": "https://api.github.com/repos/netbirdio/netbird/languages", "stargazers_url": "https://api.github.com/repos/netbirdio/netbird/stargazers", "contributors_url": "https://api.github.com/repos/netbirdio/netbird/contributors", "subscribers_url": "https://api.github.com/repos/netbirdio/netbird/subscribers", "subscription_url": "https://api.github.com/repos/netbirdio/netbird/subscription", "commits_url": "https://api.github.com/repos/netbirdio/netbird/commits{/sha}", "git_commits_url": "https://api.github.com/repos/netbirdio/netbird/git/commits{/sha}", "comments_url": "https://api.github.com/repos/netbirdio/netbird/comments{/number}", "issue_comment_url": "https://api.github.com/repos/netbirdio/netbird/issues/comments{/number}", "contents_url": "https://api.github.com/repos/netbirdio/netbird/contents/{+path}", "compare_url": "https://api.github.com/repos/netbirdio/netbird/compare/{base}...{head}", "merges_url": "https://api.github.com/repos/netbirdio/netbird/merges", "archive_url": "https://api.github.com/repos/netbirdio/netbird/{archive_format}{/ref}", "downloads_url": "https://api.github.com/repos/netbirdio/netbird/downloads", "issues_url": "https://api.github.com/repos/netbirdio/netbird/issues{/number}", "pulls_url": "https://api.github.com/repos/netbirdio/netbird/pulls{/number}", "milestones_url": "https://api.github.com/repos/netbirdio/netbird/milestones{/number}", "notifications_url": "https://api.github.com/repos/netbirdio/netbird/notifications{?since,all,participating}", "labels_url": "https://api.github.com/repos/netbirdio/netbird/labels{/name}", "releases_url": "https://api.github.com/repos/netbirdio/netbird/releases{/id}", "deployments_url": "https://api.github.com/repos/netbirdio/netbird/deployments", "created_at": "2021-04-14T12:27:20Z", "updated_at": "2026-01-07T04:18:10Z", "pushed_at": "2026-01-07T05:22:46Z", "git_url": "git://github.com/netbirdio/netbird.git", "ssh_url": "git@github.com:netbirdio/netbird.git", "clone_url": "https://github.com/netbirdio/netbird.git", "svn_url": "https://github.com/netbirdio/netbird", "homepage": "https://netbird.io", "size": 47404, "stargazers_count": 20703, "watchers_count": 20703, "language": "Go", "has_issues": true, "has_projects": true, "has_downloads": true, "has_wiki": true, "has_pages": false, "has_discussions": false, "forks_count": 1009, "mirror_url": null, "archived": false, "disabled": false, "open_issues_count": 1188, "license": {"key": "other", "name": "Other", "spdx_id": "NOASSERTION", "url": null, "node_id": "MDc6TGljZW5zZTA="}, "allow_forking": true, "is_template": false, "web_commit_signoff_required": false, "topics": ["golang", "mesh", "mesh-networks", "nat-traversal", "netbird", "vpn", "wireguard", "wireguard-vpn", "wiretrustee", "zero-trust-network-access"], "visibility": "public", "forks": 1009, "open_issues": 1188, "watchers": 20703, "default_branch": "main"}}, "commits": [{"sha": "3b19e177898bab3fac850438d35b129465ac9e1f", "parents": ["ee6d96eac5dbdaf84b21fe868cd457cf946062ba"], "message": "add api to store layer"}, {"sha": "bb7069d1f415faf49c1f8ad69e194d3c8f198452", "parents": ["3b19e177898bab3fac850438d35b129465ac9e1f"], "message": "fix api response on empty groups"}, {"sha": "5752bc6477c21f3d56776e1f64ce4cf33e2dd667", "parents": ["bb7069d1f415faf49c1f8ad69e194d3c8f198452"], "message": "add happy path for network map calc"}, {"sha": "cfcdae523bed3f370135f480542ae1f959abec9a", "parents": ["5752bc6477c21f3d56776e1f64ce4cf33e2dd667", "437a3a7941adc199727275778f1cb452f341ade7"], "message": "Merge branch 'feature/ssh-fine-grained-access' into feature/ssh-fine-grained-access-nmap\n\n# Conflicts:\n#\tmanagement/server/http/handlers/policies/policies_handler.go"}, {"sha": "f6c0e7777b26e00cf20e8b95ecd994457ea1e5b6", "parents": ["cfcdae523bed3f370135f480542ae1f959abec9a"], "message": "simplify"}, {"sha": "6b919d7cf7f46ce8fa1471522662a086a426e19c", "parents": ["f6c0e7777b26e00cf20e8b95ecd994457ea1e5b6"], "message": "filter for wildcard"}, {"sha": "9daabc0d882a03aa8a6fcf7ccf0d84741d14318d", "parents": ["6b919d7cf7f46ce8fa1471522662a086a426e19c"], "message": "handle legacy policies"}, {"sha": "3f01f90a0d391267dc7637086c8dcac8c19d2d4f", "parents": ["9daabc0d882a03aa8a6fcf7ccf0d84741d14318d"], "message": "extract wildcard and all user generation"}, {"sha": "a1870ee58acf2cd23263e3759ef08178afbc0161", "parents": ["3f01f90a0d391267dc7637086c8dcac8c19d2d4f"], "message": "handle legacy ssh configs"}, {"sha": "96ae60b1b34df4f0e2afc44608db965a77512c4f", "parents": ["a1870ee58acf2cd23263e3759ef08178afbc0161"], "message": "update account peers on user update"}, {"sha": "78b85e1ffdcf39574456caa591ea2683cfdfa872", "parents": ["96ae60b1b34df4f0e2afc44608db965a77512c4f", "9019747e2face4fd4260949ebb84cc3a5a239def"], "message": "Merge branch 'feature/ssh-fine-grained-access' into feature/ssh-fine-grained-access-nmap\n\n# Conflicts:\n#\tmanagement/internals/shared/grpc/conversion.go"}, {"sha": "fc46a5166520e5c54c64745d61525baacea3139c", "parents": ["78b85e1ffdcf39574456caa591ea2683cfdfa872"], "message": "fix hash conversion"}, {"sha": "87a39069e1570ffb7fcef4dca6f737cc05b3e026", "parents": ["fc46a5166520e5c54c64745d61525baacea3139c"], "message": "[client] Add wildcard support (#4985)\n\nAdd wildcard support"}, {"sha": "776b14cf963872137ce271e1037ce310c8b7d4fd", "parents": ["87a39069e1570ffb7fcef4dca6f737cc05b3e026"], "message": "add firewall rule proto to TCP for new netbird-ssh"}, {"sha": "e3f93fd42a8ccf0132f95f1b94f98aa9acd33245", "parents": ["776b14cf963872137ce271e1037ce310c8b7d4fd"], "message": "add firewall rule proto to TCP for new netbird-ssh"}, {"sha": "c358d8725d822d843d770c59f9d6563aefc9b351", "parents": ["e3f93fd42a8ccf0132f95f1b94f98aa9acd33245"], "message": "fix tests"}, {"sha": "690155c2e0d271ed34779f1693a8c4ad5071e670", "parents": ["c358d8725d822d843d770c59f9d6563aefc9b351"], "message": "fix test expectations"}, {"sha": "e2dfcdc37f56b63a1c2f0078b3db7c3d138858c1", "parents": ["690155c2e0d271ed34779f1693a8c4ad5071e670"], "message": "handle ALL group"}, {"sha": "27bfe6785cb5a17dece3c0c15ea2e22780f5407c", "parents": ["e2dfcdc37f56b63a1c2f0078b3db7c3d138858c1"], "message": "fix active group test"}], "resolved_issues": [{"org": "netbirdio", "repo": "netbird", "number": -1, "state": "unknown", "title": "Feature/ssh fine grained access nmap", "body": "## Describe your changes\r\n\r\n## Issue ticket number and link\r\n\r\n## Stack\r\n\r\n<!-- branch-stack -->\r\n\r\n### Checklist\r\n- [ ] Is it a bug fix\r\n- [ ] Is a typo/documentation fix\r\n- [ ] Is a feature enhancement\r\n- [ ] It is a refactor\r\n- [ ] Created tests that fail without the change (if possible)\r\n\r\n> By submitting this pull request, you confirm that you have read and agree to the terms of the [Contributor License Agreement](https://github.com/netbirdio/netbird/blob/main/CONTRIBUTOR_LICENSE_AGREEMENT.md).\r\n\r\n## Documentation\r\nSelect exactly one:\r\n\r\n- [ ] I added/updated documentation for this change\r\n- [x] Documentation is **not needed** for this change (explain why)\r\n\r\n### Docs PR URL (required if \"docs added\" is checked)\r\nPaste the PR link from https://github.com/netbirdio/docs here:\r\n\r\nhttps://github.com/netbirdio/docs/pull/__\r\n\n\n<!-- This is an auto-generated comment: release notes by coderabbit.ai -->\n\n## Summary by CodeRabbit\n\n* **New Features**\n  * Added SSH authorization system with wildcard support for flexible access management\n  * Introduced group-based SSH authentication capabilities enabling group-level access control\n\n* **Improvements**\n  * Enhanced peer network mapping to include SSH configuration and authorization data\n  * Improved consistency in peer network updates when user group memberships and policies change\n\n<sub>✏️ Tip: You can customize this high-level summary in your review settings.</sub>\n\n<!-- end of auto-generated comment: release notes by coderabbit.ai -->"}], "fix_patch": "diff --git a/client/ssh/auth/auth.go b/client/ssh/auth/auth.go\nindex cf7ccf01c46..c883849a59c 100644\n--- a/client/ssh/auth/auth.go\n+++ b/client/ssh/auth/auth.go\n@@ -13,6 +13,8 @@ import (\n const (\n \t// DefaultUserIDClaim is the default JWT claim used to extract user IDs\n \tDefaultUserIDClaim = \"sub\"\n+\t// Wildcard is a special user ID that matches all users\n+\tWildcard = \"*\"\n )\n \n var (\n@@ -121,7 +123,19 @@ func (a *Authorizer) Authorize(jwtUserID, osUsername string) error {\n \t\treturn ErrUserNotAuthorized\n \t}\n \n-\t// Check machine user mapping\n+\treturn a.checkMachineUserMapping(jwtUserID, osUsername, userIndex)\n+}\n+\n+// checkMachineUserMapping validates if a user's index is authorized for the specified OS user\n+// Checks wildcard mapping first, then specific OS user mappings\n+func (a *Authorizer) checkMachineUserMapping(jwtUserID, osUsername string, userIndex int) error {\n+\t// If wildcard exists, allow any authorized user to access any OS user\n+\tif _, hasWildcard := a.machineUsers[Wildcard]; hasWildcard {\n+\t\tlog.Infof(\"SSH auth granted: user '%s' authorized for OS user '%s' via wildcard (index: %d)\", jwtUserID, osUsername, userIndex)\n+\t\treturn nil\n+\t}\n+\n+\t// Check for specific OS username mapping\n \tallowedIndexes, hasMachineUserMapping := a.machineUsers[osUsername]\n \tif !hasMachineUserMapping {\n \t\t// No mapping for this OS user - deny by default (fail closed)\n@@ -129,7 +143,7 @@ func (a *Authorizer) Authorize(jwtUserID, osUsername string) error {\n \t\treturn ErrNoMachineUserMapping\n \t}\n \n-\t// Check if user's index is in the allowed indexes for this OS user\n+\t// Check if user's index is in the allowed indexes for this specific OS user\n \tif !a.isIndexInList(uint32(userIndex), allowedIndexes) {\n \t\tlog.Warnf(\"SSH auth denied: user '%s' not mapped to OS user '%s' (user index: %d)\", jwtUserID, osUsername, userIndex)\n \t\treturn ErrUserNotMappedToOSUser\ndiff --git a/management/internals/controllers/network_map/controller/controller.go b/management/internals/controllers/network_map/controller/controller.go\nindex 022ea774ce3..df16e192264 100644\n--- a/management/internals/controllers/network_map/controller/controller.go\n+++ b/management/internals/controllers/network_map/controller/controller.go\n@@ -178,6 +178,7 @@ func (c *Controller) sendUpdateAccountPeers(ctx context.Context, accountID strin\n \tcustomZone := account.GetPeersCustomZone(ctx, dnsDomain)\n \tresourcePolicies := account.GetResourcePoliciesMap()\n \trouters := account.GetResourceRoutersMap()\n+\tgroupIDToUserIDs := account.GetActiveGroupUsers()\n \n \tif c.experimentalNetworkMap(accountID) {\n \t\tc.initNetworkMapBuilderIfNeeded(account, approvedPeersMap)\n@@ -224,7 +225,7 @@ func (c *Controller) sendUpdateAccountPeers(ctx context.Context, accountID strin\n \t\t\tif c.experimentalNetworkMap(accountID) {\n \t\t\t\tremotePeerNetworkMap = c.getPeerNetworkMapExp(ctx, p.AccountID, p.ID, approvedPeersMap, customZone, c.accountManagerMetrics)\n \t\t\t} else {\n-\t\t\t\tremotePeerNetworkMap = account.GetPeerNetworkMap(ctx, p.ID, customZone, approvedPeersMap, resourcePolicies, routers, c.accountManagerMetrics)\n+\t\t\t\tremotePeerNetworkMap = account.GetPeerNetworkMap(ctx, p.ID, customZone, approvedPeersMap, resourcePolicies, routers, c.accountManagerMetrics, groupIDToUserIDs)\n \t\t\t}\n \n \t\t\tc.metrics.CountCalcPeerNetworkMapDuration(time.Since(start))\n@@ -320,6 +321,7 @@ func (c *Controller) UpdateAccountPeer(ctx context.Context, accountId string, pe\n \tcustomZone := account.GetPeersCustomZone(ctx, dnsDomain)\n \tresourcePolicies := account.GetResourcePoliciesMap()\n \trouters := account.GetResourceRoutersMap()\n+\tgroupIDToUserIDs := account.GetActiveGroupUsers()\n \n \tpostureChecks, err := c.getPeerPostureChecks(account, peerId)\n \tif err != nil {\n@@ -338,7 +340,7 @@ func (c *Controller) UpdateAccountPeer(ctx context.Context, accountId string, pe\n \tif c.experimentalNetworkMap(accountId) {\n \t\tremotePeerNetworkMap = c.getPeerNetworkMapExp(ctx, peer.AccountID, peer.ID, approvedPeersMap, customZone, c.accountManagerMetrics)\n \t} else {\n-\t\tremotePeerNetworkMap = account.GetPeerNetworkMap(ctx, peerId, customZone, approvedPeersMap, resourcePolicies, routers, c.accountManagerMetrics)\n+\t\tremotePeerNetworkMap = account.GetPeerNetworkMap(ctx, peerId, customZone, approvedPeersMap, resourcePolicies, routers, c.accountManagerMetrics, groupIDToUserIDs)\n \t}\n \n \tproxyNetworkMap, ok := proxyNetworkMaps[peer.ID]\n@@ -445,7 +447,7 @@ func (c *Controller) GetValidatedPeerWithMap(ctx context.Context, isRequiresAppr\n \tif c.experimentalNetworkMap(accountID) {\n \t\tnetworkMap = c.getPeerNetworkMapExp(ctx, peer.AccountID, peer.ID, approvedPeersMap, customZone, c.accountManagerMetrics)\n \t} else {\n-\t\tnetworkMap = account.GetPeerNetworkMap(ctx, peer.ID, customZone, approvedPeersMap, account.GetResourcePoliciesMap(), account.GetResourceRoutersMap(), c.accountManagerMetrics)\n+\t\tnetworkMap = account.GetPeerNetworkMap(ctx, peer.ID, customZone, approvedPeersMap, account.GetResourcePoliciesMap(), account.GetResourceRoutersMap(), c.accountManagerMetrics, account.GetActiveGroupUsers())\n \t}\n \n \tproxyNetworkMap, ok := proxyNetworkMaps[peer.ID]\n@@ -811,7 +813,7 @@ func (c *Controller) GetNetworkMap(ctx context.Context, peerID string) (*types.N\n \tif c.experimentalNetworkMap(peer.AccountID) {\n \t\tnetworkMap = c.getPeerNetworkMapExp(ctx, peer.AccountID, peerID, validatedPeers, customZone, nil)\n \t} else {\n-\t\tnetworkMap = account.GetPeerNetworkMap(ctx, peer.ID, customZone, validatedPeers, account.GetResourcePoliciesMap(), account.GetResourceRoutersMap(), nil)\n+\t\tnetworkMap = account.GetPeerNetworkMap(ctx, peer.ID, customZone, validatedPeers, account.GetResourcePoliciesMap(), account.GetResourceRoutersMap(), nil, account.GetActiveGroupUsers())\n \t}\n \n \tproxyNetworkMap, ok := proxyNetworkMaps[peer.ID]\ndiff --git a/management/internals/shared/grpc/conversion.go b/management/internals/shared/grpc/conversion.go\nindex 1a0dc009b05..3b89574d060 100644\n--- a/management/internals/shared/grpc/conversion.go\n+++ b/management/internals/shared/grpc/conversion.go\n@@ -6,7 +6,10 @@ import (\n \t\"net/url\"\n \t\"strings\"\n \n+\tlog \"github.com/sirupsen/logrus\"\n+\n \tintegrationsConfig \"github.com/netbirdio/management-integrations/integrations/config\"\n+\t\"github.com/netbirdio/netbird/client/ssh/auth\"\n \n \tnbdns \"github.com/netbirdio/netbird/dns\"\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map/controller/cache\"\n@@ -16,6 +19,7 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/types\"\n \t\"github.com/netbirdio/netbird/route\"\n \t\"github.com/netbirdio/netbird/shared/management/proto\"\n+\t\"github.com/netbirdio/netbird/shared/sshauth\"\n )\n \n func toNetbirdConfig(config *nbconfig.Config, turnCredentials *Token, relayToken *Token, extraSettings *types.ExtraSettings) *proto.NetbirdConfig {\n@@ -84,12 +88,12 @@ func toNetbirdConfig(config *nbconfig.Config, turnCredentials *Token, relayToken\n \treturn nbConfig\n }\n \n-func toPeerConfig(peer *nbpeer.Peer, network *types.Network, dnsName string, settings *types.Settings, httpConfig *nbconfig.HttpServerConfig, deviceFlowConfig *nbconfig.DeviceAuthorizationFlow) *proto.PeerConfig {\n+func toPeerConfig(peer *nbpeer.Peer, network *types.Network, dnsName string, settings *types.Settings, httpConfig *nbconfig.HttpServerConfig, deviceFlowConfig *nbconfig.DeviceAuthorizationFlow, enableSSH bool) *proto.PeerConfig {\n \tnetmask, _ := network.Net.Mask.Size()\n \tfqdn := peer.FQDN(dnsName)\n \n \tsshConfig := &proto.SSHConfig{\n-\t\tSshEnabled: peer.SSHEnabled,\n+\t\tSshEnabled: peer.SSHEnabled || enableSSH,\n \t}\n \n \tif peer.SSHEnabled {\n@@ -110,12 +114,12 @@ func toPeerConfig(peer *nbpeer.Peer, network *types.Network, dnsName string, set\n \n func ToSyncResponse(ctx context.Context, config *nbconfig.Config, httpConfig *nbconfig.HttpServerConfig, deviceFlowConfig *nbconfig.DeviceAuthorizationFlow, peer *nbpeer.Peer, turnCredentials *Token, relayCredentials *Token, networkMap *types.NetworkMap, dnsName string, checks []*posture.Checks, dnsCache *cache.DNSConfigCache, settings *types.Settings, extraSettings *types.ExtraSettings, peerGroups []string, dnsFwdPort int64) *proto.SyncResponse {\n \tresponse := &proto.SyncResponse{\n-\t\tPeerConfig: toPeerConfig(peer, networkMap.Network, dnsName, settings, httpConfig, deviceFlowConfig),\n+\t\tPeerConfig: toPeerConfig(peer, networkMap.Network, dnsName, settings, httpConfig, deviceFlowConfig, networkMap.EnableSSH),\n \t\tNetworkMap: &proto.NetworkMap{\n \t\t\tSerial:     networkMap.Network.CurrentSerial(),\n \t\t\tRoutes:     toProtocolRoutes(networkMap.Routes),\n \t\t\tDNSConfig:  toProtocolDNSConfig(networkMap.DNSConfig, dnsCache, dnsFwdPort),\n-\t\t\tPeerConfig: toPeerConfig(peer, networkMap.Network, dnsName, settings, httpConfig, deviceFlowConfig),\n+\t\t\tPeerConfig: toPeerConfig(peer, networkMap.Network, dnsName, settings, httpConfig, deviceFlowConfig, networkMap.EnableSSH),\n \t\t},\n \t\tChecks: toProtocolChecks(ctx, checks),\n \t}\n@@ -151,9 +155,52 @@ func ToSyncResponse(ctx context.Context, config *nbconfig.Config, httpConfig *nb\n \t\tresponse.NetworkMap.ForwardingRules = forwardingRules\n \t}\n \n+\tif networkMap.AuthorizedUsers != nil {\n+\t\thashedUsers, machineUsers := buildAuthorizedUsersProto(ctx, networkMap.AuthorizedUsers)\n+\t\tuserIDClaim := auth.DefaultUserIDClaim\n+\t\tif httpConfig != nil && httpConfig.AuthUserIDClaim != \"\" {\n+\t\t\tuserIDClaim = httpConfig.AuthUserIDClaim\n+\t\t}\n+\t\tresponse.NetworkMap.SshAuth = &proto.SSHAuth{AuthorizedUsers: hashedUsers, MachineUsers: machineUsers, UserIDClaim: userIDClaim}\n+\t}\n+\n \treturn response\n }\n \n+func buildAuthorizedUsersProto(ctx context.Context, authorizedUsers map[string]map[string]struct{}) ([][]byte, map[string]*proto.MachineUserIndexes) {\n+\tuserIDToIndex := make(map[string]uint32)\n+\tvar hashedUsers [][]byte\n+\tmachineUsers := make(map[string]*proto.MachineUserIndexes, len(authorizedUsers))\n+\n+\tusers, ok := authorizedUsers[auth.Wildcard]\n+\tif ok {\n+\t\twildcard := make(map[string]map[string]struct{})\n+\t\twildcard[auth.Wildcard] = users\n+\t\tauthorizedUsers = wildcard\n+\t}\n+\n+\tfor machineUser, users := range authorizedUsers {\n+\t\tindexes := make([]uint32, 0, len(users))\n+\t\tfor userID := range users {\n+\t\t\tidx, exists := userIDToIndex[userID]\n+\t\t\tif !exists {\n+\t\t\t\thash, err := sshauth.HashUserID(userID)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tlog.WithContext(ctx).Errorf(\"failed to hash user id %s: %v\", userID, err)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tidx = uint32(len(hashedUsers))\n+\t\t\t\tuserIDToIndex[userID] = idx\n+\t\t\t\thashedUsers = append(hashedUsers, hash[:])\n+\t\t\t}\n+\t\t\tindexes = append(indexes, idx)\n+\t\t}\n+\t\tmachineUsers[machineUser] = &proto.MachineUserIndexes{Indexes: indexes}\n+\t}\n+\n+\treturn hashedUsers, machineUsers\n+}\n+\n func appendRemotePeerConfig(dst []*proto.RemotePeerConfig, peers []*nbpeer.Peer, dnsName string) []*proto.RemotePeerConfig {\n \tfor _, rPeer := range peers {\n \t\tdst = append(dst, &proto.RemotePeerConfig{\ndiff --git a/management/internals/shared/grpc/server.go b/management/internals/shared/grpc/server.go\nindex 462e2e6ebf3..ad6b34c5ff4 100644\n--- a/management/internals/shared/grpc/server.go\n+++ b/management/internals/shared/grpc/server.go\n@@ -635,7 +635,7 @@ func (s *Server) prepareLoginResponse(ctx context.Context, peer *nbpeer.Peer, ne\n \t// if peer has reached this point then it has logged in\n \tloginResp := &proto.LoginResponse{\n \t\tNetbirdConfig: toNetbirdConfig(s.config, nil, relayToken, nil),\n-\t\tPeerConfig:    toPeerConfig(peer, netMap.Network, s.networkMapController.GetDNSDomain(settings), settings, s.config.HttpConfig, s.config.DeviceAuthorizationFlow),\n+\t\tPeerConfig:    toPeerConfig(peer, netMap.Network, s.networkMapController.GetDNSDomain(settings), settings, s.config.HttpConfig, s.config.DeviceAuthorizationFlow, netMap.EnableSSH),\n \t\tChecks:        toProtocolChecks(ctx, postureChecks),\n \t}\n \ndiff --git a/management/server/account.go b/management/server/account.go\nindex 04f83842e75..405a3c0f635 100644\n--- a/management/server/account.go\n+++ b/management/server/account.go\n@@ -1456,21 +1456,19 @@ func (am *DefaultAccountManager) SyncUserJWTGroups(ctx context.Context, userAuth\n \t\t}\n \t}\n \n-\tif settings.GroupsPropagationEnabled {\n-\t\tremovedGroupAffectsPeers, err := areGroupChangesAffectPeers(ctx, am.Store, userAuth.AccountId, removeOldGroups)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n+\tremovedGroupAffectsPeers, err := areGroupChangesAffectPeers(ctx, am.Store, userAuth.AccountId, removeOldGroups)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \n-\t\tnewGroupsAffectsPeers, err := areGroupChangesAffectPeers(ctx, am.Store, userAuth.AccountId, addNewGroups)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n+\tnewGroupsAffectsPeers, err := areGroupChangesAffectPeers(ctx, am.Store, userAuth.AccountId, addNewGroups)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \n-\t\tif removedGroupAffectsPeers || newGroupsAffectsPeers {\n-\t\t\tlog.WithContext(ctx).Tracef(\"user %s: JWT group membership changed, updating account peers\", userAuth.UserId)\n-\t\t\tam.BufferUpdateAccountPeers(ctx, userAuth.AccountId)\n-\t\t}\n+\tif removedGroupAffectsPeers || newGroupsAffectsPeers {\n+\t\tlog.WithContext(ctx).Tracef(\"user %s: JWT group membership changed, updating account peers\", userAuth.UserId)\n+\t\tam.BufferUpdateAccountPeers(ctx, userAuth.AccountId)\n \t}\n \n \treturn nil\ndiff --git a/management/server/http/handlers/peers/peers_handler.go b/management/server/http/handlers/peers/peers_handler.go\nindex f531f0cdb24..01913ca127f 100644\n--- a/management/server/http/handlers/peers/peers_handler.go\n+++ b/management/server/http/handlers/peers/peers_handler.go\n@@ -299,7 +299,7 @@ func (h *Handler) GetAccessiblePeers(w http.ResponseWriter, r *http.Request) {\n \tdnsDomain := h.networkMapController.GetDNSDomain(account.Settings)\n \n \tcustomZone := account.GetPeersCustomZone(r.Context(), dnsDomain)\n-\tnetMap := account.GetPeerNetworkMap(r.Context(), peerID, customZone, validPeers, account.GetResourcePoliciesMap(), account.GetResourceRoutersMap(), nil)\n+\tnetMap := account.GetPeerNetworkMap(r.Context(), peerID, customZone, validPeers, account.GetResourcePoliciesMap(), account.GetResourceRoutersMap(), nil, account.GetActiveGroupUsers())\n \n \tutil.WriteJSONObject(r.Context(), w, toAccessiblePeers(netMap, dnsDomain))\n }\ndiff --git a/management/server/peer.go b/management/server/peer.go\nindex 49f5bf2a500..7c48a805279 100644\n--- a/management/server/peer.go\n+++ b/management/server/peer.go\n@@ -91,7 +91,7 @@ func (am *DefaultAccountManager) getUserAccessiblePeers(ctx context.Context, acc\n \n \t// fetch all the peers that have access to the user's peers\n \tfor _, peer := range peers {\n-\t\taclPeers, _ := account.GetPeerConnectionResources(ctx, peer, approvedPeersMap)\n+\t\taclPeers, _, _, _ := account.GetPeerConnectionResources(ctx, peer, approvedPeersMap, account.GetActiveGroupUsers())\n \t\tfor _, p := range aclPeers {\n \t\t\tpeersMap[p.ID] = p\n \t\t}\n@@ -1057,7 +1057,7 @@ func (am *DefaultAccountManager) checkIfUserOwnsPeer(ctx context.Context, accoun\n \t}\n \n \tfor _, p := range userPeers {\n-\t\taclPeers, _ := account.GetPeerConnectionResources(ctx, p, approvedPeersMap)\n+\t\taclPeers, _, _, _ := account.GetPeerConnectionResources(ctx, p, approvedPeersMap, account.GetActiveGroupUsers())\n \t\tfor _, aclPeer := range aclPeers {\n \t\t\tif aclPeer.ID == peer.ID {\n \t\t\t\treturn peer, nil\ndiff --git a/management/server/store/sql_store.go b/management/server/store/sql_store.go\nindex 2b8981b97c1..60109849c41 100644\n--- a/management/server/store/sql_store.go\n+++ b/management/server/store/sql_store.go\n@@ -1910,16 +1910,16 @@ func (s *SqlStore) getPolicyRules(ctx context.Context, policyIDs []string) ([]*t\n \tif len(policyIDs) == 0 {\n \t\treturn nil, nil\n \t}\n-\tconst query = `SELECT id, policy_id, name, description, enabled, action, destinations, destination_resource, sources, source_resource, bidirectional, protocol, ports, port_ranges FROM policy_rules WHERE policy_id = ANY($1)`\n+\tconst query = `SELECT id, policy_id, name, description, enabled, action, destinations, destination_resource, sources, source_resource, bidirectional, protocol, ports, port_ranges, authorized_groups FROM policy_rules WHERE policy_id = ANY($1)`\n \trows, err := s.pool.Query(ctx, query, policyIDs)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \trules, err := pgx.CollectRows(rows, func(row pgx.CollectableRow) (*types.PolicyRule, error) {\n \t\tvar r types.PolicyRule\n-\t\tvar dest, destRes, sources, sourceRes, ports, portRanges []byte\n+\t\tvar dest, destRes, sources, sourceRes, ports, portRanges, authorizedGroups []byte\n \t\tvar enabled, bidirectional sql.NullBool\n-\t\terr := row.Scan(&r.ID, &r.PolicyID, &r.Name, &r.Description, &enabled, &r.Action, &dest, &destRes, &sources, &sourceRes, &bidirectional, &r.Protocol, &ports, &portRanges)\n+\t\terr := row.Scan(&r.ID, &r.PolicyID, &r.Name, &r.Description, &enabled, &r.Action, &dest, &destRes, &sources, &sourceRes, &bidirectional, &r.Protocol, &ports, &portRanges, &authorizedGroups)\n \t\tif err == nil {\n \t\t\tif enabled.Valid {\n \t\t\t\tr.Enabled = enabled.Bool\n@@ -1945,6 +1945,9 @@ func (s *SqlStore) getPolicyRules(ctx context.Context, policyIDs []string) ([]*t\n \t\t\tif portRanges != nil {\n \t\t\t\t_ = json.Unmarshal(portRanges, &r.PortRanges)\n \t\t\t}\n+\t\t\tif authorizedGroups != nil {\n+\t\t\t\t_ = json.Unmarshal(authorizedGroups, &r.AuthorizedGroups)\n+\t\t\t}\n \t\t}\n \t\treturn &r, err\n \t})\ndiff --git a/management/server/types/account.go b/management/server/types/account.go\nindex 9e86d89366c..195dbbaa937 100644\n--- a/management/server/types/account.go\n+++ b/management/server/types/account.go\n@@ -16,6 +16,7 @@ import (\n \t\"github.com/rs/xid\"\n \tlog \"github.com/sirupsen/logrus\"\n \n+\t\"github.com/netbirdio/netbird/client/ssh/auth\"\n \tnbdns \"github.com/netbirdio/netbird/dns\"\n \tresourceTypes \"github.com/netbirdio/netbird/management/server/networks/resources/types\"\n \trouterTypes \"github.com/netbirdio/netbird/management/server/networks/routers/types\"\n@@ -45,8 +46,10 @@ const (\n \n \t// nativeSSHPortString defines the default port number as a string used for native SSH connections; this port is used by clients when hijacking ssh connections.\n \tnativeSSHPortString = \"22022\"\n+\tnativeSSHPortNumber = 22022\n \t// defaultSSHPortString defines the standard SSH port number as a string, commonly used for default SSH connections.\n \tdefaultSSHPortString = \"22\"\n+\tdefaultSSHPortNumber = 22\n )\n \n type supportedFeatures struct {\n@@ -275,6 +278,7 @@ func (a *Account) GetPeerNetworkMap(\n \tresourcePolicies map[string][]*Policy,\n \trouters map[string]map[string]*routerTypes.NetworkRouter,\n \tmetrics *telemetry.AccountManagerMetrics,\n+\tgroupIDToUserIDs map[string][]string,\n ) *NetworkMap {\n \tstart := time.Now()\n \tpeer := a.Peers[peerID]\n@@ -290,7 +294,7 @@ func (a *Account) GetPeerNetworkMap(\n \t\t}\n \t}\n \n-\taclPeers, firewallRules := a.GetPeerConnectionResources(ctx, peer, validatedPeersMap)\n+\taclPeers, firewallRules, authorizedUsers, enableSSH := a.GetPeerConnectionResources(ctx, peer, validatedPeersMap, groupIDToUserIDs)\n \t// exclude expired peers\n \tvar peersToConnect []*nbpeer.Peer\n \tvar expiredPeers []*nbpeer.Peer\n@@ -338,6 +342,8 @@ func (a *Account) GetPeerNetworkMap(\n \t\tOfflinePeers:        expiredPeers,\n \t\tFirewallRules:       firewallRules,\n \t\tRoutesFirewallRules: slices.Concat(networkResourcesFirewallRules, routesFirewallRules),\n+\t\tAuthorizedUsers:     authorizedUsers,\n+\t\tEnableSSH:           enableSSH,\n \t}\n \n \tif metrics != nil {\n@@ -1009,8 +1015,10 @@ func (a *Account) UserGroupsRemoveFromPeers(userID string, groups ...string) map\n // GetPeerConnectionResources for a given peer\n //\n // This function returns the list of peers and firewall rules that are applicable to a given peer.\n-func (a *Account) GetPeerConnectionResources(ctx context.Context, peer *nbpeer.Peer, validatedPeersMap map[string]struct{}) ([]*nbpeer.Peer, []*FirewallRule) {\n+func (a *Account) GetPeerConnectionResources(ctx context.Context, peer *nbpeer.Peer, validatedPeersMap map[string]struct{}, groupIDToUserIDs map[string][]string) ([]*nbpeer.Peer, []*FirewallRule, map[string]map[string]struct{}, bool) {\n \tgenerateResources, getAccumulatedResources := a.connResourcesGenerator(ctx, peer)\n+\tauthorizedUsers := make(map[string]map[string]struct{}) // machine user to list of userIDs\n+\tsshEnabled := false\n \n \tfor _, policy := range a.Policies {\n \t\tif !policy.Enabled {\n@@ -1053,10 +1061,52 @@ func (a *Account) GetPeerConnectionResources(ctx context.Context, peer *nbpeer.P\n \t\t\tif peerInDestinations {\n \t\t\t\tgenerateResources(rule, sourcePeers, FirewallRuleDirectionIN)\n \t\t\t}\n+\n+\t\t\tif peerInDestinations && rule.Protocol == PolicyRuleProtocolNetbirdSSH {\n+\t\t\t\tsshEnabled = true\n+\t\t\t\tif len(rule.AuthorizedGroups) == 0 {\n+\t\t\t\t\tauthorizedUsers[auth.Wildcard] = a.getAllowedUserIDs()\n+\t\t\t\t} else {\n+\t\t\t\t\tfor groupID, localUsers := range rule.AuthorizedGroups {\n+\t\t\t\t\t\tuserIDs, ok := groupIDToUserIDs[groupID]\n+\t\t\t\t\t\tif !ok {\n+\t\t\t\t\t\t\tlog.WithContext(ctx).Tracef(\"no user IDs found for group ID %s\", groupID)\n+\t\t\t\t\t\t\tcontinue\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif len(localUsers) == 0 {\n+\t\t\t\t\t\t\tlocalUsers = []string{auth.Wildcard}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tfor _, localUser := range localUsers {\n+\t\t\t\t\t\t\tif authorizedUsers[localUser] == nil {\n+\t\t\t\t\t\t\t\tauthorizedUsers[localUser] = make(map[string]struct{})\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tfor _, userID := range userIDs {\n+\t\t\t\t\t\t\t\tauthorizedUsers[localUser][userID] = struct{}{}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else if peerInDestinations && policyRuleImpliesLegacySSH(rule) && peer.SSHEnabled {\n+\t\t\t\tsshEnabled = true\n+\t\t\t\tauthorizedUsers[auth.Wildcard] = a.getAllowedUserIDs()\n+\t\t\t}\n \t\t}\n \t}\n \n-\treturn getAccumulatedResources()\n+\tpeers, fwRules := getAccumulatedResources()\n+\treturn peers, fwRules, authorizedUsers, sshEnabled\n+}\n+\n+func (a *Account) getAllowedUserIDs() map[string]struct{} {\n+\tusers := make(map[string]struct{})\n+\tfor _, nbUser := range a.Users {\n+\t\tif !nbUser.IsBlocked() && !nbUser.IsServiceUser {\n+\t\t\tusers[nbUser.Id] = struct{}{}\n+\t\t}\n+\t}\n+\treturn users\n }\n \n // connResourcesGenerator returns generator and accumulator function which returns the result of generator calls\n@@ -1081,12 +1131,17 @@ func (a *Account) connResourcesGenerator(ctx context.Context, targetPeer *nbpeer\n \t\t\t\t\tpeersExists[peer.ID] = struct{}{}\n \t\t\t\t}\n \n+\t\t\t\tprotocol := rule.Protocol\n+\t\t\t\tif protocol == PolicyRuleProtocolNetbirdSSH {\n+\t\t\t\t\tprotocol = PolicyRuleProtocolTCP\n+\t\t\t\t}\n+\n \t\t\t\tfr := FirewallRule{\n \t\t\t\t\tPolicyID:  rule.ID,\n \t\t\t\t\tPeerIP:    peer.IP.String(),\n \t\t\t\t\tDirection: direction,\n \t\t\t\t\tAction:    string(rule.Action),\n-\t\t\t\t\tProtocol:  string(rule.Protocol),\n+\t\t\t\t\tProtocol:  string(protocol),\n \t\t\t\t}\n \n \t\t\t\truleID := rule.ID + fr.PeerIP + strconv.Itoa(direction) +\n@@ -1108,6 +1163,28 @@ func (a *Account) connResourcesGenerator(ctx context.Context, targetPeer *nbpeer\n \t\t}\n }\n \n+func policyRuleImpliesLegacySSH(rule *PolicyRule) bool {\n+\treturn rule.Protocol == PolicyRuleProtocolALL || (rule.Protocol == PolicyRuleProtocolTCP && (portsIncludesSSH(rule.Ports) || portRangeIncludesSSH(rule.PortRanges)))\n+}\n+\n+func portRangeIncludesSSH(portRanges []RulePortRange) bool {\n+\tfor _, pr := range portRanges {\n+\t\tif (pr.Start <= defaultSSHPortNumber && pr.End >= defaultSSHPortNumber) || (pr.Start <= nativeSSHPortNumber && pr.End >= nativeSSHPortNumber) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+func portsIncludesSSH(ports []string) bool {\n+\tfor _, port := range ports {\n+\t\tif port == defaultSSHPortString || port == nativeSSHPortString {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n // getAllPeersFromGroups for given peer ID and list of groups\n //\n // Returns a list of peers from specified groups that pass specified posture checks\n@@ -1660,6 +1737,26 @@ func (a *Account) AddAllGroup(disableDefaultPolicy bool) error {\n \treturn nil\n }\n \n+func (a *Account) GetActiveGroupUsers() map[string][]string {\n+\tallGroupID := \"\"\n+\tgroup, err := a.GetGroupAll()\n+\tif err != nil {\n+\t\tlog.Errorf(\"failed to get group all: %v\", err)\n+\t} else {\n+\t\tallGroupID = group.ID\n+\t}\n+\tgroups := make(map[string][]string, len(a.GroupsG))\n+\tfor _, user := range a.Users {\n+\t\tif !user.IsBlocked() && !user.IsServiceUser {\n+\t\t\tfor _, groupID := range user.AutoGroups {\n+\t\t\t\tgroups[groupID] = append(groups[groupID], user.Id)\n+\t\t\t}\n+\t\t\tgroups[allGroupID] = append(groups[allGroupID], user.Id)\n+\t\t}\n+\t}\n+\treturn groups\n+}\n+\n // expandPortsAndRanges expands Ports and PortRanges of a rule into individual firewall rules\n func expandPortsAndRanges(base FirewallRule, rule *PolicyRule, peer *nbpeer.Peer) []*FirewallRule {\n \tfeatures := peerSupportedFirewallFeatures(peer.Meta.WtVersion)\n@@ -1691,7 +1788,7 @@ func expandPortsAndRanges(base FirewallRule, rule *PolicyRule, peer *nbpeer.Peer\n \t\texpanded = append(expanded, &fr)\n \t}\n \n-\tif shouldCheckRulesForNativeSSH(features.nativeSSH, rule, peer) {\n+\tif shouldCheckRulesForNativeSSH(features.nativeSSH, rule, peer) || rule.Protocol == PolicyRuleProtocolNetbirdSSH {\n \t\texpanded = addNativeSSHRule(base, expanded)\n \t}\n \ndiff --git a/management/server/types/network.go b/management/server/types/network.go\nindex ffc01956517..d3708d80af5 100644\n--- a/management/server/types/network.go\n+++ b/management/server/types/network.go\n@@ -38,6 +38,8 @@ type NetworkMap struct {\n \tFirewallRules       []*FirewallRule\n \tRoutesFirewallRules []*RouteFirewallRule\n \tForwardingRules     []*ForwardingRule\n+\tAuthorizedUsers     map[string]map[string]struct{}\n+\tEnableSSH           bool\n }\n \n func (nm *NetworkMap) Merge(other *NetworkMap) {\ndiff --git a/management/server/types/policy.go b/management/server/types/policy.go\nindex c7ac7b6aeaa..d4e1a8816b9 100644\n--- a/management/server/types/policy.go\n+++ b/management/server/types/policy.go\n@@ -170,7 +170,7 @@ func ParseRuleString(rule string) (PolicyRuleProtocolType, RulePortRange, error)\n \tcase \"icmp\":\n \t\treturn \"\", RulePortRange{}, errors.New(\"icmp does not accept ports; use 'icmp' without '/…'\")\n \tcase \"netbird-ssh\":\n-\t\treturn PolicyRuleProtocolNetbirdSSH, RulePortRange{Start: 22, End: 22}, nil\n+\t\treturn PolicyRuleProtocolNetbirdSSH, RulePortRange{Start: nativeSSHPortNumber, End: nativeSSHPortNumber}, nil\n \tdefault:\n \t\treturn \"\", RulePortRange{}, fmt.Errorf(\"invalid protocol: %q\", protoStr)\n \t}\ndiff --git a/management/server/user.go b/management/server/user.go\nindex ca02f91e67e..9d4620462cf 100644\n--- a/management/server/user.go\n+++ b/management/server/user.go\n@@ -523,16 +523,14 @@ func (am *DefaultAccountManager) SaveOrAddUsers(ctx context.Context, accountID,\n \t\t}\n \n \t\terr = am.Store.ExecuteInTransaction(ctx, func(transaction store.Store) error {\n-\t\t\tuserHadPeers, updatedUser, userPeersToExpire, userEvents, err := am.processUserUpdate(\n+\t\t\t_, updatedUser, userPeersToExpire, userEvents, err := am.processUserUpdate(\n \t\t\t\tctx, transaction, groupsMap, accountID, initiatorUserID, initiatorUser, update, addIfNotExists, settings,\n \t\t\t)\n \t\t\tif err != nil {\n \t\t\t\treturn fmt.Errorf(\"failed to process update for user %s: %w\", update.Id, err)\n \t\t\t}\n \n-\t\t\tif userHadPeers {\n-\t\t\t\tupdateAccountPeers = true\n-\t\t\t}\n+\t\t\tupdateAccountPeers = true\n \n \t\t\terr = transaction.SaveUser(ctx, updatedUser)\n \t\t\tif err != nil {\n@@ -581,7 +579,7 @@ func (am *DefaultAccountManager) SaveOrAddUsers(ctx context.Context, accountID,\n \t\t}\n \t}\n \n-\tif settings.GroupsPropagationEnabled && updateAccountPeers {\n+\tif updateAccountPeers {\n \t\tif err = am.Store.IncrementNetworkSerial(ctx, accountID); err != nil {\n \t\t\treturn nil, fmt.Errorf(\"failed to increment network serial: %w\", err)\n \t\t}\n", "test_patch": "diff --git a/client/ssh/auth/auth_test.go b/client/ssh/auth/auth_test.go\nindex e7c2e9a1315..b51ddcab9b4 100644\n--- a/client/ssh/auth/auth_test.go\n+++ b/client/ssh/auth/auth_test.go\n@@ -404,3 +404,150 @@ func TestAuthorizer_ConcurrentAuthorization(t *testing.T) {\n \t\tassert.NoError(t, err)\n \t}\n }\n+\n+func TestAuthorizer_Wildcard_AllowsAllAuthorizedUsers(t *testing.T) {\n+\tauthorizer := NewAuthorizer()\n+\n+\tuser1Hash, err := sshauth.HashUserID(\"user1\")\n+\trequire.NoError(t, err)\n+\tuser2Hash, err := sshauth.HashUserID(\"user2\")\n+\trequire.NoError(t, err)\n+\tuser3Hash, err := sshauth.HashUserID(\"user3\")\n+\trequire.NoError(t, err)\n+\n+\t// Configure with wildcard - all authorized users can access any OS user\n+\tconfig := &Config{\n+\t\tUserIDClaim:     DefaultUserIDClaim,\n+\t\tAuthorizedUsers: []sshauth.UserIDHash{user1Hash, user2Hash, user3Hash},\n+\t\tMachineUsers: map[string][]uint32{\n+\t\t\t\"*\": {0}, // wildcard with any indexes - indexes don't matter\n+\t\t},\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// All authorized users should be able to access any OS user\n+\terr = authorizer.Authorize(\"user1\", \"root\")\n+\tassert.NoError(t, err)\n+\n+\terr = authorizer.Authorize(\"user2\", \"postgres\")\n+\tassert.NoError(t, err)\n+\n+\terr = authorizer.Authorize(\"user3\", \"admin\")\n+\tassert.NoError(t, err)\n+\n+\terr = authorizer.Authorize(\"user1\", \"ubuntu\")\n+\tassert.NoError(t, err)\n+\n+\terr = authorizer.Authorize(\"user2\", \"nginx\")\n+\tassert.NoError(t, err)\n+\n+\terr = authorizer.Authorize(\"user3\", \"docker\")\n+\tassert.NoError(t, err)\n+}\n+\n+func TestAuthorizer_Wildcard_UnauthorizedUserStillDenied(t *testing.T) {\n+\tauthorizer := NewAuthorizer()\n+\n+\tuser1Hash, err := sshauth.HashUserID(\"user1\")\n+\trequire.NoError(t, err)\n+\n+\t// Configure with wildcard\n+\tconfig := &Config{\n+\t\tUserIDClaim:     DefaultUserIDClaim,\n+\t\tAuthorizedUsers: []sshauth.UserIDHash{user1Hash},\n+\t\tMachineUsers: map[string][]uint32{\n+\t\t\t\"*\": {0},\n+\t\t},\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// user1 should have access\n+\terr = authorizer.Authorize(\"user1\", \"root\")\n+\tassert.NoError(t, err)\n+\n+\t// Unauthorized user should still be denied even with wildcard\n+\terr = authorizer.Authorize(\"unauthorized-user\", \"root\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrUserNotAuthorized)\n+}\n+\n+func TestAuthorizer_Wildcard_TakesPrecedenceOverSpecificMappings(t *testing.T) {\n+\tauthorizer := NewAuthorizer()\n+\n+\tuser1Hash, err := sshauth.HashUserID(\"user1\")\n+\trequire.NoError(t, err)\n+\tuser2Hash, err := sshauth.HashUserID(\"user2\")\n+\trequire.NoError(t, err)\n+\n+\t// Configure with both wildcard and specific mappings - wildcard should take precedence\n+\tconfig := &Config{\n+\t\tUserIDClaim:     DefaultUserIDClaim,\n+\t\tAuthorizedUsers: []sshauth.UserIDHash{user1Hash, user2Hash},\n+\t\tMachineUsers: map[string][]uint32{\n+\t\t\t\"*\":    {0}, // wildcard exists\n+\t\t\t\"root\": {0}, // specific mapping that would normally restrict to user1 only\n+\t\t},\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// Both users should be able to access root because wildcard takes precedence\n+\terr = authorizer.Authorize(\"user1\", \"root\")\n+\tassert.NoError(t, err)\n+\n+\terr = authorizer.Authorize(\"user2\", \"root\")\n+\tassert.NoError(t, err)\n+\n+\t// Both users should be able to access any other OS user via wildcard\n+\terr = authorizer.Authorize(\"user1\", \"postgres\")\n+\tassert.NoError(t, err)\n+\n+\terr = authorizer.Authorize(\"user2\", \"admin\")\n+\tassert.NoError(t, err)\n+}\n+\n+func TestAuthorizer_NoWildcard_SpecificMappingsOnly(t *testing.T) {\n+\tauthorizer := NewAuthorizer()\n+\n+\tuser1Hash, err := sshauth.HashUserID(\"user1\")\n+\trequire.NoError(t, err)\n+\tuser2Hash, err := sshauth.HashUserID(\"user2\")\n+\trequire.NoError(t, err)\n+\n+\t// Configure WITHOUT wildcard - only specific mappings\n+\tconfig := &Config{\n+\t\tUserIDClaim:     DefaultUserIDClaim,\n+\t\tAuthorizedUsers: []sshauth.UserIDHash{user1Hash, user2Hash},\n+\t\tMachineUsers: map[string][]uint32{\n+\t\t\t\"root\":     {0}, // only user1\n+\t\t\t\"postgres\": {1}, // only user2\n+\t\t},\n+\t}\n+\tauthorizer.Update(config)\n+\n+\t// user1 can access root\n+\terr = authorizer.Authorize(\"user1\", \"root\")\n+\tassert.NoError(t, err)\n+\n+\t// user2 can access postgres\n+\terr = authorizer.Authorize(\"user2\", \"postgres\")\n+\tassert.NoError(t, err)\n+\n+\t// user1 cannot access postgres\n+\terr = authorizer.Authorize(\"user1\", \"postgres\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrUserNotMappedToOSUser)\n+\n+\t// user2 cannot access root\n+\terr = authorizer.Authorize(\"user2\", \"root\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrUserNotMappedToOSUser)\n+\n+\t// Neither can access unmapped OS users\n+\terr = authorizer.Authorize(\"user1\", \"admin\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrNoMachineUserMapping)\n+\n+\terr = authorizer.Authorize(\"user2\", \"admin\")\n+\tassert.Error(t, err)\n+\tassert.ErrorIs(t, err, ErrNoMachineUserMapping)\n+}\ndiff --git a/management/server/account_test.go b/management/server/account_test.go\nindex 7f125e3a0c8..25818ada29d 100644\n--- a/management/server/account_test.go\n+++ b/management/server/account_test.go\n@@ -397,7 +397,7 @@ func TestAccount_GetPeerNetworkMap(t *testing.T) {\n \t\t}\n \n \t\tcustomZone := account.GetPeersCustomZone(context.Background(), \"netbird.io\")\n-\t\tnetworkMap := account.GetPeerNetworkMap(context.Background(), testCase.peerID, customZone, validatedPeers, account.GetResourcePoliciesMap(), account.GetResourceRoutersMap(), nil)\n+\t\tnetworkMap := account.GetPeerNetworkMap(context.Background(), testCase.peerID, customZone, validatedPeers, account.GetResourcePoliciesMap(), account.GetResourceRoutersMap(), nil, account.GetActiveGroupUsers())\n \t\tassert.Len(t, networkMap.Peers, len(testCase.expectedPeers))\n \t\tassert.Len(t, networkMap.OfflinePeers, len(testCase.expectedOfflinePeers))\n \t}\ndiff --git a/management/server/policy_test.go b/management/server/policy_test.go\nindex 90fe8f0368c..a3f987732d0 100644\n--- a/management/server/policy_test.go\n+++ b/management/server/policy_test.go\n@@ -246,14 +246,14 @@ func TestAccount_getPeersByPolicy(t *testing.T) {\n \n \tt.Run(\"check that all peers get map\", func(t *testing.T) {\n \t\tfor _, p := range account.Peers {\n-\t\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), p, validatedPeers)\n+\t\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), p, validatedPeers, account.GetActiveGroupUsers())\n \t\t\tassert.GreaterOrEqual(t, len(peers), 1, \"minimum number peers should present\")\n \t\t\tassert.GreaterOrEqual(t, len(firewallRules), 1, \"minimum number of firewall rules should present\")\n \t\t}\n \t})\n \n \tt.Run(\"check first peer map details\", func(t *testing.T) {\n-\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], validatedPeers)\n+\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], validatedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 8)\n \t\tassert.Contains(t, peers, account.Peers[\"peerA\"])\n \t\tassert.Contains(t, peers, account.Peers[\"peerC\"])\n@@ -509,7 +509,7 @@ func TestAccount_getPeersByPolicy(t *testing.T) {\n \t})\n \n \tt.Run(\"check port ranges support for older peers\", func(t *testing.T) {\n-\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerK\"], validatedPeers)\n+\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerK\"], validatedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 1)\n \t\tassert.Contains(t, peers, account.Peers[\"peerI\"])\n \n@@ -635,7 +635,7 @@ func TestAccount_getPeersByPolicyDirect(t *testing.T) {\n \t}\n \n \tt.Run(\"check first peer map\", func(t *testing.T) {\n-\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Contains(t, peers, account.Peers[\"peerC\"])\n \n \t\texpectedFirewallRules := []*types.FirewallRule{\n@@ -665,7 +665,7 @@ func TestAccount_getPeersByPolicyDirect(t *testing.T) {\n \t})\n \n \tt.Run(\"check second peer map\", func(t *testing.T) {\n-\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerC\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerC\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Contains(t, peers, account.Peers[\"peerB\"])\n \n \t\texpectedFirewallRules := []*types.FirewallRule{\n@@ -697,7 +697,7 @@ func TestAccount_getPeersByPolicyDirect(t *testing.T) {\n \taccount.Policies[1].Rules[0].Bidirectional = false\n \n \tt.Run(\"check first peer map directional only\", func(t *testing.T) {\n-\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Contains(t, peers, account.Peers[\"peerC\"])\n \n \t\texpectedFirewallRules := []*types.FirewallRule{\n@@ -719,7 +719,7 @@ func TestAccount_getPeersByPolicyDirect(t *testing.T) {\n \t})\n \n \tt.Run(\"check second peer map directional only\", func(t *testing.T) {\n-\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerC\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerC\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Contains(t, peers, account.Peers[\"peerB\"])\n \n \t\texpectedFirewallRules := []*types.FirewallRule{\n@@ -917,7 +917,7 @@ func TestAccount_getPeersByPolicyPostureChecks(t *testing.T) {\n \tt.Run(\"verify peer's network map with default group peer list\", func(t *testing.T) {\n \t\t// peerB doesn't fulfill the NB posture check but is included in the destination group Swarm,\n \t\t// will establish a connection with all source peers satisfying the NB posture check.\n-\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 4)\n \t\tassert.Len(t, firewallRules, 4)\n \t\tassert.Contains(t, peers, account.Peers[\"peerA\"])\n@@ -927,7 +927,7 @@ func TestAccount_getPeersByPolicyPostureChecks(t *testing.T) {\n \n \t\t// peerC satisfy the NB posture check, should establish connection to all destination group peer's\n \t\t// We expect a single permissive firewall rule which all outgoing connections\n-\t\tpeers, firewallRules = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerC\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerC\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, len(account.Groups[\"GroupSwarm\"].Peers))\n \t\tassert.Len(t, firewallRules, 7)\n \t\texpectedFirewallRules := []*types.FirewallRule{\n@@ -992,7 +992,7 @@ func TestAccount_getPeersByPolicyPostureChecks(t *testing.T) {\n \n \t\t// peerE doesn't fulfill the NB posture check and exists in only destination group Swarm,\n \t\t// all source group peers satisfying the NB posture check should establish connection\n-\t\tpeers, firewallRules = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerE\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerE\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 4)\n \t\tassert.Len(t, firewallRules, 4)\n \t\tassert.Contains(t, peers, account.Peers[\"peerA\"])\n@@ -1002,7 +1002,7 @@ func TestAccount_getPeersByPolicyPostureChecks(t *testing.T) {\n \n \t\t// peerI doesn't fulfill the OS version posture check and exists in only destination group Swarm,\n \t\t// all source group peers satisfying the NB posture check should establish connection\n-\t\tpeers, firewallRules = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerI\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerI\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 4)\n \t\tassert.Len(t, firewallRules, 4)\n \t\tassert.Contains(t, peers, account.Peers[\"peerA\"])\n@@ -1017,19 +1017,19 @@ func TestAccount_getPeersByPolicyPostureChecks(t *testing.T) {\n \n \t\t// peerB doesn't satisfy the NB posture check, and doesn't exist in destination group peer's\n \t\t// no connection should be established to any peer of destination group\n-\t\tpeers, firewallRules := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ := account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerB\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 0)\n \t\tassert.Len(t, firewallRules, 0)\n \n \t\t// peerI doesn't satisfy the OS version posture check, and doesn't exist in destination group peer's\n \t\t// no connection should be established to any peer of destination group\n-\t\tpeers, firewallRules = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerI\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerI\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 0)\n \t\tassert.Len(t, firewallRules, 0)\n \n \t\t// peerC satisfy the NB posture check, should establish connection to all destination group peer's\n \t\t// We expect a single permissive firewall rule which all outgoing connections\n-\t\tpeers, firewallRules = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerC\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerC\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, len(account.Groups[\"GroupSwarm\"].Peers))\n \t\tassert.Len(t, firewallRules, len(account.Groups[\"GroupSwarm\"].Peers))\n \n@@ -1044,14 +1044,14 @@ func TestAccount_getPeersByPolicyPostureChecks(t *testing.T) {\n \n \t\t// peerE doesn't fulfill the NB posture check and exists in only destination group Swarm,\n \t\t// all source group peers satisfying the NB posture check should establish connection\n-\t\tpeers, firewallRules = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerE\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerE\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 3)\n \t\tassert.Len(t, firewallRules, 3)\n \t\tassert.Contains(t, peers, account.Peers[\"peerA\"])\n \t\tassert.Contains(t, peers, account.Peers[\"peerC\"])\n \t\tassert.Contains(t, peers, account.Peers[\"peerD\"])\n \n-\t\tpeers, firewallRules = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerA\"], approvedPeers)\n+\t\tpeers, firewallRules, _, _ = account.GetPeerConnectionResources(context.Background(), account.Peers[\"peerA\"], approvedPeers, account.GetActiveGroupUsers())\n \t\tassert.Len(t, peers, 5)\n \t\t// assert peers from Group Swarm\n \t\tassert.Contains(t, peers, account.Peers[\"peerD\"])\ndiff --git a/management/server/types/account_test.go b/management/server/types/account_test.go\nindex f9aa6a1c22a..2c9f2428db7 100644\n--- a/management/server/types/account_test.go\n+++ b/management/server/types/account_test.go\n@@ -1105,6 +1105,193 @@ func Test_ExpandPortsAndRanges_SSHRuleExpansion(t *testing.T) {\n \t}\n }\n \n+func Test_GetActiveGroupUsers(t *testing.T) {\n+\ttests := []struct {\n+\t\tname     string\n+\t\taccount  *Account\n+\t\texpected map[string][]string\n+\t}{\n+\t\t{\n+\t\t\tname: \"all users are active\",\n+\t\t\taccount: &Account{\n+\t\t\t\tUsers: map[string]*User{\n+\t\t\t\t\t\"user1\": {\n+\t\t\t\t\t\tId:         \"user1\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\", \"group2\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user2\": {\n+\t\t\t\t\t\tId:         \"user2\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group2\", \"group3\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user3\": {\n+\t\t\t\t\t\tId:         \"user3\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: map[string][]string{\n+\t\t\t\t\"group1\": {\"user1\", \"user3\"},\n+\t\t\t\t\"group2\": {\"user1\", \"user2\"},\n+\t\t\t\t\"group3\": {\"user2\"},\n+\t\t\t\t\"\":       {\"user1\", \"user2\", \"user3\"},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"some users are blocked\",\n+\t\t\taccount: &Account{\n+\t\t\t\tUsers: map[string]*User{\n+\t\t\t\t\t\"user1\": {\n+\t\t\t\t\t\tId:         \"user1\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\", \"group2\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user2\": {\n+\t\t\t\t\t\tId:         \"user2\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group2\", \"group3\"},\n+\t\t\t\t\t\tBlocked:    true,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user3\": {\n+\t\t\t\t\t\tId:         \"user3\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\", \"group3\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: map[string][]string{\n+\t\t\t\t\"group1\": {\"user1\", \"user3\"},\n+\t\t\t\t\"group2\": {\"user1\"},\n+\t\t\t\t\"group3\": {\"user3\"},\n+\t\t\t\t\"\":       {\"user1\", \"user3\"},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"all users are blocked\",\n+\t\t\taccount: &Account{\n+\t\t\t\tUsers: map[string]*User{\n+\t\t\t\t\t\"user1\": {\n+\t\t\t\t\t\tId:         \"user1\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\"},\n+\t\t\t\t\t\tBlocked:    true,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user2\": {\n+\t\t\t\t\t\tId:         \"user2\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group2\"},\n+\t\t\t\t\t\tBlocked:    true,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: map[string][]string{},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"user with no auto groups\",\n+\t\t\taccount: &Account{\n+\t\t\t\tUsers: map[string]*User{\n+\t\t\t\t\t\"user1\": {\n+\t\t\t\t\t\tId:         \"user1\",\n+\t\t\t\t\t\tAutoGroups: []string{},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user2\": {\n+\t\t\t\t\t\tId:         \"user2\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: map[string][]string{\n+\t\t\t\t\"group1\": {\"user2\"},\n+\t\t\t\t\"\":       {\"user1\", \"user2\"},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"empty account\",\n+\t\t\taccount: &Account{\n+\t\t\t\tUsers: map[string]*User{},\n+\t\t\t},\n+\t\t\texpected: map[string][]string{},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"multiple users in same group\",\n+\t\t\taccount: &Account{\n+\t\t\t\tUsers: map[string]*User{\n+\t\t\t\t\t\"user1\": {\n+\t\t\t\t\t\tId:         \"user1\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user2\": {\n+\t\t\t\t\t\tId:         \"user2\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user3\": {\n+\t\t\t\t\t\tId:         \"user3\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: map[string][]string{\n+\t\t\t\t\"group1\": {\"user1\", \"user2\", \"user3\"},\n+\t\t\t\t\"\":       {\"user1\", \"user2\", \"user3\"},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"user in multiple groups with blocked users\",\n+\t\t\taccount: &Account{\n+\t\t\t\tUsers: map[string]*User{\n+\t\t\t\t\t\"user1\": {\n+\t\t\t\t\t\tId:         \"user1\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\", \"group2\", \"group3\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user2\": {\n+\t\t\t\t\t\tId:         \"user2\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group1\", \"group2\"},\n+\t\t\t\t\t\tBlocked:    true,\n+\t\t\t\t\t},\n+\t\t\t\t\t\"user3\": {\n+\t\t\t\t\t\tId:         \"user3\",\n+\t\t\t\t\t\tAutoGroups: []string{\"group3\"},\n+\t\t\t\t\t\tBlocked:    false,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpected: map[string][]string{\n+\t\t\t\t\"group1\": {\"user1\"},\n+\t\t\t\t\"group2\": {\"user1\"},\n+\t\t\t\t\"group3\": {\"user1\", \"user3\"},\n+\t\t\t\t\"\":       {\"user1\", \"user3\"},\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tresult := tt.account.GetActiveGroupUsers()\n+\n+\t\t\t// Check that the number of groups matches\n+\t\t\tassert.Equal(t, len(tt.expected), len(result), \"number of groups should match\")\n+\n+\t\t\t// Check each group's users\n+\t\t\tfor groupID, expectedUsers := range tt.expected {\n+\t\t\t\tactualUsers, exists := result[groupID]\n+\t\t\t\tassert.True(t, exists, \"group %s should exist in result\", groupID)\n+\t\t\t\tassert.ElementsMatch(t, expectedUsers, actualUsers, \"users in group %s should match\", groupID)\n+\t\t\t}\n+\n+\t\t\t// Ensure no extra groups in result\n+\t\t\tfor groupID := range result {\n+\t\t\t\t_, exists := tt.expected[groupID]\n+\t\t\t\tassert.True(t, exists, \"unexpected group %s in result\", groupID)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n func Test_FilterZoneRecordsForPeers(t *testing.T) {\n \ttests := []struct {\n \t\tname            string\ndiff --git a/management/server/types/networkmap_golden_test.go b/management/server/types/networkmap_golden_test.go\nindex d85aaabb212..913094e4c90 100644\n--- a/management/server/types/networkmap_golden_test.go\n+++ b/management/server/types/networkmap_golden_test.go\n@@ -69,7 +69,7 @@ func TestGetPeerNetworkMap_Golden(t *testing.T) {\n \tresourcePolicies := account.GetResourcePoliciesMap()\n \trouters := account.GetResourceRoutersMap()\n \n-\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil)\n+\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil, account.GetActiveGroupUsers())\n \n \tnormalizeAndSortNetworkMap(networkMap)\n \n@@ -141,7 +141,7 @@ func BenchmarkGetPeerNetworkMap(b *testing.B) {\n \tb.Run(\"old builder\", func(b *testing.B) {\n \t\tfor range b.N {\n \t\t\tfor _, peerID := range peerIDs {\n-\t\t\t\t_ = account.GetPeerNetworkMap(ctx, peerID, dns.CustomZone{}, validatedPeersMap, nil, nil, nil)\n+\t\t\t\t_ = account.GetPeerNetworkMap(ctx, peerID, dns.CustomZone{}, validatedPeersMap, nil, nil, nil, account.GetActiveGroupUsers())\n \t\t\t}\n \t\t}\n \t})\n@@ -201,7 +201,7 @@ func TestGetPeerNetworkMap_Golden_WithNewPeer(t *testing.T) {\n \tresourcePolicies := account.GetResourcePoliciesMap()\n \trouters := account.GetResourceRoutersMap()\n \n-\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil)\n+\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil, account.GetActiveGroupUsers())\n \n \tnormalizeAndSortNetworkMap(networkMap)\n \n@@ -320,7 +320,7 @@ func BenchmarkGetPeerNetworkMap_AfterPeerAdded(b *testing.B) {\n \tb.Run(\"old builder after add\", func(b *testing.B) {\n \t\tfor i := 0; i < b.N; i++ {\n \t\t\tfor _, testingPeerID := range peerIDs {\n-\t\t\t\t_ = account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, nil, nil, nil)\n+\t\t\t\t_ = account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, nil, nil, nil, account.GetActiveGroupUsers())\n \t\t\t}\n \t\t}\n \t})\n@@ -395,7 +395,7 @@ func TestGetPeerNetworkMap_Golden_WithNewRoutingPeer(t *testing.T) {\n \tresourcePolicies := account.GetResourcePoliciesMap()\n \trouters := account.GetResourceRoutersMap()\n \n-\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil)\n+\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil, account.GetActiveGroupUsers())\n \n \tnormalizeAndSortNetworkMap(networkMap)\n \n@@ -550,7 +550,7 @@ func BenchmarkGetPeerNetworkMap_AfterRouterPeerAdded(b *testing.B) {\n \tb.Run(\"old builder after add\", func(b *testing.B) {\n \t\tfor i := 0; i < b.N; i++ {\n \t\t\tfor _, testingPeerID := range peerIDs {\n-\t\t\t\t_ = account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, nil, nil, nil)\n+\t\t\t\t_ = account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, nil, nil, nil, account.GetActiveGroupUsers())\n \t\t\t}\n \t\t}\n \t})\n@@ -604,7 +604,7 @@ func TestGetPeerNetworkMap_Golden_WithDeletedPeer(t *testing.T) {\n \tresourcePolicies := account.GetResourcePoliciesMap()\n \trouters := account.GetResourceRoutersMap()\n \n-\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil)\n+\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil, account.GetActiveGroupUsers())\n \n \tnormalizeAndSortNetworkMap(networkMap)\n \n@@ -730,7 +730,7 @@ func TestGetPeerNetworkMap_Golden_WithDeletedRouterPeer(t *testing.T) {\n \tresourcePolicies := account.GetResourcePoliciesMap()\n \trouters := account.GetResourceRoutersMap()\n \n-\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil)\n+\tnetworkMap := account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, resourcePolicies, routers, nil, account.GetActiveGroupUsers())\n \n \tnormalizeAndSortNetworkMap(networkMap)\n \n@@ -847,7 +847,7 @@ func BenchmarkGetPeerNetworkMap_AfterPeerDeleted(b *testing.B) {\n \tb.Run(\"old builder after delete\", func(b *testing.B) {\n \t\tfor i := 0; i < b.N; i++ {\n \t\t\tfor _, testingPeerID := range peerIDs {\n-\t\t\t\t_ = account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, nil, nil, nil)\n+\t\t\t\t_ = account.GetPeerNetworkMap(ctx, testingPeerID, dns.CustomZone{}, validatedPeersMap, nil, nil, nil, account.GetActiveGroupUsers())\n \t\t\t}\n \t\t}\n \t})\ndiff --git a/management/server/user_test.go b/management/server/user_test.go\nindex 0d778cfa2b7..3032ee3e8ab 100644\n--- a/management/server/user_test.go\n+++ b/management/server/user_test.go\n@@ -1379,11 +1379,11 @@ func TestUserAccountPeersUpdate(t *testing.T) {\n \t\tupdateManager.CloseChannel(context.Background(), peer1.ID)\n \t})\n \n-\t// Creating a new regular user should not update account peers and not send peer update\n+\t// Creating a new regular user should send peer update (as users are not filtered yet)\n \tt.Run(\"creating new regular user with no groups\", func(t *testing.T) {\n \t\tdone := make(chan struct{})\n \t\tgo func() {\n-\t\t\tpeerShouldNotReceiveUpdate(t, updMsg)\n+\t\t\tpeerShouldReceiveUpdate(t, updMsg)\n \t\t\tclose(done)\n \t\t}()\n \n@@ -1402,11 +1402,11 @@ func TestUserAccountPeersUpdate(t *testing.T) {\n \t\t}\n \t})\n \n-\t// updating user with no linked peers should not update account peers and not send peer update\n+\t// updating user with no linked peers should update account peers and send peer update (as users are not filtered yet)\n \tt.Run(\"updating user with no linked peers\", func(t *testing.T) {\n \t\tdone := make(chan struct{})\n \t\tgo func() {\n-\t\t\tpeerShouldNotReceiveUpdate(t, updMsg)\n+\t\t\tpeerShouldReceiveUpdate(t, updMsg)\n \t\t\tclose(done)\n \t\t}()\n \n"}
{"org": "netbirdio", "repo": "netbird", "number": 4015, "state": "closed", "title": "[client,management] Rewrite the SSH feature", "body": "## Describe your changes\r\n\r\n\r\n### NetBird SSH Client\r\n- Port forwarding\r\n- Windows support\r\n- Non-interactive commands\r\n- Single command execution over SSH\r\n\r\n### SSH Server\r\n- SFTP\r\n- Port forwarding (without user switching)\r\n- PTY (interactive, non-interactive)\r\n- Non-PTY (commands)\r\n- Windows support\r\n- JWT auth (user identity instead of machine identity, can be turned off) \r\n\r\n### New Flags\r\n```\r\n# server\r\n--enable-ssh-local-port-forwarding\r\n--enable-ssh-remote-port-forwarding\r\n--enable-ssh-root\r\n--enable-ssh-sftp\r\n--disable-ssh-auth\r\n\r\n# client\r\n--ssh-jwt-cache-ttl\r\n```\r\n\r\n### UI\r\n\r\n- Better organization\r\n<img width=\"608\" height=\"432\" alt=\"image\" src=\"https://github.com/user-attachments/assets/7e8f7415-7f7f-47f4-b945-d1e6135e8bd7\" />\r\n\r\n<img width=\"608\" height=\"432\" alt=\"image\" src=\"https://github.com/user-attachments/assets/d463c3d3-0742-4700-91ca-29db0b47c1f4\" />\r\n \r\n<img width=\"608\" height=\"432\" alt=\"image\" src=\"https://github.com/user-attachments/assets/8023d3de-f6fd-4c5d-8985-a49a452a6491\" />\r\n\r\n\r\n### Changes\r\n- Default port changed to 22022\r\n- Redirect port 22 to 22022 when SSH server enabled\r\n- Remove implicit OpenSSH firewall port\r\n- Management now passes its `jwks` config to peers with enabled ssh server\r\n- SSH server peers verify incoming clients' `jwt` with max token age \r\n- SSH clients request `jwt`s from the IdP and send these for authentication with remote ssh peers\r\n- Add `netbird ssh detect` command to detect if the remote peer is running the NetBird server\r\n- Add `netbird ssh proxy` command for native ssh and sftp clients. The proxy requests `jwt`s just like `netbird ssh`, passes them for authentication and bridges the connection between the native client and the remote server.\r\n- Add jwt capability to the wasm ssh client\r\n\r\n\r\n### Auth Flows\r\n\r\n  1. NetBird SSH Flow (`netbird ssh <peer>`)\r\n\r\n  ```mermaid\r\n  flowchart TD\r\n      A[User: netbird ssh &lt;peer&gt;] --> B[Connect to peer:22]\r\n      B --> C[Detect Server Type]\r\n      C --> D[Send 'netbird-detect' request]\r\n\r\n      D --> E{Server Response}\r\n\r\n      E -->|No NetBird identifier| F[Regular SSH Server]\r\n      E -->|NetBird + JWT required| G[NetBird with JWT Auth]\r\n      E -->|NetBird + No JWT| H[NetBird without JWT]\r\n\r\n      F --> I[Standard SSH Connection]\r\n      H --> I\r\n\r\n      G --> J[Request JWT from NetBird daemon]\r\n\r\n      J --> J1{Check JWT cache}\r\n      J1 -->|Cache valid| J2[Use cached JWT token]\r\n      J1 -->|No cache/expired| J3[OIDC flow:<br/>User authorizes via IDP callback]\r\n      J3 --> J4[Receive & cache JWT token]\r\n      J4 --> K[Connect to peer SSH server]\r\n      J2 --> K\r\n\r\n      K --> M[Send JWT authentication request]\r\n      M --> N{JWT Valid?}\r\n\r\n      N -->|No| O[Connection Rejected]\r\n      N -->|Yes| P[SSH Session Established]\r\n      I --> P\r\n\r\n      P --> Q[Interactive Shell / Execute Command / Port Forwarding]\r\n\r\n      style G fill:#f57c00,color:#fff\r\n      style J fill:#1976d2,color:#fff\r\n      style J1 fill:#1976d2,color:#fff\r\n      style J3 fill:#e65100,color:#fff\r\n      style P fill:#388e3c,color:#fff\r\n  ```\r\n\r\n  2. Native SSH Flow (e.g. openssh client)\r\n\r\n  ```mermaid\r\n  flowchart TD\r\n      A[User: ssh &lt;peer&gt;] --> B[OpenSSH loads config:<br/>/etc/ssh/ssh_config.d/99-netbird.conf]\r\n      B --> D{Host matches NetBird pattern?}\r\n\r\n      D -->|No| E[Standard SSH connection]\r\n\r\n      D -->|Yes| F[Run detection check:<br/>netbird ssh detect &lt;peer&gt; 22]\r\n      F --> G{Is NetBird SSH server?}\r\n\r\n      G -->|No| E\r\n\r\n      G -->|Yes - JWT required| H[Activate ProxyCommand:<br/>netbird ssh proxy &lt;peer&gt; 22]\r\n\r\n      H --> I[Local SSH Proxy Started]\r\n      I --> J[OpenSSH connects to proxy via stdio]\r\n\r\n      J --> K[Proxy requests JWT from daemon]\r\n\r\n      K --> K1{Check JWT cache}\r\n      K1 -->|Cache valid| K2[Use cached JWT token]\r\n      K1 -->|No cache/expired| K3[OIDC flow:<br/>User authorizes via IDP callback]\r\n      K3 --> K4[Receive & cache JWT token]\r\n      K4 --> L[Proxy connects to peer SSH server]\r\n      K2 --> L\r\n\r\n      L --> M[Proxy sends JWT authentication]\r\n\r\n      M --> N{JWT Valid?}\r\n      N -->|No| O[Connection Rejected]\r\n      N -->|Yes| P[Proxy establishes session]\r\n\r\n      P --> Q[Bidirectional forwarding:<br/>OpenSSH ↔ Proxy ↔ Peer SSH Server]\r\n\r\n      Q --> R[User interacts with remote shell]\r\n\r\n      style H fill:#f57c00,color:#fff\r\n      style I fill:#1976d2,color:#fff\r\n      style K fill:#1976d2,color:#fff\r\n      style K1 fill:#1976d2,color:#fff\r\n      style K3 fill:#e65100,color:#fff\r\n      style Q fill:#388e3c,color:#fff\r\n\r\n      classDef proxyBox fill:#1565c0,stroke:#0d47a1,stroke-width:2px,color:#fff\r\n      class I,K,L,M,P,Q proxyBox\r\n  ```\r\n\r\n## Issue ticket number and link\r\n\r\nFixes https://github.com/netbirdio/netbird/issues/4759 https://github.com/netbirdio/netbird/issues/4672 https://github.com/netbirdio/netbird/issues/4456  https://github.com/netbirdio/netbird/issues/4039 https://github.com/netbirdio/netbird/issues/3985 https://github.com/netbirdio/netbird/issues/2498 https://github.com/netbirdio/netbird/issues/4457\r\n\r\n\r\n## Stack\r\n\r\n<!-- branch-stack -->\r\n\r\n### Checklist\r\n- [x] Is it a bug fix\r\n- [ ] Is a typo/documentation fix\r\n- [x] Is a feature enhancement\r\n- [x] It is a refactor\r\n- [x] Created tests that fail without the change (if possible)\r\n- [ ] Extended the README / documentation, if necessary\r\n\r\n## Documentation\r\nSelect exactly one:\r\n\r\n- [x] I added/updated documentation for this change [ netbirdio/docs/pull/475 ]\r\n- [ ] Documentation is **not needed** for this change \r\n---\r\n\r\n\r\n> By submitting this pull request, you confirm that you have read and agree to the terms of the [Contributor License Agreement](https://github.com/netbirdio/netbird/blob/main/CONTRIBUTOR_LICENSE_AGREEMENT.md).\r\n\r\n\r\n<!-- This is an auto-generated comment: release notes by coderabbit.ai -->\r\n## Summary by CodeRabbit\r\n\r\n* **New Features**\r\n  * Complete SSH support: embedded SSH server and client (JWT-backed auth), SFTP, local/remote port forwarding, SSH proxy, host-key retrieval, session listing, SSH client config generation, server detection, and UI/WASM controls including SSH JWT cache TTL.\r\n* **Bug Fixes**\r\n  * License check made quieter and more robust by suppressing noisy errors during scanning.\r\n<!-- end of auto-generated comment: release notes by coderabbit.ai -->", "url": "https://api.github.com/repos/netbirdio/netbird/pulls/4015", "id": 2605408068, "node_id": "PR_kwDOFVUT786bS19E", "html_url": "https://github.com/netbirdio/netbird/pull/4015", "diff_url": "https://github.com/netbirdio/netbird/pull/4015.diff", "patch_url": "https://github.com/netbirdio/netbird/pull/4015.patch", "issue_url": "https://api.github.com/repos/netbirdio/netbird/issues/4015", "created_at": "2025-06-19T17:33:36+00:00", "updated_at": "2025-11-17T16:10:44+00:00", "closed_at": "2025-11-17T16:10:42+00:00", "merged_at": "2025-11-17T16:10:41+00:00", "merge_commit_sha": "d71a82769c32238cf29bd1bb3bd3ec520c0c1ab9", "labels": [], "draft": false, "commits_url": "https://api.github.com/repos/netbirdio/netbird/pulls/4015/commits", "review_comments_url": "https://api.github.com/repos/netbirdio/netbird/pulls/4015/comments", "review_comment_url": "https://api.github.com/repos/netbirdio/netbird/pulls/comments{/number}", "comments_url": "https://api.github.com/repos/netbirdio/netbird/issues/4015/comments", "base": {"label": "netbirdio:main", "ref": "main", "sha": "e4b41d0ad70676b3f3f4a18f621b5467bd1c509c", "user": {"login": "netbirdio", "id": 100464677, "node_id": "O_kgDOBfz4JQ", "avatar_url": "https://avatars.githubusercontent.com/u/100464677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/netbirdio", "html_url": "https://github.com/netbirdio", "followers_url": "https://api.github.com/users/netbirdio/followers", "following_url": "https://api.github.com/users/netbirdio/following{/other_user}", "gists_url": "https://api.github.com/users/netbirdio/gists{/gist_id}", "starred_url": "https://api.github.com/users/netbirdio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/netbirdio/subscriptions", "organizations_url": "https://api.github.com/users/netbirdio/orgs", "repos_url": "https://api.github.com/users/netbirdio/repos", "events_url": "https://api.github.com/users/netbirdio/events{/privacy}", "received_events_url": "https://api.github.com/users/netbirdio/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "repo": {"id": 357897199, "node_id": "MDEwOlJlcG9zaXRvcnkzNTc4OTcxOTk=", "name": "netbird", "full_name": "netbirdio/netbird", "private": false, "owner": {"login": "netbirdio", "id": 100464677, "node_id": "O_kgDOBfz4JQ", "avatar_url": "https://avatars.githubusercontent.com/u/100464677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/netbirdio", "html_url": "https://github.com/netbirdio", "followers_url": "https://api.github.com/users/netbirdio/followers", "following_url": "https://api.github.com/users/netbirdio/following{/other_user}", "gists_url": "https://api.github.com/users/netbirdio/gists{/gist_id}", "starred_url": "https://api.github.com/users/netbirdio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/netbirdio/subscriptions", "organizations_url": "https://api.github.com/users/netbirdio/orgs", "repos_url": "https://api.github.com/users/netbirdio/repos", "events_url": "https://api.github.com/users/netbirdio/events{/privacy}", "received_events_url": "https://api.github.com/users/netbirdio/received_events", "type": "Organization", "user_view_type": "public", "site_admin": false}, "html_url": "https://github.com/netbirdio/netbird", "description": "Connect your devices into a secure WireGuard®-based overlay network with SSO, MFA and granular access controls.", "fork": false, "url": "https://api.github.com/repos/netbirdio/netbird", "forks_url": "https://api.github.com/repos/netbirdio/netbird/forks", "keys_url": "https://api.github.com/repos/netbirdio/netbird/keys{/key_id}", "collaborators_url": "https://api.github.com/repos/netbirdio/netbird/collaborators{/collaborator}", "teams_url": "https://api.github.com/repos/netbirdio/netbird/teams", "hooks_url": "https://api.github.com/repos/netbirdio/netbird/hooks", "issue_events_url": "https://api.github.com/repos/netbirdio/netbird/issues/events{/number}", "events_url": "https://api.github.com/repos/netbirdio/netbird/events", "assignees_url": "https://api.github.com/repos/netbirdio/netbird/assignees{/user}", "branches_url": "https://api.github.com/repos/netbirdio/netbird/branches{/branch}", "tags_url": "https://api.github.com/repos/netbirdio/netbird/tags", "blobs_url": "https://api.github.com/repos/netbirdio/netbird/git/blobs{/sha}", "git_tags_url": "https://api.github.com/repos/netbirdio/netbird/git/tags{/sha}", "git_refs_url": "https://api.github.com/repos/netbirdio/netbird/git/refs{/sha}", "trees_url": "https://api.github.com/repos/netbirdio/netbird/git/trees{/sha}", "statuses_url": "https://api.github.com/repos/netbirdio/netbird/statuses/{sha}", "languages_url": "https://api.github.com/repos/netbirdio/netbird/languages", "stargazers_url": "https://api.github.com/repos/netbirdio/netbird/stargazers", "contributors_url": "https://api.github.com/repos/netbirdio/netbird/contributors", "subscribers_url": "https://api.github.com/repos/netbirdio/netbird/subscribers", "subscription_url": "https://api.github.com/repos/netbirdio/netbird/subscription", "commits_url": "https://api.github.com/repos/netbirdio/netbird/commits{/sha}", "git_commits_url": "https://api.github.com/repos/netbirdio/netbird/git/commits{/sha}", "comments_url": "https://api.github.com/repos/netbirdio/netbird/comments{/number}", "issue_comment_url": "https://api.github.com/repos/netbirdio/netbird/issues/comments{/number}", "contents_url": "https://api.github.com/repos/netbirdio/netbird/contents/{+path}", "compare_url": "https://api.github.com/repos/netbirdio/netbird/compare/{base}...{head}", "merges_url": "https://api.github.com/repos/netbirdio/netbird/merges", "archive_url": "https://api.github.com/repos/netbirdio/netbird/{archive_format}{/ref}", "downloads_url": "https://api.github.com/repos/netbirdio/netbird/downloads", "issues_url": "https://api.github.com/repos/netbirdio/netbird/issues{/number}", "pulls_url": "https://api.github.com/repos/netbirdio/netbird/pulls{/number}", "milestones_url": "https://api.github.com/repos/netbirdio/netbird/milestones{/number}", "notifications_url": "https://api.github.com/repos/netbirdio/netbird/notifications{?since,all,participating}", "labels_url": "https://api.github.com/repos/netbirdio/netbird/labels{/name}", "releases_url": "https://api.github.com/repos/netbirdio/netbird/releases{/id}", "deployments_url": "https://api.github.com/repos/netbirdio/netbird/deployments", "created_at": "2021-04-14T12:27:20Z", "updated_at": "2026-01-07T04:18:10Z", "pushed_at": "2026-01-07T05:22:46Z", "git_url": "git://github.com/netbirdio/netbird.git", "ssh_url": "git@github.com:netbirdio/netbird.git", "clone_url": "https://github.com/netbirdio/netbird.git", "svn_url": "https://github.com/netbirdio/netbird", "homepage": "https://netbird.io", "size": 47404, "stargazers_count": 20703, "watchers_count": 20703, "language": "Go", "has_issues": true, "has_projects": true, "has_downloads": true, "has_wiki": true, "has_pages": false, "has_discussions": false, "forks_count": 1009, "mirror_url": null, "archived": false, "disabled": false, "open_issues_count": 1188, "license": {"key": "other", "name": "Other", "spdx_id": "NOASSERTION", "url": null, "node_id": "MDc6TGljZW5zZTA="}, "allow_forking": true, "is_template": false, "web_commit_signoff_required": false, "topics": ["golang", "mesh", "mesh-networks", "nat-traversal", "netbird", "vpn", "wireguard", "wireguard-vpn", "wiretrustee", "zero-trust-network-access"], "visibility": "public", "forks": 1009, "open_issues": 1188, "watchers": 20703, "default_branch": "main"}}, "commits": [{"sha": "bb74e903cd04bc38b54a0c28bb00db393eeb7f2d", "parents": ["8df8c1012f647f1947a4a1d673051825240b8f2f"], "message": "Implement dns routes for Android"}, {"sha": "49bbd9055753a9af4c0f2217601bf73572c7e7fe", "parents": ["bb74e903cd04bc38b54a0c28bb00db393eeb7f2d"], "message": "Fix test"}, {"sha": "50ac3d437e774185c2ce912fc590473cd95f49a9", "parents": ["49bbd9055753a9af4c0f2217601bf73572c7e7fe"], "message": "Fix lint issues"}, {"sha": "631b77dc3c1a1123eacb20d655473cfc55ff63a0", "parents": ["50ac3d437e774185c2ce912fc590473cd95f49a9"], "message": "Remove some allocations"}, {"sha": "8e94d85d149079be63b65ec3f4aea5f9c630305b", "parents": ["631b77dc3c1a1123eacb20d655473cfc55ff63a0"], "message": "Rename test files"}, {"sha": "8684981b57b201673986195a4e467ef0b3ce15a5", "parents": ["8e94d85d149079be63b65ec3f4aea5f9c630305b"], "message": "Add tests"}, {"sha": "7cd44a9a3c6d1faef080ff4a12bb47e705ae25ad", "parents": ["8684981b57b201673986195a4e467ef0b3ce15a5"], "message": "Improve nat perf"}, {"sha": "2952669e97ffa84079c093180dcbe0c9c23520b6", "parents": ["7cd44a9a3c6d1faef080ff4a12bb47e705ae25ad"], "message": "Fix lint"}, {"sha": "51b9e93eb924f4ed6d61331c117d32802d3929b3", "parents": ["2952669e97ffa84079c093180dcbe0c9c23520b6", "f61ebdb3bc07b35d2b5335d383269dee53ac67d5"], "message": "Merge branch 'main' into android-dns-routes"}, {"sha": "1a3b04d2fe012220eae1bbf909f82aed20306dfd", "parents": ["51b9e93eb924f4ed6d61331c117d32802d3929b3"], "message": "Swap tracking and nat order"}, {"sha": "471f90e8dbcaa18d0889f07290d56f7afbfa086f", "parents": ["1a3b04d2fe012220eae1bbf909f82aed20306dfd"], "message": "Rename methods"}, {"sha": "d47c6b624eedb98f18791384e64a448ec7bffb46", "parents": ["471f90e8dbcaa18d0889f07290d56f7afbfa086f"], "message": "Fix spelling"}, {"sha": "f51ce7cee52a7818b005db9db49170e0bfb97c38", "parents": ["d47c6b624eedb98f18791384e64a448ec7bffb46"], "message": "Remove nil checks"}, {"sha": "9468e69c8c4642ebe7fbe574de89c16f466013cd", "parents": ["f51ce7cee52a7818b005db9db49170e0bfb97c38"], "message": "Extract static error"}, {"sha": "306d75fe1a5aa16487dc4542397ddb29935cf533", "parents": ["9468e69c8c4642ebe7fbe574de89c16f466013cd"], "message": "Set up fake ip route only if the dns feature flag is enabled"}, {"sha": "a79cb1c11b9bcea4aa9f79fb39892bbd9eb067b7", "parents": ["306d75fe1a5aa16487dc4542397ddb29935cf533", "0e5dc9d41229ef3f368aa5feb336934815b69a04"], "message": "Merge branch 'main' into android-dns-routes"}, {"sha": "26fc32f1be9f3b32ad29d123c656152eeb801f39", "parents": ["a79cb1c11b9bcea4aa9f79fb39892bbd9eb067b7"], "message": "Fix errorf"}, {"sha": "c7884039b885d0c17dbd7c8a26a64ae9ddbd25b3", "parents": ["26fc32f1be9f3b32ad29d123c656152eeb801f39"], "message": "Revert \"Fix errorf\"\n\nThis reverts commit 26fc32f1be9f3b32ad29d123c656152eeb801f39."}, {"sha": "5fc95d4a0cead6f46b71a7dabe9e97ca1dabfa04", "parents": ["c7884039b885d0c17dbd7c8a26a64ae9ddbd25b3"], "message": "Display domains properly"}, {"sha": "11bdf5b3a5ffd55b4b966896b32b145af86e4d7d", "parents": ["5fc95d4a0cead6f46b71a7dabe9e97ca1dabfa04"], "message": "Use r"}, {"sha": "5299e9fda3d53b74ebae0fdf3dc2c4f5f20c1713", "parents": ["11bdf5b3a5ffd55b4b966896b32b145af86e4d7d", "6c633497bc84c19f452bf8d230901f1f2dabcd6b"], "message": "Merge branch 'main' into android-dns-routes"}, {"sha": "0f79a8942d342e98258fdab600e94d4fe003ec26", "parents": ["5299e9fda3d53b74ebae0fdf3dc2c4f5f20c1713"], "message": "Fix route notificaiton"}, {"sha": "520f2cfdb4d2fba67412b66b90402398a62d814a", "parents": ["0f79a8942d342e98258fdab600e94d4fe003ec26"], "message": "Remove implicit inbound ssh firewall rules and change default port"}, {"sha": "6ed846ae298aff7221ad2ec65db9c1b56cc9d373", "parents": ["520f2cfdb4d2fba67412b66b90402398a62d814a"], "message": "Refactor ssh server and client"}, {"sha": "f56075ca159820ba99f090631280f2df14a4a1ed", "parents": ["6ed846ae298aff7221ad2ec65db9c1b56cc9d373"], "message": "Tidy mod"}, {"sha": "9d1554f9f7a01d2ae7eaac6bb19aef78660f7466", "parents": ["f56075ca159820ba99f090631280f2df14a4a1ed"], "message": "Complete overhaul"}, {"sha": "279b77dee00f3e01b8f1188b60eb4d3c7b1923f8", "parents": ["9d1554f9f7a01d2ae7eaac6bb19aef78660f7466"], "message": "Bump sftp"}, {"sha": "4bbca28eb6170769801a8c40ca1d822edbc346ea", "parents": ["279b77dee00f3e01b8f1188b60eb4d3c7b1923f8"], "message": "Fix lint"}, {"sha": "96084e3a026626a5b35b5b63ea22485f6c0a05fd", "parents": ["4bbca28eb6170769801a8c40ca1d822edbc346ea"], "message": "Reduce complexity"}, {"sha": "0d5408baecd247a3daadd1798325c8bcbf85849c", "parents": ["96084e3a026626a5b35b5b63ea22485f6c0a05fd"], "message": "Fix lint"}, {"sha": "5970591d24d34514bb1a5be78c4199193065440a", "parents": ["0d5408baecd247a3daadd1798325c8bcbf85849c"], "message": "Fix lint"}, {"sha": "1fdde66c312329ad62d1333815a3e51735faf6a2", "parents": ["5970591d24d34514bb1a5be78c4199193065440a"], "message": "More lint"}, {"sha": "612de2c784de284a67036a478df62256e309b8f0", "parents": ["1fdde66c312329ad62d1333815a3e51735faf6a2"], "message": "Remove socketfilter temporarily"}, {"sha": "76f9e11b2950f2d285ecf8b59861a0db068fec94", "parents": ["612de2c784de284a67036a478df62256e309b8f0"], "message": "Fix tests"}, {"sha": "6e15882c1152e2038e76fa5cb9f847ff28bdb182", "parents": ["76f9e11b2950f2d285ecf8b59861a0db068fec94"], "message": "Fix tests and windows username validation"}, {"sha": "04bb314426dbcc445f72c33fecbe42c21b6718e8", "parents": ["6e15882c1152e2038e76fa5cb9f847ff28bdb182"], "message": "Allow sftp same user switching on windows"}, {"sha": "3e490d974c99d30ffd19b0bde35aa87d751b6343", "parents": ["04bb314426dbcc445f72c33fecbe42c21b6718e8"], "message": "Remove duplicated code"}, {"sha": "9e51d2e8fbc5ddaee26681cc8d86ecd299e6d00c", "parents": ["3e490d974c99d30ffd19b0bde35aa87d751b6343"], "message": "Fix lint and sonar"}, {"sha": "a21f924b2618a6e72339fa553d12c7bdce75d9bf", "parents": ["9e51d2e8fbc5ddaee26681cc8d86ecd299e6d00c"], "message": "Fix some windows tests"}, {"sha": "a476b8d12f4cc9f8dbd890b4d704e2849a2c9913", "parents": ["a21f924b2618a6e72339fa553d12c7bdce75d9bf"], "message": "Fix more windows tests"}, {"sha": "982841e25b047ebd17d0c88b33cbea5dc317cb87", "parents": ["a476b8d12f4cc9f8dbd890b4d704e2849a2c9913"], "message": "Test up tests users if none are available on CI"}, {"sha": "f1bb4d2ac3d05346825e33941d867573db704c88", "parents": ["982841e25b047ebd17d0c88b33cbea5dc317cb87"], "message": "Fix more Windows tests"}, {"sha": "aa30b7afe848eee8bdcb358404f7728c48b827f2", "parents": ["f1bb4d2ac3d05346825e33941d867573db704c88"], "message": "More windows tests"}, {"sha": "088956645fcfd95a1a787e75cc3dd3f30cfcc2b3", "parents": ["aa30b7afe848eee8bdcb358404f7728c48b827f2"], "message": "Fix username validation and skip ci tests properly"}, {"sha": "a4b067553d0d2fab9c0244acda6a3abb68a319c5", "parents": ["088956645fcfd95a1a787e75cc3dd3f30cfcc2b3", "77ec32dd6fc87f8498c4bff55dba12f31dc9b2e1"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "e4e0b8fff97b88111283606ed6669a4737e7d8a5", "parents": ["a4b067553d0d2fab9c0244acda6a3abb68a319c5"], "message": "Remove empty file"}, {"sha": "cdded8c22e131a550f35e53aa09f8d5d1427d4e0", "parents": ["e4e0b8fff97b88111283606ed6669a4737e7d8a5", "a76c8eafb46cda5e44de0f3784160a34e8cdb4a2"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "9a7daa132e749bda07a2d96fabb6e73153633028", "parents": ["cdded8c22e131a550f35e53aa09f8d5d1427d4e0"], "message": "Fix client ssh file"}, {"sha": "ac7120871ba1e510b8027ffd126700cde9048b01", "parents": ["9a7daa132e749bda07a2d96fabb6e73153633028"], "message": "Fix proto"}, {"sha": "fa893aa0a4b85a13dac42ff785bc7c5199b7eb25", "parents": ["ac7120871ba1e510b8027ffd126700cde9048b01"], "message": "Fix build"}, {"sha": "d93b7c2f3863e91783b2dfd7ce11ad9c598c4e6c", "parents": ["fa893aa0a4b85a13dac42ff785bc7c5199b7eb25"], "message": "Fix known hosts entries"}, {"sha": "758a97c35210e3c8d7e3cc5b61e94abf026e8d91", "parents": ["d93b7c2f3863e91783b2dfd7ce11ad9c598c4e6c"], "message": "Generate ssh_config independently of ssh server"}, {"sha": "b43ef4f17b84054abc88869d129ff904f07fc3a9", "parents": ["758a97c35210e3c8d7e3cc5b61e94abf026e8d91", "f063866ce8c62b27b00cf2098a68e89542f837f9"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "b1a9242c984209a68be56ee97fa5daecbb8a1fdf", "parents": ["b43ef4f17b84054abc88869d129ff904f07fc3a9"], "message": "Fix merge commit changes"}, {"sha": "cdd5c6c005ac772a27743eef6ae48cd6c008c4c8", "parents": ["b1a9242c984209a68be56ee97fa5daecbb8a1fdf"], "message": "Address review"}, {"sha": "77a352763d64c2b5a29f1fcec0bb2b21ce59dc70", "parents": ["cdd5c6c005ac772a27743eef6ae48cd6c008c4c8"], "message": "Fix button style"}, {"sha": "79d28b71ee1d7bdae82879a4ff3ef8a1726200ec", "parents": ["77a352763d64c2b5a29f1fcec0bb2b21ce59dc70"], "message": "Improve forwarding cancellation"}, {"sha": "4c53372815b52b4f1cccecafc262a41902a9cf13", "parents": ["79d28b71ee1d7bdae82879a4ff3ef8a1726200ec"], "message": "Add missing flags"}, {"sha": "5272fc2b1895e679be458d308786b79df77e305c", "parents": ["4c53372815b52b4f1cccecafc262a41902a9cf13", "644ed4b934452d578ec4854ebda311cd42341f08"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "66483ab48def71538253dd9ab236da99cab22836", "parents": ["5272fc2b1895e679be458d308786b79df77e305c", "e7b5537dcc280384470668f461bbb1f7d2f41218"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "b3c7b3c7b2baa7b24612a8de1a7b1f3302471e5d", "parents": ["66483ab48def71538253dd9ab236da99cab22836"], "message": "Fix js build"}, {"sha": "7e0bbaaa3cf536bd61e0308a2595d63ffdd4f266", "parents": ["b3c7b3c7b2baa7b24612a8de1a7b1f3302471e5d", "88467883fc4a14607393beaac412f573eaaa1d43"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "d9efe4e944829f4dd65dfeff7d14ed4c793f2d02", "parents": ["7e0bbaaa3cf536bd61e0308a2595d63ffdd4f266"], "message": "Add ssh authenatication with jwt (#4550)"}, {"sha": "f3d31698da2c6ebe42d9b369c3bfac113eaeb8b7", "parents": ["d9efe4e944829f4dd65dfeff7d14ed4c793f2d02"], "message": "Skip some auth tests on windows that are already covered"}, {"sha": "19adcb5f63d4ee025a7f9175343948fc8e0be68d", "parents": ["f3d31698da2c6ebe42d9b369c3bfac113eaeb8b7", "4d33567888fe704fb75f0c0a74ed8a27fd131052"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "610c880ec9943570ef069a9658e66e9413fdafab", "parents": ["19adcb5f63d4ee025a7f9175343948fc8e0be68d"], "message": "Fix missing jwt config passed to peers"}, {"sha": "4d89d0f11560fe2118b099a343d1a2782d6a0598", "parents": ["610c880ec9943570ef069a9658e66e9413fdafab"], "message": "Remove unused code"}, {"sha": "7216c201dab5d906c23b5bb6e2a7c8c007dcd8f8", "parents": ["4d89d0f11560fe2118b099a343d1a2782d6a0598"], "message": "Log priv check errors"}, {"sha": "559f6aeeaf8b05f32de35a9c9ded7879e16e7663", "parents": ["7216c201dab5d906c23b5bb6e2a7c8c007dcd8f8"], "message": "Improve logging"}, {"sha": "4d297205c395456a516b75f9c3957ed1d93e9484", "parents": ["559f6aeeaf8b05f32de35a9c9ded7879e16e7663"], "message": "Fix test build"}, {"sha": "cf97799db83e85170f763370c060fb3e27f339fc", "parents": ["4d297205c395456a516b75f9c3957ed1d93e9484"], "message": "Fix test"}, {"sha": "316c0afa9a4875692caaca03c01686e41f2bcbb5", "parents": ["cf97799db83e85170f763370c060fb3e27f339fc"], "message": "Remove unused arg"}, {"sha": "34b55c600e8ca0851e6ea94ab7c2e54c60f85461", "parents": ["316c0afa9a4875692caaca03c01686e41f2bcbb5"], "message": "Log errors on debug"}, {"sha": "4dadcfd9bdc6cc7159999ef527273b938716a836", "parents": ["34b55c600e8ca0851e6ea94ab7c2e54c60f85461"], "message": "Remove client.log check"}, {"sha": "11d71e6e228e16b645279211a90e0eda7173c7d9", "parents": ["4dadcfd9bdc6cc7159999ef527273b938716a836"], "message": "Ignore default log file"}, {"sha": "5882daf5d990592b64a8970b2ae3d385240f07cd", "parents": ["11d71e6e228e16b645279211a90e0eda7173c7d9"], "message": "Force relay connection, do not waste signaling resources on ICE connection (#4628)"}, {"sha": "4386a21956f7d2d4368e823e1e7a57f8310f5fd4", "parents": ["5882daf5d990592b64a8970b2ae3d385240f07cd", "f5301230bfef5d8b3abaf60634646793fa7b63ac"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "c20202a6c3af35ee137334fd1cbc952a4123407f", "parents": ["4386a21956f7d2d4368e823e1e7a57f8310f5fd4"], "message": "Add new flags to test"}, {"sha": "6f141349887d1e3e84fd79d80152877b2c5344bf", "parents": ["c20202a6c3af35ee137334fd1cbc952a4123407f", "d7321c130b56bc831bfdd8cbec5ff211d37e7de4"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "e6854dfd9955710919dc120613350ac67e0840bc", "parents": ["6f141349887d1e3e84fd79d80152877b2c5344bf"], "message": "Improve session logging"}, {"sha": "576b4a779c77d6958041842059865fdcd99d2888", "parents": ["e6854dfd9955710919dc120613350ac67e0840bc"], "message": "Log shell"}, {"sha": "a7a85d4dc8f30c6b12ff9182fb4d70157ed2db78", "parents": ["576b4a779c77d6958041842059865fdcd99d2888"], "message": "Fix tests"}, {"sha": "107066fa3da35ccf6171f7d3a6358a469d5d41d6", "parents": ["a7a85d4dc8f30c6b12ff9182fb4d70157ed2db78", "d3a34adcc948800e7d96b59e2b814348ef5569a0"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "e3bb8c1b7bbf5ac0a88526f72e14b46ebc5338db", "parents": ["107066fa3da35ccf6171f7d3a6358a469d5d41d6", "a2313a5ba4959a5550c242947a4faf3f9b0cde9b"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "6f817cad6d1962728cd48db76d24a7cd135eb227", "parents": ["e3bb8c1b7bbf5ac0a88526f72e14b46ebc5338db"], "message": "Remove duplicate code"}, {"sha": "8db91abfdf63e790fa11455719325e6941a94e0c", "parents": ["6f817cad6d1962728cd48db76d24a7cd135eb227", "c92e6c1b5fd040248b4fd36a2e397daeeb21ba9f"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "3779a3385f72e81f5d24eb1efa89bb7a9ad1e059", "parents": ["8db91abfdf63e790fa11455719325e6941a94e0c"], "message": "Fix tests"}, {"sha": "ce196ab9c63e817f0ae1d9431c520bb72e17e695", "parents": ["3779a3385f72e81f5d24eb1efa89bb7a9ad1e059"], "message": "[client, management] Move client-imported GPL code to separate package (#4692)"}, {"sha": "848c4e769f72ef413601e3b5c0414234356960e0", "parents": ["ce196ab9c63e817f0ae1d9431c520bb72e17e695"], "message": "Translate usernames to UPN format for domain login"}, {"sha": "9cfdc6e6e4b017a63de8d2e1b0e056d05d31c427", "parents": ["848c4e769f72ef413601e3b5c0414234356960e0", "229e0038ee643ec775d0670c030db70670ae298c"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "0a36d0d97c946f6d8dfdb1f3dd09ea4034cf569e", "parents": ["9cfdc6e6e4b017a63de8d2e1b0e056d05d31c427"], "message": "Fix login hint cycle"}, {"sha": "f6019b994e4f78ab091c1b304b45eb79a5fb3194", "parents": ["0a36d0d97c946f6d8dfdb1f3dd09ea4034cf569e"], "message": "Disable jwt cache by default and add flag"}, {"sha": "37e47464b8bedc0dd2a1ea54ed153c938115acfa", "parents": ["f6019b994e4f78ab091c1b304b45eb79a5fb3194", "2e16c9914a7ba92fa92f56c66c079e4dd1e0fd34"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "e61935893eecd297098f0921724984bcfd01aae7", "parents": ["37e47464b8bedc0dd2a1ea54ed153c938115acfa", "6aa4ba7af441c9c07fd76d7946e179ea5257e975"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "e1ef294448d96f014ee1d925181bc826b96cb0a5", "parents": ["e61935893eecd297098f0921724984bcfd01aae7"], "message": "Set default token age if mgmt sends 0"}, {"sha": "79c400a01c57339844ce8114fc91466e8c5a3ab5", "parents": ["e1ef294448d96f014ee1d925181bc826b96cb0a5", "dbfc8a52c932a4a246c07938eeabfaef78f66c3b"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "2d90799e940d5c196302652d91f48ea586389514", "parents": ["79c400a01c57339844ce8114fc91466e8c5a3ab5"], "message": "Fix tests after merge"}, {"sha": "25d2675a85c69567d962daa42c159c7c749c27ca", "parents": ["2d90799e940d5c196302652d91f48ea586389514"], "message": "[client] Add PTY support to ssh with a command (#4754)"}, {"sha": "5a78ecbdd04b21a2a07b3029b462771f66e6f893", "parents": ["25d2675a85c69567d962daa42c159c7c749c27ca"], "message": "[client] Add ssh server status output (#4760)"}, {"sha": "9176f8b2aa86b5c25ef3e86d66ef3699dc7553d9", "parents": ["5a78ecbdd04b21a2a07b3029b462771f66e6f893"], "message": "Address review"}, {"sha": "0c8dc0274d4d010b744bea2ed922fb490d34328a", "parents": ["9176f8b2aa86b5c25ef3e86d66ef3699dc7553d9"], "message": "Address rest of the review"}, {"sha": "619e35fd2a3f144d426f070a1d7e5f4f466526c3", "parents": ["0c8dc0274d4d010b744bea2ed922fb490d34328a"], "message": "Pass through exit code"}, {"sha": "f7a37ed0ac618d66b46b1bd0a07f9c35be100643", "parents": ["619e35fd2a3f144d426f070a1d7e5f4f466526c3"], "message": "Address more review comments"}, {"sha": "c8fae06555320e800ded474ab85b10ff908e3970", "parents": ["f7a37ed0ac618d66b46b1bd0a07f9c35be100643"], "message": "Fix long flags"}, {"sha": "706ad49e1b0ee6f65e60b4a9611ff0232040aac9", "parents": ["c8fae06555320e800ded474ab85b10ff908e3970", "e4b41d0ad70676b3f3f4a18f621b5467bd1c509c"], "message": "Merge branch 'main' into ssh-rewrite"}, {"sha": "30518f443a45b01343e7b4246e524191fc2ef215", "parents": ["706ad49e1b0ee6f65e60b4a9611ff0232040aac9"], "message": "Ignore no exit status err"}, {"sha": "0dfe473ab146d09d829c5791bea8dcaa8ba9a92f", "parents": ["30518f443a45b01343e7b4246e524191fc2ef215"], "message": "Fix invalid flag parsing"}, {"sha": "3c8c0972dc56ab8d5505a81d54af1245d04b7083", "parents": ["0dfe473ab146d09d829c5791bea8dcaa8ba9a92f"], "message": "Fix merge log msg"}, {"sha": "06042aa8813a4ec421654d8cd45363cc849e7170", "parents": ["3c8c0972dc56ab8d5505a81d54af1245d04b7083"], "message": "Fix lint"}, {"sha": "f518a895918c91e91cc47e3c35ab89a04bd19188", "parents": ["06042aa8813a4ec421654d8cd45363cc849e7170"], "message": "Fix ui detecting changes on ttl"}, {"sha": "5f6d415a25b250b9bf8276194009e8fb77146c03", "parents": ["f518a895918c91e91cc47e3c35ab89a04bd19188"], "message": "Remove hardcoded jwks path"}, {"sha": "8ee50ea31053602e229f075b01843c3c40d32e76", "parents": ["5f6d415a25b250b9bf8276194009e8fb77146c03"], "message": "Fix cli flag test"}, {"sha": "0812992a54006193a53c8c1a9684817f10c5a3ea", "parents": ["8ee50ea31053602e229f075b01843c3c40d32e76"], "message": "Check nil in priv result"}], "resolved_issues": [{"org": "netbirdio", "repo": "netbird", "number": -1, "state": "unknown", "title": "[client,management] Rewrite the SSH feature", "body": "## Describe your changes\r\n\r\n\r\n### NetBird SSH Client\r\n- Port forwarding\r\n- Windows support\r\n- Non-interactive commands\r\n- Single command execution over SSH\r\n\r\n### SSH Server\r\n- SFTP\r\n- Port forwarding (without user switching)\r\n- PTY (interactive, non-interactive)\r\n- Non-PTY (commands)\r\n- Windows support\r\n- JWT auth (user identity instead of machine identity, can be turned off) \r\n\r\n### New Flags\r\n```\r\n# server\r\n--enable-ssh-local-port-forwarding\r\n--enable-ssh-remote-port-forwarding\r\n--enable-ssh-root\r\n--enable-ssh-sftp\r\n--disable-ssh-auth\r\n\r\n# client\r\n--ssh-jwt-cache-ttl\r\n```\r\n\r\n### UI\r\n\r\n- Better organization\r\n<img width=\"608\" height=\"432\" alt=\"image\" src=\"https://github.com/user-attachments/assets/7e8f7415-7f7f-47f4-b945-d1e6135e8bd7\" />\r\n\r\n<img width=\"608\" height=\"432\" alt=\"image\" src=\"https://github.com/user-attachments/assets/d463c3d3-0742-4700-91ca-29db0b47c1f4\" />\r\n \r\n<img width=\"608\" height=\"432\" alt=\"image\" src=\"https://github.com/user-attachments/assets/8023d3de-f6fd-4c5d-8985-a49a452a6491\" />\r\n\r\n\r\n### Changes\r\n- Default port changed to 22022\r\n- Redirect port 22 to 22022 when SSH server enabled\r\n- Remove implicit OpenSSH firewall port\r\n- Management now passes its `jwks` config to peers with enabled ssh server\r\n- SSH server peers verify incoming clients' `jwt` with max token age \r\n- SSH clients request `jwt`s from the IdP and send these for authentication with remote ssh peers\r\n- Add `netbird ssh detect` command to detect if the remote peer is running the NetBird server\r\n- Add `netbird ssh proxy` command for native ssh and sftp clients. The proxy requests `jwt`s just like `netbird ssh`, passes them for authentication and bridges the connection between the native client and the remote server.\r\n- Add jwt capability to the wasm ssh client\r\n\r\n\r\n### Auth Flows\r\n\r\n  1. NetBird SSH Flow (`netbird ssh <peer>`)\r\n\r\n  ```mermaid\r\n  flowchart TD\r\n      A[User: netbird ssh &lt;peer&gt;] --> B[Connect to peer:22]\r\n      B --> C[Detect Server Type]\r\n      C --> D[Send 'netbird-detect' request]\r\n\r\n      D --> E{Server Response}\r\n\r\n      E -->|No NetBird identifier| F[Regular SSH Server]\r\n      E -->|NetBird + JWT required| G[NetBird with JWT Auth]\r\n      E -->|NetBird + No JWT| H[NetBird without JWT]\r\n\r\n      F --> I[Standard SSH Connection]\r\n      H --> I\r\n\r\n      G --> J[Request JWT from NetBird daemon]\r\n\r\n      J --> J1{Check JWT cache}\r\n      J1 -->|Cache valid| J2[Use cached JWT token]\r\n      J1 -->|No cache/expired| J3[OIDC flow:<br/>User authorizes via IDP callback]\r\n      J3 --> J4[Receive & cache JWT token]\r\n      J4 --> K[Connect to peer SSH server]\r\n      J2 --> K\r\n\r\n      K --> M[Send JWT authentication request]\r\n      M --> N{JWT Valid?}\r\n\r\n      N -->|No| O[Connection Rejected]\r\n      N -->|Yes| P[SSH Session Established]\r\n      I --> P\r\n\r\n      P --> Q[Interactive Shell / Execute Command / Port Forwarding]\r\n\r\n      style G fill:#f57c00,color:#fff\r\n      style J fill:#1976d2,color:#fff\r\n      style J1 fill:#1976d2,color:#fff\r\n      style J3 fill:#e65100,color:#fff\r\n      style P fill:#388e3c,color:#fff\r\n  ```\r\n\r\n  2. Native SSH Flow (e.g. openssh client)\r\n\r\n  ```mermaid\r\n  flowchart TD\r\n      A[User: ssh &lt;peer&gt;] --> B[OpenSSH loads config:<br/>/etc/ssh/ssh_config.d/99-netbird.conf]\r\n      B --> D{Host matches NetBird pattern?}\r\n\r\n      D -->|No| E[Standard SSH connection]\r\n\r\n      D -->|Yes| F[Run detection check:<br/>netbird ssh detect &lt;peer&gt; 22]\r\n      F --> G{Is NetBird SSH server?}\r\n\r\n      G -->|No| E\r\n\r\n      G -->|Yes - JWT required| H[Activate ProxyCommand:<br/>netbird ssh proxy &lt;peer&gt; 22]\r\n\r\n      H --> I[Local SSH Proxy Started]\r\n      I --> J[OpenSSH connects to proxy via stdio]\r\n\r\n      J --> K[Proxy requests JWT from daemon]\r\n\r\n      K --> K1{Check JWT cache}\r\n      K1 -->|Cache valid| K2[Use cached JWT token]\r\n      K1 -->|No cache/expired| K3[OIDC flow:<br/>User authorizes via IDP callback]\r\n      K3 --> K4[Receive & cache JWT token]\r\n      K4 --> L[Proxy connects to peer SSH server]\r\n      K2 --> L\r\n\r\n      L --> M[Proxy sends JWT authentication]\r\n\r\n      M --> N{JWT Valid?}\r\n      N -->|No| O[Connection Rejected]\r\n      N -->|Yes| P[Proxy establishes session]\r\n\r\n      P --> Q[Bidirectional forwarding:<br/>OpenSSH ↔ Proxy ↔ Peer SSH Server]\r\n\r\n      Q --> R[User interacts with remote shell]\r\n\r\n      style H fill:#f57c00,color:#fff\r\n      style I fill:#1976d2,color:#fff\r\n      style K fill:#1976d2,color:#fff\r\n      style K1 fill:#1976d2,color:#fff\r\n      style K3 fill:#e65100,color:#fff\r\n      style Q fill:#388e3c,color:#fff\r\n\r\n      classDef proxyBox fill:#1565c0,stroke:#0d47a1,stroke-width:2px,color:#fff\r\n      class I,K,L,M,P,Q proxyBox\r\n  ```\r\n\r\n## Issue ticket number and link\r\n\r\nFixes https://github.com/netbirdio/netbird/issues/4759 https://github.com/netbirdio/netbird/issues/4672 https://github.com/netbirdio/netbird/issues/4456  https://github.com/netbirdio/netbird/issues/4039 https://github.com/netbirdio/netbird/issues/3985 https://github.com/netbirdio/netbird/issues/2498 https://github.com/netbirdio/netbird/issues/4457\r\n\r\n\r\n## Stack\r\n\r\n<!-- branch-stack -->\r\n\r\n### Checklist\r\n- [x] Is it a bug fix\r\n- [ ] Is a typo/documentation fix\r\n- [x] Is a feature enhancement\r\n- [x] It is a refactor\r\n- [x] Created tests that fail without the change (if possible)\r\n- [ ] Extended the README / documentation, if necessary\r\n\r\n## Documentation\r\nSelect exactly one:\r\n\r\n- [x] I added/updated documentation for this change [ netbirdio/docs/pull/475 ]\r\n- [ ] Documentation is **not needed** for this change \r\n---\r\n\r\n\r\n> By submitting this pull request, you confirm that you have read and agree to the terms of the [Contributor License Agreement](https://github.com/netbirdio/netbird/blob/main/CONTRIBUTOR_LICENSE_AGREEMENT.md).\r\n\r\n\r\n<!-- This is an auto-generated comment: release notes by coderabbit.ai -->\r\n## Summary by CodeRabbit\r\n\r\n* **New Features**\r\n  * Complete SSH support: embedded SSH server and client (JWT-backed auth), SFTP, local/remote port forwarding, SSH proxy, host-key retrieval, session listing, SSH client config generation, server detection, and UI/WASM controls including SSH JWT cache TTL.\r\n* **Bug Fixes**\r\n  * License check made quieter and more robust by suppressing noisy errors during scanning.\r\n<!-- end of auto-generated comment: release notes by coderabbit.ai -->"}], "fix_patch": "diff --git a/.github/workflows/check-license-dependencies.yml b/.github/workflows/check-license-dependencies.yml\nindex 2a3e7d42413..543ba2ab223 100644\n--- a/.github/workflows/check-license-dependencies.yml\n+++ b/.github/workflows/check-license-dependencies.yml\n@@ -19,35 +19,37 @@ jobs:\n     runs-on: ubuntu-latest\n \n     steps:\n-    - uses: actions/checkout@v4\n+      - uses: actions/checkout@v4\n \n-    - name: Check for problematic license dependencies\n-      run: |\n-        echo \"Checking for dependencies on management/, signal/, and relay/ packages...\"\n-\n-        # Find all directories except the problematic ones and system dirs\n-        FOUND_ISSUES=0\n-        find . -maxdepth 1 -type d -not -name \".\" -not -name \"management\" -not -name \"signal\" -not -name \"relay\" -not -name \".git*\" | sort | while read dir; do\n-          echo \"=== Checking $dir ===\"\n-          # Search for problematic imports, excluding test files\n-          RESULTS=$(grep -r \"github.com/netbirdio/netbird/\\(management\\|signal\\|relay\\)\" \"$dir\" --include=\"*.go\" | grep -v \"_test.go\" | grep -v \"test_\" | grep -v \"/test/\" || true)\n-          if [ ! -z \"$RESULTS\" ]; then\n-            echo \"❌ Found problematic dependencies:\"\n-            echo \"$RESULTS\"\n-            FOUND_ISSUES=1\n-          else\n-            echo \"✓ No problematic dependencies found\"\n-          fi\n-        done\n-        if [ $FOUND_ISSUES -eq 1 ]; then\n+      - name: Check for problematic license dependencies\n+        run: |\n+          echo \"Checking for dependencies on management/, signal/, and relay/ packages...\"\n           echo \"\"\n-          echo \"❌ Found dependencies on management/, signal/, or relay/ packages\"\n-          echo \"These packages are licensed under AGPLv3 and must not be imported by BSD-licensed code\"\n-          exit 1\n-        else\n+\n+          # Find all directories except the problematic ones and system dirs\n+          FOUND_ISSUES=0\n+          while IFS= read -r dir; do\n+            echo \"=== Checking $dir ===\"\n+            # Search for problematic imports, excluding test files\n+            RESULTS=$(grep -r \"github.com/netbirdio/netbird/\\(management\\|signal\\|relay\\)\" \"$dir\" --include=\"*.go\" 2>/dev/null | grep -v \"_test.go\" | grep -v \"test_\" | grep -v \"/test/\" || true)\n+            if [ -n \"$RESULTS\" ]; then\n+              echo \"❌ Found problematic dependencies:\"\n+              echo \"$RESULTS\"\n+              FOUND_ISSUES=1\n+            else\n+              echo \"✓ No problematic dependencies found\"\n+            fi\n+          done < <(find . -maxdepth 1 -type d -not -name \".\" -not -name \"management\" -not -name \"signal\" -not -name \"relay\" -not -name \".git*\" | sort)\n+\n           echo \"\"\n-          echo \"✅ All internal license dependencies are clean\"\n-        fi\n+          if [ $FOUND_ISSUES -eq 1 ]; then\n+            echo \"❌ Found dependencies on management/, signal/, or relay/ packages\"\n+            echo \"These packages are licensed under AGPLv3 and must not be imported by BSD-licensed code\"\n+            exit 1\n+          else\n+            echo \"\"\n+            echo \"✅ All internal license dependencies are clean\"\n+          fi\n \n   check-external-licenses:\n     name: Check External GPL/AGPL Licenses\ndiff --git a/client/android/client.go b/client/android/client.go\nindex d2d0c37f65e..86fb1445d76 100644\n--- a/client/android/client.go\n+++ b/client/android/client.go\n@@ -17,9 +17,9 @@ import (\n \t\"github.com/netbirdio/netbird/client/internal/peer\"\n \t\"github.com/netbirdio/netbird/client/internal/profilemanager\"\n \t\"github.com/netbirdio/netbird/client/internal/stdnet\"\n+\t\"github.com/netbirdio/netbird/client/net\"\n \t\"github.com/netbirdio/netbird/client/system\"\n \t\"github.com/netbirdio/netbird/formatter\"\n-\t\"github.com/netbirdio/netbird/client/net\"\n )\n \n // ConnectionListener export internal Listener for mobile\ndiff --git a/client/android/preferences.go b/client/android/preferences.go\nindex 9a5d6bb21c1..c3c8eb3fbc9 100644\n--- a/client/android/preferences.go\n+++ b/client/android/preferences.go\n@@ -201,6 +201,94 @@ func (p *Preferences) SetServerSSHAllowed(allowed bool) {\n \tp.configInput.ServerSSHAllowed = &allowed\n }\n \n+// GetEnableSSHRoot reads SSH root login setting from config file\n+func (p *Preferences) GetEnableSSHRoot() (bool, error) {\n+\tif p.configInput.EnableSSHRoot != nil {\n+\t\treturn *p.configInput.EnableSSHRoot, nil\n+\t}\n+\n+\tcfg, err := profilemanager.ReadConfig(p.configInput.ConfigPath)\n+\tif err != nil {\n+\t\treturn false, err\n+\t}\n+\tif cfg.EnableSSHRoot == nil {\n+\t\t// Default to false for security on Android\n+\t\treturn false, nil\n+\t}\n+\treturn *cfg.EnableSSHRoot, err\n+}\n+\n+// SetEnableSSHRoot stores the given value and waits for commit\n+func (p *Preferences) SetEnableSSHRoot(enabled bool) {\n+\tp.configInput.EnableSSHRoot = &enabled\n+}\n+\n+// GetEnableSSHSFTP reads SSH SFTP setting from config file\n+func (p *Preferences) GetEnableSSHSFTP() (bool, error) {\n+\tif p.configInput.EnableSSHSFTP != nil {\n+\t\treturn *p.configInput.EnableSSHSFTP, nil\n+\t}\n+\n+\tcfg, err := profilemanager.ReadConfig(p.configInput.ConfigPath)\n+\tif err != nil {\n+\t\treturn false, err\n+\t}\n+\tif cfg.EnableSSHSFTP == nil {\n+\t\t// Default to false for security on Android\n+\t\treturn false, nil\n+\t}\n+\treturn *cfg.EnableSSHSFTP, err\n+}\n+\n+// SetEnableSSHSFTP stores the given value and waits for commit\n+func (p *Preferences) SetEnableSSHSFTP(enabled bool) {\n+\tp.configInput.EnableSSHSFTP = &enabled\n+}\n+\n+// GetEnableSSHLocalPortForwarding reads SSH local port forwarding setting from config file\n+func (p *Preferences) GetEnableSSHLocalPortForwarding() (bool, error) {\n+\tif p.configInput.EnableSSHLocalPortForwarding != nil {\n+\t\treturn *p.configInput.EnableSSHLocalPortForwarding, nil\n+\t}\n+\n+\tcfg, err := profilemanager.ReadConfig(p.configInput.ConfigPath)\n+\tif err != nil {\n+\t\treturn false, err\n+\t}\n+\tif cfg.EnableSSHLocalPortForwarding == nil {\n+\t\t// Default to false for security on Android\n+\t\treturn false, nil\n+\t}\n+\treturn *cfg.EnableSSHLocalPortForwarding, err\n+}\n+\n+// SetEnableSSHLocalPortForwarding stores the given value and waits for commit\n+func (p *Preferences) SetEnableSSHLocalPortForwarding(enabled bool) {\n+\tp.configInput.EnableSSHLocalPortForwarding = &enabled\n+}\n+\n+// GetEnableSSHRemotePortForwarding reads SSH remote port forwarding setting from config file\n+func (p *Preferences) GetEnableSSHRemotePortForwarding() (bool, error) {\n+\tif p.configInput.EnableSSHRemotePortForwarding != nil {\n+\t\treturn *p.configInput.EnableSSHRemotePortForwarding, nil\n+\t}\n+\n+\tcfg, err := profilemanager.ReadConfig(p.configInput.ConfigPath)\n+\tif err != nil {\n+\t\treturn false, err\n+\t}\n+\tif cfg.EnableSSHRemotePortForwarding == nil {\n+\t\t// Default to false for security on Android\n+\t\treturn false, nil\n+\t}\n+\treturn *cfg.EnableSSHRemotePortForwarding, err\n+}\n+\n+// SetEnableSSHRemotePortForwarding stores the given value and waits for commit\n+func (p *Preferences) SetEnableSSHRemotePortForwarding(enabled bool) {\n+\tp.configInput.EnableSSHRemotePortForwarding = &enabled\n+}\n+\n // GetBlockInbound reads block inbound setting from config file\n func (p *Preferences) GetBlockInbound() (bool, error) {\n \tif p.configInput.BlockInbound != nil {\ndiff --git a/client/cmd/root.go b/client/cmd/root.go\nindex 11e5228f1e4..9f2eb109c5e 100644\n--- a/client/cmd/root.go\n+++ b/client/cmd/root.go\n@@ -35,7 +35,6 @@ const (\n \twireguardPortFlag        = \"wireguard-port\"\n \tnetworkMonitorFlag       = \"network-monitor\"\n \tdisableAutoConnectFlag   = \"disable-auto-connect\"\n-\tserverSSHAllowedFlag     = \"allow-server-ssh\"\n \textraIFaceBlackListFlag  = \"extra-iface-blacklist\"\n \tdnsRouteIntervalFlag     = \"dns-router-interval\"\n \tenableLazyConnectionFlag = \"enable-lazy-connection\"\n@@ -64,7 +63,6 @@ var (\n \tcustomDNSAddress        string\n \trosenpassEnabled        bool\n \trosenpassPermissive     bool\n-\tserverSSHAllowed        bool\n \tinterfaceName           string\n \twireguardPort           uint16\n \tnetworkMonitor          bool\n@@ -176,7 +174,6 @@ func init() {\n \t)\n \tupCmd.PersistentFlags().BoolVar(&rosenpassEnabled, enableRosenpassFlag, false, \"[Experimental] Enable Rosenpass feature. If enabled, the connection will be post-quantum secured via Rosenpass.\")\n \tupCmd.PersistentFlags().BoolVar(&rosenpassPermissive, rosenpassPermissiveFlag, false, \"[Experimental] Enable Rosenpass in permissive mode to allow this peer to accept WireGuard connections without requiring Rosenpass functionality from peers that do not have Rosenpass enabled.\")\n-\tupCmd.PersistentFlags().BoolVar(&serverSSHAllowed, serverSSHAllowedFlag, false, \"Allow SSH server on peer. If enabled, the SSH server will be permitted\")\n \tupCmd.PersistentFlags().BoolVar(&autoConnectDisabled, disableAutoConnectFlag, false, \"Disables auto-connect feature. If enabled, then the client won't connect automatically when the service starts.\")\n \tupCmd.PersistentFlags().BoolVar(&lazyConnEnabled, enableLazyConnectionFlag, false, \"[Experimental] Enable the lazy connection feature. If enabled, the client will establish connections on-demand. Note: this setting may be overridden by management configuration.\")\n \ndiff --git a/client/cmd/ssh.go b/client/cmd/ssh.go\nindex 5358ddacbd6..70c7dbcffe9 100644\n--- a/client/cmd/ssh.go\n+++ b/client/cmd/ssh.go\n@@ -3,125 +3,809 @@ package cmd\n import (\n \t\"context\"\n \t\"errors\"\n+\t\"flag\"\n \t\"fmt\"\n+\t\"net\"\n \t\"os\"\n \t\"os/signal\"\n+\t\"os/user\"\n+\t\"slices\"\n+\t\"strconv\"\n \t\"strings\"\n \t\"syscall\"\n \n+\tlog \"github.com/sirupsen/logrus\"\n \t\"github.com/spf13/cobra\"\n+\t\"golang.org/x/crypto/ssh\"\n \n \t\"github.com/netbirdio/netbird/client/internal\"\n-\t\"github.com/netbirdio/netbird/client/internal/profilemanager\"\n-\tnbssh \"github.com/netbirdio/netbird/client/ssh\"\n+\tsshclient \"github.com/netbirdio/netbird/client/ssh/client\"\n+\t\"github.com/netbirdio/netbird/client/ssh/detection\"\n+\tsshproxy \"github.com/netbirdio/netbird/client/ssh/proxy\"\n+\tsshserver \"github.com/netbirdio/netbird/client/ssh/server\"\n \t\"github.com/netbirdio/netbird/util\"\n )\n \n+const (\n+\tsshUsernameDesc      = \"SSH username\"\n+\thostArgumentRequired = \"host argument required\"\n+\n+\tserverSSHAllowedFlag           = \"allow-server-ssh\"\n+\tenableSSHRootFlag              = \"enable-ssh-root\"\n+\tenableSSHSFTPFlag              = \"enable-ssh-sftp\"\n+\tenableSSHLocalPortForwardFlag  = \"enable-ssh-local-port-forwarding\"\n+\tenableSSHRemotePortForwardFlag = \"enable-ssh-remote-port-forwarding\"\n+\tdisableSSHAuthFlag             = \"disable-ssh-auth\"\n+\tsshJWTCacheTTLFlag             = \"ssh-jwt-cache-ttl\"\n+)\n+\n+var (\n+\tport                  int\n+\tusername              string\n+\thost                  string\n+\tcommand               string\n+\tlocalForwards         []string\n+\tremoteForwards        []string\n+\tstrictHostKeyChecking bool\n+\tknownHostsFile        string\n+\tidentityFile          string\n+\tskipCachedToken       bool\n+\trequestPTY            bool\n+)\n+\n var (\n-\tport     int\n-\tuserName = \"root\"\n-\thost     string\n+\tserverSSHAllowed           bool\n+\tenableSSHRoot              bool\n+\tenableSSHSFTP              bool\n+\tenableSSHLocalPortForward  bool\n+\tenableSSHRemotePortForward bool\n+\tdisableSSHAuth             bool\n+\tsshJWTCacheTTL             int\n )\n \n+func init() {\n+\tupCmd.PersistentFlags().BoolVar(&serverSSHAllowed, serverSSHAllowedFlag, false, \"Allow SSH server on peer\")\n+\tupCmd.PersistentFlags().BoolVar(&enableSSHRoot, enableSSHRootFlag, false, \"Enable root login for SSH server\")\n+\tupCmd.PersistentFlags().BoolVar(&enableSSHSFTP, enableSSHSFTPFlag, false, \"Enable SFTP subsystem for SSH server\")\n+\tupCmd.PersistentFlags().BoolVar(&enableSSHLocalPortForward, enableSSHLocalPortForwardFlag, false, \"Enable local port forwarding for SSH server\")\n+\tupCmd.PersistentFlags().BoolVar(&enableSSHRemotePortForward, enableSSHRemotePortForwardFlag, false, \"Enable remote port forwarding for SSH server\")\n+\tupCmd.PersistentFlags().BoolVar(&disableSSHAuth, disableSSHAuthFlag, false, \"Disable SSH authentication\")\n+\tupCmd.PersistentFlags().IntVar(&sshJWTCacheTTL, sshJWTCacheTTLFlag, 0, \"SSH JWT token cache TTL in seconds (0=disabled)\")\n+\n+\tsshCmd.PersistentFlags().IntVarP(&port, \"port\", \"p\", sshserver.DefaultSSHPort, \"Remote SSH port\")\n+\tsshCmd.PersistentFlags().StringVarP(&username, \"user\", \"u\", \"\", sshUsernameDesc)\n+\tsshCmd.PersistentFlags().StringVar(&username, \"login\", \"\", sshUsernameDesc+\" (alias for --user)\")\n+\tsshCmd.PersistentFlags().BoolVarP(&requestPTY, \"tty\", \"t\", false, \"Force pseudo-terminal allocation\")\n+\tsshCmd.PersistentFlags().BoolVar(&strictHostKeyChecking, \"strict-host-key-checking\", true, \"Enable strict host key checking (default: true)\")\n+\tsshCmd.PersistentFlags().StringVarP(&knownHostsFile, \"known-hosts\", \"o\", \"\", \"Path to known_hosts file (default: ~/.ssh/known_hosts)\")\n+\tsshCmd.PersistentFlags().StringVarP(&identityFile, \"identity\", \"i\", \"\", \"Path to SSH private key file (deprecated)\")\n+\t_ = sshCmd.PersistentFlags().MarkDeprecated(\"identity\", \"this flag is no longer used\")\n+\tsshCmd.PersistentFlags().BoolVar(&skipCachedToken, \"no-cache\", false, \"Skip cached JWT token and force fresh authentication\")\n+\n+\tsshCmd.PersistentFlags().StringArrayP(\"L\", \"L\", []string{}, \"Local port forwarding [bind_address:]port:host:hostport\")\n+\tsshCmd.PersistentFlags().StringArrayP(\"R\", \"R\", []string{}, \"Remote port forwarding [bind_address:]port:host:hostport\")\n+\n+\tsshCmd.AddCommand(sshSftpCmd)\n+\tsshCmd.AddCommand(sshProxyCmd)\n+\tsshCmd.AddCommand(sshDetectCmd)\n+}\n+\n var sshCmd = &cobra.Command{\n-\tUse: \"ssh [user@]host\",\n-\tArgs: func(cmd *cobra.Command, args []string) error {\n-\t\tif len(args) < 1 {\n-\t\t\treturn errors.New(\"requires a host argument\")\n+\tUse:   \"ssh [flags] [user@]host [command]\",\n+\tShort: \"Connect to a NetBird peer via SSH\",\n+\tLong: `Connect to a NetBird peer using SSH with support for port forwarding.\n+\n+Port Forwarding:\n+  -L [bind_address:]port:host:hostport   Local port forwarding\n+  -L [bind_address:]port:/path/to/socket Local port forwarding to Unix socket\n+  -R [bind_address:]port:host:hostport   Remote port forwarding\n+  -R [bind_address:]port:/path/to/socket Remote port forwarding to Unix socket\n+\n+SSH Options:\n+  -p, --port int                       Remote SSH port (default 22)\n+  -u, --user string                    SSH username\n+      --login string                   SSH username (alias for --user)\n+  -t, --tty                            Force pseudo-terminal allocation\n+      --strict-host-key-checking       Enable strict host key checking (default: true)\n+  -o, --known-hosts string             Path to known_hosts file\n+\n+Examples:\n+  netbird ssh peer-hostname\n+  netbird ssh root@peer-hostname\n+  netbird ssh --login root peer-hostname\n+  netbird ssh peer-hostname ls -la\n+  netbird ssh peer-hostname whoami\n+  netbird ssh -t peer-hostname tmux                  # Force PTY for tmux/screen\n+  netbird ssh -t peer-hostname sudo -i               # Force PTY for interactive sudo\n+  netbird ssh -L 8080:localhost:80 peer-hostname     # Local port forwarding\n+  netbird ssh -R 9090:localhost:3000 peer-hostname   # Remote port forwarding\n+  netbird ssh -L \"*:8080:localhost:80\" peer-hostname # Bind to all interfaces\n+  netbird ssh -L 8080:/tmp/socket peer-hostname      # Unix socket forwarding`,\n+\tDisableFlagParsing: true,\n+\tArgs:               validateSSHArgsWithoutFlagParsing,\n+\tRunE:               sshFn,\n+\tAliases:            []string{\"ssh\"},\n+}\n+\n+func sshFn(cmd *cobra.Command, args []string) error {\n+\tfor _, arg := range args {\n+\t\tif arg == \"-h\" || arg == \"--help\" {\n+\t\t\treturn cmd.Help()\n \t\t}\n+\t}\n \n-\t\tsplit := strings.Split(args[0], \"@\")\n-\t\tif len(split) == 2 {\n-\t\t\tuserName = split[0]\n-\t\t\thost = split[1]\n-\t\t} else {\n-\t\t\thost = args[0]\n+\tSetFlagsFromEnvVars(rootCmd)\n+\tSetFlagsFromEnvVars(cmd)\n+\n+\tcmd.SetOut(cmd.OutOrStdout())\n+\n+\tlogOutput := \"console\"\n+\tif firstLogFile := util.FindFirstLogPath(logFiles); firstLogFile != \"\" && firstLogFile != defaultLogFile {\n+\t\tlogOutput = firstLogFile\n+\t}\n+\tif err := util.InitLog(logLevel, logOutput); err != nil {\n+\t\treturn fmt.Errorf(\"init log: %w\", err)\n+\t}\n+\n+\tctx := internal.CtxInitState(cmd.Context())\n+\n+\tsig := make(chan os.Signal, 1)\n+\tsignal.Notify(sig, syscall.SIGTERM, syscall.SIGINT)\n+\tsshctx, cancel := context.WithCancel(ctx)\n+\n+\terrCh := make(chan error, 1)\n+\tgo func() {\n+\t\tif err := runSSH(sshctx, host, cmd); err != nil {\n+\t\t\terrCh <- err\n \t\t}\n+\t\tcancel()\n+\t}()\n \n+\tselect {\n+\tcase <-sig:\n+\t\tcancel()\n+\t\t<-sshctx.Done()\n \t\treturn nil\n-\t},\n-\tShort: \"Connect to a remote SSH server\",\n-\tRunE: func(cmd *cobra.Command, args []string) error {\n-\t\tSetFlagsFromEnvVars(rootCmd)\n-\t\tSetFlagsFromEnvVars(cmd)\n+\tcase err := <-errCh:\n+\t\treturn err\n+\tcase <-sshctx.Done():\n+\t}\n \n-\t\tcmd.SetOut(cmd.OutOrStdout())\n+\treturn nil\n+}\n \n-\t\terr := util.InitLog(logLevel, util.LogConsole)\n-\t\tif err != nil {\n-\t\t\treturn fmt.Errorf(\"failed initializing log %v\", err)\n+// getEnvOrDefault checks for environment variables with WT_ and NB_ prefixes\n+func getEnvOrDefault(flagName, defaultValue string) string {\n+\tif envValue := os.Getenv(\"WT_\" + flagName); envValue != \"\" {\n+\t\treturn envValue\n+\t}\n+\tif envValue := os.Getenv(\"NB_\" + flagName); envValue != \"\" {\n+\t\treturn envValue\n+\t}\n+\treturn defaultValue\n+}\n+\n+// resetSSHGlobals sets SSH globals to their default values\n+func resetSSHGlobals() {\n+\tport = sshserver.DefaultSSHPort\n+\tusername = \"\"\n+\thost = \"\"\n+\tcommand = \"\"\n+\tlocalForwards = nil\n+\tremoteForwards = nil\n+\tstrictHostKeyChecking = true\n+\tknownHostsFile = \"\"\n+\tidentityFile = \"\"\n+}\n+\n+// parseCustomSSHFlags extracts -L, -R flags and returns filtered args\n+func parseCustomSSHFlags(args []string) ([]string, []string, []string) {\n+\tvar localForwardFlags []string\n+\tvar remoteForwardFlags []string\n+\tvar filteredArgs []string\n+\n+\tfor i := 0; i < len(args); i++ {\n+\t\targ := args[i]\n+\t\tswitch {\n+\t\tcase strings.HasPrefix(arg, \"-L\"):\n+\t\t\tlocalForwardFlags, i = parseForwardFlag(arg, args, i, localForwardFlags)\n+\t\tcase strings.HasPrefix(arg, \"-R\"):\n+\t\t\tremoteForwardFlags, i = parseForwardFlag(arg, args, i, remoteForwardFlags)\n+\t\tdefault:\n+\t\t\tfilteredArgs = append(filteredArgs, arg)\n \t\t}\n+\t}\n \n-\t\tif !util.IsAdmin() {\n-\t\t\tcmd.Printf(\"error: you must have Administrator privileges to run this command\\n\")\n-\t\t\treturn nil\n+\treturn filteredArgs, localForwardFlags, remoteForwardFlags\n+}\n+\n+func parseForwardFlag(arg string, args []string, i int, flags []string) ([]string, int) {\n+\tif arg == \"-L\" || arg == \"-R\" {\n+\t\tif i+1 < len(args) {\n+\t\t\tflags = append(flags, args[i+1])\n+\t\t\ti++\n \t\t}\n+\t} else if len(arg) > 2 {\n+\t\tflags = append(flags, arg[2:])\n+\t}\n+\treturn flags, i\n+}\n+\n+// extractGlobalFlags parses global flags that were passed before 'ssh' command\n+func extractGlobalFlags(args []string) {\n+\tsshPos := findSSHCommandPosition(args)\n+\tif sshPos == -1 {\n+\t\treturn\n+\t}\n \n-\t\tctx := internal.CtxInitState(cmd.Context())\n+\tglobalArgs := args[:sshPos]\n+\tparseGlobalArgs(globalArgs)\n+}\n \n-\t\tsm := profilemanager.NewServiceManager(configPath)\n-\t\tactiveProf, err := sm.GetActiveProfileState()\n-\t\tif err != nil {\n-\t\t\treturn fmt.Errorf(\"get active profile: %v\", err)\n+// findSSHCommandPosition locates the 'ssh' command in the argument list\n+func findSSHCommandPosition(args []string) int {\n+\tfor i, arg := range args {\n+\t\tif arg == \"ssh\" {\n+\t\t\treturn i\n \t\t}\n-\t\tprofPath, err := activeProf.FilePath()\n-\t\tif err != nil {\n-\t\t\treturn fmt.Errorf(\"get active profile path: %v\", err)\n+\t}\n+\treturn -1\n+}\n+\n+const (\n+\tconfigFlag   = \"config\"\n+\tlogLevelFlag = \"log-level\"\n+\tlogFileFlag  = \"log-file\"\n+)\n+\n+// parseGlobalArgs processes the global arguments and sets the corresponding variables\n+func parseGlobalArgs(globalArgs []string) {\n+\tflagHandlers := map[string]func(string){\n+\t\tconfigFlag:   func(value string) { configPath = value },\n+\t\tlogLevelFlag: func(value string) { logLevel = value },\n+\t\tlogFileFlag: func(value string) {\n+\t\t\tif !slices.Contains(logFiles, value) {\n+\t\t\t\tlogFiles = append(logFiles, value)\n+\t\t\t}\n+\t\t},\n+\t}\n+\n+\tshortFlags := map[string]string{\n+\t\t\"c\": configFlag,\n+\t\t\"l\": logLevelFlag,\n+\t}\n+\n+\tfor i := 0; i < len(globalArgs); i++ {\n+\t\targ := globalArgs[i]\n+\n+\t\tif handled, nextIndex := parseFlag(arg, globalArgs, i, flagHandlers, shortFlags); handled {\n+\t\t\ti = nextIndex\n+\t\t}\n+\t}\n+}\n+\n+// parseFlag handles generic flag parsing for both long and short forms\n+func parseFlag(arg string, args []string, currentIndex int, flagHandlers map[string]func(string), shortFlags map[string]string) (bool, int) {\n+\tif parsedValue, found := parseEqualsFormat(arg, flagHandlers, shortFlags); found {\n+\t\tflagHandlers[parsedValue.flagName](parsedValue.value)\n+\t\treturn true, currentIndex\n+\t}\n+\n+\tif parsedValue, found := parseSpacedFormat(arg, args, currentIndex, flagHandlers, shortFlags); found {\n+\t\tflagHandlers[parsedValue.flagName](parsedValue.value)\n+\t\treturn true, currentIndex + 1\n+\t}\n+\n+\treturn false, currentIndex\n+}\n+\n+type parsedFlag struct {\n+\tflagName string\n+\tvalue    string\n+}\n+\n+// parseEqualsFormat handles --flag=value and -f=value formats\n+func parseEqualsFormat(arg string, flagHandlers map[string]func(string), shortFlags map[string]string) (parsedFlag, bool) {\n+\tif !strings.Contains(arg, \"=\") {\n+\t\treturn parsedFlag{}, false\n+\t}\n+\n+\tparts := strings.SplitN(arg, \"=\", 2)\n+\tif len(parts) != 2 {\n+\t\treturn parsedFlag{}, false\n+\t}\n+\n+\tif strings.HasPrefix(parts[0], \"--\") {\n+\t\tflagName := strings.TrimPrefix(parts[0], \"--\")\n+\t\tif _, exists := flagHandlers[flagName]; exists {\n+\t\t\treturn parsedFlag{flagName: flagName, value: parts[1]}, true\n \t\t}\n+\t}\n \n-\t\tconfig, err := profilemanager.ReadConfig(profPath)\n-\t\tif err != nil {\n-\t\t\treturn fmt.Errorf(\"read profile config: %v\", err)\n+\tif strings.HasPrefix(parts[0], \"-\") && len(parts[0]) == 2 {\n+\t\tshortFlag := strings.TrimPrefix(parts[0], \"-\")\n+\t\tif longFlag, exists := shortFlags[shortFlag]; exists {\n+\t\t\tif _, exists := flagHandlers[longFlag]; exists {\n+\t\t\t\treturn parsedFlag{flagName: longFlag, value: parts[1]}, true\n+\t\t\t}\n \t\t}\n+\t}\n+\n+\treturn parsedFlag{}, false\n+}\n+\n+// parseSpacedFormat handles --flag value and -f value formats\n+func parseSpacedFormat(arg string, args []string, currentIndex int, flagHandlers map[string]func(string), shortFlags map[string]string) (parsedFlag, bool) {\n+\tif currentIndex+1 >= len(args) {\n+\t\treturn parsedFlag{}, false\n+\t}\n \n-\t\tsig := make(chan os.Signal, 1)\n-\t\tsignal.Notify(sig, syscall.SIGTERM, syscall.SIGINT)\n-\t\tsshctx, cancel := context.WithCancel(ctx)\n+\tif strings.HasPrefix(arg, \"--\") {\n+\t\tflagName := strings.TrimPrefix(arg, \"--\")\n+\t\tif _, exists := flagHandlers[flagName]; exists {\n+\t\t\treturn parsedFlag{flagName: flagName, value: args[currentIndex+1]}, true\n+\t\t}\n+\t}\n \n-\t\tgo func() {\n-\t\t\t// blocking\n-\t\t\tif err := runSSH(sshctx, host, []byte(config.SSHKey), cmd); err != nil {\n-\t\t\t\tcmd.Printf(\"Error: %v\\n\", err)\n-\t\t\t\tos.Exit(1)\n+\tif strings.HasPrefix(arg, \"-\") && len(arg) == 2 {\n+\t\tshortFlag := strings.TrimPrefix(arg, \"-\")\n+\t\tif longFlag, exists := shortFlags[shortFlag]; exists {\n+\t\t\tif _, exists := flagHandlers[longFlag]; exists {\n+\t\t\t\treturn parsedFlag{flagName: longFlag, value: args[currentIndex+1]}, true\n \t\t\t}\n-\t\t\tcancel()\n-\t\t}()\n+\t\t}\n+\t}\n+\n+\treturn parsedFlag{}, false\n+}\n+\n+// createSSHFlagSet creates and configures the flag set for SSH command parsing\n+// sshFlags contains all SSH-related flags and parameters\n+type sshFlags struct {\n+\tPort                  int\n+\tUsername              string\n+\tLogin                 string\n+\tRequestPTY            bool\n+\tStrictHostKeyChecking bool\n+\tKnownHostsFile        string\n+\tIdentityFile          string\n+\tSkipCachedToken       bool\n+\tConfigPath            string\n+\tLogLevel              string\n+\tLocalForwards         []string\n+\tRemoteForwards        []string\n+\tHost                  string\n+\tCommand               string\n+}\n+\n+func createSSHFlagSet() (*flag.FlagSet, *sshFlags) {\n+\tdefaultConfigPath := getEnvOrDefault(\"CONFIG\", configPath)\n+\tdefaultLogLevel := getEnvOrDefault(\"LOG_LEVEL\", logLevel)\n+\n+\tfs := flag.NewFlagSet(\"ssh-flags\", flag.ContinueOnError)\n+\tfs.SetOutput(nil)\n+\n+\tflags := &sshFlags{}\n+\n+\tfs.IntVar(&flags.Port, \"p\", sshserver.DefaultSSHPort, \"SSH port\")\n+\tfs.IntVar(&flags.Port, \"port\", sshserver.DefaultSSHPort, \"SSH port\")\n+\tfs.StringVar(&flags.Username, \"u\", \"\", sshUsernameDesc)\n+\tfs.StringVar(&flags.Username, \"user\", \"\", sshUsernameDesc)\n+\tfs.StringVar(&flags.Login, \"login\", \"\", sshUsernameDesc+\" (alias for --user)\")\n+\tfs.BoolVar(&flags.RequestPTY, \"t\", false, \"Force pseudo-terminal allocation\")\n+\tfs.BoolVar(&flags.RequestPTY, \"tty\", false, \"Force pseudo-terminal allocation\")\n+\n+\tfs.BoolVar(&flags.StrictHostKeyChecking, \"strict-host-key-checking\", true, \"Enable strict host key checking\")\n+\tfs.StringVar(&flags.KnownHostsFile, \"o\", \"\", \"Path to known_hosts file\")\n+\tfs.StringVar(&flags.KnownHostsFile, \"known-hosts\", \"\", \"Path to known_hosts file\")\n+\tfs.StringVar(&flags.IdentityFile, \"i\", \"\", \"Path to SSH private key file\")\n+\tfs.StringVar(&flags.IdentityFile, \"identity\", \"\", \"Path to SSH private key file\")\n+\tfs.BoolVar(&flags.SkipCachedToken, \"no-cache\", false, \"Skip cached JWT token and force fresh authentication\")\n \n-\t\tselect {\n-\t\tcase <-sig:\n-\t\t\tcancel()\n-\t\tcase <-sshctx.Done():\n+\tfs.StringVar(&flags.ConfigPath, \"c\", defaultConfigPath, \"Netbird config file location\")\n+\tfs.StringVar(&flags.ConfigPath, \"config\", defaultConfigPath, \"Netbird config file location\")\n+\tfs.StringVar(&flags.LogLevel, \"l\", defaultLogLevel, \"sets Netbird log level\")\n+\tfs.StringVar(&flags.LogLevel, \"log-level\", defaultLogLevel, \"sets Netbird log level\")\n+\n+\treturn fs, flags\n+}\n+\n+func validateSSHArgsWithoutFlagParsing(_ *cobra.Command, args []string) error {\n+\tif len(args) < 1 {\n+\t\treturn errors.New(hostArgumentRequired)\n+\t}\n+\n+\tresetSSHGlobals()\n+\n+\tif len(os.Args) > 2 {\n+\t\textractGlobalFlags(os.Args[1:])\n+\t}\n+\n+\tfilteredArgs, localForwardFlags, remoteForwardFlags := parseCustomSSHFlags(args)\n+\n+\tfs, flags := createSSHFlagSet()\n+\n+\tif err := fs.Parse(filteredArgs); err != nil {\n+\t\tif errors.Is(err, flag.ErrHelp) {\n+\t\t\treturn nil\n \t\t}\n+\t\treturn err\n+\t}\n \n-\t\treturn nil\n-\t},\n+\tremaining := fs.Args()\n+\tif len(remaining) < 1 {\n+\t\treturn errors.New(hostArgumentRequired)\n+\t}\n+\n+\tport = flags.Port\n+\tif flags.Username != \"\" {\n+\t\tusername = flags.Username\n+\t} else if flags.Login != \"\" {\n+\t\tusername = flags.Login\n+\t}\n+\n+\trequestPTY = flags.RequestPTY\n+\tstrictHostKeyChecking = flags.StrictHostKeyChecking\n+\tknownHostsFile = flags.KnownHostsFile\n+\tidentityFile = flags.IdentityFile\n+\tskipCachedToken = flags.SkipCachedToken\n+\n+\tif flags.ConfigPath != getEnvOrDefault(\"CONFIG\", configPath) {\n+\t\tconfigPath = flags.ConfigPath\n+\t}\n+\tif flags.LogLevel != getEnvOrDefault(\"LOG_LEVEL\", logLevel) {\n+\t\tlogLevel = flags.LogLevel\n+\t}\n+\n+\tlocalForwards = localForwardFlags\n+\tremoteForwards = remoteForwardFlags\n+\n+\treturn parseHostnameAndCommand(remaining)\n }\n \n-func runSSH(ctx context.Context, addr string, pemKey []byte, cmd *cobra.Command) error {\n-\tc, err := nbssh.DialWithKey(fmt.Sprintf(\"%s:%d\", addr, port), userName, pemKey)\n+func parseHostnameAndCommand(args []string) error {\n+\tif len(args) < 1 {\n+\t\treturn errors.New(hostArgumentRequired)\n+\t}\n+\n+\targ := args[0]\n+\tif strings.Contains(arg, \"@\") {\n+\t\tparts := strings.SplitN(arg, \"@\", 2)\n+\t\tif len(parts) != 2 || parts[0] == \"\" || parts[1] == \"\" {\n+\t\t\treturn errors.New(\"invalid user@host format\")\n+\t\t}\n+\t\tif username == \"\" {\n+\t\t\tusername = parts[0]\n+\t\t}\n+\t\thost = parts[1]\n+\t} else {\n+\t\thost = arg\n+\t}\n+\n+\tif username == \"\" {\n+\t\tif sudoUser := os.Getenv(\"SUDO_USER\"); sudoUser != \"\" {\n+\t\t\tusername = sudoUser\n+\t\t} else if currentUser, err := user.Current(); err == nil {\n+\t\t\tusername = currentUser.Username\n+\t\t} else {\n+\t\t\tusername = \"root\"\n+\t\t}\n+\t}\n+\n+\t// Everything after hostname becomes the command\n+\tif len(args) > 1 {\n+\t\tcommand = strings.Join(args[1:], \" \")\n+\t}\n+\n+\treturn nil\n+}\n+\n+func runSSH(ctx context.Context, addr string, cmd *cobra.Command) error {\n+\ttarget := fmt.Sprintf(\"%s:%d\", addr, port)\n+\tc, err := sshclient.Dial(ctx, target, username, sshclient.DialOptions{\n+\t\tKnownHostsFile:     knownHostsFile,\n+\t\tIdentityFile:       identityFile,\n+\t\tDaemonAddr:         daemonAddr,\n+\t\tSkipCachedToken:    skipCachedToken,\n+\t\tInsecureSkipVerify: !strictHostKeyChecking,\n+\t})\n+\n+\tif err != nil {\n+\t\tcmd.Printf(\"Failed to connect to %s@%s\\n\", username, target)\n+\t\tcmd.Printf(\"\\nTroubleshooting steps:\\n\")\n+\t\tcmd.Printf(\"  1. Check peer connectivity: netbird status -d\\n\")\n+\t\tcmd.Printf(\"  2. Verify SSH server is enabled on the peer\\n\")\n+\t\tcmd.Printf(\"  3. Ensure correct hostname/IP is used\\n\")\n+\t\treturn fmt.Errorf(\"dial %s: %w\", target, err)\n+\t}\n+\n+\tsshCtx, cancel := context.WithCancel(ctx)\n+\tdefer cancel()\n+\n+\tgo func() {\n+\t\t<-sshCtx.Done()\n+\t\tif err := c.Close(); err != nil {\n+\t\t\tcmd.Printf(\"Error closing SSH connection: %v\\n\", err)\n+\t\t}\n+\t}()\n+\n+\tif err := startPortForwarding(sshCtx, c, cmd); err != nil {\n+\t\treturn fmt.Errorf(\"start port forwarding: %w\", err)\n+\t}\n+\n+\tif command != \"\" {\n+\t\treturn executeSSHCommand(sshCtx, c, command)\n+\t}\n+\treturn openSSHTerminal(sshCtx, c)\n+}\n+\n+// executeSSHCommand executes a command over SSH.\n+func executeSSHCommand(ctx context.Context, c *sshclient.Client, command string) error {\n+\tvar err error\n+\tif requestPTY {\n+\t\terr = c.ExecuteCommandWithPTY(ctx, command)\n+\t} else {\n+\t\terr = c.ExecuteCommandWithIO(ctx, command)\n+\t}\n+\n+\tif err != nil {\n+\t\tif errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) {\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\tvar exitErr *ssh.ExitError\n+\t\tif errors.As(err, &exitErr) {\n+\t\t\tos.Exit(exitErr.ExitStatus())\n+\t\t}\n+\n+\t\tvar exitMissingErr *ssh.ExitMissingError\n+\t\tif errors.As(err, &exitMissingErr) {\n+\t\t\tlog.Debugf(\"Remote command exited without exit status: %v\", err)\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\treturn fmt.Errorf(\"execute command: %w\", err)\n+\t}\n+\treturn nil\n+}\n+\n+// openSSHTerminal opens an interactive SSH terminal.\n+func openSSHTerminal(ctx context.Context, c *sshclient.Client) error {\n+\tif err := c.OpenTerminal(ctx); err != nil {\n+\t\tif errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) {\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\tvar exitMissingErr *ssh.ExitMissingError\n+\t\tif errors.As(err, &exitMissingErr) {\n+\t\t\tlog.Debugf(\"Remote terminal exited without exit status: %v\", err)\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\treturn fmt.Errorf(\"open terminal: %w\", err)\n+\t}\n+\treturn nil\n+}\n+\n+// startPortForwarding starts local and remote port forwarding based on command line flags\n+func startPortForwarding(ctx context.Context, c *sshclient.Client, cmd *cobra.Command) error {\n+\tfor _, forward := range localForwards {\n+\t\tif err := parseAndStartLocalForward(ctx, c, forward, cmd); err != nil {\n+\t\t\treturn fmt.Errorf(\"local port forward %s: %w\", forward, err)\n+\t\t}\n+\t}\n+\n+\tfor _, forward := range remoteForwards {\n+\t\tif err := parseAndStartRemoteForward(ctx, c, forward, cmd); err != nil {\n+\t\t\treturn fmt.Errorf(\"remote port forward %s: %w\", forward, err)\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// parseAndStartLocalForward parses and starts a local port forward (-L)\n+func parseAndStartLocalForward(ctx context.Context, c *sshclient.Client, forward string, cmd *cobra.Command) error {\n+\tlocalAddr, remoteAddr, err := parsePortForwardSpec(forward)\n \tif err != nil {\n-\t\tcmd.Printf(\"Error: %v\\n\", err)\n-\t\tcmd.Printf(\"Couldn't connect. Please check the connection status or if the ssh server is enabled on the other peer\" +\n-\t\t\t\"\\nYou can verify the connection by running:\\n\\n\" +\n-\t\t\t\" netbird status\\n\\n\")\n \t\treturn err\n \t}\n+\n+\tcmd.Printf(\"Local port forwarding: %s -> %s\\n\", localAddr, remoteAddr)\n+\n \tgo func() {\n-\t\t<-ctx.Done()\n-\t\terr = c.Close()\n-\t\tif err != nil {\n-\t\t\treturn\n+\t\tif err := c.LocalPortForward(ctx, localAddr, remoteAddr); err != nil && !errors.Is(err, context.Canceled) {\n+\t\t\tcmd.Printf(\"Local port forward error: %v\\n\", err)\n \t\t}\n \t}()\n \n-\terr = c.OpenTerminal()\n+\treturn nil\n+}\n+\n+// parseAndStartRemoteForward parses and starts a remote port forward (-R)\n+func parseAndStartRemoteForward(ctx context.Context, c *sshclient.Client, forward string, cmd *cobra.Command) error {\n+\tremoteAddr, localAddr, err := parsePortForwardSpec(forward)\n \tif err != nil {\n \t\treturn err\n \t}\n \n+\tcmd.Printf(\"Remote port forwarding: %s -> %s\\n\", remoteAddr, localAddr)\n+\n+\tgo func() {\n+\t\tif err := c.RemotePortForward(ctx, remoteAddr, localAddr); err != nil && !errors.Is(err, context.Canceled) {\n+\t\t\tcmd.Printf(\"Remote port forward error: %v\\n\", err)\n+\t\t}\n+\t}()\n+\n \treturn nil\n }\n \n-func init() {\n-\tsshCmd.PersistentFlags().IntVarP(&port, \"port\", \"p\", nbssh.DefaultSSHPort, \"Sets remote SSH port. Defaults to \"+fmt.Sprint(nbssh.DefaultSSHPort))\n+// parsePortForwardSpec parses port forward specifications like \"8080:localhost:80\" or \"[::1]:8080:localhost:80\".\n+// Also supports Unix sockets like \"8080:/tmp/socket\" or \"127.0.0.1:8080:/tmp/socket\".\n+func parsePortForwardSpec(spec string) (string, string, error) {\n+\t// Support formats:\n+\t// port:host:hostport  -> localhost:port -> host:hostport\n+\t// host:port:host:hostport  -> host:port -> host:hostport\n+\t// [host]:port:host:hostport -> [host]:port -> host:hostport\n+\t// port:unix_socket_path -> localhost:port -> unix_socket_path\n+\t// host:port:unix_socket_path -> host:port -> unix_socket_path\n+\n+\tif strings.HasPrefix(spec, \"[\") && strings.Contains(spec, \"]:\") {\n+\t\treturn parseIPv6ForwardSpec(spec)\n+\t}\n+\n+\tparts := strings.Split(spec, \":\")\n+\tif len(parts) < 2 {\n+\t\treturn \"\", \"\", fmt.Errorf(\"invalid port forward specification: %s (expected format: [local_host:]local_port:remote_target)\", spec)\n+\t}\n+\n+\tswitch len(parts) {\n+\tcase 2:\n+\t\treturn parseTwoPartForwardSpec(parts, spec)\n+\tcase 3:\n+\t\treturn parseThreePartForwardSpec(parts)\n+\tcase 4:\n+\t\treturn parseFourPartForwardSpec(parts)\n+\tdefault:\n+\t\treturn \"\", \"\", fmt.Errorf(\"invalid port forward specification: %s\", spec)\n+\t}\n+}\n+\n+// parseTwoPartForwardSpec handles \"port:unix_socket\" format.\n+func parseTwoPartForwardSpec(parts []string, spec string) (string, string, error) {\n+\tif isUnixSocket(parts[1]) {\n+\t\tlocalAddr := \"localhost:\" + parts[0]\n+\t\tremoteAddr := parts[1]\n+\t\treturn localAddr, remoteAddr, nil\n+\t}\n+\treturn \"\", \"\", fmt.Errorf(\"invalid port forward specification: %s (expected format: [local_host:]local_port:remote_host:remote_port or [local_host:]local_port:unix_socket)\", spec)\n+}\n+\n+// parseThreePartForwardSpec handles \"port:host:hostport\" or \"host:port:unix_socket\" formats.\n+func parseThreePartForwardSpec(parts []string) (string, string, error) {\n+\tif isUnixSocket(parts[2]) {\n+\t\tlocalHost := normalizeLocalHost(parts[0])\n+\t\tlocalAddr := localHost + \":\" + parts[1]\n+\t\tremoteAddr := parts[2]\n+\t\treturn localAddr, remoteAddr, nil\n+\t}\n+\tlocalAddr := \"localhost:\" + parts[0]\n+\tremoteAddr := parts[1] + \":\" + parts[2]\n+\treturn localAddr, remoteAddr, nil\n+}\n+\n+// parseFourPartForwardSpec handles \"host:port:host:hostport\" format.\n+func parseFourPartForwardSpec(parts []string) (string, string, error) {\n+\tlocalHost := normalizeLocalHost(parts[0])\n+\tlocalAddr := localHost + \":\" + parts[1]\n+\tremoteAddr := parts[2] + \":\" + parts[3]\n+\treturn localAddr, remoteAddr, nil\n+}\n+\n+// parseIPv6ForwardSpec handles \"[host]:port:host:hostport\" format.\n+func parseIPv6ForwardSpec(spec string) (string, string, error) {\n+\tidx := strings.Index(spec, \"]:\")\n+\tif idx == -1 {\n+\t\treturn \"\", \"\", fmt.Errorf(\"invalid IPv6 port forward specification: %s\", spec)\n+\t}\n+\n+\tipv6Host := spec[:idx+1]\n+\tremaining := spec[idx+2:]\n+\n+\tparts := strings.Split(remaining, \":\")\n+\tif len(parts) != 3 {\n+\t\treturn \"\", \"\", fmt.Errorf(\"invalid IPv6 port forward specification: %s (expected [ipv6]:port:host:hostport)\", spec)\n+\t}\n+\n+\tlocalAddr := ipv6Host + \":\" + parts[0]\n+\tremoteAddr := parts[1] + \":\" + parts[2]\n+\treturn localAddr, remoteAddr, nil\n+}\n+\n+// isUnixSocket checks if a path is a Unix socket path.\n+func isUnixSocket(path string) bool {\n+\treturn strings.HasPrefix(path, \"/\") || strings.HasPrefix(path, \"./\")\n+}\n+\n+// normalizeLocalHost converts \"*\" to \"0.0.0.0\" for binding to all interfaces.\n+func normalizeLocalHost(host string) string {\n+\tif host == \"*\" {\n+\t\treturn \"0.0.0.0\"\n+\t}\n+\treturn host\n+}\n+\n+var sshProxyCmd = &cobra.Command{\n+\tUse:    \"proxy <host> <port>\",\n+\tShort:  \"Internal SSH proxy for native SSH client integration\",\n+\tLong:   \"Internal command used by SSH ProxyCommand to handle JWT authentication\",\n+\tHidden: true,\n+\tArgs:   cobra.ExactArgs(2),\n+\tRunE:   sshProxyFn,\n+}\n+\n+func sshProxyFn(cmd *cobra.Command, args []string) error {\n+\tlogOutput := \"console\"\n+\tif firstLogFile := util.FindFirstLogPath(logFiles); firstLogFile != \"\" && firstLogFile != defaultLogFile {\n+\t\tlogOutput = firstLogFile\n+\t}\n+\tif err := util.InitLog(logLevel, logOutput); err != nil {\n+\t\treturn fmt.Errorf(\"init log: %w\", err)\n+\t}\n+\n+\thost := args[0]\n+\tportStr := args[1]\n+\n+\tport, err := strconv.Atoi(portStr)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"invalid port: %s\", portStr)\n+\t}\n+\n+\tproxy, err := sshproxy.New(daemonAddr, host, port, cmd.ErrOrStderr())\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"create SSH proxy: %w\", err)\n+\t}\n+\tdefer func() {\n+\t\tif err := proxy.Close(); err != nil {\n+\t\t\tlog.Debugf(\"close SSH proxy: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tif err := proxy.Connect(cmd.Context()); err != nil {\n+\t\treturn fmt.Errorf(\"SSH proxy: %w\", err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+var sshDetectCmd = &cobra.Command{\n+\tUse:    \"detect <host> <port>\",\n+\tShort:  \"Detect if a host is running NetBird SSH\",\n+\tLong:   \"Internal command used by SSH Match exec to detect NetBird SSH servers. Exit codes: 0=JWT, 1=no-JWT, 2=regular SSH\",\n+\tHidden: true,\n+\tArgs:   cobra.ExactArgs(2),\n+\tRunE:   sshDetectFn,\n+}\n+\n+func sshDetectFn(cmd *cobra.Command, args []string) error {\n+\tif err := util.InitLog(logLevel, \"console\"); err != nil {\n+\t\tos.Exit(detection.ServerTypeRegular.ExitCode())\n+\t}\n+\n+\thost := args[0]\n+\tportStr := args[1]\n+\n+\tport, err := strconv.Atoi(portStr)\n+\tif err != nil {\n+\t\tos.Exit(detection.ServerTypeRegular.ExitCode())\n+\t}\n+\n+\tdialer := &net.Dialer{Timeout: detection.Timeout}\n+\tserverType, err := detection.DetectSSHServerType(cmd.Context(), dialer, host, port)\n+\tif err != nil {\n+\t\tos.Exit(detection.ServerTypeRegular.ExitCode())\n+\t}\n+\n+\tos.Exit(serverType.ExitCode())\n+\treturn nil\n }\ndiff --git a/client/cmd/ssh_exec_unix.go b/client/cmd/ssh_exec_unix.go\nnew file mode 100644\nindex 00000000000..2412f072c5e\n--- /dev/null\n+++ b/client/cmd/ssh_exec_unix.go\n@@ -0,0 +1,74 @@\n+//go:build unix\n+\n+package cmd\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\n+\t\"github.com/spf13/cobra\"\n+\n+\tsshserver \"github.com/netbirdio/netbird/client/ssh/server\"\n+)\n+\n+var (\n+\tsshExecUID        uint32\n+\tsshExecGID        uint32\n+\tsshExecGroups     []uint\n+\tsshExecWorkingDir string\n+\tsshExecShell      string\n+\tsshExecCommand    string\n+\tsshExecPTY        bool\n+)\n+\n+// sshExecCmd represents the hidden ssh exec subcommand for privilege dropping\n+var sshExecCmd = &cobra.Command{\n+\tUse:    \"exec\",\n+\tShort:  \"Internal SSH execution with privilege dropping (hidden)\",\n+\tHidden: true,\n+\tRunE:   runSSHExec,\n+}\n+\n+func init() {\n+\tsshExecCmd.Flags().Uint32Var(&sshExecUID, \"uid\", 0, \"Target user ID\")\n+\tsshExecCmd.Flags().Uint32Var(&sshExecGID, \"gid\", 0, \"Target group ID\")\n+\tsshExecCmd.Flags().UintSliceVar(&sshExecGroups, \"groups\", nil, \"Supplementary group IDs (can be repeated)\")\n+\tsshExecCmd.Flags().StringVar(&sshExecWorkingDir, \"working-dir\", \"\", \"Working directory\")\n+\tsshExecCmd.Flags().StringVar(&sshExecShell, \"shell\", \"/bin/sh\", \"Shell to execute\")\n+\tsshExecCmd.Flags().BoolVar(&sshExecPTY, \"pty\", false, \"Request PTY (will fail as executor doesn't support PTY)\")\n+\tsshExecCmd.Flags().StringVar(&sshExecCommand, \"cmd\", \"\", \"Command to execute\")\n+\n+\tif err := sshExecCmd.MarkFlagRequired(\"uid\"); err != nil {\n+\t\t_, _ = fmt.Fprintf(os.Stderr, \"failed to mark uid flag as required: %v\\n\", err)\n+\t\tos.Exit(1)\n+\t}\n+\tif err := sshExecCmd.MarkFlagRequired(\"gid\"); err != nil {\n+\t\t_, _ = fmt.Fprintf(os.Stderr, \"failed to mark gid flag as required: %v\\n\", err)\n+\t\tos.Exit(1)\n+\t}\n+\n+\tsshCmd.AddCommand(sshExecCmd)\n+}\n+\n+// runSSHExec handles the SSH exec subcommand execution.\n+func runSSHExec(cmd *cobra.Command, _ []string) error {\n+\tprivilegeDropper := sshserver.NewPrivilegeDropper()\n+\n+\tvar groups []uint32\n+\tfor _, groupInt := range sshExecGroups {\n+\t\tgroups = append(groups, uint32(groupInt))\n+\t}\n+\n+\tconfig := sshserver.ExecutorConfig{\n+\t\tUID:        sshExecUID,\n+\t\tGID:        sshExecGID,\n+\t\tGroups:     groups,\n+\t\tWorkingDir: sshExecWorkingDir,\n+\t\tShell:      sshExecShell,\n+\t\tCommand:    sshExecCommand,\n+\t\tPTY:        sshExecPTY,\n+\t}\n+\n+\tprivilegeDropper.ExecuteWithPrivilegeDrop(cmd.Context(), config)\n+\treturn nil\n+}\ndiff --git a/client/cmd/ssh_sftp_unix.go b/client/cmd/ssh_sftp_unix.go\nnew file mode 100644\nindex 00000000000..c06aab01713\n--- /dev/null\n+++ b/client/cmd/ssh_sftp_unix.go\n@@ -0,0 +1,94 @@\n+//go:build unix\n+\n+package cmd\n+\n+import (\n+\t\"errors\"\n+\t\"io\"\n+\t\"os\"\n+\n+\t\"github.com/pkg/sftp\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"github.com/spf13/cobra\"\n+\n+\tsshserver \"github.com/netbirdio/netbird/client/ssh/server\"\n+)\n+\n+var (\n+\tsftpUID        uint32\n+\tsftpGID        uint32\n+\tsftpGroupsInt  []uint\n+\tsftpWorkingDir string\n+)\n+\n+var sshSftpCmd = &cobra.Command{\n+\tUse:    \"sftp\",\n+\tShort:  \"SFTP server with privilege dropping (internal use)\",\n+\tHidden: true,\n+\tRunE:   sftpMain,\n+}\n+\n+func init() {\n+\tsshSftpCmd.Flags().Uint32Var(&sftpUID, \"uid\", 0, \"Target user ID\")\n+\tsshSftpCmd.Flags().Uint32Var(&sftpGID, \"gid\", 0, \"Target group ID\")\n+\tsshSftpCmd.Flags().UintSliceVar(&sftpGroupsInt, \"groups\", nil, \"Supplementary group IDs (can be repeated)\")\n+\tsshSftpCmd.Flags().StringVar(&sftpWorkingDir, \"working-dir\", \"\", \"Working directory\")\n+}\n+\n+func sftpMain(cmd *cobra.Command, _ []string) error {\n+\tprivilegeDropper := sshserver.NewPrivilegeDropper()\n+\n+\tvar groups []uint32\n+\tfor _, groupInt := range sftpGroupsInt {\n+\t\tgroups = append(groups, uint32(groupInt))\n+\t}\n+\n+\tconfig := sshserver.ExecutorConfig{\n+\t\tUID:        sftpUID,\n+\t\tGID:        sftpGID,\n+\t\tGroups:     groups,\n+\t\tWorkingDir: sftpWorkingDir,\n+\t\tShell:      \"\",\n+\t\tCommand:    \"\",\n+\t}\n+\n+\tlog.Tracef(\"dropping privileges for SFTP to UID=%d, GID=%d, groups=%v\", config.UID, config.GID, config.Groups)\n+\n+\tif err := privilegeDropper.DropPrivileges(config.UID, config.GID, config.Groups); err != nil {\n+\t\tcmd.PrintErrf(\"privilege drop failed: %v\\n\", err)\n+\t\tos.Exit(sshserver.ExitCodePrivilegeDropFail)\n+\t}\n+\n+\tif config.WorkingDir != \"\" {\n+\t\tif err := os.Chdir(config.WorkingDir); err != nil {\n+\t\t\tcmd.PrintErrf(\"failed to change to working directory %s: %v\\n\", config.WorkingDir, err)\n+\t\t}\n+\t}\n+\n+\tsftpServer, err := sftp.NewServer(struct {\n+\t\tio.Reader\n+\t\tio.WriteCloser\n+\t}{\n+\t\tReader:      os.Stdin,\n+\t\tWriteCloser: os.Stdout,\n+\t})\n+\tif err != nil {\n+\t\tcmd.PrintErrf(\"SFTP server creation failed: %v\\n\", err)\n+\t\tos.Exit(sshserver.ExitCodeShellExecFail)\n+\t}\n+\n+\tlog.Tracef(\"starting SFTP server with dropped privileges\")\n+\tif err := sftpServer.Serve(); err != nil && !errors.Is(err, io.EOF) {\n+\t\tcmd.PrintErrf(\"SFTP server error: %v\\n\", err)\n+\t\tif closeErr := sftpServer.Close(); closeErr != nil {\n+\t\t\tcmd.PrintErrf(\"SFTP server close error: %v\\n\", closeErr)\n+\t\t}\n+\t\tos.Exit(sshserver.ExitCodeShellExecFail)\n+\t}\n+\n+\tif closeErr := sftpServer.Close(); closeErr != nil {\n+\t\tcmd.PrintErrf(\"SFTP server close error: %v\\n\", closeErr)\n+\t}\n+\tos.Exit(sshserver.ExitCodeSuccess)\n+\treturn nil\n+}\ndiff --git a/client/cmd/ssh_sftp_windows.go b/client/cmd/ssh_sftp_windows.go\nnew file mode 100644\nindex 00000000000..ffd2d11487e\n--- /dev/null\n+++ b/client/cmd/ssh_sftp_windows.go\n@@ -0,0 +1,94 @@\n+//go:build windows\n+\n+package cmd\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"os/user\"\n+\t\"strings\"\n+\n+\t\"github.com/pkg/sftp\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"github.com/spf13/cobra\"\n+\n+\tsshserver \"github.com/netbirdio/netbird/client/ssh/server\"\n+)\n+\n+var (\n+\tsftpWorkingDir  string\n+\twindowsUsername string\n+\twindowsDomain   string\n+)\n+\n+var sshSftpCmd = &cobra.Command{\n+\tUse:    \"sftp\",\n+\tShort:  \"SFTP server with user switching for Windows (internal use)\",\n+\tHidden: true,\n+\tRunE:   sftpMain,\n+}\n+\n+func init() {\n+\tsshSftpCmd.Flags().StringVar(&sftpWorkingDir, \"working-dir\", \"\", \"Working directory\")\n+\tsshSftpCmd.Flags().StringVar(&windowsUsername, \"windows-username\", \"\", \"Windows username for user switching\")\n+\tsshSftpCmd.Flags().StringVar(&windowsDomain, \"windows-domain\", \"\", \"Windows domain for user switching\")\n+}\n+\n+func sftpMain(cmd *cobra.Command, _ []string) error {\n+\treturn sftpMainDirect(cmd)\n+}\n+\n+func sftpMainDirect(cmd *cobra.Command) error {\n+\tcurrentUser, err := user.Current()\n+\tif err != nil {\n+\t\tcmd.PrintErrf(\"failed to get current user: %v\\n\", err)\n+\t\tos.Exit(sshserver.ExitCodeValidationFail)\n+\t}\n+\n+\tif windowsUsername != \"\" {\n+\t\texpectedUsername := windowsUsername\n+\t\tif windowsDomain != \"\" {\n+\t\t\texpectedUsername = fmt.Sprintf(`%s\\%s`, windowsDomain, windowsUsername)\n+\t\t}\n+\t\tif !strings.EqualFold(currentUser.Username, expectedUsername) && !strings.EqualFold(currentUser.Username, windowsUsername) {\n+\t\t\tcmd.PrintErrf(\"user switching failed\\n\")\n+\t\t\tos.Exit(sshserver.ExitCodeValidationFail)\n+\t\t}\n+\t}\n+\n+\tlog.Debugf(\"SFTP process running as: %s (UID: %s, Name: %s)\", currentUser.Username, currentUser.Uid, currentUser.Name)\n+\n+\tif sftpWorkingDir != \"\" {\n+\t\tif err := os.Chdir(sftpWorkingDir); err != nil {\n+\t\t\tcmd.PrintErrf(\"failed to change to working directory %s: %v\\n\", sftpWorkingDir, err)\n+\t\t}\n+\t}\n+\n+\tsftpServer, err := sftp.NewServer(struct {\n+\t\tio.Reader\n+\t\tio.WriteCloser\n+\t}{\n+\t\tReader:      os.Stdin,\n+\t\tWriteCloser: os.Stdout,\n+\t})\n+\tif err != nil {\n+\t\tcmd.PrintErrf(\"SFTP server creation failed: %v\\n\", err)\n+\t\tos.Exit(sshserver.ExitCodeShellExecFail)\n+\t}\n+\n+\tlog.Debugf(\"starting SFTP server\")\n+\texitCode := sshserver.ExitCodeSuccess\n+\tif err := sftpServer.Serve(); err != nil && !errors.Is(err, io.EOF) {\n+\t\tcmd.PrintErrf(\"SFTP server error: %v\\n\", err)\n+\t\texitCode = sshserver.ExitCodeShellExecFail\n+\t}\n+\n+\tif err := sftpServer.Close(); err != nil {\n+\t\tlog.Debugf(\"SFTP server close error: %v\", err)\n+\t}\n+\n+\tos.Exit(exitCode)\n+\treturn nil\n+}\ndiff --git a/client/cmd/status.go b/client/cmd/status.go\nindex 6e57ceb894e..06460a6a7ee 100644\n--- a/client/cmd/status.go\n+++ b/client/cmd/status.go\n@@ -109,7 +109,7 @@ func statusFunc(cmd *cobra.Command, args []string) error {\n \tcase yamlFlag:\n \t\tstatusOutputString, err = nbstatus.ParseToYAML(outputInformationHolder)\n \tdefault:\n-\t\tstatusOutputString = nbstatus.ParseGeneralSummary(outputInformationHolder, false, false, false)\n+\t\tstatusOutputString = nbstatus.ParseGeneralSummary(outputInformationHolder, false, false, false, false)\n \t}\n \n \tif err != nil {\ndiff --git a/client/cmd/up.go b/client/cmd/up.go\nindex 80175f7be59..140ba2cb29c 100644\n--- a/client/cmd/up.go\n+++ b/client/cmd/up.go\n@@ -355,6 +355,25 @@ func setupSetConfigReq(customDNSAddressConverted []byte, cmd *cobra.Command, pro\n \tif cmd.Flag(serverSSHAllowedFlag).Changed {\n \t\treq.ServerSSHAllowed = &serverSSHAllowed\n \t}\n+\tif cmd.Flag(enableSSHRootFlag).Changed {\n+\t\treq.EnableSSHRoot = &enableSSHRoot\n+\t}\n+\tif cmd.Flag(enableSSHSFTPFlag).Changed {\n+\t\treq.EnableSSHSFTP = &enableSSHSFTP\n+\t}\n+\tif cmd.Flag(enableSSHLocalPortForwardFlag).Changed {\n+\t\treq.EnableSSHLocalPortForwarding = &enableSSHLocalPortForward\n+\t}\n+\tif cmd.Flag(enableSSHRemotePortForwardFlag).Changed {\n+\t\treq.EnableSSHRemotePortForwarding = &enableSSHRemotePortForward\n+\t}\n+\tif cmd.Flag(disableSSHAuthFlag).Changed {\n+\t\treq.DisableSSHAuth = &disableSSHAuth\n+\t}\n+\tif cmd.Flag(sshJWTCacheTTLFlag).Changed {\n+\t\tsshJWTCacheTTL32 := int32(sshJWTCacheTTL)\n+\t\treq.SshJWTCacheTTL = &sshJWTCacheTTL32\n+\t}\n \tif cmd.Flag(interfaceNameFlag).Changed {\n \t\tif err := parseInterfaceName(interfaceName); err != nil {\n \t\t\tlog.Errorf(\"parse interface name: %v\", err)\n@@ -439,6 +458,30 @@ func setupConfig(customDNSAddressConverted []byte, cmd *cobra.Command, configFil\n \t\tic.ServerSSHAllowed = &serverSSHAllowed\n \t}\n \n+\tif cmd.Flag(enableSSHRootFlag).Changed {\n+\t\tic.EnableSSHRoot = &enableSSHRoot\n+\t}\n+\n+\tif cmd.Flag(enableSSHSFTPFlag).Changed {\n+\t\tic.EnableSSHSFTP = &enableSSHSFTP\n+\t}\n+\n+\tif cmd.Flag(enableSSHLocalPortForwardFlag).Changed {\n+\t\tic.EnableSSHLocalPortForwarding = &enableSSHLocalPortForward\n+\t}\n+\n+\tif cmd.Flag(enableSSHRemotePortForwardFlag).Changed {\n+\t\tic.EnableSSHRemotePortForwarding = &enableSSHRemotePortForward\n+\t}\n+\n+\tif cmd.Flag(disableSSHAuthFlag).Changed {\n+\t\tic.DisableSSHAuth = &disableSSHAuth\n+\t}\n+\n+\tif cmd.Flag(sshJWTCacheTTLFlag).Changed {\n+\t\tic.SSHJWTCacheTTL = &sshJWTCacheTTL\n+\t}\n+\n \tif cmd.Flag(interfaceNameFlag).Changed {\n \t\tif err := parseInterfaceName(interfaceName); err != nil {\n \t\t\treturn nil, err\n@@ -539,6 +582,31 @@ func setupLoginRequest(providedSetupKey string, customDNSAddressConverted []byte\n \t\tloginRequest.ServerSSHAllowed = &serverSSHAllowed\n \t}\n \n+\tif cmd.Flag(enableSSHRootFlag).Changed {\n+\t\tloginRequest.EnableSSHRoot = &enableSSHRoot\n+\t}\n+\n+\tif cmd.Flag(enableSSHSFTPFlag).Changed {\n+\t\tloginRequest.EnableSSHSFTP = &enableSSHSFTP\n+\t}\n+\n+\tif cmd.Flag(enableSSHLocalPortForwardFlag).Changed {\n+\t\tloginRequest.EnableSSHLocalPortForwarding = &enableSSHLocalPortForward\n+\t}\n+\n+\tif cmd.Flag(enableSSHRemotePortForwardFlag).Changed {\n+\t\tloginRequest.EnableSSHRemotePortForwarding = &enableSSHRemotePortForward\n+\t}\n+\n+\tif cmd.Flag(disableSSHAuthFlag).Changed {\n+\t\tloginRequest.DisableSSHAuth = &disableSSHAuth\n+\t}\n+\n+\tif cmd.Flag(sshJWTCacheTTLFlag).Changed {\n+\t\tsshJWTCacheTTL32 := int32(sshJWTCacheTTL)\n+\t\tloginRequest.SshJWTCacheTTL = &sshJWTCacheTTL32\n+\t}\n+\n \tif cmd.Flag(disableAutoConnectFlag).Changed {\n \t\tloginRequest.DisableAutoConnect = &autoConnectDisabled\n \t}\ndiff --git a/client/embed/embed.go b/client/embed/embed.go\nindex e918235ed13..3090ca6a2e0 100644\n--- a/client/embed/embed.go\n+++ b/client/embed/embed.go\n@@ -18,12 +18,16 @@ import (\n \t\"github.com/netbirdio/netbird/client/internal\"\n \t\"github.com/netbirdio/netbird/client/internal/peer\"\n \t\"github.com/netbirdio/netbird/client/internal/profilemanager\"\n+\tsshcommon \"github.com/netbirdio/netbird/client/ssh\"\n \t\"github.com/netbirdio/netbird/client/system\"\n )\n \n-var ErrClientAlreadyStarted = errors.New(\"client already started\")\n-var ErrClientNotStarted = errors.New(\"client not started\")\n-var ErrConfigNotInitialized = errors.New(\"config not initialized\")\n+var (\n+\tErrClientAlreadyStarted = errors.New(\"client already started\")\n+\tErrClientNotStarted     = errors.New(\"client not started\")\n+\tErrEngineNotStarted     = errors.New(\"engine not started\")\n+\tErrConfigNotInitialized = errors.New(\"config not initialized\")\n+)\n \n // Client manages a netbird embedded client instance.\n type Client struct {\n@@ -238,17 +242,9 @@ func (c *Client) GetConfig() (profilemanager.Config, error) {\n // Dial dials a network address in the netbird network.\n // Not applicable if the userspace networking mode is disabled.\n func (c *Client) Dial(ctx context.Context, network, address string) (net.Conn, error) {\n-\tc.mu.Lock()\n-\tconnect := c.connect\n-\tif connect == nil {\n-\t\tc.mu.Unlock()\n-\t\treturn nil, ErrClientNotStarted\n-\t}\n-\tc.mu.Unlock()\n-\n-\tengine := connect.Engine()\n-\tif engine == nil {\n-\t\treturn nil, errors.New(\"engine not started\")\n+\tengine, err := c.getEngine()\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n \n \tnsnet, err := engine.GetNet()\n@@ -259,6 +255,11 @@ func (c *Client) Dial(ctx context.Context, network, address string) (net.Conn, e\n \treturn nsnet.DialContext(ctx, network, address)\n }\n \n+// DialContext dials a network address in the netbird network with context\n+func (c *Client) DialContext(ctx context.Context, network, address string) (net.Conn, error) {\n+\treturn c.Dial(ctx, network, address)\n+}\n+\n // ListenTCP listens on the given address in the netbird network.\n // Not applicable if the userspace networking mode is disabled.\n func (c *Client) ListenTCP(address string) (net.Listener, error) {\n@@ -314,18 +315,47 @@ func (c *Client) NewHTTPClient() *http.Client {\n \t}\n }\n \n-func (c *Client) getNet() (*wgnetstack.Net, netip.Addr, error) {\n+// VerifySSHHostKey verifies an SSH host key against stored peer keys.\n+// Returns nil if the key matches, ErrPeerNotFound if peer is not in network,\n+// ErrNoStoredKey if peer has no stored key, or an error for verification failures.\n+func (c *Client) VerifySSHHostKey(peerAddress string, key []byte) error {\n+\tengine, err := c.getEngine()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tstoredKey, found := engine.GetPeerSSHKey(peerAddress)\n+\tif !found {\n+\t\treturn sshcommon.ErrPeerNotFound\n+\t}\n+\n+\treturn sshcommon.VerifyHostKey(storedKey, key, peerAddress)\n+}\n+\n+// getEngine safely retrieves the engine from the client with proper locking.\n+// Returns ErrClientNotStarted if the client is not started.\n+// Returns ErrEngineNotStarted if the engine is not available.\n+func (c *Client) getEngine() (*internal.Engine, error) {\n \tc.mu.Lock()\n \tconnect := c.connect\n+\tc.mu.Unlock()\n+\n \tif connect == nil {\n-\t\tc.mu.Unlock()\n-\t\treturn nil, netip.Addr{}, errors.New(\"client not started\")\n+\t\treturn nil, ErrClientNotStarted\n \t}\n-\tc.mu.Unlock()\n \n \tengine := connect.Engine()\n \tif engine == nil {\n-\t\treturn nil, netip.Addr{}, errors.New(\"engine not started\")\n+\t\treturn nil, ErrEngineNotStarted\n+\t}\n+\n+\treturn engine, nil\n+}\n+\n+func (c *Client) getNet() (*wgnetstack.Net, netip.Addr, error) {\n+\tengine, err := c.getEngine()\n+\tif err != nil {\n+\t\treturn nil, netip.Addr{}, err\n \t}\n \n \taddr, err := engine.Address()\ndiff --git a/client/firewall/uspfilter/filter.go b/client/firewall/uspfilter/filter.go\nindex 990630ee4e3..4e22bde3fbd 100644\n--- a/client/firewall/uspfilter/filter.go\n+++ b/client/firewall/uspfilter/filter.go\n@@ -35,6 +35,12 @@ const (\n \tipTCPHeaderMinSize = 40\n )\n \n+// serviceKey represents a protocol/port combination for netstack service registry\n+type serviceKey struct {\n+\tprotocol gopacket.LayerType\n+\tport     uint16\n+}\n+\n const (\n \t// EnvDisableConntrack disables the stateful filter, replies to outbound traffic won't be allowed.\n \tEnvDisableConntrack = \"NB_DISABLE_CONNTRACK\"\n@@ -59,12 +65,6 @@ const (\n \n var errNatNotSupported = errors.New(\"nat not supported with userspace firewall\")\n \n-// serviceKey represents a protocol/port combination for netstack service registry\n-type serviceKey struct {\n-\tprotocol gopacket.LayerType\n-\tport     uint16\n-}\n-\n // RuleSet is a set of rules grouped by a string key\n type RuleSet map[string]PeerRule\n \ndiff --git a/client/internal/acl/manager.go b/client/internal/acl/manager.go\nindex 965decc7380..dd6f9479a30 100644\n--- a/client/internal/acl/manager.go\n+++ b/client/internal/acl/manager.go\n@@ -17,7 +17,6 @@ import (\n \tnberrors \"github.com/netbirdio/netbird/client/errors\"\n \tfirewall \"github.com/netbirdio/netbird/client/firewall/manager\"\n \t\"github.com/netbirdio/netbird/client/internal/acl/id\"\n-\t\"github.com/netbirdio/netbird/client/ssh\"\n \t\"github.com/netbirdio/netbird/shared/management/domain\"\n \tmgmProto \"github.com/netbirdio/netbird/shared/management/proto\"\n )\n@@ -83,22 +82,6 @@ func (d *DefaultManager) ApplyFiltering(networkMap *mgmProto.NetworkMap, dnsRout\n func (d *DefaultManager) applyPeerACLs(networkMap *mgmProto.NetworkMap) {\n \trules := networkMap.FirewallRules\n \n-\tenableSSH := networkMap.PeerConfig != nil &&\n-\t\tnetworkMap.PeerConfig.SshConfig != nil &&\n-\t\tnetworkMap.PeerConfig.SshConfig.SshEnabled\n-\n-\t// If SSH enabled, add default firewall rule which accepts connection to any peer\n-\t// in the network by SSH (TCP port defined by ssh.DefaultSSHPort).\n-\tif enableSSH {\n-\t\trules = append(rules, &mgmProto.FirewallRule{\n-\t\t\tPeerIP:    \"0.0.0.0\",\n-\t\t\tDirection: mgmProto.RuleDirection_IN,\n-\t\t\tAction:    mgmProto.RuleAction_ACCEPT,\n-\t\t\tProtocol:  mgmProto.RuleProtocol_TCP,\n-\t\t\tPort:      strconv.Itoa(ssh.DefaultSSHPort),\n-\t\t})\n-\t}\n-\n \t// if we got empty rules list but management not set networkMap.FirewallRulesIsEmpty flag\n \t// we have old version of management without rules handling, we should allow all traffic\n \tif len(networkMap.FirewallRules) == 0 && !networkMap.FirewallRulesIsEmpty {\ndiff --git a/client/internal/connect.go b/client/internal/connect.go\nindex bb7c2b38b0e..6ad5f264bc9 100644\n--- a/client/internal/connect.go\n+++ b/client/internal/connect.go\n@@ -416,20 +416,25 @@ func createEngineConfig(key wgtypes.Key, config *profilemanager.Config, peerConf\n \t\tnm = *config.NetworkMonitor\n \t}\n \tengineConf := &EngineConfig{\n-\t\tWgIfaceName:          config.WgIface,\n-\t\tWgAddr:               peerConfig.Address,\n-\t\tIFaceBlackList:       config.IFaceBlackList,\n-\t\tDisableIPv6Discovery: config.DisableIPv6Discovery,\n-\t\tWgPrivateKey:         key,\n-\t\tWgPort:               config.WgPort,\n-\t\tNetworkMonitor:       nm,\n-\t\tSSHKey:               []byte(config.SSHKey),\n-\t\tNATExternalIPs:       config.NATExternalIPs,\n-\t\tCustomDNSAddress:     config.CustomDNSAddress,\n-\t\tRosenpassEnabled:     config.RosenpassEnabled,\n-\t\tRosenpassPermissive:  config.RosenpassPermissive,\n-\t\tServerSSHAllowed:     util.ReturnBoolWithDefaultTrue(config.ServerSSHAllowed),\n-\t\tDNSRouteInterval:     config.DNSRouteInterval,\n+\t\tWgIfaceName:                   config.WgIface,\n+\t\tWgAddr:                        peerConfig.Address,\n+\t\tIFaceBlackList:                config.IFaceBlackList,\n+\t\tDisableIPv6Discovery:          config.DisableIPv6Discovery,\n+\t\tWgPrivateKey:                  key,\n+\t\tWgPort:                        config.WgPort,\n+\t\tNetworkMonitor:                nm,\n+\t\tSSHKey:                        []byte(config.SSHKey),\n+\t\tNATExternalIPs:                config.NATExternalIPs,\n+\t\tCustomDNSAddress:              config.CustomDNSAddress,\n+\t\tRosenpassEnabled:              config.RosenpassEnabled,\n+\t\tRosenpassPermissive:           config.RosenpassPermissive,\n+\t\tServerSSHAllowed:              util.ReturnBoolWithDefaultTrue(config.ServerSSHAllowed),\n+\t\tEnableSSHRoot:                 config.EnableSSHRoot,\n+\t\tEnableSSHSFTP:                 config.EnableSSHSFTP,\n+\t\tEnableSSHLocalPortForwarding:  config.EnableSSHLocalPortForwarding,\n+\t\tEnableSSHRemotePortForwarding: config.EnableSSHRemotePortForwarding,\n+\t\tDisableSSHAuth:                config.DisableSSHAuth,\n+\t\tDNSRouteInterval:              config.DNSRouteInterval,\n \n \t\tDisableClientRoutes: config.DisableClientRoutes,\n \t\tDisableServerRoutes: config.DisableServerRoutes || config.BlockInbound,\n@@ -515,6 +520,11 @@ func loginToManagement(ctx context.Context, client mgm.Client, pubSSHKey []byte,\n \t\tconfig.BlockLANAccess,\n \t\tconfig.BlockInbound,\n \t\tconfig.LazyConnectionEnabled,\n+\t\tconfig.EnableSSHRoot,\n+\t\tconfig.EnableSSHSFTP,\n+\t\tconfig.EnableSSHLocalPortForwarding,\n+\t\tconfig.EnableSSHRemotePortForwarding,\n+\t\tconfig.DisableSSHAuth,\n \t)\n \tloginResp, err := client.Login(*serverPublicKey, sysInfo, pubSSHKey, config.DNSLabels)\n \tif err != nil {\ndiff --git a/client/internal/debug/debug.go b/client/internal/debug/debug.go\nindex fbec29ce38b..58977b8844d 100644\n--- a/client/internal/debug/debug.go\n+++ b/client/internal/debug/debug.go\n@@ -453,6 +453,18 @@ func (g *BundleGenerator) addCommonConfigFields(configContent *strings.Builder)\n \tif g.internalConfig.ServerSSHAllowed != nil {\n \t\tconfigContent.WriteString(fmt.Sprintf(\"ServerSSHAllowed: %v\\n\", *g.internalConfig.ServerSSHAllowed))\n \t}\n+\tif g.internalConfig.EnableSSHRoot != nil {\n+\t\tconfigContent.WriteString(fmt.Sprintf(\"EnableSSHRoot: %v\\n\", *g.internalConfig.EnableSSHRoot))\n+\t}\n+\tif g.internalConfig.EnableSSHSFTP != nil {\n+\t\tconfigContent.WriteString(fmt.Sprintf(\"EnableSSHSFTP: %v\\n\", *g.internalConfig.EnableSSHSFTP))\n+\t}\n+\tif g.internalConfig.EnableSSHLocalPortForwarding != nil {\n+\t\tconfigContent.WriteString(fmt.Sprintf(\"EnableSSHLocalPortForwarding: %v\\n\", *g.internalConfig.EnableSSHLocalPortForwarding))\n+\t}\n+\tif g.internalConfig.EnableSSHRemotePortForwarding != nil {\n+\t\tconfigContent.WriteString(fmt.Sprintf(\"EnableSSHRemotePortForwarding: %v\\n\", *g.internalConfig.EnableSSHRemotePortForwarding))\n+\t}\n \n \tconfigContent.WriteString(fmt.Sprintf(\"DisableClientRoutes: %v\\n\", g.internalConfig.DisableClientRoutes))\n \tconfigContent.WriteString(fmt.Sprintf(\"DisableServerRoutes: %v\\n\", g.internalConfig.DisableServerRoutes))\ndiff --git a/client/internal/engine.go b/client/internal/engine.go\nindex ebc05c45355..1deb3d3cfca 100644\n--- a/client/internal/engine.go\n+++ b/client/internal/engine.go\n@@ -9,7 +9,6 @@ import (\n \t\"net/netip\"\n \t\"net/url\"\n \t\"os\"\n-\t\"reflect\"\n \t\"runtime\"\n \t\"slices\"\n \t\"sort\"\n@@ -30,7 +29,6 @@ import (\n \tfirewallManager \"github.com/netbirdio/netbird/client/firewall/manager\"\n \t\"github.com/netbirdio/netbird/client/iface\"\n \t\"github.com/netbirdio/netbird/client/iface/device\"\n-\tnbnetstack \"github.com/netbirdio/netbird/client/iface/netstack\"\n \t\"github.com/netbirdio/netbird/client/iface/udpmux\"\n \t\"github.com/netbirdio/netbird/client/internal/acl\"\n \t\"github.com/netbirdio/netbird/client/internal/dns\"\n@@ -51,10 +49,10 @@ import (\n \t\"github.com/netbirdio/netbird/client/internal/routemanager/systemops\"\n \t\"github.com/netbirdio/netbird/client/internal/statemanager\"\n \tcProto \"github.com/netbirdio/netbird/client/proto\"\n+\tsshconfig \"github.com/netbirdio/netbird/client/ssh/config\"\n \t\"github.com/netbirdio/netbird/shared/management/domain\"\n \tsemaphoregroup \"github.com/netbirdio/netbird/util/semaphore-group\"\n \n-\tnbssh \"github.com/netbirdio/netbird/client/ssh\"\n \t\"github.com/netbirdio/netbird/client/system\"\n \tnbdns \"github.com/netbirdio/netbird/dns\"\n \t\"github.com/netbirdio/netbird/route\"\n@@ -115,7 +113,12 @@ type EngineConfig struct {\n \tRosenpassEnabled    bool\n \tRosenpassPermissive bool\n \n-\tServerSSHAllowed bool\n+\tServerSSHAllowed              bool\n+\tEnableSSHRoot                 *bool\n+\tEnableSSHSFTP                 *bool\n+\tEnableSSHLocalPortForwarding  *bool\n+\tEnableSSHRemotePortForwarding *bool\n+\tDisableSSHAuth                *bool\n \n \tDNSRouteInterval time.Duration\n \n@@ -148,8 +151,6 @@ type Engine struct {\n \n \t// syncMsgMux is used to guarantee sequential Management Service message processing\n \tsyncMsgMux *sync.Mutex\n-\t// sshMux protects sshServer field access\n-\tsshMux sync.Mutex\n \n \tconfig    *EngineConfig\n \tmobileDep MobileDependency\n@@ -175,8 +176,7 @@ type Engine struct {\n \n \tnetworkMonitor *networkmonitor.NetworkMonitor\n \n-\tsshServerFunc func(hostKeyPEM []byte, addr string) (nbssh.Server, error)\n-\tsshServer     nbssh.Server\n+\tsshServer sshServer\n \n \tstatusRecorder *peer.Status\n \n@@ -246,7 +246,6 @@ func NewEngine(\n \t\tSTUNs:          []*stun.URI{},\n \t\tTURNs:          []*stun.URI{},\n \t\tnetworkSerial:  0,\n-\t\tsshServerFunc:  nbssh.DefaultSSHServer,\n \t\tstatusRecorder: statusRecorder,\n \t\tchecks:         checks,\n \t\tconnSemaphore:  semaphoregroup.NewSemaphoreGroup(connInitLimit),\n@@ -268,6 +267,7 @@ func NewEngine(\n \t\tpath = mobileDep.StateFilePath\n \t}\n \tengine.stateManager = statemanager.New(path)\n+\tengine.stateManager.RegisterState(&sshconfig.ShutdownState{})\n \n \tlog.Infof(\"I am: %s\", config.WgPrivateKey.PublicKey().String())\n \treturn engine\n@@ -292,6 +292,12 @@ func (e *Engine) Stop() error {\n \t}\n \tlog.Info(\"Network monitor: stopped\")\n \n+\tif err := e.stopSSHServer(); err != nil {\n+\t\tlog.Warnf(\"failed to stop SSH server: %v\", err)\n+\t}\n+\n+\te.cleanupSSHConfig()\n+\n \t// stop/restore DNS first so dbus and friends don't complain because of a missing interface\n \te.stopDNSServer()\n \n@@ -703,16 +709,10 @@ func (e *Engine) removeAllPeers() error {\n \treturn nil\n }\n \n-// removePeer closes an existing peer connection, removes a peer, and clears authorized key of the SSH server\n+// removePeer closes an existing peer connection and removes a peer\n func (e *Engine) removePeer(peerKey string) error {\n \tlog.Debugf(\"removing peer from engine %s\", peerKey)\n \n-\te.sshMux.Lock()\n-\tif !isNil(e.sshServer) {\n-\t\te.sshServer.RemoveAuthorizedKey(peerKey)\n-\t}\n-\te.sshMux.Unlock()\n-\n \te.connMgr.RemovePeerConn(peerKey)\n \n \terr := e.statusRecorder.RemovePeer(peerKey)\n@@ -884,6 +884,11 @@ func (e *Engine) updateChecksIfNew(checks []*mgmProto.Checks) error {\n \t\te.config.BlockLANAccess,\n \t\te.config.BlockInbound,\n \t\te.config.LazyConnectionEnabled,\n+\t\te.config.EnableSSHRoot,\n+\t\te.config.EnableSSHSFTP,\n+\t\te.config.EnableSSHLocalPortForwarding,\n+\t\te.config.EnableSSHRemotePortForwarding,\n+\t\te.config.DisableSSHAuth,\n \t)\n \n \tif err := e.mgmClient.SyncMeta(info); err != nil {\n@@ -893,74 +898,6 @@ func (e *Engine) updateChecksIfNew(checks []*mgmProto.Checks) error {\n \treturn nil\n }\n \n-func isNil(server nbssh.Server) bool {\n-\treturn server == nil || reflect.ValueOf(server).IsNil()\n-}\n-\n-func (e *Engine) updateSSH(sshConf *mgmProto.SSHConfig) error {\n-\tif e.config.BlockInbound {\n-\t\tlog.Infof(\"SSH server is disabled because inbound connections are blocked\")\n-\t\treturn nil\n-\t}\n-\n-\tif !e.config.ServerSSHAllowed {\n-\t\tlog.Info(\"SSH server is not enabled\")\n-\t\treturn nil\n-\t}\n-\n-\tif sshConf.GetSshEnabled() {\n-\t\tif runtime.GOOS == \"windows\" {\n-\t\t\tlog.Warnf(\"running SSH server on %s is not supported\", runtime.GOOS)\n-\t\t\treturn nil\n-\t\t}\n-\t\te.sshMux.Lock()\n-\t\t// start SSH server if it wasn't running\n-\t\tif isNil(e.sshServer) {\n-\t\t\tlistenAddr := fmt.Sprintf(\"%s:%d\", e.wgInterface.Address().IP.String(), nbssh.DefaultSSHPort)\n-\t\t\tif nbnetstack.IsEnabled() {\n-\t\t\t\tlistenAddr = fmt.Sprintf(\"127.0.0.1:%d\", nbssh.DefaultSSHPort)\n-\t\t\t}\n-\t\t\t// nil sshServer means it has not yet been started\n-\t\t\tserver, err := e.sshServerFunc(e.config.SSHKey, listenAddr)\n-\t\t\tif err != nil {\n-\t\t\t\te.sshMux.Unlock()\n-\t\t\t\treturn fmt.Errorf(\"create ssh server: %w\", err)\n-\t\t\t}\n-\n-\t\t\te.sshServer = server\n-\t\t\te.sshMux.Unlock()\n-\n-\t\t\tgo func() {\n-\t\t\t\t// blocking\n-\t\t\t\terr = server.Start()\n-\t\t\t\tif err != nil {\n-\t\t\t\t\t// will throw error when we stop it even if it is a graceful stop\n-\t\t\t\t\tlog.Debugf(\"stopped SSH server with error %v\", err)\n-\t\t\t\t}\n-\t\t\t\te.sshMux.Lock()\n-\t\t\t\te.sshServer = nil\n-\t\t\t\te.sshMux.Unlock()\n-\t\t\t\tlog.Infof(\"stopped SSH server\")\n-\t\t\t}()\n-\t\t} else {\n-\t\t\te.sshMux.Unlock()\n-\t\t\tlog.Debugf(\"SSH server is already running\")\n-\t\t}\n-\t} else {\n-\t\te.sshMux.Lock()\n-\t\tif !isNil(e.sshServer) {\n-\t\t\t// Disable SSH server request, so stop it if it was running\n-\t\t\terr := e.sshServer.Stop()\n-\t\t\tif err != nil {\n-\t\t\t\tlog.Warnf(\"failed to stop SSH server %v\", err)\n-\t\t\t}\n-\t\t\te.sshServer = nil\n-\t\t}\n-\t\te.sshMux.Unlock()\n-\t}\n-\treturn nil\n-}\n-\n func (e *Engine) updateConfig(conf *mgmProto.PeerConfig) error {\n \tif e.wgInterface == nil {\n \t\treturn errors.New(\"wireguard interface is not initialized\")\n@@ -973,8 +910,7 @@ func (e *Engine) updateConfig(conf *mgmProto.PeerConfig) error {\n \t}\n \n \tif conf.GetSshConfig() != nil {\n-\t\terr := e.updateSSH(conf.GetSshConfig())\n-\t\tif err != nil {\n+\t\tif err := e.updateSSH(conf.GetSshConfig()); err != nil {\n \t\t\tlog.Warnf(\"failed handling SSH server setup: %v\", err)\n \t\t}\n \t}\n@@ -1012,6 +948,11 @@ func (e *Engine) receiveManagementEvents() {\n \t\t\te.config.BlockLANAccess,\n \t\t\te.config.BlockInbound,\n \t\t\te.config.LazyConnectionEnabled,\n+\t\t\te.config.EnableSSHRoot,\n+\t\t\te.config.EnableSSHSFTP,\n+\t\t\te.config.EnableSSHLocalPortForwarding,\n+\t\t\te.config.EnableSSHRemotePortForwarding,\n+\t\t\te.config.DisableSSHAuth,\n \t\t)\n \n \t\terr = e.mgmClient.Sync(e.ctx, info, e.handleSync)\n@@ -1170,19 +1111,11 @@ func (e *Engine) updateNetworkMap(networkMap *mgmProto.NetworkMap) error {\n \n \t\te.statusRecorder.FinishPeerListModifications()\n \n-\t\t// update SSHServer by adding remote peer SSH keys\n-\t\te.sshMux.Lock()\n-\t\tif !isNil(e.sshServer) {\n-\t\t\tfor _, config := range networkMap.GetRemotePeers() {\n-\t\t\t\tif config.GetSshConfig() != nil && config.GetSshConfig().GetSshPubKey() != nil {\n-\t\t\t\t\terr := e.sshServer.AddAuthorizedKey(config.WgPubKey, string(config.GetSshConfig().GetSshPubKey()))\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\tlog.Warnf(\"failed adding authorized key to SSH DefaultServer %v\", err)\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n+\t\te.updatePeerSSHHostKeys(networkMap.GetRemotePeers())\n+\n+\t\tif err := e.updateSSHClientConfig(networkMap.GetRemotePeers()); err != nil {\n+\t\t\tlog.Warnf(\"failed to update SSH client config: %v\", err)\n \t\t}\n-\t\te.sshMux.Unlock()\n \t}\n \n \t// must set the exclude list after the peers are added. Without it the manager can not figure out the peers parameters from the store\n@@ -1544,15 +1477,6 @@ func (e *Engine) close() {\n \t\te.statusRecorder.SetWgIface(nil)\n \t}\n \n-\te.sshMux.Lock()\n-\tif !isNil(e.sshServer) {\n-\t\terr := e.sshServer.Stop()\n-\t\tif err != nil {\n-\t\t\tlog.Warnf(\"failed stopping the SSH server: %v\", err)\n-\t\t}\n-\t}\n-\te.sshMux.Unlock()\n-\n \tif e.firewall != nil {\n \t\terr := e.firewall.Close(e.stateManager)\n \t\tif err != nil {\n@@ -1583,6 +1507,11 @@ func (e *Engine) readInitialSettings() ([]*route.Route, *nbdns.Config, bool, err\n \t\te.config.BlockLANAccess,\n \t\te.config.BlockInbound,\n \t\te.config.LazyConnectionEnabled,\n+\t\te.config.EnableSSHRoot,\n+\t\te.config.EnableSSHSFTP,\n+\t\te.config.EnableSSHLocalPortForwarding,\n+\t\te.config.EnableSSHRemotePortForwarding,\n+\t\te.config.DisableSSHAuth,\n \t)\n \n \tnetMap, err := e.mgmClient.GetNetworkMap(info)\ndiff --git a/client/internal/engine_ssh.go b/client/internal/engine_ssh.go\nnew file mode 100644\nindex 00000000000..861b3d6d215\n--- /dev/null\n+++ b/client/internal/engine_ssh.go\n@@ -0,0 +1,355 @@\n+package internal\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"net/netip\"\n+\t\"strings\"\n+\n+\tlog \"github.com/sirupsen/logrus\"\n+\n+\tfirewallManager \"github.com/netbirdio/netbird/client/firewall/manager\"\n+\tnftypes \"github.com/netbirdio/netbird/client/internal/netflow/types\"\n+\tsshconfig \"github.com/netbirdio/netbird/client/ssh/config\"\n+\tsshserver \"github.com/netbirdio/netbird/client/ssh/server\"\n+\tmgmProto \"github.com/netbirdio/netbird/shared/management/proto\"\n+)\n+\n+type sshServer interface {\n+\tStart(ctx context.Context, addr netip.AddrPort) error\n+\tStop() error\n+\tGetStatus() (bool, []sshserver.SessionInfo)\n+}\n+\n+func (e *Engine) setupSSHPortRedirection() error {\n+\tif e.firewall == nil || e.wgInterface == nil {\n+\t\treturn nil\n+\t}\n+\n+\tlocalAddr := e.wgInterface.Address().IP\n+\tif !localAddr.IsValid() {\n+\t\treturn errors.New(\"invalid local NetBird address\")\n+\t}\n+\n+\tif err := e.firewall.AddInboundDNAT(localAddr, firewallManager.ProtocolTCP, 22, 22022); err != nil {\n+\t\treturn fmt.Errorf(\"add SSH port redirection: %w\", err)\n+\t}\n+\tlog.Infof(\"SSH port redirection enabled: %s:22 -> %s:22022\", localAddr, localAddr)\n+\n+\treturn nil\n+}\n+\n+func (e *Engine) updateSSH(sshConf *mgmProto.SSHConfig) error {\n+\tif e.config.BlockInbound {\n+\t\tlog.Info(\"SSH server is disabled because inbound connections are blocked\")\n+\t\treturn e.stopSSHServer()\n+\t}\n+\n+\tif !e.config.ServerSSHAllowed {\n+\t\tlog.Info(\"SSH server is disabled in config\")\n+\t\treturn e.stopSSHServer()\n+\t}\n+\n+\tif !sshConf.GetSshEnabled() {\n+\t\tif e.config.ServerSSHAllowed {\n+\t\t\tlog.Info(\"SSH server is locally allowed but disabled by management server\")\n+\t\t}\n+\t\treturn e.stopSSHServer()\n+\t}\n+\n+\tif e.sshServer != nil {\n+\t\tlog.Debug(\"SSH server is already running\")\n+\t\treturn nil\n+\t}\n+\n+\tif e.config.DisableSSHAuth != nil && *e.config.DisableSSHAuth {\n+\t\tlog.Info(\"starting SSH server without JWT authentication (authentication disabled by config)\")\n+\t\treturn e.startSSHServer(nil)\n+\t}\n+\n+\tif protoJWT := sshConf.GetJwtConfig(); protoJWT != nil {\n+\t\tjwtConfig := &sshserver.JWTConfig{\n+\t\t\tIssuer:       protoJWT.GetIssuer(),\n+\t\t\tAudience:     protoJWT.GetAudience(),\n+\t\t\tKeysLocation: protoJWT.GetKeysLocation(),\n+\t\t\tMaxTokenAge:  protoJWT.GetMaxTokenAge(),\n+\t\t}\n+\n+\t\treturn e.startSSHServer(jwtConfig)\n+\t}\n+\n+\treturn errors.New(\"SSH server requires valid JWT configuration\")\n+}\n+\n+// updateSSHClientConfig updates the SSH client configuration with peer information\n+func (e *Engine) updateSSHClientConfig(remotePeers []*mgmProto.RemotePeerConfig) error {\n+\tpeerInfo := e.extractPeerSSHInfo(remotePeers)\n+\tif len(peerInfo) == 0 {\n+\t\tlog.Debug(\"no SSH-enabled peers found, skipping SSH config update\")\n+\t\treturn nil\n+\t}\n+\n+\tconfigMgr := sshconfig.New()\n+\tif err := configMgr.SetupSSHClientConfig(peerInfo); err != nil {\n+\t\tlog.Warnf(\"failed to update SSH client config: %v\", err)\n+\t\treturn nil // Don't fail engine startup on SSH config issues\n+\t}\n+\n+\tlog.Debugf(\"updated SSH client config with %d peers\", len(peerInfo))\n+\n+\tif err := e.stateManager.UpdateState(&sshconfig.ShutdownState{\n+\t\tSSHConfigDir:  configMgr.GetSSHConfigDir(),\n+\t\tSSHConfigFile: configMgr.GetSSHConfigFile(),\n+\t}); err != nil {\n+\t\tlog.Warnf(\"failed to update SSH config state: %v\", err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// extractPeerSSHInfo extracts SSH information from peer configurations\n+func (e *Engine) extractPeerSSHInfo(remotePeers []*mgmProto.RemotePeerConfig) []sshconfig.PeerSSHInfo {\n+\tvar peerInfo []sshconfig.PeerSSHInfo\n+\n+\tfor _, peerConfig := range remotePeers {\n+\t\tif peerConfig.GetSshConfig() == nil {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tsshPubKeyBytes := peerConfig.GetSshConfig().GetSshPubKey()\n+\t\tif len(sshPubKeyBytes) == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tpeerIP := e.extractPeerIP(peerConfig)\n+\t\thostname := e.extractHostname(peerConfig)\n+\n+\t\tpeerInfo = append(peerInfo, sshconfig.PeerSSHInfo{\n+\t\t\tHostname: hostname,\n+\t\t\tIP:       peerIP,\n+\t\t\tFQDN:     peerConfig.GetFqdn(),\n+\t\t})\n+\t}\n+\n+\treturn peerInfo\n+}\n+\n+// extractPeerIP extracts IP address from peer's allowed IPs\n+func (e *Engine) extractPeerIP(peerConfig *mgmProto.RemotePeerConfig) string {\n+\tif len(peerConfig.GetAllowedIps()) == 0 {\n+\t\treturn \"\"\n+\t}\n+\n+\tif prefix, err := netip.ParsePrefix(peerConfig.GetAllowedIps()[0]); err == nil {\n+\t\treturn prefix.Addr().String()\n+\t}\n+\treturn \"\"\n+}\n+\n+// extractHostname extracts short hostname from FQDN\n+func (e *Engine) extractHostname(peerConfig *mgmProto.RemotePeerConfig) string {\n+\tfqdn := peerConfig.GetFqdn()\n+\tif fqdn == \"\" {\n+\t\treturn \"\"\n+\t}\n+\n+\tparts := strings.Split(fqdn, \".\")\n+\tif len(parts) > 0 && parts[0] != \"\" {\n+\t\treturn parts[0]\n+\t}\n+\treturn \"\"\n+}\n+\n+// updatePeerSSHHostKeys updates peer SSH host keys in the status recorder for daemon API access\n+func (e *Engine) updatePeerSSHHostKeys(remotePeers []*mgmProto.RemotePeerConfig) {\n+\tfor _, peerConfig := range remotePeers {\n+\t\tif peerConfig.GetSshConfig() == nil {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tsshPubKeyBytes := peerConfig.GetSshConfig().GetSshPubKey()\n+\t\tif len(sshPubKeyBytes) == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif err := e.statusRecorder.UpdatePeerSSHHostKey(peerConfig.GetWgPubKey(), sshPubKeyBytes); err != nil {\n+\t\t\tlog.Warnf(\"failed to update SSH host key for peer %s: %v\", peerConfig.GetWgPubKey(), err)\n+\t\t}\n+\t}\n+\n+\tlog.Debugf(\"updated peer SSH host keys for daemon API access\")\n+}\n+\n+// GetPeerSSHKey returns the SSH host key for a specific peer by IP or FQDN\n+func (e *Engine) GetPeerSSHKey(peerAddress string) ([]byte, bool) {\n+\te.syncMsgMux.Lock()\n+\tstatusRecorder := e.statusRecorder\n+\te.syncMsgMux.Unlock()\n+\n+\tif statusRecorder == nil {\n+\t\treturn nil, false\n+\t}\n+\n+\tfullStatus := statusRecorder.GetFullStatus()\n+\tfor _, peerState := range fullStatus.Peers {\n+\t\tif peerState.IP == peerAddress || peerState.FQDN == peerAddress {\n+\t\t\tif len(peerState.SSHHostKey) > 0 {\n+\t\t\t\treturn peerState.SSHHostKey, true\n+\t\t\t}\n+\t\t\treturn nil, false\n+\t\t}\n+\t}\n+\n+\treturn nil, false\n+}\n+\n+// cleanupSSHConfig removes NetBird SSH client configuration on shutdown\n+func (e *Engine) cleanupSSHConfig() {\n+\tconfigMgr := sshconfig.New()\n+\n+\tif err := configMgr.RemoveSSHClientConfig(); err != nil {\n+\t\tlog.Warnf(\"failed to remove SSH client config: %v\", err)\n+\t} else {\n+\t\tlog.Debugf(\"SSH client config cleanup completed\")\n+\t}\n+}\n+\n+// startSSHServer initializes and starts the SSH server with proper configuration.\n+func (e *Engine) startSSHServer(jwtConfig *sshserver.JWTConfig) error {\n+\tif e.wgInterface == nil {\n+\t\treturn errors.New(\"wg interface not initialized\")\n+\t}\n+\n+\tserverConfig := &sshserver.Config{\n+\t\tHostKeyPEM: e.config.SSHKey,\n+\t\tJWT:        jwtConfig,\n+\t}\n+\tserver := sshserver.New(serverConfig)\n+\n+\twgAddr := e.wgInterface.Address()\n+\tserver.SetNetworkValidation(wgAddr)\n+\n+\tnetbirdIP := wgAddr.IP\n+\tlistenAddr := netip.AddrPortFrom(netbirdIP, sshserver.InternalSSHPort)\n+\n+\tif netstackNet := e.wgInterface.GetNet(); netstackNet != nil {\n+\t\tserver.SetNetstackNet(netstackNet)\n+\t}\n+\n+\te.configureSSHServer(server)\n+\n+\tif err := server.Start(e.ctx, listenAddr); err != nil {\n+\t\treturn fmt.Errorf(\"start SSH server: %w\", err)\n+\t}\n+\n+\te.sshServer = server\n+\n+\tif netstackNet := e.wgInterface.GetNet(); netstackNet != nil {\n+\t\tif registrar, ok := e.firewall.(interface {\n+\t\t\tRegisterNetstackService(protocol nftypes.Protocol, port uint16)\n+\t\t}); ok {\n+\t\t\tregistrar.RegisterNetstackService(nftypes.TCP, sshserver.InternalSSHPort)\n+\t\t\tlog.Debugf(\"registered SSH service with netstack for TCP:%d\", sshserver.InternalSSHPort)\n+\t\t}\n+\t}\n+\n+\tif err := e.setupSSHPortRedirection(); err != nil {\n+\t\tlog.Warnf(\"failed to setup SSH port redirection: %v\", err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// configureSSHServer applies SSH configuration options to the server.\n+func (e *Engine) configureSSHServer(server *sshserver.Server) {\n+\tif e.config.EnableSSHRoot != nil && *e.config.EnableSSHRoot {\n+\t\tserver.SetAllowRootLogin(true)\n+\t\tlog.Info(\"SSH root login enabled\")\n+\t} else {\n+\t\tserver.SetAllowRootLogin(false)\n+\t\tlog.Info(\"SSH root login disabled (default)\")\n+\t}\n+\n+\tif e.config.EnableSSHSFTP != nil && *e.config.EnableSSHSFTP {\n+\t\tserver.SetAllowSFTP(true)\n+\t\tlog.Info(\"SSH SFTP subsystem enabled\")\n+\t} else {\n+\t\tserver.SetAllowSFTP(false)\n+\t\tlog.Info(\"SSH SFTP subsystem disabled (default)\")\n+\t}\n+\n+\tif e.config.EnableSSHLocalPortForwarding != nil && *e.config.EnableSSHLocalPortForwarding {\n+\t\tserver.SetAllowLocalPortForwarding(true)\n+\t\tlog.Info(\"SSH local port forwarding enabled\")\n+\t} else {\n+\t\tserver.SetAllowLocalPortForwarding(false)\n+\t\tlog.Info(\"SSH local port forwarding disabled (default)\")\n+\t}\n+\n+\tif e.config.EnableSSHRemotePortForwarding != nil && *e.config.EnableSSHRemotePortForwarding {\n+\t\tserver.SetAllowRemotePortForwarding(true)\n+\t\tlog.Info(\"SSH remote port forwarding enabled\")\n+\t} else {\n+\t\tserver.SetAllowRemotePortForwarding(false)\n+\t\tlog.Info(\"SSH remote port forwarding disabled (default)\")\n+\t}\n+}\n+\n+func (e *Engine) cleanupSSHPortRedirection() error {\n+\tif e.firewall == nil || e.wgInterface == nil {\n+\t\treturn nil\n+\t}\n+\n+\tlocalAddr := e.wgInterface.Address().IP\n+\tif !localAddr.IsValid() {\n+\t\treturn errors.New(\"invalid local NetBird address\")\n+\t}\n+\n+\tif err := e.firewall.RemoveInboundDNAT(localAddr, firewallManager.ProtocolTCP, 22, 22022); err != nil {\n+\t\treturn fmt.Errorf(\"remove SSH port redirection: %w\", err)\n+\t}\n+\tlog.Debugf(\"SSH port redirection removed: %s:22 -> %s:22022\", localAddr, localAddr)\n+\n+\treturn nil\n+}\n+\n+func (e *Engine) stopSSHServer() error {\n+\tif e.sshServer == nil {\n+\t\treturn nil\n+\t}\n+\n+\tif err := e.cleanupSSHPortRedirection(); err != nil {\n+\t\tlog.Warnf(\"failed to cleanup SSH port redirection: %v\", err)\n+\t}\n+\n+\tif netstackNet := e.wgInterface.GetNet(); netstackNet != nil {\n+\t\tif registrar, ok := e.firewall.(interface {\n+\t\t\tUnregisterNetstackService(protocol nftypes.Protocol, port uint16)\n+\t\t}); ok {\n+\t\t\tregistrar.UnregisterNetstackService(nftypes.TCP, sshserver.InternalSSHPort)\n+\t\t\tlog.Debugf(\"unregistered SSH service from netstack for TCP:%d\", sshserver.InternalSSHPort)\n+\t\t}\n+\t}\n+\n+\tlog.Info(\"stopping SSH server\")\n+\terr := e.sshServer.Stop()\n+\te.sshServer = nil\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"stop: %w\", err)\n+\t}\n+\treturn nil\n+}\n+\n+// GetSSHServerStatus returns the SSH server status and active sessions\n+func (e *Engine) GetSSHServerStatus() (enabled bool, sessions []sshserver.SessionInfo) {\n+\te.syncMsgMux.Lock()\n+\tsshServer := e.sshServer\n+\te.syncMsgMux.Unlock()\n+\n+\tif sshServer == nil {\n+\t\treturn false, nil\n+\t}\n+\n+\treturn sshServer.GetStatus()\n+}\ndiff --git a/client/internal/login.go b/client/internal/login.go\nindex 257e3c3acb9..f528783ef0d 100644\n--- a/client/internal/login.go\n+++ b/client/internal/login.go\n@@ -124,6 +124,11 @@ func doMgmLogin(ctx context.Context, mgmClient *mgm.GrpcClient, pubSSHKey []byte\n \t\tconfig.BlockLANAccess,\n \t\tconfig.BlockInbound,\n \t\tconfig.LazyConnectionEnabled,\n+\t\tconfig.EnableSSHRoot,\n+\t\tconfig.EnableSSHSFTP,\n+\t\tconfig.EnableSSHLocalPortForwarding,\n+\t\tconfig.EnableSSHRemotePortForwarding,\n+\t\tconfig.DisableSSHAuth,\n \t)\n \tloginResp, err := mgmClient.Login(*serverKey, sysInfo, pubSSHKey, config.DNSLabels)\n \treturn serverKey, loginResp, err\n@@ -150,6 +155,11 @@ func registerPeer(ctx context.Context, serverPublicKey wgtypes.Key, client *mgm.\n \t\tconfig.BlockLANAccess,\n \t\tconfig.BlockInbound,\n \t\tconfig.LazyConnectionEnabled,\n+\t\tconfig.EnableSSHRoot,\n+\t\tconfig.EnableSSHSFTP,\n+\t\tconfig.EnableSSHLocalPortForwarding,\n+\t\tconfig.EnableSSHRemotePortForwarding,\n+\t\tconfig.DisableSSHAuth,\n \t)\n \tloginResp, err := client.Register(serverPublicKey, validSetupKey.String(), jwtToken, info, pubSSHKey, config.DNSLabels)\n \tif err != nil {\ndiff --git a/client/internal/peer/conn.go b/client/internal/peer/conn.go\nindex 68afe986a48..426c31e1ad2 100644\n--- a/client/internal/peer/conn.go\n+++ b/client/internal/peer/conn.go\n@@ -666,7 +666,7 @@ func (conn *Conn) isConnectedOnAllWay() (connected bool) {\n \t\t}\n \t}()\n \n-\tif conn.statusICE.Get() == worker.StatusDisconnected && !conn.workerICE.InProgress() {\n+\tif runtime.GOOS != \"js\" && conn.statusICE.Get() == worker.StatusDisconnected && !conn.workerICE.InProgress() {\n \t\treturn false\n \t}\n \ndiff --git a/client/internal/peer/env.go b/client/internal/peer/env.go\nindex 32a458d00a0..7f500c410c3 100644\n--- a/client/internal/peer/env.go\n+++ b/client/internal/peer/env.go\n@@ -2,6 +2,7 @@ package peer\n \n import (\n \t\"os\"\n+\t\"runtime\"\n \t\"strings\"\n )\n \n@@ -10,5 +11,8 @@ const (\n )\n \n func isForceRelayed() bool {\n+\tif runtime.GOOS == \"js\" {\n+\t\treturn true\n+\t}\n \treturn strings.EqualFold(os.Getenv(EnvKeyNBForceRelay), \"true\")\n }\ndiff --git a/client/internal/peer/status.go b/client/internal/peer/status.go\nindex 239cce7e032..76f4f523c1b 100644\n--- a/client/internal/peer/status.go\n+++ b/client/internal/peer/status.go\n@@ -21,9 +21,9 @@ import (\n \t\"github.com/netbirdio/netbird/client/internal/ingressgw\"\n \t\"github.com/netbirdio/netbird/client/internal/relay\"\n \t\"github.com/netbirdio/netbird/client/proto\"\n+\t\"github.com/netbirdio/netbird/route\"\n \t\"github.com/netbirdio/netbird/shared/management/domain\"\n \trelayClient \"github.com/netbirdio/netbird/shared/relay/client\"\n-\t\"github.com/netbirdio/netbird/route\"\n )\n \n const eventQueueSize = 10\n@@ -67,6 +67,7 @@ type State struct {\n \tBytesRx                    int64\n \tLatency                    time.Duration\n \tRosenpassEnabled           bool\n+\tSSHHostKey                 []byte\n \troutes                     map[string]struct{}\n }\n \n@@ -572,6 +573,22 @@ func (d *Status) UpdatePeerFQDN(peerPubKey, fqdn string) error {\n \treturn nil\n }\n \n+// UpdatePeerSSHHostKey updates peer's SSH host key\n+func (d *Status) UpdatePeerSSHHostKey(peerPubKey string, sshHostKey []byte) error {\n+\td.mux.Lock()\n+\tdefer d.mux.Unlock()\n+\n+\tpeerState, ok := d.peers[peerPubKey]\n+\tif !ok {\n+\t\treturn errors.New(\"peer doesn't exist\")\n+\t}\n+\n+\tpeerState.SSHHostKey = sshHostKey\n+\td.peers[peerPubKey] = peerState\n+\n+\treturn nil\n+}\n+\n // FinishPeerListModifications this event invoke the notification\n func (d *Status) FinishPeerListModifications() {\n \td.mux.Lock()\ndiff --git a/client/internal/profilemanager/config.go b/client/internal/profilemanager/config.go\nindex f038220891e..8f467a21475 100644\n--- a/client/internal/profilemanager/config.go\n+++ b/client/internal/profilemanager/config.go\n@@ -44,24 +44,30 @@ var DefaultInterfaceBlacklist = []string{\n \n // ConfigInput carries configuration changes to the client\n type ConfigInput struct {\n-\tManagementURL       string\n-\tAdminURL            string\n-\tConfigPath          string\n-\tStateFilePath       string\n-\tPreSharedKey        *string\n-\tServerSSHAllowed    *bool\n-\tNATExternalIPs      []string\n-\tCustomDNSAddress    []byte\n-\tRosenpassEnabled    *bool\n-\tRosenpassPermissive *bool\n-\tInterfaceName       *string\n-\tWireguardPort       *int\n-\tNetworkMonitor      *bool\n-\tDisableAutoConnect  *bool\n-\tExtraIFaceBlackList []string\n-\tDNSRouteInterval    *time.Duration\n-\tClientCertPath      string\n-\tClientCertKeyPath   string\n+\tManagementURL                 string\n+\tAdminURL                      string\n+\tConfigPath                    string\n+\tStateFilePath                 string\n+\tPreSharedKey                  *string\n+\tServerSSHAllowed              *bool\n+\tEnableSSHRoot                 *bool\n+\tEnableSSHSFTP                 *bool\n+\tEnableSSHLocalPortForwarding  *bool\n+\tEnableSSHRemotePortForwarding *bool\n+\tDisableSSHAuth                *bool\n+\tSSHJWTCacheTTL                *int\n+\tNATExternalIPs                []string\n+\tCustomDNSAddress              []byte\n+\tRosenpassEnabled              *bool\n+\tRosenpassPermissive           *bool\n+\tInterfaceName                 *string\n+\tWireguardPort                 *int\n+\tNetworkMonitor                *bool\n+\tDisableAutoConnect            *bool\n+\tExtraIFaceBlackList           []string\n+\tDNSRouteInterval              *time.Duration\n+\tClientCertPath                string\n+\tClientCertKeyPath             string\n \n \tDisableClientRoutes *bool\n \tDisableServerRoutes *bool\n@@ -82,18 +88,24 @@ type ConfigInput struct {\n // Config Configuration type\n type Config struct {\n \t// Wireguard private key of local peer\n-\tPrivateKey           string\n-\tPreSharedKey         string\n-\tManagementURL        *url.URL\n-\tAdminURL             *url.URL\n-\tWgIface              string\n-\tWgPort               int\n-\tNetworkMonitor       *bool\n-\tIFaceBlackList       []string\n-\tDisableIPv6Discovery bool\n-\tRosenpassEnabled     bool\n-\tRosenpassPermissive  bool\n-\tServerSSHAllowed     *bool\n+\tPrivateKey                    string\n+\tPreSharedKey                  string\n+\tManagementURL                 *url.URL\n+\tAdminURL                      *url.URL\n+\tWgIface                       string\n+\tWgPort                        int\n+\tNetworkMonitor                *bool\n+\tIFaceBlackList                []string\n+\tDisableIPv6Discovery          bool\n+\tRosenpassEnabled              bool\n+\tRosenpassPermissive           bool\n+\tServerSSHAllowed              *bool\n+\tEnableSSHRoot                 *bool\n+\tEnableSSHSFTP                 *bool\n+\tEnableSSHLocalPortForwarding  *bool\n+\tEnableSSHRemotePortForwarding *bool\n+\tDisableSSHAuth                *bool\n+\tSSHJWTCacheTTL                *int\n \n \tDisableClientRoutes bool\n \tDisableServerRoutes bool\n@@ -376,6 +388,62 @@ func (config *Config) apply(input ConfigInput) (updated bool, err error) {\n \t\tupdated = true\n \t}\n \n+\tif input.EnableSSHRoot != nil && input.EnableSSHRoot != config.EnableSSHRoot {\n+\t\tif *input.EnableSSHRoot {\n+\t\t\tlog.Infof(\"enabling SSH root login\")\n+\t\t} else {\n+\t\t\tlog.Infof(\"disabling SSH root login\")\n+\t\t}\n+\t\tconfig.EnableSSHRoot = input.EnableSSHRoot\n+\t\tupdated = true\n+\t}\n+\n+\tif input.EnableSSHSFTP != nil && input.EnableSSHSFTP != config.EnableSSHSFTP {\n+\t\tif *input.EnableSSHSFTP {\n+\t\t\tlog.Infof(\"enabling SSH SFTP subsystem\")\n+\t\t} else {\n+\t\t\tlog.Infof(\"disabling SSH SFTP subsystem\")\n+\t\t}\n+\t\tconfig.EnableSSHSFTP = input.EnableSSHSFTP\n+\t\tupdated = true\n+\t}\n+\n+\tif input.EnableSSHLocalPortForwarding != nil && input.EnableSSHLocalPortForwarding != config.EnableSSHLocalPortForwarding {\n+\t\tif *input.EnableSSHLocalPortForwarding {\n+\t\t\tlog.Infof(\"enabling SSH local port forwarding\")\n+\t\t} else {\n+\t\t\tlog.Infof(\"disabling SSH local port forwarding\")\n+\t\t}\n+\t\tconfig.EnableSSHLocalPortForwarding = input.EnableSSHLocalPortForwarding\n+\t\tupdated = true\n+\t}\n+\n+\tif input.EnableSSHRemotePortForwarding != nil && input.EnableSSHRemotePortForwarding != config.EnableSSHRemotePortForwarding {\n+\t\tif *input.EnableSSHRemotePortForwarding {\n+\t\t\tlog.Infof(\"enabling SSH remote port forwarding\")\n+\t\t} else {\n+\t\t\tlog.Infof(\"disabling SSH remote port forwarding\")\n+\t\t}\n+\t\tconfig.EnableSSHRemotePortForwarding = input.EnableSSHRemotePortForwarding\n+\t\tupdated = true\n+\t}\n+\n+\tif input.DisableSSHAuth != nil && input.DisableSSHAuth != config.DisableSSHAuth {\n+\t\tif *input.DisableSSHAuth {\n+\t\t\tlog.Infof(\"disabling SSH authentication\")\n+\t\t} else {\n+\t\t\tlog.Infof(\"enabling SSH authentication\")\n+\t\t}\n+\t\tconfig.DisableSSHAuth = input.DisableSSHAuth\n+\t\tupdated = true\n+\t}\n+\n+\tif input.SSHJWTCacheTTL != nil && input.SSHJWTCacheTTL != config.SSHJWTCacheTTL {\n+\t\tlog.Infof(\"updating SSH JWT cache TTL to %d seconds\", *input.SSHJWTCacheTTL)\n+\t\tconfig.SSHJWTCacheTTL = input.SSHJWTCacheTTL\n+\t\tupdated = true\n+\t}\n+\n \tif input.DNSRouteInterval != nil && *input.DNSRouteInterval != config.DNSRouteInterval {\n \t\tlog.Infof(\"updating DNS route interval to %s (old value %s)\",\n \t\t\tinput.DNSRouteInterval.String(), config.DNSRouteInterval.String())\ndiff --git a/client/internal/profilemanager/profilemanager.go b/client/internal/profilemanager/profilemanager.go\nindex fe0afae2bff..c87f521cb13 100644\n--- a/client/internal/profilemanager/profilemanager.go\n+++ b/client/internal/profilemanager/profilemanager.go\n@@ -132,3 +132,21 @@ func (pm *ProfileManager) setActiveProfileState(profileName string) error {\n \n \treturn nil\n }\n+\n+// GetLoginHint retrieves the email from the active profile to use as login_hint.\n+func GetLoginHint() string {\n+\tpm := NewProfileManager()\n+\tactiveProf, err := pm.GetActiveProfile()\n+\tif err != nil {\n+\t\tlog.Debugf(\"failed to get active profile for login hint: %v\", err)\n+\t\treturn \"\"\n+\t}\n+\n+\tprofileState, err := pm.GetProfileState(activeProf.Name)\n+\tif err != nil {\n+\t\tlog.Debugf(\"failed to get profile state for login hint: %v\", err)\n+\t\treturn \"\"\n+\t}\n+\n+\treturn profileState.Email\n+}\ndiff --git a/client/internal/routemanager/dynamic/route.go b/client/internal/routemanager/dynamic/route.go\nindex 587e05c7422..8d1398a7a37 100644\n--- a/client/internal/routemanager/dynamic/route.go\n+++ b/client/internal/routemanager/dynamic/route.go\n@@ -18,8 +18,8 @@ import (\n \t\"github.com/netbirdio/netbird/client/internal/routemanager/iface\"\n \t\"github.com/netbirdio/netbird/client/internal/routemanager/refcounter\"\n \t\"github.com/netbirdio/netbird/client/internal/routemanager/util\"\n-\t\"github.com/netbirdio/netbird/shared/management/domain\"\n \t\"github.com/netbirdio/netbird/route\"\n+\t\"github.com/netbirdio/netbird/shared/management/domain\"\n )\n \n const (\ndiff --git a/client/internal/routemanager/manager.go b/client/internal/routemanager/manager.go\nindex 26cf758d90f..2baa0e6683a 100644\n--- a/client/internal/routemanager/manager.go\n+++ b/client/internal/routemanager/manager.go\n@@ -24,7 +24,6 @@ import (\n \t\"github.com/netbirdio/netbird/client/iface/netstack\"\n \t\"github.com/netbirdio/netbird/client/internal/dns\"\n \t\"github.com/netbirdio/netbird/client/internal/listener\"\n-\tnbdns \"github.com/netbirdio/netbird/dns\"\n \t\"github.com/netbirdio/netbird/client/internal/peer\"\n \t\"github.com/netbirdio/netbird/client/internal/peerstore\"\n \t\"github.com/netbirdio/netbird/client/internal/routemanager/client\"\n@@ -39,6 +38,7 @@ import (\n \t\"github.com/netbirdio/netbird/client/internal/routeselector\"\n \t\"github.com/netbirdio/netbird/client/internal/statemanager\"\n \tnbnet \"github.com/netbirdio/netbird/client/net\"\n+\tnbdns \"github.com/netbirdio/netbird/dns\"\n \t\"github.com/netbirdio/netbird/route\"\n \trelayClient \"github.com/netbirdio/netbird/shared/relay/client\"\n \t\"github.com/netbirdio/netbird/version\"\ndiff --git a/client/ios/NetBirdSDK/client.go b/client/ios/NetBirdSDK/client.go\nindex fa1c89aab6a..b0d377c21bf 100644\n--- a/client/ios/NetBirdSDK/client.go\n+++ b/client/ios/NetBirdSDK/client.go\n@@ -20,8 +20,8 @@ import (\n \t\"github.com/netbirdio/netbird/client/internal/profilemanager\"\n \t\"github.com/netbirdio/netbird/client/system\"\n \t\"github.com/netbirdio/netbird/formatter\"\n-\t\"github.com/netbirdio/netbird/shared/management/domain\"\n \t\"github.com/netbirdio/netbird/route\"\n+\t\"github.com/netbirdio/netbird/shared/management/domain\"\n )\n \n // ConnectionListener export internal Listener for mobile\ndiff --git a/client/proto/daemon.pb.go b/client/proto/daemon.pb.go\nindex 02f09b08a0d..7b9ae25f755 100644\n--- a/client/proto/daemon.pb.go\n+++ b/client/proto/daemon.pb.go\n@@ -137,7 +137,7 @@ func (x SystemEvent_Severity) Number() protoreflect.EnumNumber {\n \n // Deprecated: Use SystemEvent_Severity.Descriptor instead.\n func (SystemEvent_Severity) EnumDescriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{49, 0}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{51, 0}\n }\n \n type SystemEvent_Category int32\n@@ -192,7 +192,7 @@ func (x SystemEvent_Category) Number() protoreflect.EnumNumber {\n \n // Deprecated: Use SystemEvent_Category.Descriptor instead.\n func (SystemEvent_Category) EnumDescriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{49, 1}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{51, 1}\n }\n \n type EmptyRequest struct {\n@@ -280,9 +280,15 @@ type LoginRequest struct {\n \tUsername              *string `protobuf:\"bytes,31,opt,name=username,proto3,oneof\" json:\"username,omitempty\"`\n \tMtu                   *int64  `protobuf:\"varint,32,opt,name=mtu,proto3,oneof\" json:\"mtu,omitempty\"`\n \t// hint is used to pre-fill the email/username field during SSO authentication\n-\tHint          *string `protobuf:\"bytes,33,opt,name=hint,proto3,oneof\" json:\"hint,omitempty\"`\n-\tunknownFields protoimpl.UnknownFields\n-\tsizeCache     protoimpl.SizeCache\n+\tHint                          *string `protobuf:\"bytes,33,opt,name=hint,proto3,oneof\" json:\"hint,omitempty\"`\n+\tEnableSSHRoot                 *bool   `protobuf:\"varint,34,opt,name=enableSSHRoot,proto3,oneof\" json:\"enableSSHRoot,omitempty\"`\n+\tEnableSSHSFTP                 *bool   `protobuf:\"varint,35,opt,name=enableSSHSFTP,proto3,oneof\" json:\"enableSSHSFTP,omitempty\"`\n+\tEnableSSHLocalPortForwarding  *bool   `protobuf:\"varint,36,opt,name=enableSSHLocalPortForwarding,proto3,oneof\" json:\"enableSSHLocalPortForwarding,omitempty\"`\n+\tEnableSSHRemotePortForwarding *bool   `protobuf:\"varint,37,opt,name=enableSSHRemotePortForwarding,proto3,oneof\" json:\"enableSSHRemotePortForwarding,omitempty\"`\n+\tDisableSSHAuth                *bool   `protobuf:\"varint,38,opt,name=disableSSHAuth,proto3,oneof\" json:\"disableSSHAuth,omitempty\"`\n+\tSshJWTCacheTTL                *int32  `protobuf:\"varint,39,opt,name=sshJWTCacheTTL,proto3,oneof\" json:\"sshJWTCacheTTL,omitempty\"`\n+\tunknownFields                 protoimpl.UnknownFields\n+\tsizeCache                     protoimpl.SizeCache\n }\n \n func (x *LoginRequest) Reset() {\n@@ -547,6 +553,48 @@ func (x *LoginRequest) GetHint() string {\n \treturn \"\"\n }\n \n+func (x *LoginRequest) GetEnableSSHRoot() bool {\n+\tif x != nil && x.EnableSSHRoot != nil {\n+\t\treturn *x.EnableSSHRoot\n+\t}\n+\treturn false\n+}\n+\n+func (x *LoginRequest) GetEnableSSHSFTP() bool {\n+\tif x != nil && x.EnableSSHSFTP != nil {\n+\t\treturn *x.EnableSSHSFTP\n+\t}\n+\treturn false\n+}\n+\n+func (x *LoginRequest) GetEnableSSHLocalPortForwarding() bool {\n+\tif x != nil && x.EnableSSHLocalPortForwarding != nil {\n+\t\treturn *x.EnableSSHLocalPortForwarding\n+\t}\n+\treturn false\n+}\n+\n+func (x *LoginRequest) GetEnableSSHRemotePortForwarding() bool {\n+\tif x != nil && x.EnableSSHRemotePortForwarding != nil {\n+\t\treturn *x.EnableSSHRemotePortForwarding\n+\t}\n+\treturn false\n+}\n+\n+func (x *LoginRequest) GetDisableSSHAuth() bool {\n+\tif x != nil && x.DisableSSHAuth != nil {\n+\t\treturn *x.DisableSSHAuth\n+\t}\n+\treturn false\n+}\n+\n+func (x *LoginRequest) GetSshJWTCacheTTL() int32 {\n+\tif x != nil && x.SshJWTCacheTTL != nil {\n+\t\treturn *x.SshJWTCacheTTL\n+\t}\n+\treturn 0\n+}\n+\n type LoginResponse struct {\n \tstate                   protoimpl.MessageState `protogen:\"open.v1\"`\n \tNeedsSSOLogin           bool                   `protobuf:\"varint,1,opt,name=needsSSOLogin,proto3\" json:\"needsSSOLogin,omitempty\"`\n@@ -1057,24 +1105,30 @@ type GetConfigResponse struct {\n \t// preSharedKey settings value.\n \tPreSharedKey string `protobuf:\"bytes,4,opt,name=preSharedKey,proto3\" json:\"preSharedKey,omitempty\"`\n \t// adminURL settings value.\n-\tAdminURL              string `protobuf:\"bytes,5,opt,name=adminURL,proto3\" json:\"adminURL,omitempty\"`\n-\tInterfaceName         string `protobuf:\"bytes,6,opt,name=interfaceName,proto3\" json:\"interfaceName,omitempty\"`\n-\tWireguardPort         int64  `protobuf:\"varint,7,opt,name=wireguardPort,proto3\" json:\"wireguardPort,omitempty\"`\n-\tMtu                   int64  `protobuf:\"varint,8,opt,name=mtu,proto3\" json:\"mtu,omitempty\"`\n-\tDisableAutoConnect    bool   `protobuf:\"varint,9,opt,name=disableAutoConnect,proto3\" json:\"disableAutoConnect,omitempty\"`\n-\tServerSSHAllowed      bool   `protobuf:\"varint,10,opt,name=serverSSHAllowed,proto3\" json:\"serverSSHAllowed,omitempty\"`\n-\tRosenpassEnabled      bool   `protobuf:\"varint,11,opt,name=rosenpassEnabled,proto3\" json:\"rosenpassEnabled,omitempty\"`\n-\tRosenpassPermissive   bool   `protobuf:\"varint,12,opt,name=rosenpassPermissive,proto3\" json:\"rosenpassPermissive,omitempty\"`\n-\tDisableNotifications  bool   `protobuf:\"varint,13,opt,name=disable_notifications,json=disableNotifications,proto3\" json:\"disable_notifications,omitempty\"`\n-\tLazyConnectionEnabled bool   `protobuf:\"varint,14,opt,name=lazyConnectionEnabled,proto3\" json:\"lazyConnectionEnabled,omitempty\"`\n-\tBlockInbound          bool   `protobuf:\"varint,15,opt,name=blockInbound,proto3\" json:\"blockInbound,omitempty\"`\n-\tNetworkMonitor        bool   `protobuf:\"varint,16,opt,name=networkMonitor,proto3\" json:\"networkMonitor,omitempty\"`\n-\tDisableDns            bool   `protobuf:\"varint,17,opt,name=disable_dns,json=disableDns,proto3\" json:\"disable_dns,omitempty\"`\n-\tDisableClientRoutes   bool   `protobuf:\"varint,18,opt,name=disable_client_routes,json=disableClientRoutes,proto3\" json:\"disable_client_routes,omitempty\"`\n-\tDisableServerRoutes   bool   `protobuf:\"varint,19,opt,name=disable_server_routes,json=disableServerRoutes,proto3\" json:\"disable_server_routes,omitempty\"`\n-\tBlockLanAccess        bool   `protobuf:\"varint,20,opt,name=block_lan_access,json=blockLanAccess,proto3\" json:\"block_lan_access,omitempty\"`\n-\tunknownFields         protoimpl.UnknownFields\n-\tsizeCache             protoimpl.SizeCache\n+\tAdminURL                      string `protobuf:\"bytes,5,opt,name=adminURL,proto3\" json:\"adminURL,omitempty\"`\n+\tInterfaceName                 string `protobuf:\"bytes,6,opt,name=interfaceName,proto3\" json:\"interfaceName,omitempty\"`\n+\tWireguardPort                 int64  `protobuf:\"varint,7,opt,name=wireguardPort,proto3\" json:\"wireguardPort,omitempty\"`\n+\tMtu                           int64  `protobuf:\"varint,8,opt,name=mtu,proto3\" json:\"mtu,omitempty\"`\n+\tDisableAutoConnect            bool   `protobuf:\"varint,9,opt,name=disableAutoConnect,proto3\" json:\"disableAutoConnect,omitempty\"`\n+\tServerSSHAllowed              bool   `protobuf:\"varint,10,opt,name=serverSSHAllowed,proto3\" json:\"serverSSHAllowed,omitempty\"`\n+\tRosenpassEnabled              bool   `protobuf:\"varint,11,opt,name=rosenpassEnabled,proto3\" json:\"rosenpassEnabled,omitempty\"`\n+\tRosenpassPermissive           bool   `protobuf:\"varint,12,opt,name=rosenpassPermissive,proto3\" json:\"rosenpassPermissive,omitempty\"`\n+\tDisableNotifications          bool   `protobuf:\"varint,13,opt,name=disable_notifications,json=disableNotifications,proto3\" json:\"disable_notifications,omitempty\"`\n+\tLazyConnectionEnabled         bool   `protobuf:\"varint,14,opt,name=lazyConnectionEnabled,proto3\" json:\"lazyConnectionEnabled,omitempty\"`\n+\tBlockInbound                  bool   `protobuf:\"varint,15,opt,name=blockInbound,proto3\" json:\"blockInbound,omitempty\"`\n+\tNetworkMonitor                bool   `protobuf:\"varint,16,opt,name=networkMonitor,proto3\" json:\"networkMonitor,omitempty\"`\n+\tDisableDns                    bool   `protobuf:\"varint,17,opt,name=disable_dns,json=disableDns,proto3\" json:\"disable_dns,omitempty\"`\n+\tDisableClientRoutes           bool   `protobuf:\"varint,18,opt,name=disable_client_routes,json=disableClientRoutes,proto3\" json:\"disable_client_routes,omitempty\"`\n+\tDisableServerRoutes           bool   `protobuf:\"varint,19,opt,name=disable_server_routes,json=disableServerRoutes,proto3\" json:\"disable_server_routes,omitempty\"`\n+\tBlockLanAccess                bool   `protobuf:\"varint,20,opt,name=block_lan_access,json=blockLanAccess,proto3\" json:\"block_lan_access,omitempty\"`\n+\tEnableSSHRoot                 bool   `protobuf:\"varint,21,opt,name=enableSSHRoot,proto3\" json:\"enableSSHRoot,omitempty\"`\n+\tEnableSSHSFTP                 bool   `protobuf:\"varint,24,opt,name=enableSSHSFTP,proto3\" json:\"enableSSHSFTP,omitempty\"`\n+\tEnableSSHLocalPortForwarding  bool   `protobuf:\"varint,22,opt,name=enableSSHLocalPortForwarding,proto3\" json:\"enableSSHLocalPortForwarding,omitempty\"`\n+\tEnableSSHRemotePortForwarding bool   `protobuf:\"varint,23,opt,name=enableSSHRemotePortForwarding,proto3\" json:\"enableSSHRemotePortForwarding,omitempty\"`\n+\tDisableSSHAuth                bool   `protobuf:\"varint,25,opt,name=disableSSHAuth,proto3\" json:\"disableSSHAuth,omitempty\"`\n+\tSshJWTCacheTTL                int32  `protobuf:\"varint,26,opt,name=sshJWTCacheTTL,proto3\" json:\"sshJWTCacheTTL,omitempty\"`\n+\tunknownFields                 protoimpl.UnknownFields\n+\tsizeCache                     protoimpl.SizeCache\n }\n \n func (x *GetConfigResponse) Reset() {\n@@ -1247,6 +1301,48 @@ func (x *GetConfigResponse) GetBlockLanAccess() bool {\n \treturn false\n }\n \n+func (x *GetConfigResponse) GetEnableSSHRoot() bool {\n+\tif x != nil {\n+\t\treturn x.EnableSSHRoot\n+\t}\n+\treturn false\n+}\n+\n+func (x *GetConfigResponse) GetEnableSSHSFTP() bool {\n+\tif x != nil {\n+\t\treturn x.EnableSSHSFTP\n+\t}\n+\treturn false\n+}\n+\n+func (x *GetConfigResponse) GetEnableSSHLocalPortForwarding() bool {\n+\tif x != nil {\n+\t\treturn x.EnableSSHLocalPortForwarding\n+\t}\n+\treturn false\n+}\n+\n+func (x *GetConfigResponse) GetEnableSSHRemotePortForwarding() bool {\n+\tif x != nil {\n+\t\treturn x.EnableSSHRemotePortForwarding\n+\t}\n+\treturn false\n+}\n+\n+func (x *GetConfigResponse) GetDisableSSHAuth() bool {\n+\tif x != nil {\n+\t\treturn x.DisableSSHAuth\n+\t}\n+\treturn false\n+}\n+\n+func (x *GetConfigResponse) GetSshJWTCacheTTL() int32 {\n+\tif x != nil {\n+\t\treturn x.SshJWTCacheTTL\n+\t}\n+\treturn 0\n+}\n+\n // PeerState contains the latest state of a peer\n type PeerState struct {\n \tstate                      protoimpl.MessageState `protogen:\"open.v1\"`\n@@ -1267,6 +1363,7 @@ type PeerState struct {\n \tNetworks                   []string               `protobuf:\"bytes,16,rep,name=networks,proto3\" json:\"networks,omitempty\"`\n \tLatency                    *durationpb.Duration   `protobuf:\"bytes,17,opt,name=latency,proto3\" json:\"latency,omitempty\"`\n \tRelayAddress               string                 `protobuf:\"bytes,18,opt,name=relayAddress,proto3\" json:\"relayAddress,omitempty\"`\n+\tSshHostKey                 []byte                 `protobuf:\"bytes,19,opt,name=sshHostKey,proto3\" json:\"sshHostKey,omitempty\"`\n \tunknownFields              protoimpl.UnknownFields\n \tsizeCache                  protoimpl.SizeCache\n }\n@@ -1420,6 +1517,13 @@ func (x *PeerState) GetRelayAddress() string {\n \treturn \"\"\n }\n \n+func (x *PeerState) GetSshHostKey() []byte {\n+\tif x != nil {\n+\t\treturn x.SshHostKey\n+\t}\n+\treturn nil\n+}\n+\n // LocalPeerState contains the latest state of the local peer\n type LocalPeerState struct {\n \tstate               protoimpl.MessageState `protogen:\"open.v1\"`\n@@ -1764,6 +1868,128 @@ func (x *NSGroupState) GetError() string {\n \treturn \"\"\n }\n \n+// SSHSessionInfo contains information about an active SSH session\n+type SSHSessionInfo struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tUsername      string                 `protobuf:\"bytes,1,opt,name=username,proto3\" json:\"username,omitempty\"`\n+\tRemoteAddress string                 `protobuf:\"bytes,2,opt,name=remoteAddress,proto3\" json:\"remoteAddress,omitempty\"`\n+\tCommand       string                 `protobuf:\"bytes,3,opt,name=command,proto3\" json:\"command,omitempty\"`\n+\tJwtUsername   string                 `protobuf:\"bytes,4,opt,name=jwtUsername,proto3\" json:\"jwtUsername,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *SSHSessionInfo) Reset() {\n+\t*x = SSHSessionInfo{}\n+\tmi := &file_daemon_proto_msgTypes[19]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *SSHSessionInfo) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*SSHSessionInfo) ProtoMessage() {}\n+\n+func (x *SSHSessionInfo) ProtoReflect() protoreflect.Message {\n+\tmi := &file_daemon_proto_msgTypes[19]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use SSHSessionInfo.ProtoReflect.Descriptor instead.\n+func (*SSHSessionInfo) Descriptor() ([]byte, []int) {\n+\treturn file_daemon_proto_rawDescGZIP(), []int{19}\n+}\n+\n+func (x *SSHSessionInfo) GetUsername() string {\n+\tif x != nil {\n+\t\treturn x.Username\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *SSHSessionInfo) GetRemoteAddress() string {\n+\tif x != nil {\n+\t\treturn x.RemoteAddress\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *SSHSessionInfo) GetCommand() string {\n+\tif x != nil {\n+\t\treturn x.Command\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *SSHSessionInfo) GetJwtUsername() string {\n+\tif x != nil {\n+\t\treturn x.JwtUsername\n+\t}\n+\treturn \"\"\n+}\n+\n+// SSHServerState contains the latest state of the SSH server\n+type SSHServerState struct {\n+\tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n+\tEnabled       bool                   `protobuf:\"varint,1,opt,name=enabled,proto3\" json:\"enabled,omitempty\"`\n+\tSessions      []*SSHSessionInfo      `protobuf:\"bytes,2,rep,name=sessions,proto3\" json:\"sessions,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *SSHServerState) Reset() {\n+\t*x = SSHServerState{}\n+\tmi := &file_daemon_proto_msgTypes[20]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *SSHServerState) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*SSHServerState) ProtoMessage() {}\n+\n+func (x *SSHServerState) ProtoReflect() protoreflect.Message {\n+\tmi := &file_daemon_proto_msgTypes[20]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use SSHServerState.ProtoReflect.Descriptor instead.\n+func (*SSHServerState) Descriptor() ([]byte, []int) {\n+\treturn file_daemon_proto_rawDescGZIP(), []int{20}\n+}\n+\n+func (x *SSHServerState) GetEnabled() bool {\n+\tif x != nil {\n+\t\treturn x.Enabled\n+\t}\n+\treturn false\n+}\n+\n+func (x *SSHServerState) GetSessions() []*SSHSessionInfo {\n+\tif x != nil {\n+\t\treturn x.Sessions\n+\t}\n+\treturn nil\n+}\n+\n // FullStatus contains the full state held by the Status instance\n type FullStatus struct {\n \tstate                   protoimpl.MessageState `protogen:\"open.v1\"`\n@@ -1776,13 +2002,14 @@ type FullStatus struct {\n \tNumberOfForwardingRules int32                  `protobuf:\"varint,8,opt,name=NumberOfForwardingRules,proto3\" json:\"NumberOfForwardingRules,omitempty\"`\n \tEvents                  []*SystemEvent         `protobuf:\"bytes,7,rep,name=events,proto3\" json:\"events,omitempty\"`\n \tLazyConnectionEnabled   bool                   `protobuf:\"varint,9,opt,name=lazyConnectionEnabled,proto3\" json:\"lazyConnectionEnabled,omitempty\"`\n+\tSshServerState          *SSHServerState        `protobuf:\"bytes,10,opt,name=sshServerState,proto3\" json:\"sshServerState,omitempty\"`\n \tunknownFields           protoimpl.UnknownFields\n \tsizeCache               protoimpl.SizeCache\n }\n \n func (x *FullStatus) Reset() {\n \t*x = FullStatus{}\n-\tmi := &file_daemon_proto_msgTypes[19]\n+\tmi := &file_daemon_proto_msgTypes[21]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -1794,7 +2021,7 @@ func (x *FullStatus) String() string {\n func (*FullStatus) ProtoMessage() {}\n \n func (x *FullStatus) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[19]\n+\tmi := &file_daemon_proto_msgTypes[21]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -1807,7 +2034,7 @@ func (x *FullStatus) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use FullStatus.ProtoReflect.Descriptor instead.\n func (*FullStatus) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{19}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{21}\n }\n \n func (x *FullStatus) GetManagementState() *ManagementState {\n@@ -1873,6 +2100,13 @@ func (x *FullStatus) GetLazyConnectionEnabled() bool {\n \treturn false\n }\n \n+func (x *FullStatus) GetSshServerState() *SSHServerState {\n+\tif x != nil {\n+\t\treturn x.SshServerState\n+\t}\n+\treturn nil\n+}\n+\n // Networks\n type ListNetworksRequest struct {\n \tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n@@ -1882,7 +2116,7 @@ type ListNetworksRequest struct {\n \n func (x *ListNetworksRequest) Reset() {\n \t*x = ListNetworksRequest{}\n-\tmi := &file_daemon_proto_msgTypes[20]\n+\tmi := &file_daemon_proto_msgTypes[22]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -1894,7 +2128,7 @@ func (x *ListNetworksRequest) String() string {\n func (*ListNetworksRequest) ProtoMessage() {}\n \n func (x *ListNetworksRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[20]\n+\tmi := &file_daemon_proto_msgTypes[22]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -1907,7 +2141,7 @@ func (x *ListNetworksRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use ListNetworksRequest.ProtoReflect.Descriptor instead.\n func (*ListNetworksRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{20}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{22}\n }\n \n type ListNetworksResponse struct {\n@@ -1919,7 +2153,7 @@ type ListNetworksResponse struct {\n \n func (x *ListNetworksResponse) Reset() {\n \t*x = ListNetworksResponse{}\n-\tmi := &file_daemon_proto_msgTypes[21]\n+\tmi := &file_daemon_proto_msgTypes[23]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -1931,7 +2165,7 @@ func (x *ListNetworksResponse) String() string {\n func (*ListNetworksResponse) ProtoMessage() {}\n \n func (x *ListNetworksResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[21]\n+\tmi := &file_daemon_proto_msgTypes[23]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -1944,7 +2178,7 @@ func (x *ListNetworksResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use ListNetworksResponse.ProtoReflect.Descriptor instead.\n func (*ListNetworksResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{21}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{23}\n }\n \n func (x *ListNetworksResponse) GetRoutes() []*Network {\n@@ -1965,7 +2199,7 @@ type SelectNetworksRequest struct {\n \n func (x *SelectNetworksRequest) Reset() {\n \t*x = SelectNetworksRequest{}\n-\tmi := &file_daemon_proto_msgTypes[22]\n+\tmi := &file_daemon_proto_msgTypes[24]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -1977,7 +2211,7 @@ func (x *SelectNetworksRequest) String() string {\n func (*SelectNetworksRequest) ProtoMessage() {}\n \n func (x *SelectNetworksRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[22]\n+\tmi := &file_daemon_proto_msgTypes[24]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -1990,7 +2224,7 @@ func (x *SelectNetworksRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SelectNetworksRequest.ProtoReflect.Descriptor instead.\n func (*SelectNetworksRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{22}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{24}\n }\n \n func (x *SelectNetworksRequest) GetNetworkIDs() []string {\n@@ -2022,7 +2256,7 @@ type SelectNetworksResponse struct {\n \n func (x *SelectNetworksResponse) Reset() {\n \t*x = SelectNetworksResponse{}\n-\tmi := &file_daemon_proto_msgTypes[23]\n+\tmi := &file_daemon_proto_msgTypes[25]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2034,7 +2268,7 @@ func (x *SelectNetworksResponse) String() string {\n func (*SelectNetworksResponse) ProtoMessage() {}\n \n func (x *SelectNetworksResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[23]\n+\tmi := &file_daemon_proto_msgTypes[25]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2047,7 +2281,7 @@ func (x *SelectNetworksResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SelectNetworksResponse.ProtoReflect.Descriptor instead.\n func (*SelectNetworksResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{23}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{25}\n }\n \n type IPList struct {\n@@ -2059,7 +2293,7 @@ type IPList struct {\n \n func (x *IPList) Reset() {\n \t*x = IPList{}\n-\tmi := &file_daemon_proto_msgTypes[24]\n+\tmi := &file_daemon_proto_msgTypes[26]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2071,7 +2305,7 @@ func (x *IPList) String() string {\n func (*IPList) ProtoMessage() {}\n \n func (x *IPList) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[24]\n+\tmi := &file_daemon_proto_msgTypes[26]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2084,7 +2318,7 @@ func (x *IPList) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use IPList.ProtoReflect.Descriptor instead.\n func (*IPList) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{24}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{26}\n }\n \n func (x *IPList) GetIps() []string {\n@@ -2107,7 +2341,7 @@ type Network struct {\n \n func (x *Network) Reset() {\n \t*x = Network{}\n-\tmi := &file_daemon_proto_msgTypes[25]\n+\tmi := &file_daemon_proto_msgTypes[27]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2119,7 +2353,7 @@ func (x *Network) String() string {\n func (*Network) ProtoMessage() {}\n \n func (x *Network) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[25]\n+\tmi := &file_daemon_proto_msgTypes[27]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2132,7 +2366,7 @@ func (x *Network) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use Network.ProtoReflect.Descriptor instead.\n func (*Network) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{25}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{27}\n }\n \n func (x *Network) GetID() string {\n@@ -2184,7 +2418,7 @@ type PortInfo struct {\n \n func (x *PortInfo) Reset() {\n \t*x = PortInfo{}\n-\tmi := &file_daemon_proto_msgTypes[26]\n+\tmi := &file_daemon_proto_msgTypes[28]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2196,7 +2430,7 @@ func (x *PortInfo) String() string {\n func (*PortInfo) ProtoMessage() {}\n \n func (x *PortInfo) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[26]\n+\tmi := &file_daemon_proto_msgTypes[28]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2209,7 +2443,7 @@ func (x *PortInfo) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use PortInfo.ProtoReflect.Descriptor instead.\n func (*PortInfo) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{26}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{28}\n }\n \n func (x *PortInfo) GetPortSelection() isPortInfo_PortSelection {\n@@ -2266,7 +2500,7 @@ type ForwardingRule struct {\n \n func (x *ForwardingRule) Reset() {\n \t*x = ForwardingRule{}\n-\tmi := &file_daemon_proto_msgTypes[27]\n+\tmi := &file_daemon_proto_msgTypes[29]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2278,7 +2512,7 @@ func (x *ForwardingRule) String() string {\n func (*ForwardingRule) ProtoMessage() {}\n \n func (x *ForwardingRule) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[27]\n+\tmi := &file_daemon_proto_msgTypes[29]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2291,7 +2525,7 @@ func (x *ForwardingRule) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use ForwardingRule.ProtoReflect.Descriptor instead.\n func (*ForwardingRule) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{27}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{29}\n }\n \n func (x *ForwardingRule) GetProtocol() string {\n@@ -2338,7 +2572,7 @@ type ForwardingRulesResponse struct {\n \n func (x *ForwardingRulesResponse) Reset() {\n \t*x = ForwardingRulesResponse{}\n-\tmi := &file_daemon_proto_msgTypes[28]\n+\tmi := &file_daemon_proto_msgTypes[30]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2350,7 +2584,7 @@ func (x *ForwardingRulesResponse) String() string {\n func (*ForwardingRulesResponse) ProtoMessage() {}\n \n func (x *ForwardingRulesResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[28]\n+\tmi := &file_daemon_proto_msgTypes[30]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2363,7 +2597,7 @@ func (x *ForwardingRulesResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use ForwardingRulesResponse.ProtoReflect.Descriptor instead.\n func (*ForwardingRulesResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{28}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{30}\n }\n \n func (x *ForwardingRulesResponse) GetRules() []*ForwardingRule {\n@@ -2387,7 +2621,7 @@ type DebugBundleRequest struct {\n \n func (x *DebugBundleRequest) Reset() {\n \t*x = DebugBundleRequest{}\n-\tmi := &file_daemon_proto_msgTypes[29]\n+\tmi := &file_daemon_proto_msgTypes[31]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2399,7 +2633,7 @@ func (x *DebugBundleRequest) String() string {\n func (*DebugBundleRequest) ProtoMessage() {}\n \n func (x *DebugBundleRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[29]\n+\tmi := &file_daemon_proto_msgTypes[31]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2412,7 +2646,7 @@ func (x *DebugBundleRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use DebugBundleRequest.ProtoReflect.Descriptor instead.\n func (*DebugBundleRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{29}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{31}\n }\n \n func (x *DebugBundleRequest) GetAnonymize() bool {\n@@ -2461,7 +2695,7 @@ type DebugBundleResponse struct {\n \n func (x *DebugBundleResponse) Reset() {\n \t*x = DebugBundleResponse{}\n-\tmi := &file_daemon_proto_msgTypes[30]\n+\tmi := &file_daemon_proto_msgTypes[32]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2473,7 +2707,7 @@ func (x *DebugBundleResponse) String() string {\n func (*DebugBundleResponse) ProtoMessage() {}\n \n func (x *DebugBundleResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[30]\n+\tmi := &file_daemon_proto_msgTypes[32]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2486,7 +2720,7 @@ func (x *DebugBundleResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use DebugBundleResponse.ProtoReflect.Descriptor instead.\n func (*DebugBundleResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{30}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{32}\n }\n \n func (x *DebugBundleResponse) GetPath() string {\n@@ -2518,7 +2752,7 @@ type GetLogLevelRequest struct {\n \n func (x *GetLogLevelRequest) Reset() {\n \t*x = GetLogLevelRequest{}\n-\tmi := &file_daemon_proto_msgTypes[31]\n+\tmi := &file_daemon_proto_msgTypes[33]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2530,7 +2764,7 @@ func (x *GetLogLevelRequest) String() string {\n func (*GetLogLevelRequest) ProtoMessage() {}\n \n func (x *GetLogLevelRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[31]\n+\tmi := &file_daemon_proto_msgTypes[33]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2543,7 +2777,7 @@ func (x *GetLogLevelRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use GetLogLevelRequest.ProtoReflect.Descriptor instead.\n func (*GetLogLevelRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{31}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{33}\n }\n \n type GetLogLevelResponse struct {\n@@ -2555,7 +2789,7 @@ type GetLogLevelResponse struct {\n \n func (x *GetLogLevelResponse) Reset() {\n \t*x = GetLogLevelResponse{}\n-\tmi := &file_daemon_proto_msgTypes[32]\n+\tmi := &file_daemon_proto_msgTypes[34]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2567,7 +2801,7 @@ func (x *GetLogLevelResponse) String() string {\n func (*GetLogLevelResponse) ProtoMessage() {}\n \n func (x *GetLogLevelResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[32]\n+\tmi := &file_daemon_proto_msgTypes[34]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2580,7 +2814,7 @@ func (x *GetLogLevelResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use GetLogLevelResponse.ProtoReflect.Descriptor instead.\n func (*GetLogLevelResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{32}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{34}\n }\n \n func (x *GetLogLevelResponse) GetLevel() LogLevel {\n@@ -2599,7 +2833,7 @@ type SetLogLevelRequest struct {\n \n func (x *SetLogLevelRequest) Reset() {\n \t*x = SetLogLevelRequest{}\n-\tmi := &file_daemon_proto_msgTypes[33]\n+\tmi := &file_daemon_proto_msgTypes[35]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2611,7 +2845,7 @@ func (x *SetLogLevelRequest) String() string {\n func (*SetLogLevelRequest) ProtoMessage() {}\n \n func (x *SetLogLevelRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[33]\n+\tmi := &file_daemon_proto_msgTypes[35]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2624,7 +2858,7 @@ func (x *SetLogLevelRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SetLogLevelRequest.ProtoReflect.Descriptor instead.\n func (*SetLogLevelRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{33}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{35}\n }\n \n func (x *SetLogLevelRequest) GetLevel() LogLevel {\n@@ -2642,7 +2876,7 @@ type SetLogLevelResponse struct {\n \n func (x *SetLogLevelResponse) Reset() {\n \t*x = SetLogLevelResponse{}\n-\tmi := &file_daemon_proto_msgTypes[34]\n+\tmi := &file_daemon_proto_msgTypes[36]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2654,7 +2888,7 @@ func (x *SetLogLevelResponse) String() string {\n func (*SetLogLevelResponse) ProtoMessage() {}\n \n func (x *SetLogLevelResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[34]\n+\tmi := &file_daemon_proto_msgTypes[36]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2667,7 +2901,7 @@ func (x *SetLogLevelResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SetLogLevelResponse.ProtoReflect.Descriptor instead.\n func (*SetLogLevelResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{34}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{36}\n }\n \n // State represents a daemon state entry\n@@ -2680,7 +2914,7 @@ type State struct {\n \n func (x *State) Reset() {\n \t*x = State{}\n-\tmi := &file_daemon_proto_msgTypes[35]\n+\tmi := &file_daemon_proto_msgTypes[37]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2692,7 +2926,7 @@ func (x *State) String() string {\n func (*State) ProtoMessage() {}\n \n func (x *State) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[35]\n+\tmi := &file_daemon_proto_msgTypes[37]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2705,7 +2939,7 @@ func (x *State) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use State.ProtoReflect.Descriptor instead.\n func (*State) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{35}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{37}\n }\n \n func (x *State) GetName() string {\n@@ -2724,7 +2958,7 @@ type ListStatesRequest struct {\n \n func (x *ListStatesRequest) Reset() {\n \t*x = ListStatesRequest{}\n-\tmi := &file_daemon_proto_msgTypes[36]\n+\tmi := &file_daemon_proto_msgTypes[38]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2736,7 +2970,7 @@ func (x *ListStatesRequest) String() string {\n func (*ListStatesRequest) ProtoMessage() {}\n \n func (x *ListStatesRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[36]\n+\tmi := &file_daemon_proto_msgTypes[38]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2749,7 +2983,7 @@ func (x *ListStatesRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use ListStatesRequest.ProtoReflect.Descriptor instead.\n func (*ListStatesRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{36}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{38}\n }\n \n // ListStatesResponse contains a list of states\n@@ -2762,7 +2996,7 @@ type ListStatesResponse struct {\n \n func (x *ListStatesResponse) Reset() {\n \t*x = ListStatesResponse{}\n-\tmi := &file_daemon_proto_msgTypes[37]\n+\tmi := &file_daemon_proto_msgTypes[39]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2774,7 +3008,7 @@ func (x *ListStatesResponse) String() string {\n func (*ListStatesResponse) ProtoMessage() {}\n \n func (x *ListStatesResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[37]\n+\tmi := &file_daemon_proto_msgTypes[39]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2787,7 +3021,7 @@ func (x *ListStatesResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use ListStatesResponse.ProtoReflect.Descriptor instead.\n func (*ListStatesResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{37}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{39}\n }\n \n func (x *ListStatesResponse) GetStates() []*State {\n@@ -2808,7 +3042,7 @@ type CleanStateRequest struct {\n \n func (x *CleanStateRequest) Reset() {\n \t*x = CleanStateRequest{}\n-\tmi := &file_daemon_proto_msgTypes[38]\n+\tmi := &file_daemon_proto_msgTypes[40]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2820,7 +3054,7 @@ func (x *CleanStateRequest) String() string {\n func (*CleanStateRequest) ProtoMessage() {}\n \n func (x *CleanStateRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[38]\n+\tmi := &file_daemon_proto_msgTypes[40]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2833,7 +3067,7 @@ func (x *CleanStateRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use CleanStateRequest.ProtoReflect.Descriptor instead.\n func (*CleanStateRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{38}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{40}\n }\n \n func (x *CleanStateRequest) GetStateName() string {\n@@ -2860,7 +3094,7 @@ type CleanStateResponse struct {\n \n func (x *CleanStateResponse) Reset() {\n \t*x = CleanStateResponse{}\n-\tmi := &file_daemon_proto_msgTypes[39]\n+\tmi := &file_daemon_proto_msgTypes[41]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2872,7 +3106,7 @@ func (x *CleanStateResponse) String() string {\n func (*CleanStateResponse) ProtoMessage() {}\n \n func (x *CleanStateResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[39]\n+\tmi := &file_daemon_proto_msgTypes[41]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2885,7 +3119,7 @@ func (x *CleanStateResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use CleanStateResponse.ProtoReflect.Descriptor instead.\n func (*CleanStateResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{39}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{41}\n }\n \n func (x *CleanStateResponse) GetCleanedStates() int32 {\n@@ -2906,7 +3140,7 @@ type DeleteStateRequest struct {\n \n func (x *DeleteStateRequest) Reset() {\n \t*x = DeleteStateRequest{}\n-\tmi := &file_daemon_proto_msgTypes[40]\n+\tmi := &file_daemon_proto_msgTypes[42]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2918,7 +3152,7 @@ func (x *DeleteStateRequest) String() string {\n func (*DeleteStateRequest) ProtoMessage() {}\n \n func (x *DeleteStateRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[40]\n+\tmi := &file_daemon_proto_msgTypes[42]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2931,7 +3165,7 @@ func (x *DeleteStateRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use DeleteStateRequest.ProtoReflect.Descriptor instead.\n func (*DeleteStateRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{40}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{42}\n }\n \n func (x *DeleteStateRequest) GetStateName() string {\n@@ -2958,7 +3192,7 @@ type DeleteStateResponse struct {\n \n func (x *DeleteStateResponse) Reset() {\n \t*x = DeleteStateResponse{}\n-\tmi := &file_daemon_proto_msgTypes[41]\n+\tmi := &file_daemon_proto_msgTypes[43]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -2970,7 +3204,7 @@ func (x *DeleteStateResponse) String() string {\n func (*DeleteStateResponse) ProtoMessage() {}\n \n func (x *DeleteStateResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[41]\n+\tmi := &file_daemon_proto_msgTypes[43]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2983,7 +3217,7 @@ func (x *DeleteStateResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use DeleteStateResponse.ProtoReflect.Descriptor instead.\n func (*DeleteStateResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{41}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{43}\n }\n \n func (x *DeleteStateResponse) GetDeletedStates() int32 {\n@@ -3002,7 +3236,7 @@ type SetSyncResponsePersistenceRequest struct {\n \n func (x *SetSyncResponsePersistenceRequest) Reset() {\n \t*x = SetSyncResponsePersistenceRequest{}\n-\tmi := &file_daemon_proto_msgTypes[42]\n+\tmi := &file_daemon_proto_msgTypes[44]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3014,7 +3248,7 @@ func (x *SetSyncResponsePersistenceRequest) String() string {\n func (*SetSyncResponsePersistenceRequest) ProtoMessage() {}\n \n func (x *SetSyncResponsePersistenceRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[42]\n+\tmi := &file_daemon_proto_msgTypes[44]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3027,7 +3261,7 @@ func (x *SetSyncResponsePersistenceRequest) ProtoReflect() protoreflect.Message\n \n // Deprecated: Use SetSyncResponsePersistenceRequest.ProtoReflect.Descriptor instead.\n func (*SetSyncResponsePersistenceRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{42}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{44}\n }\n \n func (x *SetSyncResponsePersistenceRequest) GetEnabled() bool {\n@@ -3045,7 +3279,7 @@ type SetSyncResponsePersistenceResponse struct {\n \n func (x *SetSyncResponsePersistenceResponse) Reset() {\n \t*x = SetSyncResponsePersistenceResponse{}\n-\tmi := &file_daemon_proto_msgTypes[43]\n+\tmi := &file_daemon_proto_msgTypes[45]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3057,7 +3291,7 @@ func (x *SetSyncResponsePersistenceResponse) String() string {\n func (*SetSyncResponsePersistenceResponse) ProtoMessage() {}\n \n func (x *SetSyncResponsePersistenceResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[43]\n+\tmi := &file_daemon_proto_msgTypes[45]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3070,7 +3304,7 @@ func (x *SetSyncResponsePersistenceResponse) ProtoReflect() protoreflect.Message\n \n // Deprecated: Use SetSyncResponsePersistenceResponse.ProtoReflect.Descriptor instead.\n func (*SetSyncResponsePersistenceResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{43}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{45}\n }\n \n type TCPFlags struct {\n@@ -3087,7 +3321,7 @@ type TCPFlags struct {\n \n func (x *TCPFlags) Reset() {\n \t*x = TCPFlags{}\n-\tmi := &file_daemon_proto_msgTypes[44]\n+\tmi := &file_daemon_proto_msgTypes[46]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3099,7 +3333,7 @@ func (x *TCPFlags) String() string {\n func (*TCPFlags) ProtoMessage() {}\n \n func (x *TCPFlags) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[44]\n+\tmi := &file_daemon_proto_msgTypes[46]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3112,7 +3346,7 @@ func (x *TCPFlags) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use TCPFlags.ProtoReflect.Descriptor instead.\n func (*TCPFlags) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{44}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{46}\n }\n \n func (x *TCPFlags) GetSyn() bool {\n@@ -3174,7 +3408,7 @@ type TracePacketRequest struct {\n \n func (x *TracePacketRequest) Reset() {\n \t*x = TracePacketRequest{}\n-\tmi := &file_daemon_proto_msgTypes[45]\n+\tmi := &file_daemon_proto_msgTypes[47]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3186,7 +3420,7 @@ func (x *TracePacketRequest) String() string {\n func (*TracePacketRequest) ProtoMessage() {}\n \n func (x *TracePacketRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[45]\n+\tmi := &file_daemon_proto_msgTypes[47]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3199,7 +3433,7 @@ func (x *TracePacketRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use TracePacketRequest.ProtoReflect.Descriptor instead.\n func (*TracePacketRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{45}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{47}\n }\n \n func (x *TracePacketRequest) GetSourceIp() string {\n@@ -3277,7 +3511,7 @@ type TraceStage struct {\n \n func (x *TraceStage) Reset() {\n \t*x = TraceStage{}\n-\tmi := &file_daemon_proto_msgTypes[46]\n+\tmi := &file_daemon_proto_msgTypes[48]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3289,7 +3523,7 @@ func (x *TraceStage) String() string {\n func (*TraceStage) ProtoMessage() {}\n \n func (x *TraceStage) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[46]\n+\tmi := &file_daemon_proto_msgTypes[48]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3302,7 +3536,7 @@ func (x *TraceStage) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use TraceStage.ProtoReflect.Descriptor instead.\n func (*TraceStage) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{46}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{48}\n }\n \n func (x *TraceStage) GetName() string {\n@@ -3343,7 +3577,7 @@ type TracePacketResponse struct {\n \n func (x *TracePacketResponse) Reset() {\n \t*x = TracePacketResponse{}\n-\tmi := &file_daemon_proto_msgTypes[47]\n+\tmi := &file_daemon_proto_msgTypes[49]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3355,7 +3589,7 @@ func (x *TracePacketResponse) String() string {\n func (*TracePacketResponse) ProtoMessage() {}\n \n func (x *TracePacketResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[47]\n+\tmi := &file_daemon_proto_msgTypes[49]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3368,7 +3602,7 @@ func (x *TracePacketResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use TracePacketResponse.ProtoReflect.Descriptor instead.\n func (*TracePacketResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{47}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{49}\n }\n \n func (x *TracePacketResponse) GetStages() []*TraceStage {\n@@ -3393,7 +3627,7 @@ type SubscribeRequest struct {\n \n func (x *SubscribeRequest) Reset() {\n \t*x = SubscribeRequest{}\n-\tmi := &file_daemon_proto_msgTypes[48]\n+\tmi := &file_daemon_proto_msgTypes[50]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3405,7 +3639,7 @@ func (x *SubscribeRequest) String() string {\n func (*SubscribeRequest) ProtoMessage() {}\n \n func (x *SubscribeRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[48]\n+\tmi := &file_daemon_proto_msgTypes[50]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3418,7 +3652,7 @@ func (x *SubscribeRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SubscribeRequest.ProtoReflect.Descriptor instead.\n func (*SubscribeRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{48}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{50}\n }\n \n type SystemEvent struct {\n@@ -3436,7 +3670,7 @@ type SystemEvent struct {\n \n func (x *SystemEvent) Reset() {\n \t*x = SystemEvent{}\n-\tmi := &file_daemon_proto_msgTypes[49]\n+\tmi := &file_daemon_proto_msgTypes[51]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3448,7 +3682,7 @@ func (x *SystemEvent) String() string {\n func (*SystemEvent) ProtoMessage() {}\n \n func (x *SystemEvent) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[49]\n+\tmi := &file_daemon_proto_msgTypes[51]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3461,7 +3695,7 @@ func (x *SystemEvent) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SystemEvent.ProtoReflect.Descriptor instead.\n func (*SystemEvent) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{49}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{51}\n }\n \n func (x *SystemEvent) GetId() string {\n@@ -3521,7 +3755,7 @@ type GetEventsRequest struct {\n \n func (x *GetEventsRequest) Reset() {\n \t*x = GetEventsRequest{}\n-\tmi := &file_daemon_proto_msgTypes[50]\n+\tmi := &file_daemon_proto_msgTypes[52]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3533,7 +3767,7 @@ func (x *GetEventsRequest) String() string {\n func (*GetEventsRequest) ProtoMessage() {}\n \n func (x *GetEventsRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[50]\n+\tmi := &file_daemon_proto_msgTypes[52]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3546,7 +3780,7 @@ func (x *GetEventsRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use GetEventsRequest.ProtoReflect.Descriptor instead.\n func (*GetEventsRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{50}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{52}\n }\n \n type GetEventsResponse struct {\n@@ -3558,7 +3792,7 @@ type GetEventsResponse struct {\n \n func (x *GetEventsResponse) Reset() {\n \t*x = GetEventsResponse{}\n-\tmi := &file_daemon_proto_msgTypes[51]\n+\tmi := &file_daemon_proto_msgTypes[53]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3570,7 +3804,7 @@ func (x *GetEventsResponse) String() string {\n func (*GetEventsResponse) ProtoMessage() {}\n \n func (x *GetEventsResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[51]\n+\tmi := &file_daemon_proto_msgTypes[53]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3583,7 +3817,7 @@ func (x *GetEventsResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use GetEventsResponse.ProtoReflect.Descriptor instead.\n func (*GetEventsResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{51}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{53}\n }\n \n func (x *GetEventsResponse) GetEvents() []*SystemEvent {\n@@ -3603,7 +3837,7 @@ type SwitchProfileRequest struct {\n \n func (x *SwitchProfileRequest) Reset() {\n \t*x = SwitchProfileRequest{}\n-\tmi := &file_daemon_proto_msgTypes[52]\n+\tmi := &file_daemon_proto_msgTypes[54]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3615,7 +3849,7 @@ func (x *SwitchProfileRequest) String() string {\n func (*SwitchProfileRequest) ProtoMessage() {}\n \n func (x *SwitchProfileRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[52]\n+\tmi := &file_daemon_proto_msgTypes[54]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3628,7 +3862,7 @@ func (x *SwitchProfileRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SwitchProfileRequest.ProtoReflect.Descriptor instead.\n func (*SwitchProfileRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{52}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{54}\n }\n \n func (x *SwitchProfileRequest) GetProfileName() string {\n@@ -3653,7 +3887,7 @@ type SwitchProfileResponse struct {\n \n func (x *SwitchProfileResponse) Reset() {\n \t*x = SwitchProfileResponse{}\n-\tmi := &file_daemon_proto_msgTypes[53]\n+\tmi := &file_daemon_proto_msgTypes[55]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3665,7 +3899,7 @@ func (x *SwitchProfileResponse) String() string {\n func (*SwitchProfileResponse) ProtoMessage() {}\n \n func (x *SwitchProfileResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[53]\n+\tmi := &file_daemon_proto_msgTypes[55]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3678,7 +3912,7 @@ func (x *SwitchProfileResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SwitchProfileResponse.ProtoReflect.Descriptor instead.\n func (*SwitchProfileResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{53}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{55}\n }\n \n type SetConfigRequest struct {\n@@ -3711,16 +3945,22 @@ type SetConfigRequest struct {\n \tExtraIFaceBlacklist   []string `protobuf:\"bytes,24,rep,name=extraIFaceBlacklist,proto3\" json:\"extraIFaceBlacklist,omitempty\"`\n \tDnsLabels             []string `protobuf:\"bytes,25,rep,name=dns_labels,json=dnsLabels,proto3\" json:\"dns_labels,omitempty\"`\n \t// cleanDNSLabels clean map list of DNS labels.\n-\tCleanDNSLabels   bool                 `protobuf:\"varint,26,opt,name=cleanDNSLabels,proto3\" json:\"cleanDNSLabels,omitempty\"`\n-\tDnsRouteInterval *durationpb.Duration `protobuf:\"bytes,27,opt,name=dnsRouteInterval,proto3,oneof\" json:\"dnsRouteInterval,omitempty\"`\n-\tMtu              *int64               `protobuf:\"varint,28,opt,name=mtu,proto3,oneof\" json:\"mtu,omitempty\"`\n-\tunknownFields    protoimpl.UnknownFields\n-\tsizeCache        protoimpl.SizeCache\n+\tCleanDNSLabels                bool                 `protobuf:\"varint,26,opt,name=cleanDNSLabels,proto3\" json:\"cleanDNSLabels,omitempty\"`\n+\tDnsRouteInterval              *durationpb.Duration `protobuf:\"bytes,27,opt,name=dnsRouteInterval,proto3,oneof\" json:\"dnsRouteInterval,omitempty\"`\n+\tMtu                           *int64               `protobuf:\"varint,28,opt,name=mtu,proto3,oneof\" json:\"mtu,omitempty\"`\n+\tEnableSSHRoot                 *bool                `protobuf:\"varint,29,opt,name=enableSSHRoot,proto3,oneof\" json:\"enableSSHRoot,omitempty\"`\n+\tEnableSSHSFTP                 *bool                `protobuf:\"varint,30,opt,name=enableSSHSFTP,proto3,oneof\" json:\"enableSSHSFTP,omitempty\"`\n+\tEnableSSHLocalPortForwarding  *bool                `protobuf:\"varint,31,opt,name=enableSSHLocalPortForwarding,proto3,oneof\" json:\"enableSSHLocalPortForwarding,omitempty\"`\n+\tEnableSSHRemotePortForwarding *bool                `protobuf:\"varint,32,opt,name=enableSSHRemotePortForwarding,proto3,oneof\" json:\"enableSSHRemotePortForwarding,omitempty\"`\n+\tDisableSSHAuth                *bool                `protobuf:\"varint,33,opt,name=disableSSHAuth,proto3,oneof\" json:\"disableSSHAuth,omitempty\"`\n+\tSshJWTCacheTTL                *int32               `protobuf:\"varint,34,opt,name=sshJWTCacheTTL,proto3,oneof\" json:\"sshJWTCacheTTL,omitempty\"`\n+\tunknownFields                 protoimpl.UnknownFields\n+\tsizeCache                     protoimpl.SizeCache\n }\n \n func (x *SetConfigRequest) Reset() {\n \t*x = SetConfigRequest{}\n-\tmi := &file_daemon_proto_msgTypes[54]\n+\tmi := &file_daemon_proto_msgTypes[56]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3732,7 +3972,7 @@ func (x *SetConfigRequest) String() string {\n func (*SetConfigRequest) ProtoMessage() {}\n \n func (x *SetConfigRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[54]\n+\tmi := &file_daemon_proto_msgTypes[56]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3745,7 +3985,7 @@ func (x *SetConfigRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SetConfigRequest.ProtoReflect.Descriptor instead.\n func (*SetConfigRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{54}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{56}\n }\n \n func (x *SetConfigRequest) GetUsername() string {\n@@ -3944,6 +4184,48 @@ func (x *SetConfigRequest) GetMtu() int64 {\n \treturn 0\n }\n \n+func (x *SetConfigRequest) GetEnableSSHRoot() bool {\n+\tif x != nil && x.EnableSSHRoot != nil {\n+\t\treturn *x.EnableSSHRoot\n+\t}\n+\treturn false\n+}\n+\n+func (x *SetConfigRequest) GetEnableSSHSFTP() bool {\n+\tif x != nil && x.EnableSSHSFTP != nil {\n+\t\treturn *x.EnableSSHSFTP\n+\t}\n+\treturn false\n+}\n+\n+func (x *SetConfigRequest) GetEnableSSHLocalPortForwarding() bool {\n+\tif x != nil && x.EnableSSHLocalPortForwarding != nil {\n+\t\treturn *x.EnableSSHLocalPortForwarding\n+\t}\n+\treturn false\n+}\n+\n+func (x *SetConfigRequest) GetEnableSSHRemotePortForwarding() bool {\n+\tif x != nil && x.EnableSSHRemotePortForwarding != nil {\n+\t\treturn *x.EnableSSHRemotePortForwarding\n+\t}\n+\treturn false\n+}\n+\n+func (x *SetConfigRequest) GetDisableSSHAuth() bool {\n+\tif x != nil && x.DisableSSHAuth != nil {\n+\t\treturn *x.DisableSSHAuth\n+\t}\n+\treturn false\n+}\n+\n+func (x *SetConfigRequest) GetSshJWTCacheTTL() int32 {\n+\tif x != nil && x.SshJWTCacheTTL != nil {\n+\t\treturn *x.SshJWTCacheTTL\n+\t}\n+\treturn 0\n+}\n+\n type SetConfigResponse struct {\n \tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n \tunknownFields protoimpl.UnknownFields\n@@ -3952,7 +4234,7 @@ type SetConfigResponse struct {\n \n func (x *SetConfigResponse) Reset() {\n \t*x = SetConfigResponse{}\n-\tmi := &file_daemon_proto_msgTypes[55]\n+\tmi := &file_daemon_proto_msgTypes[57]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -3964,7 +4246,7 @@ func (x *SetConfigResponse) String() string {\n func (*SetConfigResponse) ProtoMessage() {}\n \n func (x *SetConfigResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[55]\n+\tmi := &file_daemon_proto_msgTypes[57]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3977,7 +4259,7 @@ func (x *SetConfigResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SetConfigResponse.ProtoReflect.Descriptor instead.\n func (*SetConfigResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{55}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{57}\n }\n \n type AddProfileRequest struct {\n@@ -3990,7 +4272,7 @@ type AddProfileRequest struct {\n \n func (x *AddProfileRequest) Reset() {\n \t*x = AddProfileRequest{}\n-\tmi := &file_daemon_proto_msgTypes[56]\n+\tmi := &file_daemon_proto_msgTypes[58]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4002,7 +4284,7 @@ func (x *AddProfileRequest) String() string {\n func (*AddProfileRequest) ProtoMessage() {}\n \n func (x *AddProfileRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[56]\n+\tmi := &file_daemon_proto_msgTypes[58]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4015,7 +4297,7 @@ func (x *AddProfileRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use AddProfileRequest.ProtoReflect.Descriptor instead.\n func (*AddProfileRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{56}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{58}\n }\n \n func (x *AddProfileRequest) GetUsername() string {\n@@ -4040,7 +4322,7 @@ type AddProfileResponse struct {\n \n func (x *AddProfileResponse) Reset() {\n \t*x = AddProfileResponse{}\n-\tmi := &file_daemon_proto_msgTypes[57]\n+\tmi := &file_daemon_proto_msgTypes[59]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4052,7 +4334,7 @@ func (x *AddProfileResponse) String() string {\n func (*AddProfileResponse) ProtoMessage() {}\n \n func (x *AddProfileResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[57]\n+\tmi := &file_daemon_proto_msgTypes[59]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4065,7 +4347,7 @@ func (x *AddProfileResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use AddProfileResponse.ProtoReflect.Descriptor instead.\n func (*AddProfileResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{57}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{59}\n }\n \n type RemoveProfileRequest struct {\n@@ -4078,7 +4360,7 @@ type RemoveProfileRequest struct {\n \n func (x *RemoveProfileRequest) Reset() {\n \t*x = RemoveProfileRequest{}\n-\tmi := &file_daemon_proto_msgTypes[58]\n+\tmi := &file_daemon_proto_msgTypes[60]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4090,7 +4372,7 @@ func (x *RemoveProfileRequest) String() string {\n func (*RemoveProfileRequest) ProtoMessage() {}\n \n func (x *RemoveProfileRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[58]\n+\tmi := &file_daemon_proto_msgTypes[60]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4103,7 +4385,7 @@ func (x *RemoveProfileRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use RemoveProfileRequest.ProtoReflect.Descriptor instead.\n func (*RemoveProfileRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{58}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{60}\n }\n \n func (x *RemoveProfileRequest) GetUsername() string {\n@@ -4128,7 +4410,7 @@ type RemoveProfileResponse struct {\n \n func (x *RemoveProfileResponse) Reset() {\n \t*x = RemoveProfileResponse{}\n-\tmi := &file_daemon_proto_msgTypes[59]\n+\tmi := &file_daemon_proto_msgTypes[61]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4140,7 +4422,7 @@ func (x *RemoveProfileResponse) String() string {\n func (*RemoveProfileResponse) ProtoMessage() {}\n \n func (x *RemoveProfileResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[59]\n+\tmi := &file_daemon_proto_msgTypes[61]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4153,7 +4435,7 @@ func (x *RemoveProfileResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use RemoveProfileResponse.ProtoReflect.Descriptor instead.\n func (*RemoveProfileResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{59}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{61}\n }\n \n type ListProfilesRequest struct {\n@@ -4165,7 +4447,7 @@ type ListProfilesRequest struct {\n \n func (x *ListProfilesRequest) Reset() {\n \t*x = ListProfilesRequest{}\n-\tmi := &file_daemon_proto_msgTypes[60]\n+\tmi := &file_daemon_proto_msgTypes[62]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4177,7 +4459,7 @@ func (x *ListProfilesRequest) String() string {\n func (*ListProfilesRequest) ProtoMessage() {}\n \n func (x *ListProfilesRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[60]\n+\tmi := &file_daemon_proto_msgTypes[62]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4190,7 +4472,7 @@ func (x *ListProfilesRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use ListProfilesRequest.ProtoReflect.Descriptor instead.\n func (*ListProfilesRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{60}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{62}\n }\n \n func (x *ListProfilesRequest) GetUsername() string {\n@@ -4209,7 +4491,7 @@ type ListProfilesResponse struct {\n \n func (x *ListProfilesResponse) Reset() {\n \t*x = ListProfilesResponse{}\n-\tmi := &file_daemon_proto_msgTypes[61]\n+\tmi := &file_daemon_proto_msgTypes[63]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4221,7 +4503,7 @@ func (x *ListProfilesResponse) String() string {\n func (*ListProfilesResponse) ProtoMessage() {}\n \n func (x *ListProfilesResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[61]\n+\tmi := &file_daemon_proto_msgTypes[63]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4234,7 +4516,7 @@ func (x *ListProfilesResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use ListProfilesResponse.ProtoReflect.Descriptor instead.\n func (*ListProfilesResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{61}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{63}\n }\n \n func (x *ListProfilesResponse) GetProfiles() []*Profile {\n@@ -4254,7 +4536,7 @@ type Profile struct {\n \n func (x *Profile) Reset() {\n \t*x = Profile{}\n-\tmi := &file_daemon_proto_msgTypes[62]\n+\tmi := &file_daemon_proto_msgTypes[64]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4266,7 +4548,7 @@ func (x *Profile) String() string {\n func (*Profile) ProtoMessage() {}\n \n func (x *Profile) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[62]\n+\tmi := &file_daemon_proto_msgTypes[64]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4279,7 +4561,7 @@ func (x *Profile) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use Profile.ProtoReflect.Descriptor instead.\n func (*Profile) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{62}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{64}\n }\n \n func (x *Profile) GetName() string {\n@@ -4304,7 +4586,7 @@ type GetActiveProfileRequest struct {\n \n func (x *GetActiveProfileRequest) Reset() {\n \t*x = GetActiveProfileRequest{}\n-\tmi := &file_daemon_proto_msgTypes[63]\n+\tmi := &file_daemon_proto_msgTypes[65]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4316,7 +4598,7 @@ func (x *GetActiveProfileRequest) String() string {\n func (*GetActiveProfileRequest) ProtoMessage() {}\n \n func (x *GetActiveProfileRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[63]\n+\tmi := &file_daemon_proto_msgTypes[65]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4329,7 +4611,7 @@ func (x *GetActiveProfileRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use GetActiveProfileRequest.ProtoReflect.Descriptor instead.\n func (*GetActiveProfileRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{63}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{65}\n }\n \n type GetActiveProfileResponse struct {\n@@ -4342,7 +4624,7 @@ type GetActiveProfileResponse struct {\n \n func (x *GetActiveProfileResponse) Reset() {\n \t*x = GetActiveProfileResponse{}\n-\tmi := &file_daemon_proto_msgTypes[64]\n+\tmi := &file_daemon_proto_msgTypes[66]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4354,7 +4636,7 @@ func (x *GetActiveProfileResponse) String() string {\n func (*GetActiveProfileResponse) ProtoMessage() {}\n \n func (x *GetActiveProfileResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[64]\n+\tmi := &file_daemon_proto_msgTypes[66]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4367,7 +4649,7 @@ func (x *GetActiveProfileResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use GetActiveProfileResponse.ProtoReflect.Descriptor instead.\n func (*GetActiveProfileResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{64}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{66}\n }\n \n func (x *GetActiveProfileResponse) GetProfileName() string {\n@@ -4394,7 +4676,7 @@ type LogoutRequest struct {\n \n func (x *LogoutRequest) Reset() {\n \t*x = LogoutRequest{}\n-\tmi := &file_daemon_proto_msgTypes[65]\n+\tmi := &file_daemon_proto_msgTypes[67]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4406,7 +4688,7 @@ func (x *LogoutRequest) String() string {\n func (*LogoutRequest) ProtoMessage() {}\n \n func (x *LogoutRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[65]\n+\tmi := &file_daemon_proto_msgTypes[67]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4419,7 +4701,7 @@ func (x *LogoutRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use LogoutRequest.ProtoReflect.Descriptor instead.\n func (*LogoutRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{65}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{67}\n }\n \n func (x *LogoutRequest) GetProfileName() string {\n@@ -4444,7 +4726,7 @@ type LogoutResponse struct {\n \n func (x *LogoutResponse) Reset() {\n \t*x = LogoutResponse{}\n-\tmi := &file_daemon_proto_msgTypes[66]\n+\tmi := &file_daemon_proto_msgTypes[68]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4456,7 +4738,7 @@ func (x *LogoutResponse) String() string {\n func (*LogoutResponse) ProtoMessage() {}\n \n func (x *LogoutResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[66]\n+\tmi := &file_daemon_proto_msgTypes[68]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4469,7 +4751,7 @@ func (x *LogoutResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use LogoutResponse.ProtoReflect.Descriptor instead.\n func (*LogoutResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{66}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{68}\n }\n \n type GetFeaturesRequest struct {\n@@ -4480,7 +4762,7 @@ type GetFeaturesRequest struct {\n \n func (x *GetFeaturesRequest) Reset() {\n \t*x = GetFeaturesRequest{}\n-\tmi := &file_daemon_proto_msgTypes[67]\n+\tmi := &file_daemon_proto_msgTypes[69]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4492,7 +4774,7 @@ func (x *GetFeaturesRequest) String() string {\n func (*GetFeaturesRequest) ProtoMessage() {}\n \n func (x *GetFeaturesRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[67]\n+\tmi := &file_daemon_proto_msgTypes[69]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4505,7 +4787,7 @@ func (x *GetFeaturesRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use GetFeaturesRequest.ProtoReflect.Descriptor instead.\n func (*GetFeaturesRequest) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{67}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{69}\n }\n \n type GetFeaturesResponse struct {\n@@ -4518,7 +4800,7 @@ type GetFeaturesResponse struct {\n \n func (x *GetFeaturesResponse) Reset() {\n \t*x = GetFeaturesResponse{}\n-\tmi := &file_daemon_proto_msgTypes[68]\n+\tmi := &file_daemon_proto_msgTypes[70]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4530,7 +4812,7 @@ func (x *GetFeaturesResponse) String() string {\n func (*GetFeaturesResponse) ProtoMessage() {}\n \n func (x *GetFeaturesResponse) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[68]\n+\tmi := &file_daemon_proto_msgTypes[70]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4543,7 +4825,7 @@ func (x *GetFeaturesResponse) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use GetFeaturesResponse.ProtoReflect.Descriptor instead.\n func (*GetFeaturesResponse) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{68}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{70}\n }\n \n func (x *GetFeaturesResponse) GetDisableProfiles() bool {\n@@ -4560,6 +4842,390 @@ func (x *GetFeaturesResponse) GetDisableUpdateSettings() bool {\n \treturn false\n }\n \n+// GetPeerSSHHostKeyRequest for retrieving SSH host key for a specific peer\n+type GetPeerSSHHostKeyRequest struct {\n+\tstate protoimpl.MessageState `protogen:\"open.v1\"`\n+\t// peer IP address or FQDN to get SSH host key for\n+\tPeerAddress   string `protobuf:\"bytes,1,opt,name=peerAddress,proto3\" json:\"peerAddress,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *GetPeerSSHHostKeyRequest) Reset() {\n+\t*x = GetPeerSSHHostKeyRequest{}\n+\tmi := &file_daemon_proto_msgTypes[71]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *GetPeerSSHHostKeyRequest) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*GetPeerSSHHostKeyRequest) ProtoMessage() {}\n+\n+func (x *GetPeerSSHHostKeyRequest) ProtoReflect() protoreflect.Message {\n+\tmi := &file_daemon_proto_msgTypes[71]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use GetPeerSSHHostKeyRequest.ProtoReflect.Descriptor instead.\n+func (*GetPeerSSHHostKeyRequest) Descriptor() ([]byte, []int) {\n+\treturn file_daemon_proto_rawDescGZIP(), []int{71}\n+}\n+\n+func (x *GetPeerSSHHostKeyRequest) GetPeerAddress() string {\n+\tif x != nil {\n+\t\treturn x.PeerAddress\n+\t}\n+\treturn \"\"\n+}\n+\n+// GetPeerSSHHostKeyResponse contains the SSH host key for the requested peer\n+type GetPeerSSHHostKeyResponse struct {\n+\tstate protoimpl.MessageState `protogen:\"open.v1\"`\n+\t// SSH host key in SSH public key format (e.g., \"ssh-ed25519 AAAAC3... hostname\")\n+\tSshHostKey []byte `protobuf:\"bytes,1,opt,name=sshHostKey,proto3\" json:\"sshHostKey,omitempty\"`\n+\t// peer IP address\n+\tPeerIP string `protobuf:\"bytes,2,opt,name=peerIP,proto3\" json:\"peerIP,omitempty\"`\n+\t// peer FQDN\n+\tPeerFQDN string `protobuf:\"bytes,3,opt,name=peerFQDN,proto3\" json:\"peerFQDN,omitempty\"`\n+\t// indicates if the SSH host key was found\n+\tFound         bool `protobuf:\"varint,4,opt,name=found,proto3\" json:\"found,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *GetPeerSSHHostKeyResponse) Reset() {\n+\t*x = GetPeerSSHHostKeyResponse{}\n+\tmi := &file_daemon_proto_msgTypes[72]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *GetPeerSSHHostKeyResponse) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*GetPeerSSHHostKeyResponse) ProtoMessage() {}\n+\n+func (x *GetPeerSSHHostKeyResponse) ProtoReflect() protoreflect.Message {\n+\tmi := &file_daemon_proto_msgTypes[72]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use GetPeerSSHHostKeyResponse.ProtoReflect.Descriptor instead.\n+func (*GetPeerSSHHostKeyResponse) Descriptor() ([]byte, []int) {\n+\treturn file_daemon_proto_rawDescGZIP(), []int{72}\n+}\n+\n+func (x *GetPeerSSHHostKeyResponse) GetSshHostKey() []byte {\n+\tif x != nil {\n+\t\treturn x.SshHostKey\n+\t}\n+\treturn nil\n+}\n+\n+func (x *GetPeerSSHHostKeyResponse) GetPeerIP() string {\n+\tif x != nil {\n+\t\treturn x.PeerIP\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *GetPeerSSHHostKeyResponse) GetPeerFQDN() string {\n+\tif x != nil {\n+\t\treturn x.PeerFQDN\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *GetPeerSSHHostKeyResponse) GetFound() bool {\n+\tif x != nil {\n+\t\treturn x.Found\n+\t}\n+\treturn false\n+}\n+\n+// RequestJWTAuthRequest for initiating JWT authentication flow\n+type RequestJWTAuthRequest struct {\n+\tstate protoimpl.MessageState `protogen:\"open.v1\"`\n+\t// hint for OIDC login_hint parameter (typically email address)\n+\tHint          *string `protobuf:\"bytes,1,opt,name=hint,proto3,oneof\" json:\"hint,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *RequestJWTAuthRequest) Reset() {\n+\t*x = RequestJWTAuthRequest{}\n+\tmi := &file_daemon_proto_msgTypes[73]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *RequestJWTAuthRequest) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*RequestJWTAuthRequest) ProtoMessage() {}\n+\n+func (x *RequestJWTAuthRequest) ProtoReflect() protoreflect.Message {\n+\tmi := &file_daemon_proto_msgTypes[73]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use RequestJWTAuthRequest.ProtoReflect.Descriptor instead.\n+func (*RequestJWTAuthRequest) Descriptor() ([]byte, []int) {\n+\treturn file_daemon_proto_rawDescGZIP(), []int{73}\n+}\n+\n+func (x *RequestJWTAuthRequest) GetHint() string {\n+\tif x != nil && x.Hint != nil {\n+\t\treturn *x.Hint\n+\t}\n+\treturn \"\"\n+}\n+\n+// RequestJWTAuthResponse contains authentication flow information\n+type RequestJWTAuthResponse struct {\n+\tstate protoimpl.MessageState `protogen:\"open.v1\"`\n+\t// verification URI for user authentication\n+\tVerificationURI string `protobuf:\"bytes,1,opt,name=verificationURI,proto3\" json:\"verificationURI,omitempty\"`\n+\t// complete verification URI (with embedded user code)\n+\tVerificationURIComplete string `protobuf:\"bytes,2,opt,name=verificationURIComplete,proto3\" json:\"verificationURIComplete,omitempty\"`\n+\t// user code to enter on verification URI\n+\tUserCode string `protobuf:\"bytes,3,opt,name=userCode,proto3\" json:\"userCode,omitempty\"`\n+\t// device code for polling\n+\tDeviceCode string `protobuf:\"bytes,4,opt,name=deviceCode,proto3\" json:\"deviceCode,omitempty\"`\n+\t// expiration time in seconds\n+\tExpiresIn int64 `protobuf:\"varint,5,opt,name=expiresIn,proto3\" json:\"expiresIn,omitempty\"`\n+\t// if a cached token is available, it will be returned here\n+\tCachedToken string `protobuf:\"bytes,6,opt,name=cachedToken,proto3\" json:\"cachedToken,omitempty\"`\n+\t// maximum age of JWT tokens in seconds (from management server)\n+\tMaxTokenAge   int64 `protobuf:\"varint,7,opt,name=maxTokenAge,proto3\" json:\"maxTokenAge,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *RequestJWTAuthResponse) Reset() {\n+\t*x = RequestJWTAuthResponse{}\n+\tmi := &file_daemon_proto_msgTypes[74]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *RequestJWTAuthResponse) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*RequestJWTAuthResponse) ProtoMessage() {}\n+\n+func (x *RequestJWTAuthResponse) ProtoReflect() protoreflect.Message {\n+\tmi := &file_daemon_proto_msgTypes[74]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use RequestJWTAuthResponse.ProtoReflect.Descriptor instead.\n+func (*RequestJWTAuthResponse) Descriptor() ([]byte, []int) {\n+\treturn file_daemon_proto_rawDescGZIP(), []int{74}\n+}\n+\n+func (x *RequestJWTAuthResponse) GetVerificationURI() string {\n+\tif x != nil {\n+\t\treturn x.VerificationURI\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *RequestJWTAuthResponse) GetVerificationURIComplete() string {\n+\tif x != nil {\n+\t\treturn x.VerificationURIComplete\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *RequestJWTAuthResponse) GetUserCode() string {\n+\tif x != nil {\n+\t\treturn x.UserCode\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *RequestJWTAuthResponse) GetDeviceCode() string {\n+\tif x != nil {\n+\t\treturn x.DeviceCode\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *RequestJWTAuthResponse) GetExpiresIn() int64 {\n+\tif x != nil {\n+\t\treturn x.ExpiresIn\n+\t}\n+\treturn 0\n+}\n+\n+func (x *RequestJWTAuthResponse) GetCachedToken() string {\n+\tif x != nil {\n+\t\treturn x.CachedToken\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *RequestJWTAuthResponse) GetMaxTokenAge() int64 {\n+\tif x != nil {\n+\t\treturn x.MaxTokenAge\n+\t}\n+\treturn 0\n+}\n+\n+// WaitJWTTokenRequest for waiting for authentication completion\n+type WaitJWTTokenRequest struct {\n+\tstate protoimpl.MessageState `protogen:\"open.v1\"`\n+\t// device code from RequestJWTAuthResponse\n+\tDeviceCode string `protobuf:\"bytes,1,opt,name=deviceCode,proto3\" json:\"deviceCode,omitempty\"`\n+\t// user code for verification\n+\tUserCode      string `protobuf:\"bytes,2,opt,name=userCode,proto3\" json:\"userCode,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *WaitJWTTokenRequest) Reset() {\n+\t*x = WaitJWTTokenRequest{}\n+\tmi := &file_daemon_proto_msgTypes[75]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *WaitJWTTokenRequest) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*WaitJWTTokenRequest) ProtoMessage() {}\n+\n+func (x *WaitJWTTokenRequest) ProtoReflect() protoreflect.Message {\n+\tmi := &file_daemon_proto_msgTypes[75]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use WaitJWTTokenRequest.ProtoReflect.Descriptor instead.\n+func (*WaitJWTTokenRequest) Descriptor() ([]byte, []int) {\n+\treturn file_daemon_proto_rawDescGZIP(), []int{75}\n+}\n+\n+func (x *WaitJWTTokenRequest) GetDeviceCode() string {\n+\tif x != nil {\n+\t\treturn x.DeviceCode\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *WaitJWTTokenRequest) GetUserCode() string {\n+\tif x != nil {\n+\t\treturn x.UserCode\n+\t}\n+\treturn \"\"\n+}\n+\n+// WaitJWTTokenResponse contains the JWT token after authentication\n+type WaitJWTTokenResponse struct {\n+\tstate protoimpl.MessageState `protogen:\"open.v1\"`\n+\t// JWT token (access token or ID token)\n+\tToken string `protobuf:\"bytes,1,opt,name=token,proto3\" json:\"token,omitempty\"`\n+\t// token type (e.g., \"Bearer\")\n+\tTokenType string `protobuf:\"bytes,2,opt,name=tokenType,proto3\" json:\"tokenType,omitempty\"`\n+\t// expiration time in seconds\n+\tExpiresIn     int64 `protobuf:\"varint,3,opt,name=expiresIn,proto3\" json:\"expiresIn,omitempty\"`\n+\tunknownFields protoimpl.UnknownFields\n+\tsizeCache     protoimpl.SizeCache\n+}\n+\n+func (x *WaitJWTTokenResponse) Reset() {\n+\t*x = WaitJWTTokenResponse{}\n+\tmi := &file_daemon_proto_msgTypes[76]\n+\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\tms.StoreMessageInfo(mi)\n+}\n+\n+func (x *WaitJWTTokenResponse) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*WaitJWTTokenResponse) ProtoMessage() {}\n+\n+func (x *WaitJWTTokenResponse) ProtoReflect() protoreflect.Message {\n+\tmi := &file_daemon_proto_msgTypes[76]\n+\tif x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use WaitJWTTokenResponse.ProtoReflect.Descriptor instead.\n+func (*WaitJWTTokenResponse) Descriptor() ([]byte, []int) {\n+\treturn file_daemon_proto_rawDescGZIP(), []int{76}\n+}\n+\n+func (x *WaitJWTTokenResponse) GetToken() string {\n+\tif x != nil {\n+\t\treturn x.Token\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *WaitJWTTokenResponse) GetTokenType() string {\n+\tif x != nil {\n+\t\treturn x.TokenType\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *WaitJWTTokenResponse) GetExpiresIn() int64 {\n+\tif x != nil {\n+\t\treturn x.ExpiresIn\n+\t}\n+\treturn 0\n+}\n+\n type PortInfo_Range struct {\n \tstate         protoimpl.MessageState `protogen:\"open.v1\"`\n \tStart         uint32                 `protobuf:\"varint,1,opt,name=start,proto3\" json:\"start,omitempty\"`\n@@ -4570,7 +5236,7 @@ type PortInfo_Range struct {\n \n func (x *PortInfo_Range) Reset() {\n \t*x = PortInfo_Range{}\n-\tmi := &file_daemon_proto_msgTypes[70]\n+\tmi := &file_daemon_proto_msgTypes[78]\n \tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \tms.StoreMessageInfo(mi)\n }\n@@ -4582,7 +5248,7 @@ func (x *PortInfo_Range) String() string {\n func (*PortInfo_Range) ProtoMessage() {}\n \n func (x *PortInfo_Range) ProtoReflect() protoreflect.Message {\n-\tmi := &file_daemon_proto_msgTypes[70]\n+\tmi := &file_daemon_proto_msgTypes[78]\n \tif x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -4595,7 +5261,7 @@ func (x *PortInfo_Range) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use PortInfo_Range.ProtoReflect.Descriptor instead.\n func (*PortInfo_Range) Descriptor() ([]byte, []int) {\n-\treturn file_daemon_proto_rawDescGZIP(), []int{26, 0}\n+\treturn file_daemon_proto_rawDescGZIP(), []int{28, 0}\n }\n \n func (x *PortInfo_Range) GetStart() uint32 {\n@@ -4617,7 +5283,7 @@ var File_daemon_proto protoreflect.FileDescriptor\n const file_daemon_proto_rawDesc = \"\" +\n \t\"\\n\" +\n \t\"\\fdaemon.proto\\x12\\x06daemon\\x1a google/protobuf/descriptor.proto\\x1a\\x1fgoogle/protobuf/timestamp.proto\\x1a\\x1egoogle/protobuf/duration.proto\\\"\\x0e\\n\" +\n-\t\"\\fEmptyRequest\\\"\\xe5\\x0e\\n\" +\n+\t\"\\fEmptyRequest\\\"\\xb6\\x12\\n\" +\n \t\"\\fLoginRequest\\x12\\x1a\\n\" +\n \t\"\\bsetupKey\\x18\\x01 \\x01(\\tR\\bsetupKey\\x12&\\n\" +\n \t\"\\fpreSharedKey\\x18\\x02 \\x01(\\tB\\x02\\x18\\x01R\\fpreSharedKey\\x12$\\n\" +\n@@ -4655,7 +5321,13 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"\\vprofileName\\x18\\x1e \\x01(\\tH\\x11R\\vprofileName\\x88\\x01\\x01\\x12\\x1f\\n\" +\n \t\"\\busername\\x18\\x1f \\x01(\\tH\\x12R\\busername\\x88\\x01\\x01\\x12\\x15\\n\" +\n \t\"\\x03mtu\\x18  \\x01(\\x03H\\x13R\\x03mtu\\x88\\x01\\x01\\x12\\x17\\n\" +\n-\t\"\\x04hint\\x18! \\x01(\\tH\\x14R\\x04hint\\x88\\x01\\x01B\\x13\\n\" +\n+\t\"\\x04hint\\x18! \\x01(\\tH\\x14R\\x04hint\\x88\\x01\\x01\\x12)\\n\" +\n+\t\"\\renableSSHRoot\\x18\\\" \\x01(\\bH\\x15R\\renableSSHRoot\\x88\\x01\\x01\\x12)\\n\" +\n+\t\"\\renableSSHSFTP\\x18# \\x01(\\bH\\x16R\\renableSSHSFTP\\x88\\x01\\x01\\x12G\\n\" +\n+\t\"\\x1cenableSSHLocalPortForwarding\\x18$ \\x01(\\bH\\x17R\\x1cenableSSHLocalPortForwarding\\x88\\x01\\x01\\x12I\\n\" +\n+\t\"\\x1denableSSHRemotePortForwarding\\x18% \\x01(\\bH\\x18R\\x1denableSSHRemotePortForwarding\\x88\\x01\\x01\\x12+\\n\" +\n+\t\"\\x0edisableSSHAuth\\x18& \\x01(\\bH\\x19R\\x0edisableSSHAuth\\x88\\x01\\x01\\x12+\\n\" +\n+\t\"\\x0esshJWTCacheTTL\\x18' \\x01(\\x05H\\x1aR\\x0esshJWTCacheTTL\\x88\\x01\\x01B\\x13\\n\" +\n \t\"\\x11_rosenpassEnabledB\\x10\\n\" +\n \t\"\\x0e_interfaceNameB\\x10\\n\" +\n \t\"\\x0e_wireguardPortB\\x17\\n\" +\n@@ -4676,7 +5348,13 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"\\f_profileNameB\\v\\n\" +\n \t\"\\t_usernameB\\x06\\n\" +\n \t\"\\x04_mtuB\\a\\n\" +\n-\t\"\\x05_hint\\\"\\xb5\\x01\\n\" +\n+\t\"\\x05_hintB\\x10\\n\" +\n+\t\"\\x0e_enableSSHRootB\\x10\\n\" +\n+\t\"\\x0e_enableSSHSFTPB\\x1f\\n\" +\n+\t\"\\x1d_enableSSHLocalPortForwardingB \\n\" +\n+\t\"\\x1e_enableSSHRemotePortForwardingB\\x11\\n\" +\n+\t\"\\x0f_disableSSHAuthB\\x11\\n\" +\n+\t\"\\x0f_sshJWTCacheTTL\\\"\\xb5\\x01\\n\" +\n \t\"\\rLoginResponse\\x12$\\n\" +\n \t\"\\rneedsSSOLogin\\x18\\x01 \\x01(\\bR\\rneedsSSOLogin\\x12\\x1a\\n\" +\n \t\"\\buserCode\\x18\\x02 \\x01(\\tR\\buserCode\\x12(\\n\" +\n@@ -4709,7 +5387,7 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"\\fDownResponse\\\"P\\n\" +\n \t\"\\x10GetConfigRequest\\x12 \\n\" +\n \t\"\\vprofileName\\x18\\x01 \\x01(\\tR\\vprofileName\\x12\\x1a\\n\" +\n-\t\"\\busername\\x18\\x02 \\x01(\\tR\\busername\\\"\\xb5\\x06\\n\" +\n+\t\"\\busername\\x18\\x02 \\x01(\\tR\\busername\\\"\\xdb\\b\\n\" +\n \t\"\\x11GetConfigResponse\\x12$\\n\" +\n \t\"\\rmanagementUrl\\x18\\x01 \\x01(\\tR\\rmanagementUrl\\x12\\x1e\\n\" +\n \t\"\\n\" +\n@@ -4734,7 +5412,13 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"disableDns\\x122\\n\" +\n \t\"\\x15disable_client_routes\\x18\\x12 \\x01(\\bR\\x13disableClientRoutes\\x122\\n\" +\n \t\"\\x15disable_server_routes\\x18\\x13 \\x01(\\bR\\x13disableServerRoutes\\x12(\\n\" +\n-\t\"\\x10block_lan_access\\x18\\x14 \\x01(\\bR\\x0eblockLanAccess\\\"\\xde\\x05\\n\" +\n+\t\"\\x10block_lan_access\\x18\\x14 \\x01(\\bR\\x0eblockLanAccess\\x12$\\n\" +\n+\t\"\\renableSSHRoot\\x18\\x15 \\x01(\\bR\\renableSSHRoot\\x12$\\n\" +\n+\t\"\\renableSSHSFTP\\x18\\x18 \\x01(\\bR\\renableSSHSFTP\\x12B\\n\" +\n+\t\"\\x1cenableSSHLocalPortForwarding\\x18\\x16 \\x01(\\bR\\x1cenableSSHLocalPortForwarding\\x12D\\n\" +\n+\t\"\\x1denableSSHRemotePortForwarding\\x18\\x17 \\x01(\\bR\\x1denableSSHRemotePortForwarding\\x12&\\n\" +\n+\t\"\\x0edisableSSHAuth\\x18\\x19 \\x01(\\bR\\x0edisableSSHAuth\\x12&\\n\" +\n+\t\"\\x0esshJWTCacheTTL\\x18\\x1a \\x01(\\x05R\\x0esshJWTCacheTTL\\\"\\xfe\\x05\\n\" +\n \t\"\\tPeerState\\x12\\x0e\\n\" +\n \t\"\\x02IP\\x18\\x01 \\x01(\\tR\\x02IP\\x12\\x16\\n\" +\n \t\"\\x06pubKey\\x18\\x02 \\x01(\\tR\\x06pubKey\\x12\\x1e\\n\" +\n@@ -4755,7 +5439,10 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"\\x10rosenpassEnabled\\x18\\x0f \\x01(\\bR\\x10rosenpassEnabled\\x12\\x1a\\n\" +\n \t\"\\bnetworks\\x18\\x10 \\x03(\\tR\\bnetworks\\x123\\n\" +\n \t\"\\alatency\\x18\\x11 \\x01(\\v2\\x19.google.protobuf.DurationR\\alatency\\x12\\\"\\n\" +\n-\t\"\\frelayAddress\\x18\\x12 \\x01(\\tR\\frelayAddress\\\"\\xf0\\x01\\n\" +\n+\t\"\\frelayAddress\\x18\\x12 \\x01(\\tR\\frelayAddress\\x12\\x1e\\n\" +\n+\t\"\\n\" +\n+\t\"sshHostKey\\x18\\x13 \\x01(\\fR\\n\" +\n+\t\"sshHostKey\\\"\\xf0\\x01\\n\" +\n \t\"\\x0eLocalPeerState\\x12\\x0e\\n\" +\n \t\"\\x02IP\\x18\\x01 \\x01(\\tR\\x02IP\\x12\\x16\\n\" +\n \t\"\\x06pubKey\\x18\\x02 \\x01(\\tR\\x06pubKey\\x12(\\n\" +\n@@ -4781,7 +5468,15 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"\\aservers\\x18\\x01 \\x03(\\tR\\aservers\\x12\\x18\\n\" +\n \t\"\\adomains\\x18\\x02 \\x03(\\tR\\adomains\\x12\\x18\\n\" +\n \t\"\\aenabled\\x18\\x03 \\x01(\\bR\\aenabled\\x12\\x14\\n\" +\n-\t\"\\x05error\\x18\\x04 \\x01(\\tR\\x05error\\\"\\xef\\x03\\n\" +\n+\t\"\\x05error\\x18\\x04 \\x01(\\tR\\x05error\\\"\\x8e\\x01\\n\" +\n+\t\"\\x0eSSHSessionInfo\\x12\\x1a\\n\" +\n+\t\"\\busername\\x18\\x01 \\x01(\\tR\\busername\\x12$\\n\" +\n+\t\"\\rremoteAddress\\x18\\x02 \\x01(\\tR\\rremoteAddress\\x12\\x18\\n\" +\n+\t\"\\acommand\\x18\\x03 \\x01(\\tR\\acommand\\x12 \\n\" +\n+\t\"\\vjwtUsername\\x18\\x04 \\x01(\\tR\\vjwtUsername\\\"^\\n\" +\n+\t\"\\x0eSSHServerState\\x12\\x18\\n\" +\n+\t\"\\aenabled\\x18\\x01 \\x01(\\bR\\aenabled\\x122\\n\" +\n+\t\"\\bsessions\\x18\\x02 \\x03(\\v2\\x16.daemon.SSHSessionInfoR\\bsessions\\\"\\xaf\\x04\\n\" +\n \t\"\\n\" +\n \t\"FullStatus\\x12A\\n\" +\n \t\"\\x0fmanagementState\\x18\\x01 \\x01(\\v2\\x17.daemon.ManagementStateR\\x0fmanagementState\\x125\\n\" +\n@@ -4793,7 +5488,9 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"dnsServers\\x128\\n\" +\n \t\"\\x17NumberOfForwardingRules\\x18\\b \\x01(\\x05R\\x17NumberOfForwardingRules\\x12+\\n\" +\n \t\"\\x06events\\x18\\a \\x03(\\v2\\x13.daemon.SystemEventR\\x06events\\x124\\n\" +\n-\t\"\\x15lazyConnectionEnabled\\x18\\t \\x01(\\bR\\x15lazyConnectionEnabled\\\"\\x15\\n\" +\n+\t\"\\x15lazyConnectionEnabled\\x18\\t \\x01(\\bR\\x15lazyConnectionEnabled\\x12>\\n\" +\n+\t\"\\x0esshServerState\\x18\\n\" +\n+\t\" \\x01(\\v2\\x16.daemon.SSHServerStateR\\x0esshServerState\\\"\\x15\\n\" +\n \t\"\\x13ListNetworksRequest\\\"?\\n\" +\n \t\"\\x14ListNetworksResponse\\x12'\\n\" +\n \t\"\\x06routes\\x18\\x01 \\x03(\\v2\\x0f.daemon.NetworkR\\x06routes\\\"a\\n\" +\n@@ -4934,7 +5631,7 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"\\busername\\x18\\x02 \\x01(\\tH\\x01R\\busername\\x88\\x01\\x01B\\x0e\\n\" +\n \t\"\\f_profileNameB\\v\\n\" +\n \t\"\\t_username\\\"\\x17\\n\" +\n-\t\"\\x15SwitchProfileResponse\\\"\\x8e\\r\\n\" +\n+\t\"\\x15SwitchProfileResponse\\\"\\xdf\\x10\\n\" +\n \t\"\\x10SetConfigRequest\\x12\\x1a\\n\" +\n \t\"\\busername\\x18\\x01 \\x01(\\tR\\busername\\x12 \\n\" +\n \t\"\\vprofileName\\x18\\x02 \\x01(\\tR\\vprofileName\\x12$\\n\" +\n@@ -4967,7 +5664,13 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"dns_labels\\x18\\x19 \\x03(\\tR\\tdnsLabels\\x12&\\n\" +\n \t\"\\x0ecleanDNSLabels\\x18\\x1a \\x01(\\bR\\x0ecleanDNSLabels\\x12J\\n\" +\n \t\"\\x10dnsRouteInterval\\x18\\x1b \\x01(\\v2\\x19.google.protobuf.DurationH\\x10R\\x10dnsRouteInterval\\x88\\x01\\x01\\x12\\x15\\n\" +\n-\t\"\\x03mtu\\x18\\x1c \\x01(\\x03H\\x11R\\x03mtu\\x88\\x01\\x01B\\x13\\n\" +\n+\t\"\\x03mtu\\x18\\x1c \\x01(\\x03H\\x11R\\x03mtu\\x88\\x01\\x01\\x12)\\n\" +\n+\t\"\\renableSSHRoot\\x18\\x1d \\x01(\\bH\\x12R\\renableSSHRoot\\x88\\x01\\x01\\x12)\\n\" +\n+\t\"\\renableSSHSFTP\\x18\\x1e \\x01(\\bH\\x13R\\renableSSHSFTP\\x88\\x01\\x01\\x12G\\n\" +\n+\t\"\\x1cenableSSHLocalPortForwarding\\x18\\x1f \\x01(\\bH\\x14R\\x1cenableSSHLocalPortForwarding\\x88\\x01\\x01\\x12I\\n\" +\n+\t\"\\x1denableSSHRemotePortForwarding\\x18  \\x01(\\bH\\x15R\\x1denableSSHRemotePortForwarding\\x88\\x01\\x01\\x12+\\n\" +\n+\t\"\\x0edisableSSHAuth\\x18! \\x01(\\bH\\x16R\\x0edisableSSHAuth\\x88\\x01\\x01\\x12+\\n\" +\n+\t\"\\x0esshJWTCacheTTL\\x18\\\" \\x01(\\x05H\\x17R\\x0esshJWTCacheTTL\\x88\\x01\\x01B\\x13\\n\" +\n \t\"\\x11_rosenpassEnabledB\\x10\\n\" +\n \t\"\\x0e_interfaceNameB\\x10\\n\" +\n \t\"\\x0e_wireguardPortB\\x17\\n\" +\n@@ -4985,7 +5688,13 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"\\x16_lazyConnectionEnabledB\\x10\\n\" +\n \t\"\\x0e_block_inboundB\\x13\\n\" +\n \t\"\\x11_dnsRouteIntervalB\\x06\\n\" +\n-\t\"\\x04_mtu\\\"\\x13\\n\" +\n+\t\"\\x04_mtuB\\x10\\n\" +\n+\t\"\\x0e_enableSSHRootB\\x10\\n\" +\n+\t\"\\x0e_enableSSHSFTPB\\x1f\\n\" +\n+\t\"\\x1d_enableSSHLocalPortForwardingB \\n\" +\n+\t\"\\x1e_enableSSHRemotePortForwardingB\\x11\\n\" +\n+\t\"\\x0f_disableSSHAuthB\\x11\\n\" +\n+\t\"\\x0f_sshJWTCacheTTL\\\"\\x13\\n\" +\n \t\"\\x11SetConfigResponse\\\"Q\\n\" +\n \t\"\\x11AddProfileRequest\\x12\\x1a\\n\" +\n \t\"\\busername\\x18\\x01 \\x01(\\tR\\busername\\x12 \\n\" +\n@@ -5015,7 +5724,38 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"\\x12GetFeaturesRequest\\\"x\\n\" +\n \t\"\\x13GetFeaturesResponse\\x12)\\n\" +\n \t\"\\x10disable_profiles\\x18\\x01 \\x01(\\bR\\x0fdisableProfiles\\x126\\n\" +\n-\t\"\\x17disable_update_settings\\x18\\x02 \\x01(\\bR\\x15disableUpdateSettings*b\\n\" +\n+\t\"\\x17disable_update_settings\\x18\\x02 \\x01(\\bR\\x15disableUpdateSettings\\\"<\\n\" +\n+\t\"\\x18GetPeerSSHHostKeyRequest\\x12 \\n\" +\n+\t\"\\vpeerAddress\\x18\\x01 \\x01(\\tR\\vpeerAddress\\\"\\x85\\x01\\n\" +\n+\t\"\\x19GetPeerSSHHostKeyResponse\\x12\\x1e\\n\" +\n+\t\"\\n\" +\n+\t\"sshHostKey\\x18\\x01 \\x01(\\fR\\n\" +\n+\t\"sshHostKey\\x12\\x16\\n\" +\n+\t\"\\x06peerIP\\x18\\x02 \\x01(\\tR\\x06peerIP\\x12\\x1a\\n\" +\n+\t\"\\bpeerFQDN\\x18\\x03 \\x01(\\tR\\bpeerFQDN\\x12\\x14\\n\" +\n+\t\"\\x05found\\x18\\x04 \\x01(\\bR\\x05found\\\"9\\n\" +\n+\t\"\\x15RequestJWTAuthRequest\\x12\\x17\\n\" +\n+\t\"\\x04hint\\x18\\x01 \\x01(\\tH\\x00R\\x04hint\\x88\\x01\\x01B\\a\\n\" +\n+\t\"\\x05_hint\\\"\\x9a\\x02\\n\" +\n+\t\"\\x16RequestJWTAuthResponse\\x12(\\n\" +\n+\t\"\\x0fverificationURI\\x18\\x01 \\x01(\\tR\\x0fverificationURI\\x128\\n\" +\n+\t\"\\x17verificationURIComplete\\x18\\x02 \\x01(\\tR\\x17verificationURIComplete\\x12\\x1a\\n\" +\n+\t\"\\buserCode\\x18\\x03 \\x01(\\tR\\buserCode\\x12\\x1e\\n\" +\n+\t\"\\n\" +\n+\t\"deviceCode\\x18\\x04 \\x01(\\tR\\n\" +\n+\t\"deviceCode\\x12\\x1c\\n\" +\n+\t\"\\texpiresIn\\x18\\x05 \\x01(\\x03R\\texpiresIn\\x12 \\n\" +\n+\t\"\\vcachedToken\\x18\\x06 \\x01(\\tR\\vcachedToken\\x12 \\n\" +\n+\t\"\\vmaxTokenAge\\x18\\a \\x01(\\x03R\\vmaxTokenAge\\\"Q\\n\" +\n+\t\"\\x13WaitJWTTokenRequest\\x12\\x1e\\n\" +\n+\t\"\\n\" +\n+\t\"deviceCode\\x18\\x01 \\x01(\\tR\\n\" +\n+\t\"deviceCode\\x12\\x1a\\n\" +\n+\t\"\\buserCode\\x18\\x02 \\x01(\\tR\\buserCode\\\"h\\n\" +\n+\t\"\\x14WaitJWTTokenResponse\\x12\\x14\\n\" +\n+\t\"\\x05token\\x18\\x01 \\x01(\\tR\\x05token\\x12\\x1c\\n\" +\n+\t\"\\ttokenType\\x18\\x02 \\x01(\\tR\\ttokenType\\x12\\x1c\\n\" +\n+\t\"\\texpiresIn\\x18\\x03 \\x01(\\x03R\\texpiresIn*b\\n\" +\n \t\"\\bLogLevel\\x12\\v\\n\" +\n \t\"\\aUNKNOWN\\x10\\x00\\x12\\t\\n\" +\n \t\"\\x05PANIC\\x10\\x01\\x12\\t\\n\" +\n@@ -5024,7 +5764,7 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"\\x04WARN\\x10\\x04\\x12\\b\\n\" +\n \t\"\\x04INFO\\x10\\x05\\x12\\t\\n\" +\n \t\"\\x05DEBUG\\x10\\x06\\x12\\t\\n\" +\n-\t\"\\x05TRACE\\x10\\a2\\x8f\\x10\\n\" +\n+\t\"\\x05TRACE\\x10\\a2\\x8b\\x12\\n\" +\n \t\"\\rDaemonService\\x126\\n\" +\n \t\"\\x05Login\\x12\\x14.daemon.LoginRequest\\x1a\\x15.daemon.LoginResponse\\\"\\x00\\x12K\\n\" +\n \t\"\\fWaitSSOLogin\\x12\\x1b.daemon.WaitSSOLoginRequest\\x1a\\x1c.daemon.WaitSSOLoginResponse\\\"\\x00\\x12-\\n\" +\n@@ -5056,7 +5796,10 @@ const file_daemon_proto_rawDesc = \"\" +\n \t\"\\fListProfiles\\x12\\x1b.daemon.ListProfilesRequest\\x1a\\x1c.daemon.ListProfilesResponse\\\"\\x00\\x12W\\n\" +\n \t\"\\x10GetActiveProfile\\x12\\x1f.daemon.GetActiveProfileRequest\\x1a .daemon.GetActiveProfileResponse\\\"\\x00\\x129\\n\" +\n \t\"\\x06Logout\\x12\\x15.daemon.LogoutRequest\\x1a\\x16.daemon.LogoutResponse\\\"\\x00\\x12H\\n\" +\n-\t\"\\vGetFeatures\\x12\\x1a.daemon.GetFeaturesRequest\\x1a\\x1b.daemon.GetFeaturesResponse\\\"\\x00B\\bZ\\x06/protob\\x06proto3\"\n+\t\"\\vGetFeatures\\x12\\x1a.daemon.GetFeaturesRequest\\x1a\\x1b.daemon.GetFeaturesResponse\\\"\\x00\\x12Z\\n\" +\n+\t\"\\x11GetPeerSSHHostKey\\x12 .daemon.GetPeerSSHHostKeyRequest\\x1a!.daemon.GetPeerSSHHostKeyResponse\\\"\\x00\\x12Q\\n\" +\n+\t\"\\x0eRequestJWTAuth\\x12\\x1d.daemon.RequestJWTAuthRequest\\x1a\\x1e.daemon.RequestJWTAuthResponse\\\"\\x00\\x12K\\n\" +\n+\t\"\\fWaitJWTToken\\x12\\x1b.daemon.WaitJWTTokenRequest\\x1a\\x1c.daemon.WaitJWTTokenResponse\\\"\\x00B\\bZ\\x06/protob\\x06proto3\"\n \n var (\n \tfile_daemon_proto_rawDescOnce sync.Once\n@@ -5071,7 +5814,7 @@ func file_daemon_proto_rawDescGZIP() []byte {\n }\n \n var file_daemon_proto_enumTypes = make([]protoimpl.EnumInfo, 3)\n-var file_daemon_proto_msgTypes = make([]protoimpl.MessageInfo, 72)\n+var file_daemon_proto_msgTypes = make([]protoimpl.MessageInfo, 80)\n var file_daemon_proto_goTypes = []any{\n \t(LogLevel)(0),                              // 0: daemon.LogLevel\n \t(SystemEvent_Severity)(0),                  // 1: daemon.SystemEvent.Severity\n@@ -5095,155 +5838,171 @@ var file_daemon_proto_goTypes = []any{\n \t(*ManagementState)(nil),                    // 19: daemon.ManagementState\n \t(*RelayState)(nil),                         // 20: daemon.RelayState\n \t(*NSGroupState)(nil),                       // 21: daemon.NSGroupState\n-\t(*FullStatus)(nil),                         // 22: daemon.FullStatus\n-\t(*ListNetworksRequest)(nil),                // 23: daemon.ListNetworksRequest\n-\t(*ListNetworksResponse)(nil),               // 24: daemon.ListNetworksResponse\n-\t(*SelectNetworksRequest)(nil),              // 25: daemon.SelectNetworksRequest\n-\t(*SelectNetworksResponse)(nil),             // 26: daemon.SelectNetworksResponse\n-\t(*IPList)(nil),                             // 27: daemon.IPList\n-\t(*Network)(nil),                            // 28: daemon.Network\n-\t(*PortInfo)(nil),                           // 29: daemon.PortInfo\n-\t(*ForwardingRule)(nil),                     // 30: daemon.ForwardingRule\n-\t(*ForwardingRulesResponse)(nil),            // 31: daemon.ForwardingRulesResponse\n-\t(*DebugBundleRequest)(nil),                 // 32: daemon.DebugBundleRequest\n-\t(*DebugBundleResponse)(nil),                // 33: daemon.DebugBundleResponse\n-\t(*GetLogLevelRequest)(nil),                 // 34: daemon.GetLogLevelRequest\n-\t(*GetLogLevelResponse)(nil),                // 35: daemon.GetLogLevelResponse\n-\t(*SetLogLevelRequest)(nil),                 // 36: daemon.SetLogLevelRequest\n-\t(*SetLogLevelResponse)(nil),                // 37: daemon.SetLogLevelResponse\n-\t(*State)(nil),                              // 38: daemon.State\n-\t(*ListStatesRequest)(nil),                  // 39: daemon.ListStatesRequest\n-\t(*ListStatesResponse)(nil),                 // 40: daemon.ListStatesResponse\n-\t(*CleanStateRequest)(nil),                  // 41: daemon.CleanStateRequest\n-\t(*CleanStateResponse)(nil),                 // 42: daemon.CleanStateResponse\n-\t(*DeleteStateRequest)(nil),                 // 43: daemon.DeleteStateRequest\n-\t(*DeleteStateResponse)(nil),                // 44: daemon.DeleteStateResponse\n-\t(*SetSyncResponsePersistenceRequest)(nil),  // 45: daemon.SetSyncResponsePersistenceRequest\n-\t(*SetSyncResponsePersistenceResponse)(nil), // 46: daemon.SetSyncResponsePersistenceResponse\n-\t(*TCPFlags)(nil),                           // 47: daemon.TCPFlags\n-\t(*TracePacketRequest)(nil),                 // 48: daemon.TracePacketRequest\n-\t(*TraceStage)(nil),                         // 49: daemon.TraceStage\n-\t(*TracePacketResponse)(nil),                // 50: daemon.TracePacketResponse\n-\t(*SubscribeRequest)(nil),                   // 51: daemon.SubscribeRequest\n-\t(*SystemEvent)(nil),                        // 52: daemon.SystemEvent\n-\t(*GetEventsRequest)(nil),                   // 53: daemon.GetEventsRequest\n-\t(*GetEventsResponse)(nil),                  // 54: daemon.GetEventsResponse\n-\t(*SwitchProfileRequest)(nil),               // 55: daemon.SwitchProfileRequest\n-\t(*SwitchProfileResponse)(nil),              // 56: daemon.SwitchProfileResponse\n-\t(*SetConfigRequest)(nil),                   // 57: daemon.SetConfigRequest\n-\t(*SetConfigResponse)(nil),                  // 58: daemon.SetConfigResponse\n-\t(*AddProfileRequest)(nil),                  // 59: daemon.AddProfileRequest\n-\t(*AddProfileResponse)(nil),                 // 60: daemon.AddProfileResponse\n-\t(*RemoveProfileRequest)(nil),               // 61: daemon.RemoveProfileRequest\n-\t(*RemoveProfileResponse)(nil),              // 62: daemon.RemoveProfileResponse\n-\t(*ListProfilesRequest)(nil),                // 63: daemon.ListProfilesRequest\n-\t(*ListProfilesResponse)(nil),               // 64: daemon.ListProfilesResponse\n-\t(*Profile)(nil),                            // 65: daemon.Profile\n-\t(*GetActiveProfileRequest)(nil),            // 66: daemon.GetActiveProfileRequest\n-\t(*GetActiveProfileResponse)(nil),           // 67: daemon.GetActiveProfileResponse\n-\t(*LogoutRequest)(nil),                      // 68: daemon.LogoutRequest\n-\t(*LogoutResponse)(nil),                     // 69: daemon.LogoutResponse\n-\t(*GetFeaturesRequest)(nil),                 // 70: daemon.GetFeaturesRequest\n-\t(*GetFeaturesResponse)(nil),                // 71: daemon.GetFeaturesResponse\n-\tnil,                                        // 72: daemon.Network.ResolvedIPsEntry\n-\t(*PortInfo_Range)(nil),                     // 73: daemon.PortInfo.Range\n-\tnil,                                        // 74: daemon.SystemEvent.MetadataEntry\n-\t(*durationpb.Duration)(nil),                // 75: google.protobuf.Duration\n-\t(*timestamppb.Timestamp)(nil),              // 76: google.protobuf.Timestamp\n+\t(*SSHSessionInfo)(nil),                     // 22: daemon.SSHSessionInfo\n+\t(*SSHServerState)(nil),                     // 23: daemon.SSHServerState\n+\t(*FullStatus)(nil),                         // 24: daemon.FullStatus\n+\t(*ListNetworksRequest)(nil),                // 25: daemon.ListNetworksRequest\n+\t(*ListNetworksResponse)(nil),               // 26: daemon.ListNetworksResponse\n+\t(*SelectNetworksRequest)(nil),              // 27: daemon.SelectNetworksRequest\n+\t(*SelectNetworksResponse)(nil),             // 28: daemon.SelectNetworksResponse\n+\t(*IPList)(nil),                             // 29: daemon.IPList\n+\t(*Network)(nil),                            // 30: daemon.Network\n+\t(*PortInfo)(nil),                           // 31: daemon.PortInfo\n+\t(*ForwardingRule)(nil),                     // 32: daemon.ForwardingRule\n+\t(*ForwardingRulesResponse)(nil),            // 33: daemon.ForwardingRulesResponse\n+\t(*DebugBundleRequest)(nil),                 // 34: daemon.DebugBundleRequest\n+\t(*DebugBundleResponse)(nil),                // 35: daemon.DebugBundleResponse\n+\t(*GetLogLevelRequest)(nil),                 // 36: daemon.GetLogLevelRequest\n+\t(*GetLogLevelResponse)(nil),                // 37: daemon.GetLogLevelResponse\n+\t(*SetLogLevelRequest)(nil),                 // 38: daemon.SetLogLevelRequest\n+\t(*SetLogLevelResponse)(nil),                // 39: daemon.SetLogLevelResponse\n+\t(*State)(nil),                              // 40: daemon.State\n+\t(*ListStatesRequest)(nil),                  // 41: daemon.ListStatesRequest\n+\t(*ListStatesResponse)(nil),                 // 42: daemon.ListStatesResponse\n+\t(*CleanStateRequest)(nil),                  // 43: daemon.CleanStateRequest\n+\t(*CleanStateResponse)(nil),                 // 44: daemon.CleanStateResponse\n+\t(*DeleteStateRequest)(nil),                 // 45: daemon.DeleteStateRequest\n+\t(*DeleteStateResponse)(nil),                // 46: daemon.DeleteStateResponse\n+\t(*SetSyncResponsePersistenceRequest)(nil),  // 47: daemon.SetSyncResponsePersistenceRequest\n+\t(*SetSyncResponsePersistenceResponse)(nil), // 48: daemon.SetSyncResponsePersistenceResponse\n+\t(*TCPFlags)(nil),                           // 49: daemon.TCPFlags\n+\t(*TracePacketRequest)(nil),                 // 50: daemon.TracePacketRequest\n+\t(*TraceStage)(nil),                         // 51: daemon.TraceStage\n+\t(*TracePacketResponse)(nil),                // 52: daemon.TracePacketResponse\n+\t(*SubscribeRequest)(nil),                   // 53: daemon.SubscribeRequest\n+\t(*SystemEvent)(nil),                        // 54: daemon.SystemEvent\n+\t(*GetEventsRequest)(nil),                   // 55: daemon.GetEventsRequest\n+\t(*GetEventsResponse)(nil),                  // 56: daemon.GetEventsResponse\n+\t(*SwitchProfileRequest)(nil),               // 57: daemon.SwitchProfileRequest\n+\t(*SwitchProfileResponse)(nil),              // 58: daemon.SwitchProfileResponse\n+\t(*SetConfigRequest)(nil),                   // 59: daemon.SetConfigRequest\n+\t(*SetConfigResponse)(nil),                  // 60: daemon.SetConfigResponse\n+\t(*AddProfileRequest)(nil),                  // 61: daemon.AddProfileRequest\n+\t(*AddProfileResponse)(nil),                 // 62: daemon.AddProfileResponse\n+\t(*RemoveProfileRequest)(nil),               // 63: daemon.RemoveProfileRequest\n+\t(*RemoveProfileResponse)(nil),              // 64: daemon.RemoveProfileResponse\n+\t(*ListProfilesRequest)(nil),                // 65: daemon.ListProfilesRequest\n+\t(*ListProfilesResponse)(nil),               // 66: daemon.ListProfilesResponse\n+\t(*Profile)(nil),                            // 67: daemon.Profile\n+\t(*GetActiveProfileRequest)(nil),            // 68: daemon.GetActiveProfileRequest\n+\t(*GetActiveProfileResponse)(nil),           // 69: daemon.GetActiveProfileResponse\n+\t(*LogoutRequest)(nil),                      // 70: daemon.LogoutRequest\n+\t(*LogoutResponse)(nil),                     // 71: daemon.LogoutResponse\n+\t(*GetFeaturesRequest)(nil),                 // 72: daemon.GetFeaturesRequest\n+\t(*GetFeaturesResponse)(nil),                // 73: daemon.GetFeaturesResponse\n+\t(*GetPeerSSHHostKeyRequest)(nil),           // 74: daemon.GetPeerSSHHostKeyRequest\n+\t(*GetPeerSSHHostKeyResponse)(nil),          // 75: daemon.GetPeerSSHHostKeyResponse\n+\t(*RequestJWTAuthRequest)(nil),              // 76: daemon.RequestJWTAuthRequest\n+\t(*RequestJWTAuthResponse)(nil),             // 77: daemon.RequestJWTAuthResponse\n+\t(*WaitJWTTokenRequest)(nil),                // 78: daemon.WaitJWTTokenRequest\n+\t(*WaitJWTTokenResponse)(nil),               // 79: daemon.WaitJWTTokenResponse\n+\tnil,                                        // 80: daemon.Network.ResolvedIPsEntry\n+\t(*PortInfo_Range)(nil),                     // 81: daemon.PortInfo.Range\n+\tnil,                                        // 82: daemon.SystemEvent.MetadataEntry\n+\t(*durationpb.Duration)(nil),                // 83: google.protobuf.Duration\n+\t(*timestamppb.Timestamp)(nil),              // 84: google.protobuf.Timestamp\n }\n var file_daemon_proto_depIdxs = []int32{\n-\t75, // 0: daemon.LoginRequest.dnsRouteInterval:type_name -> google.protobuf.Duration\n-\t22, // 1: daemon.StatusResponse.fullStatus:type_name -> daemon.FullStatus\n-\t76, // 2: daemon.PeerState.connStatusUpdate:type_name -> google.protobuf.Timestamp\n-\t76, // 3: daemon.PeerState.lastWireguardHandshake:type_name -> google.protobuf.Timestamp\n-\t75, // 4: daemon.PeerState.latency:type_name -> google.protobuf.Duration\n-\t19, // 5: daemon.FullStatus.managementState:type_name -> daemon.ManagementState\n-\t18, // 6: daemon.FullStatus.signalState:type_name -> daemon.SignalState\n-\t17, // 7: daemon.FullStatus.localPeerState:type_name -> daemon.LocalPeerState\n-\t16, // 8: daemon.FullStatus.peers:type_name -> daemon.PeerState\n-\t20, // 9: daemon.FullStatus.relays:type_name -> daemon.RelayState\n-\t21, // 10: daemon.FullStatus.dns_servers:type_name -> daemon.NSGroupState\n-\t52, // 11: daemon.FullStatus.events:type_name -> daemon.SystemEvent\n-\t28, // 12: daemon.ListNetworksResponse.routes:type_name -> daemon.Network\n-\t72, // 13: daemon.Network.resolvedIPs:type_name -> daemon.Network.ResolvedIPsEntry\n-\t73, // 14: daemon.PortInfo.range:type_name -> daemon.PortInfo.Range\n-\t29, // 15: daemon.ForwardingRule.destinationPort:type_name -> daemon.PortInfo\n-\t29, // 16: daemon.ForwardingRule.translatedPort:type_name -> daemon.PortInfo\n-\t30, // 17: daemon.ForwardingRulesResponse.rules:type_name -> daemon.ForwardingRule\n-\t0,  // 18: daemon.GetLogLevelResponse.level:type_name -> daemon.LogLevel\n-\t0,  // 19: daemon.SetLogLevelRequest.level:type_name -> daemon.LogLevel\n-\t38, // 20: daemon.ListStatesResponse.states:type_name -> daemon.State\n-\t47, // 21: daemon.TracePacketRequest.tcp_flags:type_name -> daemon.TCPFlags\n-\t49, // 22: daemon.TracePacketResponse.stages:type_name -> daemon.TraceStage\n-\t1,  // 23: daemon.SystemEvent.severity:type_name -> daemon.SystemEvent.Severity\n-\t2,  // 24: daemon.SystemEvent.category:type_name -> daemon.SystemEvent.Category\n-\t76, // 25: daemon.SystemEvent.timestamp:type_name -> google.protobuf.Timestamp\n-\t74, // 26: daemon.SystemEvent.metadata:type_name -> daemon.SystemEvent.MetadataEntry\n-\t52, // 27: daemon.GetEventsResponse.events:type_name -> daemon.SystemEvent\n-\t75, // 28: daemon.SetConfigRequest.dnsRouteInterval:type_name -> google.protobuf.Duration\n-\t65, // 29: daemon.ListProfilesResponse.profiles:type_name -> daemon.Profile\n-\t27, // 30: daemon.Network.ResolvedIPsEntry.value:type_name -> daemon.IPList\n-\t4,  // 31: daemon.DaemonService.Login:input_type -> daemon.LoginRequest\n-\t6,  // 32: daemon.DaemonService.WaitSSOLogin:input_type -> daemon.WaitSSOLoginRequest\n-\t8,  // 33: daemon.DaemonService.Up:input_type -> daemon.UpRequest\n-\t10, // 34: daemon.DaemonService.Status:input_type -> daemon.StatusRequest\n-\t12, // 35: daemon.DaemonService.Down:input_type -> daemon.DownRequest\n-\t14, // 36: daemon.DaemonService.GetConfig:input_type -> daemon.GetConfigRequest\n-\t23, // 37: daemon.DaemonService.ListNetworks:input_type -> daemon.ListNetworksRequest\n-\t25, // 38: daemon.DaemonService.SelectNetworks:input_type -> daemon.SelectNetworksRequest\n-\t25, // 39: daemon.DaemonService.DeselectNetworks:input_type -> daemon.SelectNetworksRequest\n-\t3,  // 40: daemon.DaemonService.ForwardingRules:input_type -> daemon.EmptyRequest\n-\t32, // 41: daemon.DaemonService.DebugBundle:input_type -> daemon.DebugBundleRequest\n-\t34, // 42: daemon.DaemonService.GetLogLevel:input_type -> daemon.GetLogLevelRequest\n-\t36, // 43: daemon.DaemonService.SetLogLevel:input_type -> daemon.SetLogLevelRequest\n-\t39, // 44: daemon.DaemonService.ListStates:input_type -> daemon.ListStatesRequest\n-\t41, // 45: daemon.DaemonService.CleanState:input_type -> daemon.CleanStateRequest\n-\t43, // 46: daemon.DaemonService.DeleteState:input_type -> daemon.DeleteStateRequest\n-\t45, // 47: daemon.DaemonService.SetSyncResponsePersistence:input_type -> daemon.SetSyncResponsePersistenceRequest\n-\t48, // 48: daemon.DaemonService.TracePacket:input_type -> daemon.TracePacketRequest\n-\t51, // 49: daemon.DaemonService.SubscribeEvents:input_type -> daemon.SubscribeRequest\n-\t53, // 50: daemon.DaemonService.GetEvents:input_type -> daemon.GetEventsRequest\n-\t55, // 51: daemon.DaemonService.SwitchProfile:input_type -> daemon.SwitchProfileRequest\n-\t57, // 52: daemon.DaemonService.SetConfig:input_type -> daemon.SetConfigRequest\n-\t59, // 53: daemon.DaemonService.AddProfile:input_type -> daemon.AddProfileRequest\n-\t61, // 54: daemon.DaemonService.RemoveProfile:input_type -> daemon.RemoveProfileRequest\n-\t63, // 55: daemon.DaemonService.ListProfiles:input_type -> daemon.ListProfilesRequest\n-\t66, // 56: daemon.DaemonService.GetActiveProfile:input_type -> daemon.GetActiveProfileRequest\n-\t68, // 57: daemon.DaemonService.Logout:input_type -> daemon.LogoutRequest\n-\t70, // 58: daemon.DaemonService.GetFeatures:input_type -> daemon.GetFeaturesRequest\n-\t5,  // 59: daemon.DaemonService.Login:output_type -> daemon.LoginResponse\n-\t7,  // 60: daemon.DaemonService.WaitSSOLogin:output_type -> daemon.WaitSSOLoginResponse\n-\t9,  // 61: daemon.DaemonService.Up:output_type -> daemon.UpResponse\n-\t11, // 62: daemon.DaemonService.Status:output_type -> daemon.StatusResponse\n-\t13, // 63: daemon.DaemonService.Down:output_type -> daemon.DownResponse\n-\t15, // 64: daemon.DaemonService.GetConfig:output_type -> daemon.GetConfigResponse\n-\t24, // 65: daemon.DaemonService.ListNetworks:output_type -> daemon.ListNetworksResponse\n-\t26, // 66: daemon.DaemonService.SelectNetworks:output_type -> daemon.SelectNetworksResponse\n-\t26, // 67: daemon.DaemonService.DeselectNetworks:output_type -> daemon.SelectNetworksResponse\n-\t31, // 68: daemon.DaemonService.ForwardingRules:output_type -> daemon.ForwardingRulesResponse\n-\t33, // 69: daemon.DaemonService.DebugBundle:output_type -> daemon.DebugBundleResponse\n-\t35, // 70: daemon.DaemonService.GetLogLevel:output_type -> daemon.GetLogLevelResponse\n-\t37, // 71: daemon.DaemonService.SetLogLevel:output_type -> daemon.SetLogLevelResponse\n-\t40, // 72: daemon.DaemonService.ListStates:output_type -> daemon.ListStatesResponse\n-\t42, // 73: daemon.DaemonService.CleanState:output_type -> daemon.CleanStateResponse\n-\t44, // 74: daemon.DaemonService.DeleteState:output_type -> daemon.DeleteStateResponse\n-\t46, // 75: daemon.DaemonService.SetSyncResponsePersistence:output_type -> daemon.SetSyncResponsePersistenceResponse\n-\t50, // 76: daemon.DaemonService.TracePacket:output_type -> daemon.TracePacketResponse\n-\t52, // 77: daemon.DaemonService.SubscribeEvents:output_type -> daemon.SystemEvent\n-\t54, // 78: daemon.DaemonService.GetEvents:output_type -> daemon.GetEventsResponse\n-\t56, // 79: daemon.DaemonService.SwitchProfile:output_type -> daemon.SwitchProfileResponse\n-\t58, // 80: daemon.DaemonService.SetConfig:output_type -> daemon.SetConfigResponse\n-\t60, // 81: daemon.DaemonService.AddProfile:output_type -> daemon.AddProfileResponse\n-\t62, // 82: daemon.DaemonService.RemoveProfile:output_type -> daemon.RemoveProfileResponse\n-\t64, // 83: daemon.DaemonService.ListProfiles:output_type -> daemon.ListProfilesResponse\n-\t67, // 84: daemon.DaemonService.GetActiveProfile:output_type -> daemon.GetActiveProfileResponse\n-\t69, // 85: daemon.DaemonService.Logout:output_type -> daemon.LogoutResponse\n-\t71, // 86: daemon.DaemonService.GetFeatures:output_type -> daemon.GetFeaturesResponse\n-\t59, // [59:87] is the sub-list for method output_type\n-\t31, // [31:59] is the sub-list for method input_type\n-\t31, // [31:31] is the sub-list for extension type_name\n-\t31, // [31:31] is the sub-list for extension extendee\n-\t0,  // [0:31] is the sub-list for field type_name\n+\t83, // 0: daemon.LoginRequest.dnsRouteInterval:type_name -> google.protobuf.Duration\n+\t24, // 1: daemon.StatusResponse.fullStatus:type_name -> daemon.FullStatus\n+\t84, // 2: daemon.PeerState.connStatusUpdate:type_name -> google.protobuf.Timestamp\n+\t84, // 3: daemon.PeerState.lastWireguardHandshake:type_name -> google.protobuf.Timestamp\n+\t83, // 4: daemon.PeerState.latency:type_name -> google.protobuf.Duration\n+\t22, // 5: daemon.SSHServerState.sessions:type_name -> daemon.SSHSessionInfo\n+\t19, // 6: daemon.FullStatus.managementState:type_name -> daemon.ManagementState\n+\t18, // 7: daemon.FullStatus.signalState:type_name -> daemon.SignalState\n+\t17, // 8: daemon.FullStatus.localPeerState:type_name -> daemon.LocalPeerState\n+\t16, // 9: daemon.FullStatus.peers:type_name -> daemon.PeerState\n+\t20, // 10: daemon.FullStatus.relays:type_name -> daemon.RelayState\n+\t21, // 11: daemon.FullStatus.dns_servers:type_name -> daemon.NSGroupState\n+\t54, // 12: daemon.FullStatus.events:type_name -> daemon.SystemEvent\n+\t23, // 13: daemon.FullStatus.sshServerState:type_name -> daemon.SSHServerState\n+\t30, // 14: daemon.ListNetworksResponse.routes:type_name -> daemon.Network\n+\t80, // 15: daemon.Network.resolvedIPs:type_name -> daemon.Network.ResolvedIPsEntry\n+\t81, // 16: daemon.PortInfo.range:type_name -> daemon.PortInfo.Range\n+\t31, // 17: daemon.ForwardingRule.destinationPort:type_name -> daemon.PortInfo\n+\t31, // 18: daemon.ForwardingRule.translatedPort:type_name -> daemon.PortInfo\n+\t32, // 19: daemon.ForwardingRulesResponse.rules:type_name -> daemon.ForwardingRule\n+\t0,  // 20: daemon.GetLogLevelResponse.level:type_name -> daemon.LogLevel\n+\t0,  // 21: daemon.SetLogLevelRequest.level:type_name -> daemon.LogLevel\n+\t40, // 22: daemon.ListStatesResponse.states:type_name -> daemon.State\n+\t49, // 23: daemon.TracePacketRequest.tcp_flags:type_name -> daemon.TCPFlags\n+\t51, // 24: daemon.TracePacketResponse.stages:type_name -> daemon.TraceStage\n+\t1,  // 25: daemon.SystemEvent.severity:type_name -> daemon.SystemEvent.Severity\n+\t2,  // 26: daemon.SystemEvent.category:type_name -> daemon.SystemEvent.Category\n+\t84, // 27: daemon.SystemEvent.timestamp:type_name -> google.protobuf.Timestamp\n+\t82, // 28: daemon.SystemEvent.metadata:type_name -> daemon.SystemEvent.MetadataEntry\n+\t54, // 29: daemon.GetEventsResponse.events:type_name -> daemon.SystemEvent\n+\t83, // 30: daemon.SetConfigRequest.dnsRouteInterval:type_name -> google.protobuf.Duration\n+\t67, // 31: daemon.ListProfilesResponse.profiles:type_name -> daemon.Profile\n+\t29, // 32: daemon.Network.ResolvedIPsEntry.value:type_name -> daemon.IPList\n+\t4,  // 33: daemon.DaemonService.Login:input_type -> daemon.LoginRequest\n+\t6,  // 34: daemon.DaemonService.WaitSSOLogin:input_type -> daemon.WaitSSOLoginRequest\n+\t8,  // 35: daemon.DaemonService.Up:input_type -> daemon.UpRequest\n+\t10, // 36: daemon.DaemonService.Status:input_type -> daemon.StatusRequest\n+\t12, // 37: daemon.DaemonService.Down:input_type -> daemon.DownRequest\n+\t14, // 38: daemon.DaemonService.GetConfig:input_type -> daemon.GetConfigRequest\n+\t25, // 39: daemon.DaemonService.ListNetworks:input_type -> daemon.ListNetworksRequest\n+\t27, // 40: daemon.DaemonService.SelectNetworks:input_type -> daemon.SelectNetworksRequest\n+\t27, // 41: daemon.DaemonService.DeselectNetworks:input_type -> daemon.SelectNetworksRequest\n+\t3,  // 42: daemon.DaemonService.ForwardingRules:input_type -> daemon.EmptyRequest\n+\t34, // 43: daemon.DaemonService.DebugBundle:input_type -> daemon.DebugBundleRequest\n+\t36, // 44: daemon.DaemonService.GetLogLevel:input_type -> daemon.GetLogLevelRequest\n+\t38, // 45: daemon.DaemonService.SetLogLevel:input_type -> daemon.SetLogLevelRequest\n+\t41, // 46: daemon.DaemonService.ListStates:input_type -> daemon.ListStatesRequest\n+\t43, // 47: daemon.DaemonService.CleanState:input_type -> daemon.CleanStateRequest\n+\t45, // 48: daemon.DaemonService.DeleteState:input_type -> daemon.DeleteStateRequest\n+\t47, // 49: daemon.DaemonService.SetSyncResponsePersistence:input_type -> daemon.SetSyncResponsePersistenceRequest\n+\t50, // 50: daemon.DaemonService.TracePacket:input_type -> daemon.TracePacketRequest\n+\t53, // 51: daemon.DaemonService.SubscribeEvents:input_type -> daemon.SubscribeRequest\n+\t55, // 52: daemon.DaemonService.GetEvents:input_type -> daemon.GetEventsRequest\n+\t57, // 53: daemon.DaemonService.SwitchProfile:input_type -> daemon.SwitchProfileRequest\n+\t59, // 54: daemon.DaemonService.SetConfig:input_type -> daemon.SetConfigRequest\n+\t61, // 55: daemon.DaemonService.AddProfile:input_type -> daemon.AddProfileRequest\n+\t63, // 56: daemon.DaemonService.RemoveProfile:input_type -> daemon.RemoveProfileRequest\n+\t65, // 57: daemon.DaemonService.ListProfiles:input_type -> daemon.ListProfilesRequest\n+\t68, // 58: daemon.DaemonService.GetActiveProfile:input_type -> daemon.GetActiveProfileRequest\n+\t70, // 59: daemon.DaemonService.Logout:input_type -> daemon.LogoutRequest\n+\t72, // 60: daemon.DaemonService.GetFeatures:input_type -> daemon.GetFeaturesRequest\n+\t74, // 61: daemon.DaemonService.GetPeerSSHHostKey:input_type -> daemon.GetPeerSSHHostKeyRequest\n+\t76, // 62: daemon.DaemonService.RequestJWTAuth:input_type -> daemon.RequestJWTAuthRequest\n+\t78, // 63: daemon.DaemonService.WaitJWTToken:input_type -> daemon.WaitJWTTokenRequest\n+\t5,  // 64: daemon.DaemonService.Login:output_type -> daemon.LoginResponse\n+\t7,  // 65: daemon.DaemonService.WaitSSOLogin:output_type -> daemon.WaitSSOLoginResponse\n+\t9,  // 66: daemon.DaemonService.Up:output_type -> daemon.UpResponse\n+\t11, // 67: daemon.DaemonService.Status:output_type -> daemon.StatusResponse\n+\t13, // 68: daemon.DaemonService.Down:output_type -> daemon.DownResponse\n+\t15, // 69: daemon.DaemonService.GetConfig:output_type -> daemon.GetConfigResponse\n+\t26, // 70: daemon.DaemonService.ListNetworks:output_type -> daemon.ListNetworksResponse\n+\t28, // 71: daemon.DaemonService.SelectNetworks:output_type -> daemon.SelectNetworksResponse\n+\t28, // 72: daemon.DaemonService.DeselectNetworks:output_type -> daemon.SelectNetworksResponse\n+\t33, // 73: daemon.DaemonService.ForwardingRules:output_type -> daemon.ForwardingRulesResponse\n+\t35, // 74: daemon.DaemonService.DebugBundle:output_type -> daemon.DebugBundleResponse\n+\t37, // 75: daemon.DaemonService.GetLogLevel:output_type -> daemon.GetLogLevelResponse\n+\t39, // 76: daemon.DaemonService.SetLogLevel:output_type -> daemon.SetLogLevelResponse\n+\t42, // 77: daemon.DaemonService.ListStates:output_type -> daemon.ListStatesResponse\n+\t44, // 78: daemon.DaemonService.CleanState:output_type -> daemon.CleanStateResponse\n+\t46, // 79: daemon.DaemonService.DeleteState:output_type -> daemon.DeleteStateResponse\n+\t48, // 80: daemon.DaemonService.SetSyncResponsePersistence:output_type -> daemon.SetSyncResponsePersistenceResponse\n+\t52, // 81: daemon.DaemonService.TracePacket:output_type -> daemon.TracePacketResponse\n+\t54, // 82: daemon.DaemonService.SubscribeEvents:output_type -> daemon.SystemEvent\n+\t56, // 83: daemon.DaemonService.GetEvents:output_type -> daemon.GetEventsResponse\n+\t58, // 84: daemon.DaemonService.SwitchProfile:output_type -> daemon.SwitchProfileResponse\n+\t60, // 85: daemon.DaemonService.SetConfig:output_type -> daemon.SetConfigResponse\n+\t62, // 86: daemon.DaemonService.AddProfile:output_type -> daemon.AddProfileResponse\n+\t64, // 87: daemon.DaemonService.RemoveProfile:output_type -> daemon.RemoveProfileResponse\n+\t66, // 88: daemon.DaemonService.ListProfiles:output_type -> daemon.ListProfilesResponse\n+\t69, // 89: daemon.DaemonService.GetActiveProfile:output_type -> daemon.GetActiveProfileResponse\n+\t71, // 90: daemon.DaemonService.Logout:output_type -> daemon.LogoutResponse\n+\t73, // 91: daemon.DaemonService.GetFeatures:output_type -> daemon.GetFeaturesResponse\n+\t75, // 92: daemon.DaemonService.GetPeerSSHHostKey:output_type -> daemon.GetPeerSSHHostKeyResponse\n+\t77, // 93: daemon.DaemonService.RequestJWTAuth:output_type -> daemon.RequestJWTAuthResponse\n+\t79, // 94: daemon.DaemonService.WaitJWTToken:output_type -> daemon.WaitJWTTokenResponse\n+\t64, // [64:95] is the sub-list for method output_type\n+\t33, // [33:64] is the sub-list for method input_type\n+\t33, // [33:33] is the sub-list for extension type_name\n+\t33, // [33:33] is the sub-list for extension extendee\n+\t0,  // [0:33] is the sub-list for field type_name\n }\n \n func init() { file_daemon_proto_init() }\n@@ -5254,22 +6013,23 @@ func file_daemon_proto_init() {\n \tfile_daemon_proto_msgTypes[1].OneofWrappers = []any{}\n \tfile_daemon_proto_msgTypes[5].OneofWrappers = []any{}\n \tfile_daemon_proto_msgTypes[7].OneofWrappers = []any{}\n-\tfile_daemon_proto_msgTypes[26].OneofWrappers = []any{\n+\tfile_daemon_proto_msgTypes[28].OneofWrappers = []any{\n \t\t(*PortInfo_Port)(nil),\n \t\t(*PortInfo_Range_)(nil),\n \t}\n-\tfile_daemon_proto_msgTypes[45].OneofWrappers = []any{}\n-\tfile_daemon_proto_msgTypes[46].OneofWrappers = []any{}\n-\tfile_daemon_proto_msgTypes[52].OneofWrappers = []any{}\n+\tfile_daemon_proto_msgTypes[47].OneofWrappers = []any{}\n+\tfile_daemon_proto_msgTypes[48].OneofWrappers = []any{}\n \tfile_daemon_proto_msgTypes[54].OneofWrappers = []any{}\n-\tfile_daemon_proto_msgTypes[65].OneofWrappers = []any{}\n+\tfile_daemon_proto_msgTypes[56].OneofWrappers = []any{}\n+\tfile_daemon_proto_msgTypes[67].OneofWrappers = []any{}\n+\tfile_daemon_proto_msgTypes[73].OneofWrappers = []any{}\n \ttype x struct{}\n \tout := protoimpl.TypeBuilder{\n \t\tFile: protoimpl.DescBuilder{\n \t\t\tGoPackagePath: reflect.TypeOf(x{}).PkgPath(),\n \t\t\tRawDescriptor: unsafe.Slice(unsafe.StringData(file_daemon_proto_rawDesc), len(file_daemon_proto_rawDesc)),\n \t\t\tNumEnums:      3,\n-\t\t\tNumMessages:   72,\n+\t\t\tNumMessages:   80,\n \t\t\tNumExtensions: 0,\n \t\t\tNumServices:   1,\n \t\t},\ndiff --git a/client/proto/daemon.proto b/client/proto/daemon.proto\nindex 8d10800515b..bf85537067b 100644\n--- a/client/proto/daemon.proto\n+++ b/client/proto/daemon.proto\n@@ -84,6 +84,15 @@ service DaemonService {\n   rpc Logout(LogoutRequest) returns (LogoutResponse) {}\n \n   rpc GetFeatures(GetFeaturesRequest) returns (GetFeaturesResponse) {}\n+\n+  // GetPeerSSHHostKey retrieves SSH host key for a specific peer\n+  rpc GetPeerSSHHostKey(GetPeerSSHHostKeyRequest) returns (GetPeerSSHHostKeyResponse) {}\n+\n+  // RequestJWTAuth initiates JWT authentication flow for SSH\n+  rpc RequestJWTAuth(RequestJWTAuthRequest) returns (RequestJWTAuthResponse) {}\n+\n+  // WaitJWTToken waits for JWT authentication completion\n+  rpc WaitJWTToken(WaitJWTTokenRequest) returns (WaitJWTTokenResponse) {}\n }\n \n \n@@ -161,6 +170,13 @@ message LoginRequest {\n \n   // hint is used to pre-fill the email/username field during SSO authentication\n   optional string hint = 33;\n+\n+  optional bool enableSSHRoot = 34;\n+  optional bool enableSSHSFTP = 35;\n+  optional bool enableSSHLocalPortForwarding = 36;\n+  optional bool enableSSHRemotePortForwarding = 37;\n+  optional bool disableSSHAuth = 38;\n+  optional int32 sshJWTCacheTTL = 39;\n }\n \n message LoginResponse {\n@@ -188,9 +204,9 @@ message UpResponse {}\n \n message StatusRequest{\n   bool getFullPeerStatus = 1;\n-  bool shouldRunProbes   = 2;\n+  bool shouldRunProbes = 2;\n   // the UI do not using this yet, but CLIs could use it to wait until the status is ready\n-  optional bool waitForReady     = 3;\n+  optional bool waitForReady = 3;\n }\n \n message StatusResponse{\n@@ -255,6 +271,18 @@ message GetConfigResponse {\n   bool disable_server_routes = 19;\n \n   bool block_lan_access = 20;\n+\n+  bool enableSSHRoot = 21;\n+\n+  bool enableSSHSFTP = 24;\n+\n+  bool enableSSHLocalPortForwarding = 22;\n+\n+  bool enableSSHRemotePortForwarding = 23;\n+\n+  bool disableSSHAuth = 25;\n+\n+  int32 sshJWTCacheTTL = 26;\n }\n \n // PeerState contains the latest state of a peer\n@@ -276,6 +304,7 @@ message PeerState {\n   repeated string networks = 16;\n   google.protobuf.Duration latency = 17;\n   string relayAddress = 18;\n+  bytes sshHostKey = 19;\n }\n \n // LocalPeerState contains the latest state of the local peer\n@@ -317,6 +346,20 @@ message NSGroupState {\n   string error = 4;\n }\n \n+// SSHSessionInfo contains information about an active SSH session\n+message SSHSessionInfo {\n+  string username = 1;\n+  string remoteAddress = 2;\n+  string command = 3;\n+  string jwtUsername = 4;\n+}\n+\n+// SSHServerState contains the latest state of the SSH server\n+message SSHServerState {\n+  bool enabled = 1;\n+  repeated SSHSessionInfo sessions = 2;\n+}\n+\n // FullStatus contains the full state held by the Status instance\n message FullStatus {\n   ManagementState managementState = 1;\n@@ -330,6 +373,7 @@ message FullStatus {\n   repeated SystemEvent events = 7;\n \n   bool lazyConnectionEnabled = 9;\n+  SSHServerState sshServerState = 10;\n }\n \n // Networks\n@@ -543,56 +587,63 @@ message SwitchProfileRequest {\n message SwitchProfileResponse {}\n \n message SetConfigRequest {\n-    string username = 1;\n-    string profileName = 2;\n-    // managementUrl to authenticate.\n-    string managementUrl = 3;\n+  string username = 1;\n+  string profileName = 2;\n+  // managementUrl to authenticate.\n+  string managementUrl = 3;\n+\n+  // adminUrl to manage keys.\n+  string adminURL = 4;\n \n-    // adminUrl to manage keys.\n-    string adminURL = 4;\n+  optional bool rosenpassEnabled = 5;\n \n-    optional bool rosenpassEnabled = 5;\n+  optional string interfaceName = 6;\n \n-    optional string interfaceName = 6;\n+  optional int64 wireguardPort = 7;\n \n-    optional int64 wireguardPort = 7;\n+  optional string optionalPreSharedKey = 8;\n \n-    optional string optionalPreSharedKey = 8;\n+  optional bool disableAutoConnect = 9;\n \n-    optional bool disableAutoConnect = 9;\n+  optional bool serverSSHAllowed = 10;\n \n-    optional bool serverSSHAllowed = 10;\n+  optional bool rosenpassPermissive = 11;\n \n-    optional bool rosenpassPermissive = 11;\n+  optional bool networkMonitor = 12;\n \n-    optional bool networkMonitor = 12;\n+  optional bool disable_client_routes = 13;\n+  optional bool disable_server_routes = 14;\n+  optional bool disable_dns = 15;\n+  optional bool disable_firewall = 16;\n+  optional bool block_lan_access = 17;\n \n-    optional bool disable_client_routes = 13;\n-    optional bool disable_server_routes = 14;\n-    optional bool disable_dns = 15;\n-    optional bool disable_firewall = 16;\n-    optional bool block_lan_access = 17;\n+  optional bool disable_notifications = 18;\n \n-    optional bool disable_notifications = 18;\n+  optional bool lazyConnectionEnabled = 19;\n \n-    optional bool lazyConnectionEnabled = 19;\n+  optional bool block_inbound = 20;\n \n-    optional bool block_inbound = 20;\n+  repeated string natExternalIPs = 21;\n+  bool cleanNATExternalIPs = 22;\n \n-    repeated string natExternalIPs = 21;\n-    bool cleanNATExternalIPs = 22;\n+  bytes customDNSAddress = 23;\n \n-    bytes customDNSAddress = 23;\n+  repeated string extraIFaceBlacklist = 24;\n \n-    repeated string extraIFaceBlacklist = 24;\n+  repeated string dns_labels = 25;\n+  // cleanDNSLabels clean map list of DNS labels.\n+  bool cleanDNSLabels = 26;\n \n-    repeated string dns_labels = 25;\n-    // cleanDNSLabels clean map list of DNS labels.\n-    bool cleanDNSLabels = 26;\n+  optional google.protobuf.Duration dnsRouteInterval = 27;\n \n-    optional google.protobuf.Duration dnsRouteInterval = 27;\n+  optional int64 mtu = 28;\n \n-    optional int64 mtu = 28;\n+  optional bool enableSSHRoot = 29;\n+  optional bool enableSSHSFTP = 30;\n+  optional bool enableSSHLocalPortForwarding = 31;\n+  optional bool enableSSHRemotePortForwarding = 32;\n+  optional bool disableSSHAuth = 33;\n+  optional int32 sshJWTCacheTTL = 34;\n }\n \n message SetConfigResponse{}\n@@ -644,3 +695,63 @@ message GetFeaturesResponse{\n   bool disable_profiles = 1;\n   bool disable_update_settings = 2;\n }\n+\n+// GetPeerSSHHostKeyRequest for retrieving SSH host key for a specific peer\n+message GetPeerSSHHostKeyRequest {\n+  // peer IP address or FQDN to get SSH host key for\n+  string peerAddress = 1;\n+}\n+\n+// GetPeerSSHHostKeyResponse contains the SSH host key for the requested peer\n+message GetPeerSSHHostKeyResponse {\n+  // SSH host key in SSH public key format (e.g., \"ssh-ed25519 AAAAC3... hostname\")\n+  bytes sshHostKey = 1;\n+  // peer IP address\n+  string peerIP = 2;\n+  // peer FQDN\n+  string peerFQDN = 3;\n+  // indicates if the SSH host key was found\n+  bool found = 4;\n+}\n+\n+// RequestJWTAuthRequest for initiating JWT authentication flow\n+message RequestJWTAuthRequest {\n+  // hint for OIDC login_hint parameter (typically email address)\n+  optional string hint = 1;\n+}\n+\n+// RequestJWTAuthResponse contains authentication flow information\n+message RequestJWTAuthResponse {\n+  // verification URI for user authentication\n+  string verificationURI = 1;\n+  // complete verification URI (with embedded user code)\n+  string verificationURIComplete = 2;\n+  // user code to enter on verification URI\n+  string userCode = 3;\n+  // device code for polling\n+  string deviceCode = 4;\n+  // expiration time in seconds\n+  int64 expiresIn = 5;\n+  // if a cached token is available, it will be returned here\n+  string cachedToken = 6;\n+  // maximum age of JWT tokens in seconds (from management server)\n+  int64 maxTokenAge = 7;\n+}\n+\n+// WaitJWTTokenRequest for waiting for authentication completion\n+message WaitJWTTokenRequest {\n+  // device code from RequestJWTAuthResponse\n+  string deviceCode = 1;\n+  // user code for verification\n+  string userCode = 2;\n+}\n+\n+// WaitJWTTokenResponse contains the JWT token after authentication\n+message WaitJWTTokenResponse {\n+  // JWT token (access token or ID token)\n+  string token = 1;\n+  // token type (e.g., \"Bearer\")\n+  string tokenType = 2;\n+  // expiration time in seconds\n+  int64 expiresIn = 3;\n+}\ndiff --git a/client/proto/daemon_grpc.pb.go b/client/proto/daemon_grpc.pb.go\nindex bf7c9c7b37b..b2bf716b26d 100644\n--- a/client/proto/daemon_grpc.pb.go\n+++ b/client/proto/daemon_grpc.pb.go\n@@ -64,6 +64,12 @@ type DaemonServiceClient interface {\n \t// Logout disconnects from the network and deletes the peer from the management server\n \tLogout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error)\n \tGetFeatures(ctx context.Context, in *GetFeaturesRequest, opts ...grpc.CallOption) (*GetFeaturesResponse, error)\n+\t// GetPeerSSHHostKey retrieves SSH host key for a specific peer\n+\tGetPeerSSHHostKey(ctx context.Context, in *GetPeerSSHHostKeyRequest, opts ...grpc.CallOption) (*GetPeerSSHHostKeyResponse, error)\n+\t// RequestJWTAuth initiates JWT authentication flow for SSH\n+\tRequestJWTAuth(ctx context.Context, in *RequestJWTAuthRequest, opts ...grpc.CallOption) (*RequestJWTAuthResponse, error)\n+\t// WaitJWTToken waits for JWT authentication completion\n+\tWaitJWTToken(ctx context.Context, in *WaitJWTTokenRequest, opts ...grpc.CallOption) (*WaitJWTTokenResponse, error)\n }\n \n type daemonServiceClient struct {\n@@ -349,6 +355,33 @@ func (c *daemonServiceClient) GetFeatures(ctx context.Context, in *GetFeaturesRe\n \treturn out, nil\n }\n \n+func (c *daemonServiceClient) GetPeerSSHHostKey(ctx context.Context, in *GetPeerSSHHostKeyRequest, opts ...grpc.CallOption) (*GetPeerSSHHostKeyResponse, error) {\n+\tout := new(GetPeerSSHHostKeyResponse)\n+\terr := c.cc.Invoke(ctx, \"/daemon.DaemonService/GetPeerSSHHostKey\", in, out, opts...)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn out, nil\n+}\n+\n+func (c *daemonServiceClient) RequestJWTAuth(ctx context.Context, in *RequestJWTAuthRequest, opts ...grpc.CallOption) (*RequestJWTAuthResponse, error) {\n+\tout := new(RequestJWTAuthResponse)\n+\terr := c.cc.Invoke(ctx, \"/daemon.DaemonService/RequestJWTAuth\", in, out, opts...)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn out, nil\n+}\n+\n+func (c *daemonServiceClient) WaitJWTToken(ctx context.Context, in *WaitJWTTokenRequest, opts ...grpc.CallOption) (*WaitJWTTokenResponse, error) {\n+\tout := new(WaitJWTTokenResponse)\n+\terr := c.cc.Invoke(ctx, \"/daemon.DaemonService/WaitJWTToken\", in, out, opts...)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn out, nil\n+}\n+\n // DaemonServiceServer is the server API for DaemonService service.\n // All implementations must embed UnimplementedDaemonServiceServer\n // for forward compatibility\n@@ -399,6 +432,12 @@ type DaemonServiceServer interface {\n \t// Logout disconnects from the network and deletes the peer from the management server\n \tLogout(context.Context, *LogoutRequest) (*LogoutResponse, error)\n \tGetFeatures(context.Context, *GetFeaturesRequest) (*GetFeaturesResponse, error)\n+\t// GetPeerSSHHostKey retrieves SSH host key for a specific peer\n+\tGetPeerSSHHostKey(context.Context, *GetPeerSSHHostKeyRequest) (*GetPeerSSHHostKeyResponse, error)\n+\t// RequestJWTAuth initiates JWT authentication flow for SSH\n+\tRequestJWTAuth(context.Context, *RequestJWTAuthRequest) (*RequestJWTAuthResponse, error)\n+\t// WaitJWTToken waits for JWT authentication completion\n+\tWaitJWTToken(context.Context, *WaitJWTTokenRequest) (*WaitJWTTokenResponse, error)\n \tmustEmbedUnimplementedDaemonServiceServer()\n }\n \n@@ -490,6 +529,15 @@ func (UnimplementedDaemonServiceServer) Logout(context.Context, *LogoutRequest)\n func (UnimplementedDaemonServiceServer) GetFeatures(context.Context, *GetFeaturesRequest) (*GetFeaturesResponse, error) {\n \treturn nil, status.Errorf(codes.Unimplemented, \"method GetFeatures not implemented\")\n }\n+func (UnimplementedDaemonServiceServer) GetPeerSSHHostKey(context.Context, *GetPeerSSHHostKeyRequest) (*GetPeerSSHHostKeyResponse, error) {\n+\treturn nil, status.Errorf(codes.Unimplemented, \"method GetPeerSSHHostKey not implemented\")\n+}\n+func (UnimplementedDaemonServiceServer) RequestJWTAuth(context.Context, *RequestJWTAuthRequest) (*RequestJWTAuthResponse, error) {\n+\treturn nil, status.Errorf(codes.Unimplemented, \"method RequestJWTAuth not implemented\")\n+}\n+func (UnimplementedDaemonServiceServer) WaitJWTToken(context.Context, *WaitJWTTokenRequest) (*WaitJWTTokenResponse, error) {\n+\treturn nil, status.Errorf(codes.Unimplemented, \"method WaitJWTToken not implemented\")\n+}\n func (UnimplementedDaemonServiceServer) mustEmbedUnimplementedDaemonServiceServer() {}\n \n // UnsafeDaemonServiceServer may be embedded to opt out of forward compatibility for this service.\n@@ -1010,6 +1058,60 @@ func _DaemonService_GetFeatures_Handler(srv interface{}, ctx context.Context, de\n \treturn interceptor(ctx, in, info, handler)\n }\n \n+func _DaemonService_GetPeerSSHHostKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n+\tin := new(GetPeerSSHHostKeyRequest)\n+\tif err := dec(in); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif interceptor == nil {\n+\t\treturn srv.(DaemonServiceServer).GetPeerSSHHostKey(ctx, in)\n+\t}\n+\tinfo := &grpc.UnaryServerInfo{\n+\t\tServer:     srv,\n+\t\tFullMethod: \"/daemon.DaemonService/GetPeerSSHHostKey\",\n+\t}\n+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n+\t\treturn srv.(DaemonServiceServer).GetPeerSSHHostKey(ctx, req.(*GetPeerSSHHostKeyRequest))\n+\t}\n+\treturn interceptor(ctx, in, info, handler)\n+}\n+\n+func _DaemonService_RequestJWTAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n+\tin := new(RequestJWTAuthRequest)\n+\tif err := dec(in); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif interceptor == nil {\n+\t\treturn srv.(DaemonServiceServer).RequestJWTAuth(ctx, in)\n+\t}\n+\tinfo := &grpc.UnaryServerInfo{\n+\t\tServer:     srv,\n+\t\tFullMethod: \"/daemon.DaemonService/RequestJWTAuth\",\n+\t}\n+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n+\t\treturn srv.(DaemonServiceServer).RequestJWTAuth(ctx, req.(*RequestJWTAuthRequest))\n+\t}\n+\treturn interceptor(ctx, in, info, handler)\n+}\n+\n+func _DaemonService_WaitJWTToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n+\tin := new(WaitJWTTokenRequest)\n+\tif err := dec(in); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif interceptor == nil {\n+\t\treturn srv.(DaemonServiceServer).WaitJWTToken(ctx, in)\n+\t}\n+\tinfo := &grpc.UnaryServerInfo{\n+\t\tServer:     srv,\n+\t\tFullMethod: \"/daemon.DaemonService/WaitJWTToken\",\n+\t}\n+\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n+\t\treturn srv.(DaemonServiceServer).WaitJWTToken(ctx, req.(*WaitJWTTokenRequest))\n+\t}\n+\treturn interceptor(ctx, in, info, handler)\n+}\n+\n // DaemonService_ServiceDesc is the grpc.ServiceDesc for DaemonService service.\n // It's only intended for direct use with grpc.RegisterService,\n // and not to be introspected or modified (even as a copy)\n@@ -1125,6 +1227,18 @@ var DaemonService_ServiceDesc = grpc.ServiceDesc{\n \t\t\tMethodName: \"GetFeatures\",\n \t\t\tHandler:    _DaemonService_GetFeatures_Handler,\n \t\t},\n+\t\t{\n+\t\t\tMethodName: \"GetPeerSSHHostKey\",\n+\t\t\tHandler:    _DaemonService_GetPeerSSHHostKey_Handler,\n+\t\t},\n+\t\t{\n+\t\t\tMethodName: \"RequestJWTAuth\",\n+\t\t\tHandler:    _DaemonService_RequestJWTAuth_Handler,\n+\t\t},\n+\t\t{\n+\t\t\tMethodName: \"WaitJWTToken\",\n+\t\t\tHandler:    _DaemonService_WaitJWTToken_Handler,\n+\t\t},\n \t},\n \tStreams: []grpc.StreamDesc{\n \t\t{\ndiff --git a/client/server/jwt_cache.go b/client/server/jwt_cache.go\nnew file mode 100644\nindex 00000000000..21e17051742\n--- /dev/null\n+++ b/client/server/jwt_cache.go\n@@ -0,0 +1,79 @@\n+package server\n+\n+import (\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/awnumar/memguard\"\n+\tlog \"github.com/sirupsen/logrus\"\n+)\n+\n+type jwtCache struct {\n+\tmu           sync.RWMutex\n+\tenclave      *memguard.Enclave\n+\texpiresAt    time.Time\n+\ttimer        *time.Timer\n+\tmaxTokenSize int\n+}\n+\n+func newJWTCache() *jwtCache {\n+\treturn &jwtCache{\n+\t\tmaxTokenSize: 8192,\n+\t}\n+}\n+\n+func (c *jwtCache) store(token string, maxAge time.Duration) {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\n+\tc.cleanup()\n+\n+\tif c.timer != nil {\n+\t\tc.timer.Stop()\n+\t}\n+\n+\ttokenBytes := []byte(token)\n+\tc.enclave = memguard.NewEnclave(tokenBytes)\n+\n+\tc.expiresAt = time.Now().Add(maxAge)\n+\n+\tvar timer *time.Timer\n+\ttimer = time.AfterFunc(maxAge, func() {\n+\t\tc.mu.Lock()\n+\t\tdefer c.mu.Unlock()\n+\t\tif c.timer != timer {\n+\t\t\treturn\n+\t\t}\n+\t\tc.cleanup()\n+\t\tc.timer = nil\n+\t\tlog.Debugf(\"JWT token cache expired after %v, securely wiped from memory\", maxAge)\n+\t})\n+\tc.timer = timer\n+}\n+\n+func (c *jwtCache) get() (string, bool) {\n+\tc.mu.RLock()\n+\tdefer c.mu.RUnlock()\n+\n+\tif c.enclave == nil || time.Now().After(c.expiresAt) {\n+\t\treturn \"\", false\n+\t}\n+\n+\tbuffer, err := c.enclave.Open()\n+\tif err != nil {\n+\t\tlog.Debugf(\"Failed to open JWT token enclave: %v\", err)\n+\t\treturn \"\", false\n+\t}\n+\tdefer buffer.Destroy()\n+\n+\ttoken := string(buffer.Bytes())\n+\treturn token, true\n+}\n+\n+// cleanup destroys the secure enclave, must be called with lock held\n+func (c *jwtCache) cleanup() {\n+\tif c.enclave != nil {\n+\t\tc.enclave = nil\n+\t}\n+\tc.expiresAt = time.Time{}\n+}\ndiff --git a/client/server/network.go b/client/server/network.go\nindex 18b16795d09..bb1cce56c54 100644\n--- a/client/server/network.go\n+++ b/client/server/network.go\n@@ -11,8 +11,8 @@ import (\n \t\"golang.org/x/exp/maps\"\n \n \t\"github.com/netbirdio/netbird/client/proto\"\n-\t\"github.com/netbirdio/netbird/shared/management/domain\"\n \t\"github.com/netbirdio/netbird/route\"\n+\t\"github.com/netbirdio/netbird/shared/management/domain\"\n )\n \n type selectRoute struct {\ndiff --git a/client/server/server.go b/client/server/server.go\nindex 6699cdadc8f..a930e8a02a5 100644\n--- a/client/server/server.go\n+++ b/client/server/server.go\n@@ -46,6 +46,9 @@ const (\n \tdefaultMaxRetryTime     = 14 * 24 * time.Hour\n \tdefaultRetryMultiplier  = 1.7\n \n+\t// JWT token cache TTL for the client daemon (disabled by default)\n+\tdefaultJWTCacheTTL = 0\n+\n \terrRestoreResidualState   = \"failed to restore residual state: %v\"\n \terrProfilesDisabled       = \"profiles are disabled, you cannot use this feature without profiles enabled\"\n \terrUpdateSettingsDisabled = \"update settings are disabled, you cannot use this feature without update settings enabled\"\n@@ -81,6 +84,8 @@ type Server struct {\n \tprofileManager         *profilemanager.ServiceManager\n \tprofilesDisabled       bool\n \tupdateSettingsDisabled bool\n+\n+\tjwtCache *jwtCache\n }\n \n type oauthAuthFlow struct {\n@@ -100,6 +105,7 @@ func New(ctx context.Context, logFile string, configFile string, profilesDisable\n \t\tprofileManager:         profilemanager.NewServiceManager(configFile),\n \t\tprofilesDisabled:       profilesDisabled,\n \t\tupdateSettingsDisabled: updateSettingsDisabled,\n+\t\tjwtCache:               newJWTCache(),\n \t}\n }\n \n@@ -373,6 +379,17 @@ func (s *Server) SetConfig(callerCtx context.Context, msg *proto.SetConfigReques\n \tconfig.DisableNotifications = msg.DisableNotifications\n \tconfig.LazyConnectionEnabled = msg.LazyConnectionEnabled\n \tconfig.BlockInbound = msg.BlockInbound\n+\tconfig.EnableSSHRoot = msg.EnableSSHRoot\n+\tconfig.EnableSSHSFTP = msg.EnableSSHSFTP\n+\tconfig.EnableSSHLocalPortForwarding = msg.EnableSSHLocalPortForwarding\n+\tconfig.EnableSSHRemotePortForwarding = msg.EnableSSHRemotePortForwarding\n+\tif msg.DisableSSHAuth != nil {\n+\t\tconfig.DisableSSHAuth = msg.DisableSSHAuth\n+\t}\n+\tif msg.SshJWTCacheTTL != nil {\n+\t\tttl := int(*msg.SshJWTCacheTTL)\n+\t\tconfig.SSHJWTCacheTTL = &ttl\n+\t}\n \n \tif msg.Mtu != nil {\n \t\tmtu := uint16(*msg.Mtu)\n@@ -493,7 +510,7 @@ func (s *Server) Login(callerCtx context.Context, msg *proto.LoginRequest) (*pro\n \t\t\treturn nil, err\n \t\t}\n \n-\t\tif s.oauthAuthFlow.flow != nil && s.oauthAuthFlow.flow.GetClientID(ctx) == oAuthFlow.GetClientID(context.TODO()) {\n+\t\tif s.oauthAuthFlow.flow != nil && s.oauthAuthFlow.flow.GetClientID(ctx) == oAuthFlow.GetClientID(ctx) {\n \t\t\tif s.oauthAuthFlow.expiresAt.After(time.Now().Add(90 * time.Second)) {\n \t\t\t\tlog.Debugf(\"using previous oauth flow info\")\n \t\t\t\treturn &proto.LoginResponse{\n@@ -510,7 +527,7 @@ func (s *Server) Login(callerCtx context.Context, msg *proto.LoginRequest) (*pro\n \t\t\t}\n \t\t}\n \n-\t\tauthInfo, err := oAuthFlow.RequestAuthInfo(context.TODO())\n+\t\tauthInfo, err := oAuthFlow.RequestAuthInfo(ctx)\n \t\tif err != nil {\n \t\t\tlog.Errorf(\"getting a request OAuth flow failed: %v\", err)\n \t\t\treturn nil, err\n@@ -1065,12 +1082,235 @@ func (s *Server) Status(\n \t\tfullStatus := s.statusRecorder.GetFullStatus()\n \t\tpbFullStatus := toProtoFullStatus(fullStatus)\n \t\tpbFullStatus.Events = s.statusRecorder.GetEventHistory()\n+\n+\t\tpbFullStatus.SshServerState = s.getSSHServerState()\n+\n \t\tstatusResponse.FullStatus = pbFullStatus\n \t}\n \n \treturn &statusResponse, nil\n }\n \n+// getSSHServerState retrieves the current SSH server state including enabled status and active sessions\n+func (s *Server) getSSHServerState() *proto.SSHServerState {\n+\ts.mutex.Lock()\n+\tconnectClient := s.connectClient\n+\ts.mutex.Unlock()\n+\n+\tif connectClient == nil {\n+\t\treturn nil\n+\t}\n+\n+\tengine := connectClient.Engine()\n+\tif engine == nil {\n+\t\treturn nil\n+\t}\n+\n+\tenabled, sessions := engine.GetSSHServerStatus()\n+\tsshServerState := &proto.SSHServerState{\n+\t\tEnabled: enabled,\n+\t}\n+\n+\tfor _, session := range sessions {\n+\t\tsshServerState.Sessions = append(sshServerState.Sessions, &proto.SSHSessionInfo{\n+\t\t\tUsername:      session.Username,\n+\t\t\tRemoteAddress: session.RemoteAddress,\n+\t\t\tCommand:       session.Command,\n+\t\t\tJwtUsername:   session.JWTUsername,\n+\t\t})\n+\t}\n+\n+\treturn sshServerState\n+}\n+\n+// GetPeerSSHHostKey retrieves SSH host key for a specific peer\n+func (s *Server) GetPeerSSHHostKey(\n+\tctx context.Context,\n+\treq *proto.GetPeerSSHHostKeyRequest,\n+) (*proto.GetPeerSSHHostKeyResponse, error) {\n+\tif ctx.Err() != nil {\n+\t\treturn nil, ctx.Err()\n+\t}\n+\n+\ts.mutex.Lock()\n+\tconnectClient := s.connectClient\n+\tstatusRecorder := s.statusRecorder\n+\ts.mutex.Unlock()\n+\n+\tif connectClient == nil {\n+\t\treturn nil, errors.New(\"client not initialized\")\n+\t}\n+\n+\tengine := connectClient.Engine()\n+\tif engine == nil {\n+\t\treturn nil, errors.New(\"engine not started\")\n+\t}\n+\n+\tpeerAddress := req.GetPeerAddress()\n+\thostKey, found := engine.GetPeerSSHKey(peerAddress)\n+\n+\tresponse := &proto.GetPeerSSHHostKeyResponse{\n+\t\tFound: found,\n+\t}\n+\n+\tif !found {\n+\t\treturn response, nil\n+\t}\n+\n+\tresponse.SshHostKey = hostKey\n+\n+\tif statusRecorder == nil {\n+\t\treturn response, nil\n+\t}\n+\n+\tfullStatus := statusRecorder.GetFullStatus()\n+\tfor _, peerState := range fullStatus.Peers {\n+\t\tif peerState.IP == peerAddress || peerState.FQDN == peerAddress {\n+\t\t\tresponse.PeerIP = peerState.IP\n+\t\t\tresponse.PeerFQDN = peerState.FQDN\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\treturn response, nil\n+}\n+\n+// getJWTCacheTTL returns the JWT cache TTL from config or default (disabled)\n+func (s *Server) getJWTCacheTTL() time.Duration {\n+\ts.mutex.Lock()\n+\tconfig := s.config\n+\ts.mutex.Unlock()\n+\n+\tif config == nil || config.SSHJWTCacheTTL == nil {\n+\t\treturn defaultJWTCacheTTL\n+\t}\n+\n+\tseconds := *config.SSHJWTCacheTTL\n+\tif seconds == 0 {\n+\t\tlog.Debug(\"SSH JWT cache disabled (configured to 0)\")\n+\t\treturn 0\n+\t}\n+\n+\tttl := time.Duration(seconds) * time.Second\n+\tlog.Debugf(\"SSH JWT cache TTL set to %v from config\", ttl)\n+\treturn ttl\n+}\n+\n+// RequestJWTAuth initiates JWT authentication flow for SSH\n+func (s *Server) RequestJWTAuth(\n+\tctx context.Context,\n+\tmsg *proto.RequestJWTAuthRequest,\n+) (*proto.RequestJWTAuthResponse, error) {\n+\tif ctx.Err() != nil {\n+\t\treturn nil, ctx.Err()\n+\t}\n+\n+\ts.mutex.Lock()\n+\tconfig := s.config\n+\ts.mutex.Unlock()\n+\n+\tif config == nil {\n+\t\treturn nil, gstatus.Errorf(codes.FailedPrecondition, \"client is not configured\")\n+\t}\n+\n+\tjwtCacheTTL := s.getJWTCacheTTL()\n+\tif jwtCacheTTL > 0 {\n+\t\tif cachedToken, found := s.jwtCache.get(); found {\n+\t\t\tlog.Debugf(\"JWT token found in cache, returning cached token for SSH authentication\")\n+\n+\t\t\treturn &proto.RequestJWTAuthResponse{\n+\t\t\t\tCachedToken: cachedToken,\n+\t\t\t\tMaxTokenAge: int64(jwtCacheTTL.Seconds()),\n+\t\t\t}, nil\n+\t\t}\n+\t}\n+\n+\thint := \"\"\n+\tif msg.Hint != nil {\n+\t\thint = *msg.Hint\n+\t}\n+\n+\tif hint == \"\" {\n+\t\thint = profilemanager.GetLoginHint()\n+\t}\n+\n+\tisDesktop := isUnixRunningDesktop()\n+\toAuthFlow, err := auth.NewOAuthFlow(ctx, config, isDesktop, hint)\n+\tif err != nil {\n+\t\treturn nil, gstatus.Errorf(codes.Internal, \"failed to create OAuth flow: %v\", err)\n+\t}\n+\n+\tauthInfo, err := oAuthFlow.RequestAuthInfo(ctx)\n+\tif err != nil {\n+\t\treturn nil, gstatus.Errorf(codes.Internal, \"failed to request auth info: %v\", err)\n+\t}\n+\n+\ts.mutex.Lock()\n+\ts.oauthAuthFlow.flow = oAuthFlow\n+\ts.oauthAuthFlow.info = authInfo\n+\ts.oauthAuthFlow.expiresAt = time.Now().Add(time.Duration(authInfo.ExpiresIn) * time.Second)\n+\ts.mutex.Unlock()\n+\n+\treturn &proto.RequestJWTAuthResponse{\n+\t\tVerificationURI:         authInfo.VerificationURI,\n+\t\tVerificationURIComplete: authInfo.VerificationURIComplete,\n+\t\tUserCode:                authInfo.UserCode,\n+\t\tDeviceCode:              authInfo.DeviceCode,\n+\t\tExpiresIn:               int64(authInfo.ExpiresIn),\n+\t\tMaxTokenAge:             int64(jwtCacheTTL.Seconds()),\n+\t}, nil\n+}\n+\n+// WaitJWTToken waits for JWT authentication completion\n+func (s *Server) WaitJWTToken(\n+\tctx context.Context,\n+\treq *proto.WaitJWTTokenRequest,\n+) (*proto.WaitJWTTokenResponse, error) {\n+\tif ctx.Err() != nil {\n+\t\treturn nil, ctx.Err()\n+\t}\n+\n+\ts.mutex.Lock()\n+\toAuthFlow := s.oauthAuthFlow.flow\n+\tauthInfo := s.oauthAuthFlow.info\n+\ts.mutex.Unlock()\n+\n+\tif oAuthFlow == nil || authInfo.DeviceCode != req.DeviceCode {\n+\t\treturn nil, gstatus.Errorf(codes.InvalidArgument, \"invalid device code or no active auth flow\")\n+\t}\n+\n+\ttokenInfo, err := oAuthFlow.WaitToken(ctx, authInfo)\n+\tif err != nil {\n+\t\treturn nil, gstatus.Errorf(codes.Internal, \"failed to get token: %v\", err)\n+\t}\n+\n+\ttoken := tokenInfo.GetTokenToUse()\n+\n+\tjwtCacheTTL := s.getJWTCacheTTL()\n+\tif jwtCacheTTL > 0 {\n+\t\ts.jwtCache.store(token, jwtCacheTTL)\n+\t\tlog.Debugf(\"JWT token cached for SSH authentication, TTL: %v\", jwtCacheTTL)\n+\t} else {\n+\t\tlog.Debug(\"JWT caching disabled, not storing token\")\n+\t}\n+\n+\ts.mutex.Lock()\n+\ts.oauthAuthFlow = oauthAuthFlow{}\n+\ts.mutex.Unlock()\n+\treturn &proto.WaitJWTTokenResponse{\n+\t\tToken:     tokenInfo.GetTokenToUse(),\n+\t\tTokenType: tokenInfo.TokenType,\n+\t\tExpiresIn: int64(tokenInfo.ExpiresIn),\n+\t}, nil\n+}\n+\n+func isUnixRunningDesktop() bool {\n+\tif runtime.GOOS != \"linux\" && runtime.GOOS != \"freebsd\" {\n+\t\treturn false\n+\t}\n+\treturn os.Getenv(\"DESKTOP_SESSION\") != \"\" || os.Getenv(\"XDG_CURRENT_DESKTOP\") != \"\"\n+}\n+\n func (s *Server) runProbes(waitForProbeResult bool) {\n \tif s.connectClient == nil {\n \t\treturn\n@@ -1136,25 +1376,61 @@ func (s *Server) GetConfig(ctx context.Context, req *proto.GetConfigRequest) (*p\n \tdisableServerRoutes := cfg.DisableServerRoutes\n \tblockLANAccess := cfg.BlockLANAccess\n \n+\tenableSSHRoot := false\n+\tif cfg.EnableSSHRoot != nil {\n+\t\tenableSSHRoot = *cfg.EnableSSHRoot\n+\t}\n+\n+\tenableSSHSFTP := false\n+\tif cfg.EnableSSHSFTP != nil {\n+\t\tenableSSHSFTP = *cfg.EnableSSHSFTP\n+\t}\n+\n+\tenableSSHLocalPortForwarding := false\n+\tif cfg.EnableSSHLocalPortForwarding != nil {\n+\t\tenableSSHLocalPortForwarding = *cfg.EnableSSHLocalPortForwarding\n+\t}\n+\n+\tenableSSHRemotePortForwarding := false\n+\tif cfg.EnableSSHRemotePortForwarding != nil {\n+\t\tenableSSHRemotePortForwarding = *cfg.EnableSSHRemotePortForwarding\n+\t}\n+\n+\tdisableSSHAuth := false\n+\tif cfg.DisableSSHAuth != nil {\n+\t\tdisableSSHAuth = *cfg.DisableSSHAuth\n+\t}\n+\n+\tsshJWTCacheTTL := int32(0)\n+\tif cfg.SSHJWTCacheTTL != nil {\n+\t\tsshJWTCacheTTL = int32(*cfg.SSHJWTCacheTTL)\n+\t}\n+\n \treturn &proto.GetConfigResponse{\n-\t\tManagementUrl:         managementURL.String(),\n-\t\tPreSharedKey:          preSharedKey,\n-\t\tAdminURL:              adminURL.String(),\n-\t\tInterfaceName:         cfg.WgIface,\n-\t\tWireguardPort:         int64(cfg.WgPort),\n-\t\tMtu:                   int64(cfg.MTU),\n-\t\tDisableAutoConnect:    cfg.DisableAutoConnect,\n-\t\tServerSSHAllowed:      *cfg.ServerSSHAllowed,\n-\t\tRosenpassEnabled:      cfg.RosenpassEnabled,\n-\t\tRosenpassPermissive:   cfg.RosenpassPermissive,\n-\t\tLazyConnectionEnabled: cfg.LazyConnectionEnabled,\n-\t\tBlockInbound:          cfg.BlockInbound,\n-\t\tDisableNotifications:  disableNotifications,\n-\t\tNetworkMonitor:        networkMonitor,\n-\t\tDisableDns:            disableDNS,\n-\t\tDisableClientRoutes:   disableClientRoutes,\n-\t\tDisableServerRoutes:   disableServerRoutes,\n-\t\tBlockLanAccess:        blockLANAccess,\n+\t\tManagementUrl:                 managementURL.String(),\n+\t\tPreSharedKey:                  preSharedKey,\n+\t\tAdminURL:                      adminURL.String(),\n+\t\tInterfaceName:                 cfg.WgIface,\n+\t\tWireguardPort:                 int64(cfg.WgPort),\n+\t\tMtu:                           int64(cfg.MTU),\n+\t\tDisableAutoConnect:            cfg.DisableAutoConnect,\n+\t\tServerSSHAllowed:              *cfg.ServerSSHAllowed,\n+\t\tRosenpassEnabled:              cfg.RosenpassEnabled,\n+\t\tRosenpassPermissive:           cfg.RosenpassPermissive,\n+\t\tLazyConnectionEnabled:         cfg.LazyConnectionEnabled,\n+\t\tBlockInbound:                  cfg.BlockInbound,\n+\t\tDisableNotifications:          disableNotifications,\n+\t\tNetworkMonitor:                networkMonitor,\n+\t\tDisableDns:                    disableDNS,\n+\t\tDisableClientRoutes:           disableClientRoutes,\n+\t\tDisableServerRoutes:           disableServerRoutes,\n+\t\tBlockLanAccess:                blockLANAccess,\n+\t\tEnableSSHRoot:                 enableSSHRoot,\n+\t\tEnableSSHSFTP:                 enableSSHSFTP,\n+\t\tEnableSSHLocalPortForwarding:  enableSSHLocalPortForwarding,\n+\t\tEnableSSHRemotePortForwarding: enableSSHRemotePortForwarding,\n+\t\tDisableSSHAuth:                disableSSHAuth,\n+\t\tSshJWTCacheTTL:                sshJWTCacheTTL,\n \t}, nil\n }\n \n@@ -1385,6 +1661,7 @@ func toProtoFullStatus(fullStatus peer.FullStatus) *proto.FullStatus {\n \t\t\tRosenpassEnabled:           peerState.RosenpassEnabled,\n \t\t\tNetworks:                   maps.Keys(peerState.GetRoutes()),\n \t\t\tLatency:                    durationpb.New(peerState.Latency),\n+\t\t\tSshHostKey:                 peerState.SSHHostKey,\n \t\t}\n \t\tpbFullStatus.Peers = append(pbFullStatus.Peers, pbPeerState)\n \t}\ndiff --git a/client/server/state_generic.go b/client/server/state_generic.go\nindex e6c7bdd44d7..980ba0cda42 100644\n--- a/client/server/state_generic.go\n+++ b/client/server/state_generic.go\n@@ -6,9 +6,11 @@ import (\n \t\"github.com/netbirdio/netbird/client/internal/dns\"\n \t\"github.com/netbirdio/netbird/client/internal/routemanager/systemops\"\n \t\"github.com/netbirdio/netbird/client/internal/statemanager\"\n+\t\"github.com/netbirdio/netbird/client/ssh/config\"\n )\n \n func registerStates(mgr *statemanager.Manager) {\n \tmgr.RegisterState(&dns.ShutdownState{})\n \tmgr.RegisterState(&systemops.ShutdownState{})\n+\tmgr.RegisterState(&config.ShutdownState{})\n }\ndiff --git a/client/server/state_linux.go b/client/server/state_linux.go\nindex 08762890719..019477d8eae 100644\n--- a/client/server/state_linux.go\n+++ b/client/server/state_linux.go\n@@ -8,6 +8,7 @@ import (\n \t\"github.com/netbirdio/netbird/client/internal/dns\"\n \t\"github.com/netbirdio/netbird/client/internal/routemanager/systemops\"\n \t\"github.com/netbirdio/netbird/client/internal/statemanager\"\n+\t\"github.com/netbirdio/netbird/client/ssh/config\"\n )\n \n func registerStates(mgr *statemanager.Manager) {\n@@ -15,4 +16,5 @@ func registerStates(mgr *statemanager.Manager) {\n \tmgr.RegisterState(&systemops.ShutdownState{})\n \tmgr.RegisterState(&nftables.ShutdownState{})\n \tmgr.RegisterState(&iptables.ShutdownState{})\n+\tmgr.RegisterState(&config.ShutdownState{})\n }\ndiff --git a/client/ssh/client.go b/client/ssh/client.go\ndeleted file mode 100644\nindex afba347f809..00000000000\n--- a/client/ssh/client.go\n+++ /dev/null\n@@ -1,118 +0,0 @@\n-//go:build !js\n-\n-package ssh\n-\n-import (\n-\t\"fmt\"\n-\t\"net\"\n-\t\"os\"\n-\t\"time\"\n-\n-\t\"golang.org/x/crypto/ssh\"\n-\t\"golang.org/x/term\"\n-)\n-\n-// Client wraps crypto/ssh Client to simplify usage\n-type Client struct {\n-\tclient *ssh.Client\n-}\n-\n-// Close closes the wrapped SSH Client\n-func (c *Client) Close() error {\n-\treturn c.client.Close()\n-}\n-\n-// OpenTerminal starts an interactive terminal session with the remote SSH server\n-func (c *Client) OpenTerminal() error {\n-\tsession, err := c.client.NewSession()\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"failed to open new session: %v\", err)\n-\t}\n-\tdefer func() {\n-\t\terr := session.Close()\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t}()\n-\n-\tfd := int(os.Stdout.Fd())\n-\tstate, err := term.MakeRaw(fd)\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"failed to run raw terminal: %s\", err)\n-\t}\n-\tdefer func() {\n-\t\terr := term.Restore(fd, state)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t}()\n-\n-\tw, h, err := term.GetSize(fd)\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"terminal get size: %s\", err)\n-\t}\n-\n-\tmodes := ssh.TerminalModes{\n-\t\tssh.ECHO:          1,\n-\t\tssh.TTY_OP_ISPEED: 14400,\n-\t\tssh.TTY_OP_OSPEED: 14400,\n-\t}\n-\n-\tterminal := os.Getenv(\"TERM\")\n-\tif terminal == \"\" {\n-\t\tterminal = \"xterm-256color\"\n-\t}\n-\tif err := session.RequestPty(terminal, h, w, modes); err != nil {\n-\t\treturn fmt.Errorf(\"failed requesting pty session with xterm: %s\", err)\n-\t}\n-\n-\tsession.Stdout = os.Stdout\n-\tsession.Stderr = os.Stderr\n-\tsession.Stdin = os.Stdin\n-\n-\tif err := session.Shell(); err != nil {\n-\t\treturn fmt.Errorf(\"failed to start login shell on the remote host: %s\", err)\n-\t}\n-\n-\tif err := session.Wait(); err != nil {\n-\t\tif e, ok := err.(*ssh.ExitError); ok {\n-\t\t\tif e.ExitStatus() == 130 {\n-\t\t\t\treturn nil\n-\t\t\t}\n-\t\t}\n-\t\treturn fmt.Errorf(\"failed running SSH session: %s\", err)\n-\t}\n-\n-\treturn nil\n-}\n-\n-// DialWithKey connects to the remote SSH server with a provided private key file (PEM).\n-func DialWithKey(addr, user string, privateKey []byte) (*Client, error) {\n-\n-\tsigner, err := ssh.ParsePrivateKey(privateKey)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tconfig := &ssh.ClientConfig{\n-\t\tUser:    user,\n-\t\tTimeout: 5 * time.Second,\n-\t\tAuth: []ssh.AuthMethod{\n-\t\t\tssh.PublicKeys(signer),\n-\t\t},\n-\t\tHostKeyCallback: ssh.HostKeyCallback(func(hostname string, remote net.Addr, key ssh.PublicKey) error { return nil }),\n-\t}\n-\n-\treturn Dial(\"tcp\", addr, config)\n-}\n-\n-// Dial connects to the remote SSH server.\n-func Dial(network, addr string, config *ssh.ClientConfig) (*Client, error) {\n-\tclient, err := ssh.Dial(network, addr, config)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn &Client{\n-\t\tclient: client,\n-\t}, nil\n-}\ndiff --git a/client/ssh/client/client.go b/client/ssh/client/client.go\nnew file mode 100644\nindex 00000000000..8820563746b\n--- /dev/null\n+++ b/client/ssh/client/client.go\n@@ -0,0 +1,699 @@\n+package client\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"golang.org/x/crypto/ssh\"\n+\t\"golang.org/x/crypto/ssh/knownhosts\"\n+\t\"golang.org/x/term\"\n+\t\"google.golang.org/grpc\"\n+\t\"google.golang.org/grpc/credentials/insecure\"\n+\n+\t\"github.com/netbirdio/netbird/client/internal/profilemanager\"\n+\t\"github.com/netbirdio/netbird/client/proto\"\n+\tnbssh \"github.com/netbirdio/netbird/client/ssh\"\n+\t\"github.com/netbirdio/netbird/client/ssh/detection\"\n+)\n+\n+const (\n+\t// DefaultDaemonAddr is the default address for the NetBird daemon\n+\tDefaultDaemonAddr = \"unix:///var/run/netbird.sock\"\n+\t// DefaultDaemonAddrWindows is the default address for the NetBird daemon on Windows\n+\tDefaultDaemonAddrWindows = \"tcp://127.0.0.1:41731\"\n+)\n+\n+// Client wraps crypto/ssh Client for simplified SSH operations\n+type Client struct {\n+\tclient        *ssh.Client\n+\tterminalState *term.State\n+\tterminalFd    int\n+\n+\twindowsStdoutMode uint32 // nolint:unused\n+\twindowsStdinMode  uint32 // nolint:unused\n+}\n+\n+func (c *Client) Close() error {\n+\treturn c.client.Close()\n+}\n+\n+func (c *Client) OpenTerminal(ctx context.Context) error {\n+\tsession, err := c.client.NewSession()\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"new session: %w\", err)\n+\t}\n+\tdefer func() {\n+\t\tif err := session.Close(); err != nil {\n+\t\t\tlog.Debugf(\"session close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tif err := c.setupTerminalMode(ctx, session); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tc.setupSessionIO(session)\n+\n+\tif err := session.Shell(); err != nil {\n+\t\treturn fmt.Errorf(\"start shell: %w\", err)\n+\t}\n+\n+\treturn c.waitForSession(ctx, session)\n+}\n+\n+// setupSessionIO connects session streams to local terminal\n+func (c *Client) setupSessionIO(session *ssh.Session) {\n+\tsession.Stdout = os.Stdout\n+\tsession.Stderr = os.Stderr\n+\tsession.Stdin = os.Stdin\n+}\n+\n+// waitForSession waits for the session to complete with context cancellation\n+func (c *Client) waitForSession(ctx context.Context, session *ssh.Session) error {\n+\tdone := make(chan error, 1)\n+\tgo func() {\n+\t\tdone <- session.Wait()\n+\t}()\n+\n+\tdefer c.restoreTerminal()\n+\n+\tselect {\n+\tcase <-ctx.Done():\n+\t\treturn ctx.Err()\n+\tcase err := <-done:\n+\t\treturn c.handleSessionError(err)\n+\t}\n+}\n+\n+// handleSessionError processes session termination errors\n+func (c *Client) handleSessionError(err error) error {\n+\tif err == nil {\n+\t\treturn nil\n+\t}\n+\n+\tvar e *ssh.ExitError\n+\tvar em *ssh.ExitMissingError\n+\tif !errors.As(err, &e) && !errors.As(err, &em) {\n+\t\treturn fmt.Errorf(\"session wait: %w\", err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// restoreTerminal restores the terminal to its original state\n+func (c *Client) restoreTerminal() {\n+\tif c.terminalState != nil {\n+\t\t_ = term.Restore(c.terminalFd, c.terminalState)\n+\t\tc.terminalState = nil\n+\t\tc.terminalFd = 0\n+\t}\n+\n+\tif err := c.restoreWindowsConsoleState(); err != nil {\n+\t\tlog.Debugf(\"restore Windows console state: %v\", err)\n+\t}\n+}\n+\n+// ExecuteCommand executes a command on the remote host and returns the output\n+func (c *Client) ExecuteCommand(ctx context.Context, command string) ([]byte, error) {\n+\tsession, cleanup, err := c.createSession(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer cleanup()\n+\n+\toutput, err := session.CombinedOutput(command)\n+\tif err != nil {\n+\t\tvar e *ssh.ExitError\n+\t\tvar em *ssh.ExitMissingError\n+\t\tif !errors.As(err, &e) && !errors.As(err, &em) {\n+\t\t\treturn output, fmt.Errorf(\"execute command: %w\", err)\n+\t\t}\n+\t}\n+\n+\treturn output, nil\n+}\n+\n+// ExecuteCommandWithIO executes a command with interactive I/O connected to local terminal\n+func (c *Client) ExecuteCommandWithIO(ctx context.Context, command string) error {\n+\tsession, cleanup, err := c.createSession(ctx)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"create session: %w\", err)\n+\t}\n+\tdefer cleanup()\n+\n+\tc.setupSessionIO(session)\n+\n+\tif err := session.Start(command); err != nil {\n+\t\treturn fmt.Errorf(\"start command: %w\", err)\n+\t}\n+\n+\tdone := make(chan error, 1)\n+\tgo func() {\n+\t\tdone <- session.Wait()\n+\t}()\n+\n+\tselect {\n+\tcase <-ctx.Done():\n+\t\t_ = session.Signal(ssh.SIGTERM)\n+\t\tselect {\n+\t\tcase <-done:\n+\t\t\treturn ctx.Err()\n+\t\tcase <-time.After(100 * time.Millisecond):\n+\t\t\treturn ctx.Err()\n+\t\t}\n+\tcase err := <-done:\n+\t\treturn c.handleCommandError(err)\n+\t}\n+}\n+\n+// ExecuteCommandWithPTY executes a command with a pseudo-terminal for interactive sessions\n+func (c *Client) ExecuteCommandWithPTY(ctx context.Context, command string) error {\n+\tsession, cleanup, err := c.createSession(ctx)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"create session: %w\", err)\n+\t}\n+\tdefer cleanup()\n+\n+\tif err := c.setupTerminalMode(ctx, session); err != nil {\n+\t\treturn fmt.Errorf(\"setup terminal mode: %w\", err)\n+\t}\n+\n+\tc.setupSessionIO(session)\n+\n+\tif err := session.Start(command); err != nil {\n+\t\treturn fmt.Errorf(\"start command: %w\", err)\n+\t}\n+\n+\tdefer c.restoreTerminal()\n+\n+\tdone := make(chan error, 1)\n+\tgo func() {\n+\t\tdone <- session.Wait()\n+\t}()\n+\n+\tselect {\n+\tcase <-ctx.Done():\n+\t\t_ = session.Signal(ssh.SIGTERM)\n+\t\tselect {\n+\t\tcase <-done:\n+\t\t\treturn ctx.Err()\n+\t\tcase <-time.After(100 * time.Millisecond):\n+\t\t\treturn ctx.Err()\n+\t\t}\n+\tcase err := <-done:\n+\t\treturn c.handleCommandError(err)\n+\t}\n+}\n+\n+// handleCommandError processes command execution errors\n+func (c *Client) handleCommandError(err error) error {\n+\tif err == nil {\n+\t\treturn nil\n+\t}\n+\n+\tvar e *ssh.ExitError\n+\tvar em *ssh.ExitMissingError\n+\tif errors.As(err, &e) || errors.As(err, &em) {\n+\t\treturn err\n+\t}\n+\n+\treturn fmt.Errorf(\"execute command: %w\", err)\n+}\n+\n+// setupContextCancellation sets up context cancellation for a session\n+func (c *Client) setupContextCancellation(ctx context.Context, session *ssh.Session) func() {\n+\tdone := make(chan struct{})\n+\tgo func() {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\t\t_ = session.Signal(ssh.SIGTERM)\n+\t\t\t_ = session.Close()\n+\t\tcase <-done:\n+\t\t}\n+\t}()\n+\treturn func() { close(done) }\n+}\n+\n+// createSession creates a new SSH session with context cancellation setup\n+func (c *Client) createSession(ctx context.Context) (*ssh.Session, func(), error) {\n+\tsession, err := c.client.NewSession()\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"new session: %w\", err)\n+\t}\n+\n+\tcancel := c.setupContextCancellation(ctx, session)\n+\tcleanup := func() {\n+\t\tcancel()\n+\t\t_ = session.Close()\n+\t}\n+\n+\treturn session, cleanup, nil\n+}\n+\n+// getDefaultDaemonAddr returns the daemon address from environment or default for the OS\n+func getDefaultDaemonAddr() string {\n+\tif addr := os.Getenv(\"NB_DAEMON_ADDR\"); addr != \"\" {\n+\t\treturn addr\n+\t}\n+\tif runtime.GOOS == \"windows\" {\n+\t\treturn DefaultDaemonAddrWindows\n+\t}\n+\treturn DefaultDaemonAddr\n+}\n+\n+// DialOptions contains options for SSH connections\n+type DialOptions struct {\n+\tKnownHostsFile     string\n+\tIdentityFile       string\n+\tDaemonAddr         string\n+\tSkipCachedToken    bool\n+\tInsecureSkipVerify bool\n+}\n+\n+// Dial connects to the given ssh server with specified options\n+func Dial(ctx context.Context, addr, user string, opts DialOptions) (*Client, error) {\n+\tdaemonAddr := opts.DaemonAddr\n+\tif daemonAddr == \"\" {\n+\t\tdaemonAddr = getDefaultDaemonAddr()\n+\t}\n+\topts.DaemonAddr = daemonAddr\n+\n+\thostKeyCallback, err := createHostKeyCallback(opts)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"create host key callback: %w\", err)\n+\t}\n+\n+\tconfig := &ssh.ClientConfig{\n+\t\tUser:            user,\n+\t\tTimeout:         30 * time.Second,\n+\t\tHostKeyCallback: hostKeyCallback,\n+\t}\n+\n+\tif opts.IdentityFile != \"\" {\n+\t\tauthMethod, err := createSSHKeyAuth(opts.IdentityFile)\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"create SSH key auth: %w\", err)\n+\t\t}\n+\t\tconfig.Auth = append(config.Auth, authMethod)\n+\t}\n+\n+\treturn dialWithJWT(ctx, \"tcp\", addr, config, daemonAddr, opts.SkipCachedToken)\n+}\n+\n+// dialSSH establishes an SSH connection without JWT authentication\n+func dialSSH(ctx context.Context, network, addr string, config *ssh.ClientConfig) (*Client, error) {\n+\tdialer := &net.Dialer{}\n+\tconn, err := dialer.DialContext(ctx, network, addr)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"dial %s: %w\", addr, err)\n+\t}\n+\n+\tclientConn, chans, reqs, err := ssh.NewClientConn(conn, addr, config)\n+\tif err != nil {\n+\t\tif closeErr := conn.Close(); closeErr != nil {\n+\t\t\tlog.Debugf(\"connection close after handshake failure: %v\", closeErr)\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"ssh handshake: %w\", err)\n+\t}\n+\n+\tclient := ssh.NewClient(clientConn, chans, reqs)\n+\treturn &Client{\n+\t\tclient: client,\n+\t}, nil\n+}\n+\n+// dialWithJWT establishes an SSH connection with optional JWT authentication based on server detection\n+func dialWithJWT(ctx context.Context, network, addr string, config *ssh.ClientConfig, daemonAddr string, skipCache bool) (*Client, error) {\n+\thost, portStr, err := net.SplitHostPort(addr)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"parse address %s: %w\", addr, err)\n+\t}\n+\tport, err := strconv.Atoi(portStr)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"parse port %s: %w\", portStr, err)\n+\t}\n+\n+\tdialer := &net.Dialer{Timeout: detection.Timeout}\n+\tserverType, err := detection.DetectSSHServerType(ctx, dialer, host, port)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"SSH server detection failed: %w\", err)\n+\t}\n+\n+\tif !serverType.RequiresJWT() {\n+\t\treturn dialSSH(ctx, network, addr, config)\n+\t}\n+\n+\tjwtCtx, cancel := context.WithTimeout(ctx, config.Timeout)\n+\tdefer cancel()\n+\n+\tjwtToken, err := requestJWTToken(jwtCtx, daemonAddr, skipCache)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"request JWT token: %w\", err)\n+\t}\n+\n+\tconfigWithJWT := nbssh.AddJWTAuth(config, jwtToken)\n+\treturn dialSSH(ctx, network, addr, configWithJWT)\n+}\n+\n+// requestJWTToken requests a JWT token from the NetBird daemon\n+func requestJWTToken(ctx context.Context, daemonAddr string, skipCache bool) (string, error) {\n+\thint := profilemanager.GetLoginHint()\n+\n+\tconn, err := connectToDaemon(daemonAddr)\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"connect to daemon: %w\", err)\n+\t}\n+\tdefer conn.Close()\n+\n+\tclient := proto.NewDaemonServiceClient(conn)\n+\treturn nbssh.RequestJWTToken(ctx, client, os.Stdout, os.Stderr, !skipCache, hint)\n+}\n+\n+// verifyHostKeyViaDaemon verifies SSH host key by querying the NetBird daemon\n+func verifyHostKeyViaDaemon(hostname string, remote net.Addr, key ssh.PublicKey, daemonAddr string) error {\n+\tconn, err := connectToDaemon(daemonAddr)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer func() {\n+\t\tif err := conn.Close(); err != nil {\n+\t\t\tlog.Debugf(\"daemon connection close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tclient := proto.NewDaemonServiceClient(conn)\n+\tverifier := nbssh.NewDaemonHostKeyVerifier(client)\n+\tcallback := nbssh.CreateHostKeyCallback(verifier)\n+\treturn callback(hostname, remote, key)\n+}\n+\n+func connectToDaemon(daemonAddr string) (*grpc.ClientConn, error) {\n+\taddr := strings.TrimPrefix(daemonAddr, \"tcp://\")\n+\n+\tconn, err := grpc.NewClient(\n+\t\taddr,\n+\t\tgrpc.WithTransportCredentials(insecure.NewCredentials()),\n+\t)\n+\tif err != nil {\n+\t\tlog.Debugf(\"failed to create gRPC client for NetBird daemon at %s: %v\", daemonAddr, err)\n+\t\treturn nil, fmt.Errorf(\"failed to connect to NetBird daemon: %w\", err)\n+\t}\n+\n+\treturn conn, nil\n+}\n+\n+// getKnownHostsFiles returns paths to known_hosts files in order of preference\n+func getKnownHostsFiles() []string {\n+\tvar files []string\n+\n+\t// User's known_hosts file (highest priority)\n+\tif homeDir, err := os.UserHomeDir(); err == nil {\n+\t\tuserKnownHosts := filepath.Join(homeDir, \".ssh\", \"known_hosts\")\n+\t\tfiles = append(files, userKnownHosts)\n+\t}\n+\n+\t// NetBird managed known_hosts files\n+\tif runtime.GOOS == \"windows\" {\n+\t\tprogramData := os.Getenv(\"PROGRAMDATA\")\n+\t\tif programData == \"\" {\n+\t\t\tprogramData = `C:\\ProgramData`\n+\t\t}\n+\t\tnetbirdKnownHosts := filepath.Join(programData, \"ssh\", \"ssh_known_hosts.d\", \"99-netbird\")\n+\t\tfiles = append(files, netbirdKnownHosts)\n+\t} else {\n+\t\tfiles = append(files, \"/etc/ssh/ssh_known_hosts.d/99-netbird\")\n+\t\tfiles = append(files, \"/etc/ssh/ssh_known_hosts\")\n+\t}\n+\n+\treturn files\n+}\n+\n+// createHostKeyCallback creates a host key verification callback\n+func createHostKeyCallback(opts DialOptions) (ssh.HostKeyCallback, error) {\n+\tif opts.InsecureSkipVerify {\n+\t\treturn ssh.InsecureIgnoreHostKey(), nil // #nosec G106 - User explicitly requested insecure mode\n+\t}\n+\n+\treturn func(hostname string, remote net.Addr, key ssh.PublicKey) error {\n+\t\tif err := tryDaemonVerification(hostname, remote, key, opts.DaemonAddr); err == nil {\n+\t\t\treturn nil\n+\t\t}\n+\t\treturn tryKnownHostsVerification(hostname, remote, key, opts.KnownHostsFile)\n+\t}, nil\n+}\n+\n+func tryDaemonVerification(hostname string, remote net.Addr, key ssh.PublicKey, daemonAddr string) error {\n+\tif daemonAddr == \"\" {\n+\t\treturn fmt.Errorf(\"no daemon address\")\n+\t}\n+\treturn verifyHostKeyViaDaemon(hostname, remote, key, daemonAddr)\n+}\n+\n+func tryKnownHostsVerification(hostname string, remote net.Addr, key ssh.PublicKey, knownHostsFile string) error {\n+\tknownHostsFiles := getKnownHostsFilesList(knownHostsFile)\n+\thostKeyCallbacks := buildHostKeyCallbacks(knownHostsFiles)\n+\n+\tfor _, callback := range hostKeyCallbacks {\n+\t\tif err := callback(hostname, remote, key); err == nil {\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\treturn fmt.Errorf(\"host key verification failed: key for %s not found in any known_hosts file\", hostname)\n+}\n+\n+func getKnownHostsFilesList(knownHostsFile string) []string {\n+\tif knownHostsFile != \"\" {\n+\t\treturn []string{knownHostsFile}\n+\t}\n+\treturn getKnownHostsFiles()\n+}\n+\n+func buildHostKeyCallbacks(knownHostsFiles []string) []ssh.HostKeyCallback {\n+\tvar hostKeyCallbacks []ssh.HostKeyCallback\n+\tfor _, file := range knownHostsFiles {\n+\t\tif callback, err := knownhosts.New(file); err == nil {\n+\t\t\thostKeyCallbacks = append(hostKeyCallbacks, callback)\n+\t\t}\n+\t}\n+\treturn hostKeyCallbacks\n+}\n+\n+// createSSHKeyAuth creates SSH key authentication from a private key file\n+func createSSHKeyAuth(keyFile string) (ssh.AuthMethod, error) {\n+\tkeyData, err := os.ReadFile(keyFile)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"read SSH key file %s: %w\", keyFile, err)\n+\t}\n+\n+\tsigner, err := ssh.ParsePrivateKey(keyData)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"parse SSH private key: %w\", err)\n+\t}\n+\n+\treturn ssh.PublicKeys(signer), nil\n+}\n+\n+// LocalPortForward sets up local port forwarding, binding to localAddr and forwarding to remoteAddr\n+func (c *Client) LocalPortForward(ctx context.Context, localAddr, remoteAddr string) error {\n+\tlocalListener, err := net.Listen(\"tcp\", localAddr)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"listen on %s: %w\", localAddr, err)\n+\t}\n+\n+\tgo func() {\n+\t\tdefer func() {\n+\t\t\tif err := localListener.Close(); err != nil && !errors.Is(err, net.ErrClosed) {\n+\t\t\t\tlog.Debugf(\"local listener close error: %v\", err)\n+\t\t\t}\n+\t\t}()\n+\t\tfor {\n+\t\t\tlocalConn, err := localListener.Accept()\n+\t\t\tif err != nil {\n+\t\t\t\tif ctx.Err() != nil {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tgo c.handleLocalForward(localConn, remoteAddr)\n+\t\t}\n+\t}()\n+\n+\t<-ctx.Done()\n+\tif err := localListener.Close(); err != nil && !errors.Is(err, net.ErrClosed) {\n+\t\tlog.Debugf(\"local listener close error: %v\", err)\n+\t}\n+\treturn ctx.Err()\n+}\n+\n+// handleLocalForward handles a single local port forwarding connection\n+func (c *Client) handleLocalForward(localConn net.Conn, remoteAddr string) {\n+\tdefer func() {\n+\t\tif err := localConn.Close(); err != nil {\n+\t\t\tlog.Debugf(\"local connection close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tchannel, err := c.client.Dial(\"tcp\", remoteAddr)\n+\tif err != nil {\n+\t\tif strings.Contains(err.Error(), \"administratively prohibited\") {\n+\t\t\t_, _ = fmt.Fprintf(os.Stderr, \"channel open failed: administratively prohibited: port forwarding is disabled\\n\")\n+\t\t} else {\n+\t\t\tlog.Debugf(\"local port forwarding to %s failed: %v\", remoteAddr, err)\n+\t\t}\n+\t\treturn\n+\t}\n+\tdefer func() {\n+\t\tif err := channel.Close(); err != nil {\n+\t\t\tlog.Debugf(\"remote channel close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tgo func() {\n+\t\tif _, err := io.Copy(channel, localConn); err != nil {\n+\t\t\tlog.Debugf(\"local forward copy error (local->remote): %v\", err)\n+\t\t}\n+\t}()\n+\n+\tif _, err := io.Copy(localConn, channel); err != nil {\n+\t\tlog.Debugf(\"local forward copy error (remote->local): %v\", err)\n+\t}\n+}\n+\n+// RemotePortForward sets up remote port forwarding, binding on remote and forwarding to localAddr\n+func (c *Client) RemotePortForward(ctx context.Context, remoteAddr, localAddr string) error {\n+\thost, port, err := c.parseRemoteAddress(remoteAddr)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"parse remote address: %w\", err)\n+\t}\n+\n+\treq := c.buildTCPIPForwardRequest(host, port)\n+\tif err := c.sendTCPIPForwardRequest(req); err != nil {\n+\t\treturn fmt.Errorf(\"setup remote forward: %w\", err)\n+\t}\n+\n+\tgo c.handleRemoteForwardChannels(ctx, localAddr)\n+\n+\t<-ctx.Done()\n+\n+\tif err := c.cancelTCPIPForwardRequest(req); err != nil {\n+\t\treturn fmt.Errorf(\"cancel tcpip-forward: %w\", err)\n+\t}\n+\treturn ctx.Err()\n+}\n+\n+// parseRemoteAddress parses host and port from remote address string\n+func (c *Client) parseRemoteAddress(remoteAddr string) (string, uint32, error) {\n+\thost, portStr, err := net.SplitHostPort(remoteAddr)\n+\tif err != nil {\n+\t\treturn \"\", 0, fmt.Errorf(\"parse remote address %s: %w\", remoteAddr, err)\n+\t}\n+\n+\tport, err := strconv.Atoi(portStr)\n+\tif err != nil {\n+\t\treturn \"\", 0, fmt.Errorf(\"parse remote port %s: %w\", portStr, err)\n+\t}\n+\n+\treturn host, uint32(port), nil\n+}\n+\n+// buildTCPIPForwardRequest creates a tcpip-forward request message\n+func (c *Client) buildTCPIPForwardRequest(host string, port uint32) tcpipForwardMsg {\n+\treturn tcpipForwardMsg{\n+\t\tHost: host,\n+\t\tPort: port,\n+\t}\n+}\n+\n+// sendTCPIPForwardRequest sends the tcpip-forward request to establish remote port forwarding\n+func (c *Client) sendTCPIPForwardRequest(req tcpipForwardMsg) error {\n+\tok, _, err := c.client.SendRequest(\"tcpip-forward\", true, ssh.Marshal(&req))\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"send tcpip-forward request: %w\", err)\n+\t}\n+\tif !ok {\n+\t\treturn fmt.Errorf(\"remote port forwarding denied by server (check if --allow-ssh-remote-port-forwarding is enabled)\")\n+\t}\n+\treturn nil\n+}\n+\n+// cancelTCPIPForwardRequest cancels the tcpip-forward request\n+func (c *Client) cancelTCPIPForwardRequest(req tcpipForwardMsg) error {\n+\t_, _, err := c.client.SendRequest(\"cancel-tcpip-forward\", true, ssh.Marshal(&req))\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"send cancel-tcpip-forward request: %w\", err)\n+\t}\n+\treturn nil\n+}\n+\n+// handleRemoteForwardChannels handles incoming forwarded-tcpip channels\n+func (c *Client) handleRemoteForwardChannels(ctx context.Context, localAddr string) {\n+\t// Get the channel once - subsequent calls return nil!\n+\tchannelRequests := c.client.HandleChannelOpen(\"forwarded-tcpip\")\n+\tif channelRequests == nil {\n+\t\tlog.Debugf(\"forwarded-tcpip channel type already being handled\")\n+\t\treturn\n+\t}\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\t\treturn\n+\t\tcase newChan := <-channelRequests:\n+\t\t\tif newChan != nil {\n+\t\t\t\tgo c.handleRemoteForwardChannel(newChan, localAddr)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// handleRemoteForwardChannel handles a single forwarded-tcpip channel\n+func (c *Client) handleRemoteForwardChannel(newChan ssh.NewChannel, localAddr string) {\n+\tchannel, reqs, err := newChan.Accept()\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tdefer func() {\n+\t\tif err := channel.Close(); err != nil {\n+\t\t\tlog.Debugf(\"remote channel close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tgo ssh.DiscardRequests(reqs)\n+\n+\tlocalConn, err := net.Dial(\"tcp\", localAddr)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tdefer func() {\n+\t\tif err := localConn.Close(); err != nil {\n+\t\t\tlog.Debugf(\"local connection close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tgo func() {\n+\t\tif _, err := io.Copy(localConn, channel); err != nil {\n+\t\t\tlog.Debugf(\"remote forward copy error (remote->local): %v\", err)\n+\t\t}\n+\t}()\n+\n+\tif _, err := io.Copy(channel, localConn); err != nil {\n+\t\tlog.Debugf(\"remote forward copy error (local->remote): %v\", err)\n+\t}\n+}\n+\n+// tcpipForwardMsg represents the structure for tcpip-forward requests\n+type tcpipForwardMsg struct {\n+\tHost string\n+\tPort uint32\n+}\ndiff --git a/client/ssh/client/terminal_unix.go b/client/ssh/client/terminal_unix.go\nnew file mode 100644\nindex 00000000000..aaa3418f96e\n--- /dev/null\n+++ b/client/ssh/client/terminal_unix.go\n@@ -0,0 +1,127 @@\n+//go:build !windows\n+\n+package client\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"os/signal\"\n+\t\"syscall\"\n+\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"golang.org/x/crypto/ssh\"\n+\t\"golang.org/x/term\"\n+)\n+\n+func (c *Client) setupTerminalMode(ctx context.Context, session *ssh.Session) error {\n+\tstdinFd := int(os.Stdin.Fd())\n+\n+\tif !term.IsTerminal(stdinFd) {\n+\t\treturn c.setupNonTerminalMode(ctx, session)\n+\t}\n+\n+\tfd := int(os.Stdin.Fd())\n+\n+\tstate, err := term.MakeRaw(fd)\n+\tif err != nil {\n+\t\treturn c.setupNonTerminalMode(ctx, session)\n+\t}\n+\n+\tif err := c.setupTerminal(session, fd); err != nil {\n+\t\tif restoreErr := term.Restore(fd, state); restoreErr != nil {\n+\t\t\tlog.Debugf(\"restore terminal state: %v\", restoreErr)\n+\t\t}\n+\t\treturn err\n+\t}\n+\n+\tc.terminalState = state\n+\tc.terminalFd = fd\n+\n+\tsigChan := make(chan os.Signal, 1)\n+\tsignal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)\n+\n+\tgo func() {\n+\t\tdefer signal.Stop(sigChan)\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\t\tif err := term.Restore(fd, state); err != nil {\n+\t\t\t\tlog.Debugf(\"restore terminal state: %v\", err)\n+\t\t\t}\n+\t\tcase sig := <-sigChan:\n+\t\t\tif err := term.Restore(fd, state); err != nil {\n+\t\t\t\tlog.Debugf(\"restore terminal state: %v\", err)\n+\t\t\t}\n+\t\t\tsignal.Reset(sig)\n+\t\t\ts, ok := sig.(syscall.Signal)\n+\t\t\tif !ok {\n+\t\t\t\tlog.Debugf(\"signal %v is not a syscall.Signal: %T\", sig, sig)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif err := syscall.Kill(syscall.Getpid(), s); err != nil {\n+\t\t\t\tlog.Debugf(\"kill process with signal %v: %v\", s, err)\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n+\treturn nil\n+}\n+\n+func (c *Client) setupNonTerminalMode(_ context.Context, session *ssh.Session) error {\n+\treturn nil\n+}\n+\n+// restoreWindowsConsoleState is a no-op on Unix systems\n+func (c *Client) restoreWindowsConsoleState() error {\n+\treturn nil\n+}\n+\n+func (c *Client) setupTerminal(session *ssh.Session, fd int) error {\n+\tw, h, err := term.GetSize(fd)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"get terminal size: %w\", err)\n+\t}\n+\n+\tmodes := ssh.TerminalModes{\n+\t\tssh.ECHO:          1,\n+\t\tssh.TTY_OP_ISPEED: 14400,\n+\t\tssh.TTY_OP_OSPEED: 14400,\n+\t\t// Ctrl+C\n+\t\tssh.VINTR: 3,\n+\t\t// Ctrl+\\\n+\t\tssh.VQUIT: 28,\n+\t\t// Backspace\n+\t\tssh.VERASE: 127,\n+\t\t// Ctrl+U\n+\t\tssh.VKILL: 21,\n+\t\t// Ctrl+D\n+\t\tssh.VEOF:  4,\n+\t\tssh.VEOL:  0,\n+\t\tssh.VEOL2: 0,\n+\t\t// Ctrl+Q\n+\t\tssh.VSTART: 17,\n+\t\t// Ctrl+S\n+\t\tssh.VSTOP: 19,\n+\t\t// Ctrl+Z\n+\t\tssh.VSUSP: 26,\n+\t\t// Ctrl+O\n+\t\tssh.VDISCARD: 15,\n+\t\t// Ctrl+R\n+\t\tssh.VREPRINT: 18,\n+\t\t// Ctrl+W\n+\t\tssh.VWERASE: 23,\n+\t\t// Ctrl+V\n+\t\tssh.VLNEXT: 22,\n+\t}\n+\n+\tterminal := os.Getenv(\"TERM\")\n+\tif terminal == \"\" {\n+\t\tterminal = \"xterm-256color\"\n+\t}\n+\n+\tif err := session.RequestPty(terminal, h, w, modes); err != nil {\n+\t\treturn fmt.Errorf(\"request pty: %w\", err)\n+\t}\n+\n+\treturn nil\n+}\ndiff --git a/client/ssh/client/terminal_windows.go b/client/ssh/client/terminal_windows.go\nnew file mode 100644\nindex 00000000000..462438317e4\n--- /dev/null\n+++ b/client/ssh/client/terminal_windows.go\n@@ -0,0 +1,265 @@\n+package client\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"syscall\"\n+\t\"unsafe\"\n+\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"golang.org/x/crypto/ssh\"\n+)\n+\n+const (\n+\tenableProcessedInput            = 0x0001\n+\tenableLineInput                 = 0x0002\n+\tenableEchoInput                 = 0x0004 // Input mode: ENABLE_ECHO_INPUT\n+\tenableVirtualTerminalProcessing = 0x0004 // Output mode: ENABLE_VIRTUAL_TERMINAL_PROCESSING (same value, different mode)\n+\tenableVirtualTerminalInput      = 0x0200\n+)\n+\n+var (\n+\tkernel32                       = syscall.NewLazyDLL(\"kernel32.dll\")\n+\tprocGetConsoleMode             = kernel32.NewProc(\"GetConsoleMode\")\n+\tprocSetConsoleMode             = kernel32.NewProc(\"SetConsoleMode\")\n+\tprocGetConsoleScreenBufferInfo = kernel32.NewProc(\"GetConsoleScreenBufferInfo\")\n+)\n+\n+// ConsoleUnavailableError indicates that Windows console handles are not available\n+// (e.g., in CI environments where stdout/stdin are redirected)\n+type ConsoleUnavailableError struct {\n+\tOperation string\n+\tErr       error\n+}\n+\n+func (e *ConsoleUnavailableError) Error() string {\n+\treturn fmt.Sprintf(\"console unavailable for %s: %v\", e.Operation, e.Err)\n+}\n+\n+func (e *ConsoleUnavailableError) Unwrap() error {\n+\treturn e.Err\n+}\n+\n+type coord struct {\n+\tx, y int16\n+}\n+\n+type smallRect struct {\n+\tleft, top, right, bottom int16\n+}\n+\n+type consoleScreenBufferInfo struct {\n+\tsize              coord\n+\tcursorPosition    coord\n+\tattributes        uint16\n+\twindow            smallRect\n+\tmaximumWindowSize coord\n+}\n+\n+func (c *Client) setupTerminalMode(_ context.Context, session *ssh.Session) error {\n+\tif err := c.saveWindowsConsoleState(); err != nil {\n+\t\tvar consoleErr *ConsoleUnavailableError\n+\t\tif errors.As(err, &consoleErr) {\n+\t\t\tlog.Debugf(\"console unavailable, not requesting PTY: %v\", err)\n+\t\t\treturn nil\n+\t\t}\n+\t\treturn fmt.Errorf(\"save console state: %w\", err)\n+\t}\n+\n+\tif err := c.enableWindowsVirtualTerminal(); err != nil {\n+\t\tvar consoleErr *ConsoleUnavailableError\n+\t\tif errors.As(err, &consoleErr) {\n+\t\t\tlog.Debugf(\"virtual terminal unavailable: %v\", err)\n+\t\t} else {\n+\t\t\treturn fmt.Errorf(\"failed to enable virtual terminal: %w\", err)\n+\t\t}\n+\t}\n+\n+\tw, h := c.getWindowsConsoleSize()\n+\n+\tmodes := ssh.TerminalModes{\n+\t\tssh.ECHO:          1,\n+\t\tssh.TTY_OP_ISPEED: 14400,\n+\t\tssh.TTY_OP_OSPEED: 14400,\n+\t\tssh.ICRNL:         1,\n+\t\tssh.OPOST:         1,\n+\t\tssh.ONLCR:         1,\n+\t\tssh.ISIG:          1,\n+\t\tssh.ICANON:        1,\n+\t\tssh.VINTR:         3,   // Ctrl+C\n+\t\tssh.VQUIT:         28,  // Ctrl+\\\n+\t\tssh.VERASE:        127, // Backspace\n+\t\tssh.VKILL:         21,  // Ctrl+U\n+\t\tssh.VEOF:          4,   // Ctrl+D\n+\t\tssh.VEOL:          0,\n+\t\tssh.VEOL2:         0,\n+\t\tssh.VSTART:        17, // Ctrl+Q\n+\t\tssh.VSTOP:         19, // Ctrl+S\n+\t\tssh.VSUSP:         26, // Ctrl+Z\n+\t\tssh.VDISCARD:      15, // Ctrl+O\n+\t\tssh.VWERASE:       23, // Ctrl+W\n+\t\tssh.VLNEXT:        22, // Ctrl+V\n+\t\tssh.VREPRINT:      18, // Ctrl+R\n+\t}\n+\n+\tif err := session.RequestPty(\"xterm-256color\", h, w, modes); err != nil {\n+\t\tif restoreErr := c.restoreWindowsConsoleState(); restoreErr != nil {\n+\t\t\tlog.Debugf(\"restore Windows console state: %v\", restoreErr)\n+\t\t}\n+\t\treturn fmt.Errorf(\"request pty: %w\", err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+func (c *Client) saveWindowsConsoleState() error {\n+\tdefer func() {\n+\t\tif r := recover(); r != nil {\n+\t\t\tlog.Debugf(\"panic in saveWindowsConsoleState: %v\", r)\n+\t\t}\n+\t}()\n+\n+\tstdout := syscall.Handle(os.Stdout.Fd())\n+\tstdin := syscall.Handle(os.Stdin.Fd())\n+\n+\tvar stdoutMode, stdinMode uint32\n+\n+\tret, _, err := procGetConsoleMode.Call(uintptr(stdout), uintptr(unsafe.Pointer(&stdoutMode)))\n+\tif ret == 0 {\n+\t\tlog.Debugf(\"failed to get stdout console mode: %v\", err)\n+\t\treturn &ConsoleUnavailableError{\n+\t\t\tOperation: \"get stdout console mode\",\n+\t\t\tErr:       err,\n+\t\t}\n+\t}\n+\n+\tret, _, err = procGetConsoleMode.Call(uintptr(stdin), uintptr(unsafe.Pointer(&stdinMode)))\n+\tif ret == 0 {\n+\t\tlog.Debugf(\"failed to get stdin console mode: %v\", err)\n+\t\treturn &ConsoleUnavailableError{\n+\t\t\tOperation: \"get stdin console mode\",\n+\t\t\tErr:       err,\n+\t\t}\n+\t}\n+\n+\tc.terminalFd = 1\n+\tc.windowsStdoutMode = stdoutMode\n+\tc.windowsStdinMode = stdinMode\n+\n+\tlog.Debugf(\"saved Windows console state - stdout: 0x%04x, stdin: 0x%04x\", stdoutMode, stdinMode)\n+\treturn nil\n+}\n+\n+func (c *Client) enableWindowsVirtualTerminal() (err error) {\n+\tdefer func() {\n+\t\tif r := recover(); r != nil {\n+\t\t\terr = fmt.Errorf(\"panic in enableWindowsVirtualTerminal: %v\", r)\n+\t\t}\n+\t}()\n+\n+\tstdout := syscall.Handle(os.Stdout.Fd())\n+\tstdin := syscall.Handle(os.Stdin.Fd())\n+\tvar mode uint32\n+\n+\tret, _, winErr := procGetConsoleMode.Call(uintptr(stdout), uintptr(unsafe.Pointer(&mode)))\n+\tif ret == 0 {\n+\t\treturn &ConsoleUnavailableError{\n+\t\t\tOperation: \"get stdout console mode for VT\",\n+\t\t\tErr:       winErr,\n+\t\t}\n+\t}\n+\n+\tmode |= enableVirtualTerminalProcessing\n+\tret, _, winErr = procSetConsoleMode.Call(uintptr(stdout), uintptr(mode))\n+\tif ret == 0 {\n+\t\treturn &ConsoleUnavailableError{\n+\t\t\tOperation: \"enable virtual terminal processing\",\n+\t\t\tErr:       winErr,\n+\t\t}\n+\t}\n+\n+\tret, _, winErr = procGetConsoleMode.Call(uintptr(stdin), uintptr(unsafe.Pointer(&mode)))\n+\tif ret == 0 {\n+\t\treturn &ConsoleUnavailableError{\n+\t\t\tOperation: \"get stdin console mode for VT\",\n+\t\t\tErr:       winErr,\n+\t\t}\n+\t}\n+\n+\tmode &= ^uint32(enableLineInput | enableEchoInput | enableProcessedInput)\n+\tmode |= enableVirtualTerminalInput\n+\tret, _, winErr = procSetConsoleMode.Call(uintptr(stdin), uintptr(mode))\n+\tif ret == 0 {\n+\t\treturn &ConsoleUnavailableError{\n+\t\t\tOperation: \"set stdin raw mode\",\n+\t\t\tErr:       winErr,\n+\t\t}\n+\t}\n+\n+\tlog.Debugf(\"enabled Windows virtual terminal processing\")\n+\treturn nil\n+}\n+\n+func (c *Client) getWindowsConsoleSize() (int, int) {\n+\tdefer func() {\n+\t\tif r := recover(); r != nil {\n+\t\t\tlog.Debugf(\"panic in getWindowsConsoleSize: %v\", r)\n+\t\t}\n+\t}()\n+\n+\tstdout := syscall.Handle(os.Stdout.Fd())\n+\tvar csbi consoleScreenBufferInfo\n+\n+\tret, _, err := procGetConsoleScreenBufferInfo.Call(uintptr(stdout), uintptr(unsafe.Pointer(&csbi)))\n+\tif ret == 0 {\n+\t\tlog.Debugf(\"failed to get console buffer info, using defaults: %v\", err)\n+\t\treturn 80, 24\n+\t}\n+\n+\twidth := int(csbi.window.right - csbi.window.left + 1)\n+\theight := int(csbi.window.bottom - csbi.window.top + 1)\n+\n+\tlog.Debugf(\"Windows console size: %dx%d\", width, height)\n+\treturn width, height\n+}\n+\n+func (c *Client) restoreWindowsConsoleState() error {\n+\tvar err error\n+\tdefer func() {\n+\t\tif r := recover(); r != nil {\n+\t\t\terr = fmt.Errorf(\"panic in restoreWindowsConsoleState: %v\", r)\n+\t\t}\n+\t}()\n+\n+\tif c.terminalFd != 1 {\n+\t\treturn nil\n+\t}\n+\n+\tstdout := syscall.Handle(os.Stdout.Fd())\n+\tstdin := syscall.Handle(os.Stdin.Fd())\n+\n+\tret, _, winErr := procSetConsoleMode.Call(uintptr(stdout), uintptr(c.windowsStdoutMode))\n+\tif ret == 0 {\n+\t\tlog.Debugf(\"failed to restore stdout console mode: %v\", winErr)\n+\t\tif err == nil {\n+\t\t\terr = fmt.Errorf(\"restore stdout console mode: %w\", winErr)\n+\t\t}\n+\t}\n+\n+\tret, _, winErr = procSetConsoleMode.Call(uintptr(stdin), uintptr(c.windowsStdinMode))\n+\tif ret == 0 {\n+\t\tlog.Debugf(\"failed to restore stdin console mode: %v\", winErr)\n+\t\tif err == nil {\n+\t\t\terr = fmt.Errorf(\"restore stdin console mode: %w\", winErr)\n+\t\t}\n+\t}\n+\n+\tc.terminalFd = 0\n+\tc.windowsStdoutMode = 0\n+\tc.windowsStdinMode = 0\n+\n+\tlog.Debugf(\"restored Windows console state\")\n+\treturn err\n+}\ndiff --git a/client/ssh/common.go b/client/ssh/common.go\nnew file mode 100644\nindex 00000000000..3beb12806d9\n--- /dev/null\n+++ b/client/ssh/common.go\n@@ -0,0 +1,171 @@\n+package ssh\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net\"\n+\t\"time\"\n+\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"golang.org/x/crypto/ssh\"\n+\n+\t\"github.com/netbirdio/netbird/client/proto\"\n+)\n+\n+const (\n+\tNetBirdSSHConfigFile = \"99-netbird.conf\"\n+\n+\tUnixSSHConfigDir    = \"/etc/ssh/ssh_config.d\"\n+\tWindowsSSHConfigDir = \"ssh/ssh_config.d\"\n+)\n+\n+var (\n+\t// ErrPeerNotFound indicates the peer was not found in the network\n+\tErrPeerNotFound = errors.New(\"peer not found in network\")\n+\t// ErrNoStoredKey indicates the peer has no stored SSH host key\n+\tErrNoStoredKey = errors.New(\"peer has no stored SSH host key\")\n+)\n+\n+// HostKeyVerifier provides SSH host key verification\n+type HostKeyVerifier interface {\n+\tVerifySSHHostKey(peerAddress string, key []byte) error\n+}\n+\n+// DaemonHostKeyVerifier implements HostKeyVerifier using the NetBird daemon\n+type DaemonHostKeyVerifier struct {\n+\tclient proto.DaemonServiceClient\n+}\n+\n+// NewDaemonHostKeyVerifier creates a new daemon-based host key verifier\n+func NewDaemonHostKeyVerifier(client proto.DaemonServiceClient) *DaemonHostKeyVerifier {\n+\treturn &DaemonHostKeyVerifier{\n+\t\tclient: client,\n+\t}\n+}\n+\n+// VerifySSHHostKey verifies an SSH host key by querying the NetBird daemon\n+func (d *DaemonHostKeyVerifier) VerifySSHHostKey(peerAddress string, presentedKey []byte) error {\n+\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n+\tdefer cancel()\n+\n+\tresponse, err := d.client.GetPeerSSHHostKey(ctx, &proto.GetPeerSSHHostKeyRequest{\n+\t\tPeerAddress: peerAddress,\n+\t})\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif !response.GetFound() {\n+\t\treturn ErrPeerNotFound\n+\t}\n+\n+\tstoredKeyData := response.GetSshHostKey()\n+\n+\treturn VerifyHostKey(storedKeyData, presentedKey, peerAddress)\n+}\n+\n+// RequestJWTToken requests or retrieves a JWT token for SSH authentication\n+func RequestJWTToken(ctx context.Context, client proto.DaemonServiceClient, stdout, stderr io.Writer, useCache bool, hint string) (string, error) {\n+\treq := &proto.RequestJWTAuthRequest{}\n+\tif hint != \"\" {\n+\t\treq.Hint = &hint\n+\t}\n+\tauthResponse, err := client.RequestJWTAuth(ctx, req)\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"request JWT auth: %w\", err)\n+\t}\n+\n+\tif useCache && authResponse.CachedToken != \"\" {\n+\t\tlog.Debug(\"Using cached authentication token\")\n+\t\treturn authResponse.CachedToken, nil\n+\t}\n+\n+\tif stderr != nil {\n+\t\t_, _ = fmt.Fprintln(stderr, \"SSH authentication required.\")\n+\t\t_, _ = fmt.Fprintf(stderr, \"Please visit: %s\\n\", authResponse.VerificationURIComplete)\n+\t\tif authResponse.UserCode != \"\" {\n+\t\t\t_, _ = fmt.Fprintf(stderr, \"Or visit: %s and enter code: %s\\n\", authResponse.VerificationURI, authResponse.UserCode)\n+\t\t}\n+\t\t_, _ = fmt.Fprintln(stderr, \"Waiting for authentication...\")\n+\t}\n+\n+\ttokenResponse, err := client.WaitJWTToken(ctx, &proto.WaitJWTTokenRequest{\n+\t\tDeviceCode: authResponse.DeviceCode,\n+\t\tUserCode:   authResponse.UserCode,\n+\t})\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"wait for JWT token: %w\", err)\n+\t}\n+\n+\tif stdout != nil {\n+\t\t_, _ = fmt.Fprintln(stdout, \"Authentication successful!\")\n+\t}\n+\treturn tokenResponse.Token, nil\n+}\n+\n+// VerifyHostKey verifies an SSH host key against stored peer key data.\n+// Returns nil only if the presented key matches the stored key.\n+// Returns ErrNoStoredKey if storedKeyData is empty.\n+// Returns an error if the keys don't match or if parsing fails.\n+func VerifyHostKey(storedKeyData []byte, presentedKey []byte, peerAddress string) error {\n+\tif len(storedKeyData) == 0 {\n+\t\treturn ErrNoStoredKey\n+\t}\n+\n+\tstoredPubKey, _, _, _, err := ssh.ParseAuthorizedKey(storedKeyData)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"parse stored SSH key for %s: %w\", peerAddress, err)\n+\t}\n+\n+\tif !bytes.Equal(presentedKey, storedPubKey.Marshal()) {\n+\t\treturn fmt.Errorf(\"SSH host key mismatch for %s\", peerAddress)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// AddJWTAuth prepends JWT password authentication to existing auth methods.\n+// This ensures JWT auth is tried first while preserving any existing auth methods.\n+func AddJWTAuth(config *ssh.ClientConfig, jwtToken string) *ssh.ClientConfig {\n+\tconfigWithJWT := *config\n+\tconfigWithJWT.Auth = append([]ssh.AuthMethod{ssh.Password(jwtToken)}, config.Auth...)\n+\treturn &configWithJWT\n+}\n+\n+// CreateHostKeyCallback creates an SSH host key verification callback using the provided verifier.\n+// It tries multiple addresses (hostname, IP) for the peer before failing.\n+func CreateHostKeyCallback(verifier HostKeyVerifier) ssh.HostKeyCallback {\n+\treturn func(hostname string, remote net.Addr, key ssh.PublicKey) error {\n+\t\taddresses := buildAddressList(hostname, remote)\n+\t\tpresentedKey := key.Marshal()\n+\n+\t\tfor _, addr := range addresses {\n+\t\t\tif err := verifier.VerifySSHHostKey(addr, presentedKey); err != nil {\n+\t\t\t\tif errors.Is(err, ErrPeerNotFound) {\n+\t\t\t\t\t// Try other addresses for this peer\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\t// Verified\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\treturn fmt.Errorf(\"SSH host key verification failed: peer %s not found in network\", hostname)\n+\t}\n+}\n+\n+// buildAddressList creates a list of addresses to check for host key verification.\n+// It includes the original hostname and extracts the host part from the remote address if different.\n+func buildAddressList(hostname string, remote net.Addr) []string {\n+\taddresses := []string{hostname}\n+\tif host, _, err := net.SplitHostPort(remote.String()); err == nil {\n+\t\tif host != hostname {\n+\t\t\taddresses = append(addresses, host)\n+\t\t}\n+\t}\n+\treturn addresses\n+}\ndiff --git a/client/ssh/config/manager.go b/client/ssh/config/manager.go\nnew file mode 100644\nindex 00000000000..03a136de363\n--- /dev/null\n+++ b/client/ssh/config/manager.go\n@@ -0,0 +1,282 @@\n+package config\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\tlog \"github.com/sirupsen/logrus\"\n+\n+\tnbssh \"github.com/netbirdio/netbird/client/ssh\"\n+)\n+\n+const (\n+\tEnvDisableSSHConfig = \"NB_DISABLE_SSH_CONFIG\"\n+\n+\tEnvForceSSHConfig = \"NB_FORCE_SSH_CONFIG\"\n+\n+\tMaxPeersForSSHConfig = 200\n+\n+\tfileWriteTimeout = 2 * time.Second\n+)\n+\n+func isSSHConfigDisabled() bool {\n+\tvalue := os.Getenv(EnvDisableSSHConfig)\n+\tif value == \"\" {\n+\t\treturn false\n+\t}\n+\n+\tdisabled, err := strconv.ParseBool(value)\n+\tif err != nil {\n+\t\treturn true\n+\t}\n+\treturn disabled\n+}\n+\n+func isSSHConfigForced() bool {\n+\tvalue := os.Getenv(EnvForceSSHConfig)\n+\tif value == \"\" {\n+\t\treturn false\n+\t}\n+\n+\tforced, err := strconv.ParseBool(value)\n+\tif err != nil {\n+\t\treturn true\n+\t}\n+\treturn forced\n+}\n+\n+// shouldGenerateSSHConfig checks if SSH config should be generated based on peer count\n+func shouldGenerateSSHConfig(peerCount int) bool {\n+\tif isSSHConfigDisabled() {\n+\t\treturn false\n+\t}\n+\n+\tif isSSHConfigForced() {\n+\t\treturn true\n+\t}\n+\n+\treturn peerCount <= MaxPeersForSSHConfig\n+}\n+\n+// writeFileWithTimeout writes data to a file with a timeout\n+func writeFileWithTimeout(filename string, data []byte, perm os.FileMode) error {\n+\tctx, cancel := context.WithTimeout(context.Background(), fileWriteTimeout)\n+\tdefer cancel()\n+\n+\tdone := make(chan error, 1)\n+\tgo func() {\n+\t\tdone <- os.WriteFile(filename, data, perm)\n+\t}()\n+\n+\tselect {\n+\tcase err := <-done:\n+\t\treturn err\n+\tcase <-ctx.Done():\n+\t\treturn fmt.Errorf(\"file write timeout after %v: %s\", fileWriteTimeout, filename)\n+\t}\n+}\n+\n+// Manager handles SSH client configuration for NetBird peers\n+type Manager struct {\n+\tsshConfigDir  string\n+\tsshConfigFile string\n+}\n+\n+// PeerSSHInfo represents a peer's SSH configuration information\n+type PeerSSHInfo struct {\n+\tHostname string\n+\tIP       string\n+\tFQDN     string\n+}\n+\n+// New creates a new SSH config manager\n+func New() *Manager {\n+\tsshConfigDir := getSystemSSHConfigDir()\n+\treturn &Manager{\n+\t\tsshConfigDir:  sshConfigDir,\n+\t\tsshConfigFile: nbssh.NetBirdSSHConfigFile,\n+\t}\n+}\n+\n+// getSystemSSHConfigDir returns platform-specific SSH configuration directory\n+func getSystemSSHConfigDir() string {\n+\tif runtime.GOOS == \"windows\" {\n+\t\treturn getWindowsSSHConfigDir()\n+\t}\n+\treturn nbssh.UnixSSHConfigDir\n+}\n+\n+func getWindowsSSHConfigDir() string {\n+\tprogramData := os.Getenv(\"PROGRAMDATA\")\n+\tif programData == \"\" {\n+\t\tprogramData = `C:\\ProgramData`\n+\t}\n+\treturn filepath.Join(programData, nbssh.WindowsSSHConfigDir)\n+}\n+\n+// SetupSSHClientConfig creates SSH client configuration for NetBird peers\n+func (m *Manager) SetupSSHClientConfig(peers []PeerSSHInfo) error {\n+\tif !shouldGenerateSSHConfig(len(peers)) {\n+\t\tm.logSkipReason(len(peers))\n+\t\treturn nil\n+\t}\n+\n+\tsshConfig, err := m.buildSSHConfig(peers)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"build SSH config: %w\", err)\n+\t}\n+\treturn m.writeSSHConfig(sshConfig)\n+}\n+\n+func (m *Manager) logSkipReason(peerCount int) {\n+\tif isSSHConfigDisabled() {\n+\t\tlog.Debugf(\"SSH config management disabled via %s\", EnvDisableSSHConfig)\n+\t} else {\n+\t\tlog.Infof(\"SSH config generation skipped: too many peers (%d > %d). Use %s=true to force.\",\n+\t\t\tpeerCount, MaxPeersForSSHConfig, EnvForceSSHConfig)\n+\t}\n+}\n+\n+func (m *Manager) buildSSHConfig(peers []PeerSSHInfo) (string, error) {\n+\tsshConfig := m.buildConfigHeader()\n+\n+\tvar allHostPatterns []string\n+\tfor _, peer := range peers {\n+\t\thostPatterns := m.buildHostPatterns(peer)\n+\t\tallHostPatterns = append(allHostPatterns, hostPatterns...)\n+\t}\n+\n+\tif len(allHostPatterns) > 0 {\n+\t\tpeerConfig, err := m.buildPeerConfig(allHostPatterns)\n+\t\tif err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tsshConfig += peerConfig\n+\t}\n+\n+\treturn sshConfig, nil\n+}\n+\n+func (m *Manager) buildConfigHeader() string {\n+\treturn \"# NetBird SSH client configuration\\n\" +\n+\t\t\"# Generated automatically - do not edit manually\\n\" +\n+\t\t\"#\\n\" +\n+\t\t\"# To disable SSH config management, use:\\n\" +\n+\t\t\"#   netbird service reconfigure --service-env NB_DISABLE_SSH_CONFIG=true\\n\" +\n+\t\t\"#\\n\\n\"\n+}\n+\n+func (m *Manager) buildPeerConfig(allHostPatterns []string) (string, error) {\n+\tuniquePatterns := make(map[string]bool)\n+\tvar deduplicatedPatterns []string\n+\tfor _, pattern := range allHostPatterns {\n+\t\tif !uniquePatterns[pattern] {\n+\t\t\tuniquePatterns[pattern] = true\n+\t\t\tdeduplicatedPatterns = append(deduplicatedPatterns, pattern)\n+\t\t}\n+\t}\n+\n+\texecPath, err := m.getNetBirdExecutablePath()\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"get NetBird executable path: %w\", err)\n+\t}\n+\n+\thostLine := strings.Join(deduplicatedPatterns, \" \")\n+\tconfig := fmt.Sprintf(\"Host %s\\n\", hostLine)\n+\n+\tif runtime.GOOS == \"windows\" {\n+\t\tconfig += fmt.Sprintf(\"    Match exec \\\"%s ssh detect %%h %%p\\\"\\n\", execPath)\n+\t} else {\n+\t\tconfig += fmt.Sprintf(\"    Match exec \\\"%s ssh detect %%h %%p 2>/dev/null\\\"\\n\", execPath)\n+\t}\n+\tconfig += \"        PreferredAuthentications password,publickey,keyboard-interactive\\n\"\n+\tconfig += \"        PasswordAuthentication yes\\n\"\n+\tconfig += \"        PubkeyAuthentication yes\\n\"\n+\tconfig += \"        BatchMode no\\n\"\n+\tconfig += fmt.Sprintf(\"        ProxyCommand %s ssh proxy %%h %%p\\n\", execPath)\n+\tconfig += \"        StrictHostKeyChecking no\\n\"\n+\n+\tif runtime.GOOS == \"windows\" {\n+\t\tconfig += \"        UserKnownHostsFile NUL\\n\"\n+\t} else {\n+\t\tconfig += \"        UserKnownHostsFile /dev/null\\n\"\n+\t}\n+\n+\tconfig += \"        CheckHostIP no\\n\"\n+\tconfig += \"        LogLevel ERROR\\n\\n\"\n+\n+\treturn config, nil\n+}\n+\n+func (m *Manager) buildHostPatterns(peer PeerSSHInfo) []string {\n+\tvar hostPatterns []string\n+\tif peer.IP != \"\" {\n+\t\thostPatterns = append(hostPatterns, peer.IP)\n+\t}\n+\tif peer.FQDN != \"\" {\n+\t\thostPatterns = append(hostPatterns, peer.FQDN)\n+\t}\n+\tif peer.Hostname != \"\" && peer.Hostname != peer.FQDN {\n+\t\thostPatterns = append(hostPatterns, peer.Hostname)\n+\t}\n+\treturn hostPatterns\n+}\n+\n+func (m *Manager) writeSSHConfig(sshConfig string) error {\n+\tsshConfigPath := filepath.Join(m.sshConfigDir, m.sshConfigFile)\n+\n+\tif err := os.MkdirAll(m.sshConfigDir, 0755); err != nil {\n+\t\treturn fmt.Errorf(\"create SSH config directory %s: %w\", m.sshConfigDir, err)\n+\t}\n+\n+\tif err := writeFileWithTimeout(sshConfigPath, []byte(sshConfig), 0644); err != nil {\n+\t\treturn fmt.Errorf(\"write SSH config file %s: %w\", sshConfigPath, err)\n+\t}\n+\n+\tlog.Infof(\"Created NetBird SSH client config: %s\", sshConfigPath)\n+\treturn nil\n+}\n+\n+// RemoveSSHClientConfig removes NetBird SSH configuration\n+func (m *Manager) RemoveSSHClientConfig() error {\n+\tsshConfigPath := filepath.Join(m.sshConfigDir, m.sshConfigFile)\n+\terr := os.Remove(sshConfigPath)\n+\tif err != nil && !os.IsNotExist(err) {\n+\t\treturn fmt.Errorf(\"remove SSH config %s: %w\", sshConfigPath, err)\n+\t}\n+\tif err == nil {\n+\t\tlog.Infof(\"Removed NetBird SSH config: %s\", sshConfigPath)\n+\t}\n+\treturn nil\n+}\n+\n+func (m *Manager) getNetBirdExecutablePath() (string, error) {\n+\texecPath, err := os.Executable()\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"retrieve executable path: %w\", err)\n+\t}\n+\n+\trealPath, err := filepath.EvalSymlinks(execPath)\n+\tif err != nil {\n+\t\tlog.Debugf(\"symlink resolution failed: %v\", err)\n+\t\treturn execPath, nil\n+\t}\n+\n+\treturn realPath, nil\n+}\n+\n+// GetSSHConfigDir returns the SSH config directory path\n+func (m *Manager) GetSSHConfigDir() string {\n+\treturn m.sshConfigDir\n+}\n+\n+// GetSSHConfigFile returns the SSH config file name\n+func (m *Manager) GetSSHConfigFile() string {\n+\treturn m.sshConfigFile\n+}\ndiff --git a/client/ssh/config/shutdown_state.go b/client/ssh/config/shutdown_state.go\nnew file mode 100644\nindex 00000000000..22f0e06781a\n--- /dev/null\n+++ b/client/ssh/config/shutdown_state.go\n@@ -0,0 +1,22 @@\n+package config\n+\n+// ShutdownState represents SSH configuration state that needs to be cleaned up.\n+type ShutdownState struct {\n+\tSSHConfigDir  string\n+\tSSHConfigFile string\n+}\n+\n+// Name returns the state name for the state manager.\n+func (s *ShutdownState) Name() string {\n+\treturn \"ssh_config_state\"\n+}\n+\n+// Cleanup removes SSH client configuration files.\n+func (s *ShutdownState) Cleanup() error {\n+\tmanager := &Manager{\n+\t\tsshConfigDir:  s.SSHConfigDir,\n+\t\tsshConfigFile: s.SSHConfigFile,\n+\t}\n+\n+\treturn manager.RemoveSSHClientConfig()\n+}\ndiff --git a/client/ssh/detection/detection.go b/client/ssh/detection/detection.go\nnew file mode 100644\nindex 00000000000..487f4665a08\n--- /dev/null\n+++ b/client/ssh/detection/detection.go\n@@ -0,0 +1,99 @@\n+package detection\n+\n+import (\n+\t\"bufio\"\n+\t\"context\"\n+\t\"net\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\tlog \"github.com/sirupsen/logrus\"\n+)\n+\n+const (\n+\t// ServerIdentifier is the base response for NetBird SSH servers\n+\tServerIdentifier = \"NetBird-SSH-Server\"\n+\t// ProxyIdentifier is the base response for NetBird SSH proxy\n+\tProxyIdentifier = \"NetBird-SSH-Proxy\"\n+\t// JWTRequiredMarker is appended to responses when JWT is required\n+\tJWTRequiredMarker = \"NetBird-JWT-Required\"\n+\n+\t// Timeout is the timeout for SSH server detection\n+\tTimeout = 5 * time.Second\n+)\n+\n+type ServerType string\n+\n+const (\n+\tServerTypeNetBirdJWT   ServerType = \"netbird-jwt\"\n+\tServerTypeNetBirdNoJWT ServerType = \"netbird-no-jwt\"\n+\tServerTypeRegular      ServerType = \"regular\"\n+)\n+\n+// Dialer provides network connection capabilities\n+type Dialer interface {\n+\tDialContext(ctx context.Context, network, address string) (net.Conn, error)\n+}\n+\n+// RequiresJWT checks if the server type requires JWT authentication\n+func (s ServerType) RequiresJWT() bool {\n+\treturn s == ServerTypeNetBirdJWT\n+}\n+\n+// ExitCode returns the exit code for the detect command\n+func (s ServerType) ExitCode() int {\n+\tswitch s {\n+\tcase ServerTypeNetBirdJWT:\n+\t\treturn 0\n+\tcase ServerTypeNetBirdNoJWT:\n+\t\treturn 1\n+\tcase ServerTypeRegular:\n+\t\treturn 2\n+\tdefault:\n+\t\treturn 2\n+\t}\n+}\n+\n+// DetectSSHServerType detects SSH server type using the provided dialer\n+func DetectSSHServerType(ctx context.Context, dialer Dialer, host string, port int) (ServerType, error) {\n+\ttargetAddr := net.JoinHostPort(host, strconv.Itoa(port))\n+\n+\tconn, err := dialer.DialContext(ctx, \"tcp\", targetAddr)\n+\tif err != nil {\n+\t\tlog.Debugf(\"SSH connection failed for detection: %v\", err)\n+\t\treturn ServerTypeRegular, nil\n+\t}\n+\tdefer conn.Close()\n+\n+\tif err := conn.SetReadDeadline(time.Now().Add(Timeout)); err != nil {\n+\t\tlog.Debugf(\"set read deadline: %v\", err)\n+\t\treturn ServerTypeRegular, nil\n+\t}\n+\n+\treader := bufio.NewReader(conn)\n+\tserverBanner, err := reader.ReadString('\\n')\n+\tif err != nil {\n+\t\tlog.Debugf(\"read SSH banner: %v\", err)\n+\t\treturn ServerTypeRegular, nil\n+\t}\n+\n+\tserverBanner = strings.TrimSpace(serverBanner)\n+\tlog.Debugf(\"SSH server banner: %s\", serverBanner)\n+\n+\tif !strings.HasPrefix(serverBanner, \"SSH-\") {\n+\t\tlog.Debugf(\"Invalid SSH banner\")\n+\t\treturn ServerTypeRegular, nil\n+\t}\n+\n+\tif !strings.Contains(serverBanner, ServerIdentifier) {\n+\t\tlog.Debugf(\"Server banner does not contain identifier '%s'\", ServerIdentifier)\n+\t\treturn ServerTypeRegular, nil\n+\t}\n+\n+\tif strings.Contains(serverBanner, JWTRequiredMarker) {\n+\t\treturn ServerTypeNetBirdJWT, nil\n+\t}\n+\n+\treturn ServerTypeNetBirdNoJWT, nil\n+}\ndiff --git a/client/ssh/login.go b/client/ssh/login.go\ndeleted file mode 100644\nindex cb2615e5537..00000000000\n--- a/client/ssh/login.go\n+++ /dev/null\n@@ -1,53 +0,0 @@\n-//go:build !js\n-\n-package ssh\n-\n-import (\n-\t\"fmt\"\n-\t\"net\"\n-\t\"net/netip\"\n-\t\"os\"\n-\t\"os/exec\"\n-\t\"runtime\"\n-\n-\t\"github.com/netbirdio/netbird/util\"\n-)\n-\n-func isRoot() bool {\n-\treturn os.Geteuid() == 0\n-}\n-\n-func getLoginCmd(user string, remoteAddr net.Addr) (loginPath string, args []string, err error) {\n-\tif !isRoot() {\n-\t\tshell := getUserShell(user)\n-\t\tif shell == \"\" {\n-\t\t\tshell = \"/bin/sh\"\n-\t\t}\n-\n-\t\treturn shell, []string{\"-l\"}, nil\n-\t}\n-\n-\tloginPath, err = exec.LookPath(\"login\")\n-\tif err != nil {\n-\t\treturn \"\", nil, err\n-\t}\n-\n-\taddrPort, err := netip.ParseAddrPort(remoteAddr.String())\n-\tif err != nil {\n-\t\treturn \"\", nil, err\n-\t}\n-\n-\tswitch runtime.GOOS {\n-\tcase \"linux\":\n-\t\tif util.FileExists(\"/etc/arch-release\") && !util.FileExists(\"/etc/pam.d/remote\") {\n-\t\t\treturn loginPath, []string{\"-f\", user, \"-p\"}, nil\n-\t\t}\n-\t\treturn loginPath, []string{\"-f\", user, \"-h\", addrPort.Addr().String(), \"-p\"}, nil\n-\tcase \"darwin\":\n-\t\treturn loginPath, []string{\"-fp\", \"-h\", addrPort.Addr().String(), user}, nil\n-\tcase \"freebsd\":\n-\t\treturn loginPath, []string{\"-f\", user, \"-h\", addrPort.Addr().String(), \"-p\"}, nil\n-\tdefault:\n-\t\treturn \"\", nil, fmt.Errorf(\"unsupported platform: %s\", runtime.GOOS)\n-\t}\n-}\ndiff --git a/client/ssh/lookup.go b/client/ssh/lookup.go\ndeleted file mode 100644\nindex 9a7f6ff2eef..00000000000\n--- a/client/ssh/lookup.go\n+++ /dev/null\n@@ -1,14 +0,0 @@\n-//go:build !darwin\n-// +build !darwin\n-\n-package ssh\n-\n-import \"os/user\"\n-\n-func userNameLookup(username string) (*user.User, error) {\n-\tif username == \"\" || (username == \"root\" && !isRoot()) {\n-\t\treturn user.Current()\n-\t}\n-\n-\treturn user.Lookup(username)\n-}\ndiff --git a/client/ssh/lookup_darwin.go b/client/ssh/lookup_darwin.go\ndeleted file mode 100644\nindex 913d049dcce..00000000000\n--- a/client/ssh/lookup_darwin.go\n+++ /dev/null\n@@ -1,51 +0,0 @@\n-//go:build darwin\n-// +build darwin\n-\n-package ssh\n-\n-import (\n-\t\"bytes\"\n-\t\"fmt\"\n-\t\"os/exec\"\n-\t\"os/user\"\n-\t\"strings\"\n-)\n-\n-func userNameLookup(username string) (*user.User, error) {\n-\tif username == \"\" || (username == \"root\" && !isRoot()) {\n-\t\treturn user.Current()\n-\t}\n-\n-\tvar userObject *user.User\n-\tuserObject, err := user.Lookup(username)\n-\tif err != nil && err.Error() == user.UnknownUserError(username).Error() {\n-\t\treturn idUserNameLookup(username)\n-\t} else if err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\treturn userObject, nil\n-}\n-\n-func idUserNameLookup(username string) (*user.User, error) {\n-\tcmd := exec.Command(\"id\", \"-P\", username)\n-\tout, err := cmd.CombinedOutput()\n-\tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"error while retrieving user with id -P command, error: %v\", err)\n-\t}\n-\tcolon := \":\"\n-\n-\tif !bytes.Contains(out, []byte(username+colon)) {\n-\t\treturn nil, fmt.Errorf(\"unable to find user in returned string\")\n-\t}\n-\t// netbird:********:501:20::0:0:netbird:/Users/netbird:/bin/zsh\n-\tparts := strings.SplitN(string(out), colon, 10)\n-\tuserObject := &user.User{\n-\t\tUsername: parts[0],\n-\t\tUid:      parts[2],\n-\t\tGid:      parts[3],\n-\t\tName:     parts[7],\n-\t\tHomeDir:  parts[8],\n-\t}\n-\treturn userObject, nil\n-}\ndiff --git a/client/ssh/proxy/proxy.go b/client/ssh/proxy/proxy.go\nnew file mode 100644\nindex 00000000000..bc8a84b89b2\n--- /dev/null\n+++ b/client/ssh/proxy/proxy.go\n@@ -0,0 +1,392 @@\n+package proxy\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net\"\n+\t\"os\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\tcryptossh \"golang.org/x/crypto/ssh\"\n+\t\"google.golang.org/grpc\"\n+\t\"google.golang.org/grpc/credentials/insecure\"\n+\n+\t\"github.com/netbirdio/netbird/client/internal/profilemanager\"\n+\t\"github.com/netbirdio/netbird/client/proto\"\n+\tnbssh \"github.com/netbirdio/netbird/client/ssh\"\n+\t\"github.com/netbirdio/netbird/client/ssh/detection\"\n+\t\"github.com/netbirdio/netbird/version\"\n+)\n+\n+const (\n+\t// sshConnectionTimeout is the timeout for SSH TCP connection establishment\n+\tsshConnectionTimeout = 120 * time.Second\n+\t// sshHandshakeTimeout is the timeout for SSH handshake completion\n+\tsshHandshakeTimeout = 30 * time.Second\n+\n+\tjwtAuthErrorMsg = \"JWT authentication: %w\"\n+)\n+\n+type SSHProxy struct {\n+\tdaemonAddr   string\n+\ttargetHost   string\n+\ttargetPort   int\n+\tstderr       io.Writer\n+\tconn         *grpc.ClientConn\n+\tdaemonClient proto.DaemonServiceClient\n+}\n+\n+func New(daemonAddr, targetHost string, targetPort int, stderr io.Writer) (*SSHProxy, error) {\n+\tgrpcAddr := strings.TrimPrefix(daemonAddr, \"tcp://\")\n+\tgrpcConn, err := grpc.NewClient(grpcAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"connect to daemon: %w\", err)\n+\t}\n+\n+\treturn &SSHProxy{\n+\t\tdaemonAddr:   daemonAddr,\n+\t\ttargetHost:   targetHost,\n+\t\ttargetPort:   targetPort,\n+\t\tstderr:       stderr,\n+\t\tconn:         grpcConn,\n+\t\tdaemonClient: proto.NewDaemonServiceClient(grpcConn),\n+\t}, nil\n+}\n+\n+func (p *SSHProxy) Close() error {\n+\tif p.conn != nil {\n+\t\treturn p.conn.Close()\n+\t}\n+\treturn nil\n+}\n+\n+func (p *SSHProxy) Connect(ctx context.Context) error {\n+\thint := profilemanager.GetLoginHint()\n+\n+\tjwtToken, err := nbssh.RequestJWTToken(ctx, p.daemonClient, nil, p.stderr, true, hint)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(jwtAuthErrorMsg, err)\n+\t}\n+\n+\treturn p.runProxySSHServer(ctx, jwtToken)\n+}\n+\n+func (p *SSHProxy) runProxySSHServer(ctx context.Context, jwtToken string) error {\n+\tserverVersion := fmt.Sprintf(\"%s-%s\", detection.ProxyIdentifier, version.NetbirdVersion())\n+\n+\tsshServer := &ssh.Server{\n+\t\tHandler: func(s ssh.Session) {\n+\t\t\tp.handleSSHSession(ctx, s, jwtToken)\n+\t\t},\n+\t\tChannelHandlers: map[string]ssh.ChannelHandler{\n+\t\t\t\"session\":      ssh.DefaultSessionHandler,\n+\t\t\t\"direct-tcpip\": p.directTCPIPHandler,\n+\t\t},\n+\t\tSubsystemHandlers: map[string]ssh.SubsystemHandler{\n+\t\t\t\"sftp\": func(s ssh.Session) {\n+\t\t\t\tp.sftpSubsystemHandler(s, jwtToken)\n+\t\t\t},\n+\t\t},\n+\t\tRequestHandlers: map[string]ssh.RequestHandler{\n+\t\t\t\"tcpip-forward\":        p.tcpipForwardHandler,\n+\t\t\t\"cancel-tcpip-forward\": p.cancelTcpipForwardHandler,\n+\t\t},\n+\t\tVersion: serverVersion,\n+\t}\n+\n+\thostKey, err := generateHostKey()\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"generate host key: %w\", err)\n+\t}\n+\tsshServer.HostSigners = []ssh.Signer{hostKey}\n+\n+\tconn := &stdioConn{\n+\t\tstdin:  os.Stdin,\n+\t\tstdout: os.Stdout,\n+\t}\n+\n+\tsshServer.HandleConn(conn)\n+\n+\treturn nil\n+}\n+\n+func (p *SSHProxy) handleSSHSession(ctx context.Context, session ssh.Session, jwtToken string) {\n+\ttargetAddr := net.JoinHostPort(p.targetHost, strconv.Itoa(p.targetPort))\n+\n+\tsshClient, err := p.dialBackend(ctx, targetAddr, session.User(), jwtToken)\n+\tif err != nil {\n+\t\t_, _ = fmt.Fprintf(p.stderr, \"SSH connection to NetBird server failed: %v\\n\", err)\n+\t\treturn\n+\t}\n+\tdefer func() { _ = sshClient.Close() }()\n+\n+\tserverSession, err := sshClient.NewSession()\n+\tif err != nil {\n+\t\t_, _ = fmt.Fprintf(p.stderr, \"create server session: %v\\n\", err)\n+\t\treturn\n+\t}\n+\tdefer func() { _ = serverSession.Close() }()\n+\n+\tserverSession.Stdin = session\n+\tserverSession.Stdout = session\n+\tserverSession.Stderr = session.Stderr()\n+\n+\tptyReq, winCh, isPty := session.Pty()\n+\tif isPty {\n+\t\tif err := serverSession.RequestPty(ptyReq.Term, ptyReq.Window.Width, ptyReq.Window.Height, nil); err != nil {\n+\t\t\tlog.Debugf(\"PTY request to backend: %v\", err)\n+\t\t}\n+\n+\t\tgo func() {\n+\t\t\tfor win := range winCh {\n+\t\t\t\tif err := serverSession.WindowChange(win.Height, win.Width); err != nil {\n+\t\t\t\t\tlog.Debugf(\"window change: %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}()\n+\t}\n+\n+\tif len(session.Command()) > 0 {\n+\t\tif err := serverSession.Run(strings.Join(session.Command(), \" \")); err != nil {\n+\t\t\tlog.Debugf(\"run command: %v\", err)\n+\t\t\tp.handleProxyExitCode(session, err)\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tif err = serverSession.Shell(); err != nil {\n+\t\tlog.Debugf(\"start shell: %v\", err)\n+\t\treturn\n+\t}\n+\tif err := serverSession.Wait(); err != nil {\n+\t\tlog.Debugf(\"session wait: %v\", err)\n+\t\tp.handleProxyExitCode(session, err)\n+\t}\n+}\n+\n+func (p *SSHProxy) handleProxyExitCode(session ssh.Session, err error) {\n+\tvar exitErr *cryptossh.ExitError\n+\tif errors.As(err, &exitErr) {\n+\t\tif exitErr := session.Exit(exitErr.ExitStatus()); exitErr != nil {\n+\t\t\tlog.Debugf(\"set exit status: %v\", exitErr)\n+\t\t}\n+\t}\n+}\n+\n+func generateHostKey() (ssh.Signer, error) {\n+\tkeyPEM, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"generate ED25519 key: %w\", err)\n+\t}\n+\n+\tsigner, err := cryptossh.ParsePrivateKey(keyPEM)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"parse private key: %w\", err)\n+\t}\n+\n+\treturn signer, nil\n+}\n+\n+type stdioConn struct {\n+\tstdin  io.Reader\n+\tstdout io.Writer\n+\tclosed bool\n+\tmu     sync.Mutex\n+}\n+\n+func (c *stdioConn) Read(b []byte) (n int, err error) {\n+\tc.mu.Lock()\n+\tif c.closed {\n+\t\tc.mu.Unlock()\n+\t\treturn 0, io.EOF\n+\t}\n+\tc.mu.Unlock()\n+\treturn c.stdin.Read(b)\n+}\n+\n+func (c *stdioConn) Write(b []byte) (n int, err error) {\n+\tc.mu.Lock()\n+\tif c.closed {\n+\t\tc.mu.Unlock()\n+\t\treturn 0, io.ErrClosedPipe\n+\t}\n+\tc.mu.Unlock()\n+\treturn c.stdout.Write(b)\n+}\n+\n+func (c *stdioConn) Close() error {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\tc.closed = true\n+\treturn nil\n+}\n+\n+func (c *stdioConn) LocalAddr() net.Addr {\n+\treturn &net.UnixAddr{Name: \"stdio\", Net: \"unix\"}\n+}\n+\n+func (c *stdioConn) RemoteAddr() net.Addr {\n+\treturn &net.UnixAddr{Name: \"stdio\", Net: \"unix\"}\n+}\n+\n+func (c *stdioConn) SetDeadline(_ time.Time) error {\n+\treturn nil\n+}\n+\n+func (c *stdioConn) SetReadDeadline(_ time.Time) error {\n+\treturn nil\n+}\n+\n+func (c *stdioConn) SetWriteDeadline(_ time.Time) error {\n+\treturn nil\n+}\n+\n+func (p *SSHProxy) directTCPIPHandler(_ *ssh.Server, _ *cryptossh.ServerConn, newChan cryptossh.NewChannel, _ ssh.Context) {\n+\t_ = newChan.Reject(cryptossh.Prohibited, \"port forwarding not supported in proxy\")\n+}\n+\n+func (p *SSHProxy) sftpSubsystemHandler(s ssh.Session, jwtToken string) {\n+\tctx, cancel := context.WithCancel(s.Context())\n+\tdefer cancel()\n+\n+\ttargetAddr := net.JoinHostPort(p.targetHost, strconv.Itoa(p.targetPort))\n+\n+\tsshClient, err := p.dialBackend(ctx, targetAddr, s.User(), jwtToken)\n+\tif err != nil {\n+\t\t_, _ = fmt.Fprintf(s, \"SSH connection failed: %v\\n\", err)\n+\t\t_ = s.Exit(1)\n+\t\treturn\n+\t}\n+\tdefer func() {\n+\t\tif err := sshClient.Close(); err != nil {\n+\t\t\tlog.Debugf(\"close SSH client: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tserverSession, err := sshClient.NewSession()\n+\tif err != nil {\n+\t\t_, _ = fmt.Fprintf(s, \"create server session: %v\\n\", err)\n+\t\t_ = s.Exit(1)\n+\t\treturn\n+\t}\n+\tdefer func() {\n+\t\tif err := serverSession.Close(); err != nil {\n+\t\t\tlog.Debugf(\"close server session: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tstdin, stdout, err := p.setupSFTPPipes(serverSession)\n+\tif err != nil {\n+\t\tlog.Debugf(\"setup SFTP pipes: %v\", err)\n+\t\t_ = s.Exit(1)\n+\t\treturn\n+\t}\n+\n+\tif err := serverSession.RequestSubsystem(\"sftp\"); err != nil {\n+\t\t_, _ = fmt.Fprintf(s, \"SFTP subsystem request failed: %v\\n\", err)\n+\t\t_ = s.Exit(1)\n+\t\treturn\n+\t}\n+\n+\tp.runSFTPBridge(ctx, s, stdin, stdout, serverSession)\n+}\n+\n+func (p *SSHProxy) setupSFTPPipes(serverSession *cryptossh.Session) (io.WriteCloser, io.Reader, error) {\n+\tstdin, err := serverSession.StdinPipe()\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"get stdin pipe: %w\", err)\n+\t}\n+\n+\tstdout, err := serverSession.StdoutPipe()\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"get stdout pipe: %w\", err)\n+\t}\n+\n+\treturn stdin, stdout, nil\n+}\n+\n+func (p *SSHProxy) runSFTPBridge(ctx context.Context, s ssh.Session, stdin io.WriteCloser, stdout io.Reader, serverSession *cryptossh.Session) {\n+\tcopyErrCh := make(chan error, 2)\n+\n+\tgo func() {\n+\t\t_, err := io.Copy(stdin, s)\n+\t\tif err != nil {\n+\t\t\tlog.Debugf(\"SFTP client to server copy: %v\", err)\n+\t\t}\n+\t\tif err := stdin.Close(); err != nil {\n+\t\t\tlog.Debugf(\"close stdin: %v\", err)\n+\t\t}\n+\t\tcopyErrCh <- err\n+\t}()\n+\n+\tgo func() {\n+\t\t_, err := io.Copy(s, stdout)\n+\t\tif err != nil {\n+\t\t\tlog.Debugf(\"SFTP server to client copy: %v\", err)\n+\t\t}\n+\t\tcopyErrCh <- err\n+\t}()\n+\n+\tgo func() {\n+\t\t<-ctx.Done()\n+\t\tif err := serverSession.Close(); err != nil {\n+\t\t\tlog.Debugf(\"force close server session on context cancellation: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tfor i := 0; i < 2; i++ {\n+\t\tif err := <-copyErrCh; err != nil && !errors.Is(err, io.EOF) {\n+\t\t\tlog.Debugf(\"SFTP copy error: %v\", err)\n+\t\t}\n+\t}\n+\n+\tif err := serverSession.Wait(); err != nil {\n+\t\tlog.Debugf(\"SFTP session ended: %v\", err)\n+\t}\n+}\n+\n+func (p *SSHProxy) tcpipForwardHandler(_ ssh.Context, _ *ssh.Server, _ *cryptossh.Request) (bool, []byte) {\n+\treturn false, []byte(\"port forwarding not supported in proxy\")\n+}\n+\n+func (p *SSHProxy) cancelTcpipForwardHandler(_ ssh.Context, _ *ssh.Server, _ *cryptossh.Request) (bool, []byte) {\n+\treturn true, nil\n+}\n+\n+func (p *SSHProxy) dialBackend(ctx context.Context, addr, user, jwtToken string) (*cryptossh.Client, error) {\n+\tconfig := &cryptossh.ClientConfig{\n+\t\tUser:            user,\n+\t\tAuth:            []cryptossh.AuthMethod{cryptossh.Password(jwtToken)},\n+\t\tTimeout:         sshHandshakeTimeout,\n+\t\tHostKeyCallback: p.verifyHostKey,\n+\t}\n+\n+\tdialer := &net.Dialer{\n+\t\tTimeout: sshConnectionTimeout,\n+\t}\n+\tconn, err := dialer.DialContext(ctx, \"tcp\", addr)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"connect to server: %w\", err)\n+\t}\n+\n+\tclientConn, chans, reqs, err := cryptossh.NewClientConn(conn, addr, config)\n+\tif err != nil {\n+\t\t_ = conn.Close()\n+\t\treturn nil, fmt.Errorf(\"SSH handshake: %w\", err)\n+\t}\n+\n+\treturn cryptossh.NewClient(clientConn, chans, reqs), nil\n+}\n+\n+func (p *SSHProxy) verifyHostKey(hostname string, remote net.Addr, key cryptossh.PublicKey) error {\n+\tverifier := nbssh.NewDaemonHostKeyVerifier(p.daemonClient)\n+\tcallback := nbssh.CreateHostKeyCallback(verifier)\n+\treturn callback(hostname, remote, key)\n+}\ndiff --git a/client/ssh/server.go b/client/ssh/server.go\ndeleted file mode 100644\nindex 8c5db2547cd..00000000000\n--- a/client/ssh/server.go\n+++ /dev/null\n@@ -1,280 +0,0 @@\n-//go:build !js\n-\n-package ssh\n-\n-import (\n-\t\"fmt\"\n-\t\"io\"\n-\t\"net\"\n-\t\"os\"\n-\t\"os/exec\"\n-\t\"os/user\"\n-\t\"runtime\"\n-\t\"strings\"\n-\t\"sync\"\n-\t\"time\"\n-\n-\t\"github.com/creack/pty\"\n-\t\"github.com/gliderlabs/ssh\"\n-\tlog \"github.com/sirupsen/logrus\"\n-)\n-\n-// DefaultSSHPort is the default SSH port of the NetBird's embedded SSH server\n-const DefaultSSHPort = 44338\n-\n-// TerminalTimeout is the timeout for terminal session to be ready\n-const TerminalTimeout = 10 * time.Second\n-\n-// TerminalBackoffDelay is the delay between terminal session readiness checks\n-const TerminalBackoffDelay = 500 * time.Millisecond\n-\n-// DefaultSSHServer is a function that creates DefaultServer\n-func DefaultSSHServer(hostKeyPEM []byte, addr string) (Server, error) {\n-\treturn newDefaultServer(hostKeyPEM, addr)\n-}\n-\n-// Server is an interface of SSH server\n-type Server interface {\n-\t// Stop stops SSH server.\n-\tStop() error\n-\t// Start starts SSH server. Blocking\n-\tStart() error\n-\t// RemoveAuthorizedKey removes SSH key of a given peer from the authorized keys\n-\tRemoveAuthorizedKey(peer string)\n-\t// AddAuthorizedKey add a given peer key to server authorized keys\n-\tAddAuthorizedKey(peer, newKey string) error\n-}\n-\n-// DefaultServer is the embedded NetBird SSH server\n-type DefaultServer struct {\n-\tlistener net.Listener\n-\t// authorizedKeys is ssh pub key indexed by peer WireGuard public key\n-\tauthorizedKeys map[string]ssh.PublicKey\n-\tmu             sync.Mutex\n-\thostKeyPEM     []byte\n-\tsessions       []ssh.Session\n-}\n-\n-// newDefaultServer creates new server with provided host key\n-func newDefaultServer(hostKeyPEM []byte, addr string) (*DefaultServer, error) {\n-\tln, err := net.Listen(\"tcp\", addr)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tallowedKeys := make(map[string]ssh.PublicKey)\n-\treturn &DefaultServer{listener: ln, mu: sync.Mutex{}, hostKeyPEM: hostKeyPEM, authorizedKeys: allowedKeys, sessions: make([]ssh.Session, 0)}, nil\n-}\n-\n-// RemoveAuthorizedKey removes SSH key of a given peer from the authorized keys\n-func (srv *DefaultServer) RemoveAuthorizedKey(peer string) {\n-\tsrv.mu.Lock()\n-\tdefer srv.mu.Unlock()\n-\n-\tdelete(srv.authorizedKeys, peer)\n-}\n-\n-// AddAuthorizedKey add a given peer key to server authorized keys\n-func (srv *DefaultServer) AddAuthorizedKey(peer, newKey string) error {\n-\tsrv.mu.Lock()\n-\tdefer srv.mu.Unlock()\n-\n-\tparsedKey, _, _, _, err := ssh.ParseAuthorizedKey([]byte(newKey))\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\tsrv.authorizedKeys[peer] = parsedKey\n-\treturn nil\n-}\n-\n-// Stop stops SSH server.\n-func (srv *DefaultServer) Stop() error {\n-\tsrv.mu.Lock()\n-\tdefer srv.mu.Unlock()\n-\terr := srv.listener.Close()\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tfor _, session := range srv.sessions {\n-\t\terr := session.Close()\n-\t\tif err != nil {\n-\t\t\tlog.Warnf(\"failed closing SSH session from %v\", err)\n-\t\t}\n-\t}\n-\n-\treturn nil\n-}\n-\n-func (srv *DefaultServer) publicKeyHandler(ctx ssh.Context, key ssh.PublicKey) bool {\n-\tsrv.mu.Lock()\n-\tdefer srv.mu.Unlock()\n-\n-\tfor _, allowed := range srv.authorizedKeys {\n-\t\tif ssh.KeysEqual(allowed, key) {\n-\t\t\treturn true\n-\t\t}\n-\t}\n-\n-\treturn false\n-}\n-\n-func prepareUserEnv(user *user.User, shell string) []string {\n-\treturn []string{\n-\t\tfmt.Sprint(\"SHELL=\" + shell),\n-\t\tfmt.Sprint(\"USER=\" + user.Username),\n-\t\tfmt.Sprint(\"HOME=\" + user.HomeDir),\n-\t}\n-}\n-\n-func acceptEnv(s string) bool {\n-\tsplit := strings.Split(s, \"=\")\n-\tif len(split) != 2 {\n-\t\treturn false\n-\t}\n-\treturn split[0] == \"TERM\" || split[0] == \"LANG\" || strings.HasPrefix(split[0], \"LC_\")\n-}\n-\n-// sessionHandler handles SSH session post auth\n-func (srv *DefaultServer) sessionHandler(session ssh.Session) {\n-\tsrv.mu.Lock()\n-\tsrv.sessions = append(srv.sessions, session)\n-\tsrv.mu.Unlock()\n-\n-\tdefer func() {\n-\t\terr := session.Close()\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t}()\n-\n-\tlog.Infof(\"Establishing SSH session for %s from host %s\", session.User(), session.RemoteAddr().String())\n-\n-\tlocalUser, err := userNameLookup(session.User())\n-\tif err != nil {\n-\t\t_, err = fmt.Fprintf(session, \"remote SSH server couldn't find local user %s\\n\", session.User()) //nolint\n-\t\terr = session.Exit(1)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tlog.Warnf(\"failed SSH session from %v, user %s\", session.RemoteAddr(), session.User())\n-\t\treturn\n-\t}\n-\n-\tptyReq, winCh, isPty := session.Pty()\n-\tif isPty {\n-\t\tloginCmd, loginArgs, err := getLoginCmd(localUser.Username, session.RemoteAddr())\n-\t\tif err != nil {\n-\t\t\tlog.Warnf(\"failed logging-in user %s from remote IP %s\", localUser.Username, session.RemoteAddr().String())\n-\t\t\treturn\n-\t\t}\n-\t\tcmd := exec.Command(loginCmd, loginArgs...)\n-\t\tgo func() {\n-\t\t\t<-session.Context().Done()\n-\t\t\tif cmd.Process == nil {\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\terr := cmd.Process.Kill()\n-\t\t\tif err != nil {\n-\t\t\t\tlog.Debugf(\"failed killing SSH process %v\", err)\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t}()\n-\t\tcmd.Dir = localUser.HomeDir\n-\t\tcmd.Env = append(cmd.Env, fmt.Sprintf(\"TERM=%s\", ptyReq.Term))\n-\t\tcmd.Env = append(cmd.Env, prepareUserEnv(localUser, getUserShell(localUser.Uid))...)\n-\t\tfor _, v := range session.Environ() {\n-\t\t\tif acceptEnv(v) {\n-\t\t\t\tcmd.Env = append(cmd.Env, v)\n-\t\t\t}\n-\t\t}\n-\n-\t\tlog.Debugf(\"Login command: %s\", cmd.String())\n-\t\tfile, err := pty.Start(cmd)\n-\t\tif err != nil {\n-\t\t\tlog.Errorf(\"failed starting SSH server: %v\", err)\n-\t\t}\n-\n-\t\tgo func() {\n-\t\t\tfor win := range winCh {\n-\t\t\t\tsetWinSize(file, win.Width, win.Height)\n-\t\t\t}\n-\t\t}()\n-\n-\t\tsrv.stdInOut(file, session)\n-\n-\t\terr = cmd.Wait()\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t} else {\n-\t\t_, err := io.WriteString(session, \"only PTY is supported.\\n\")\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\terr = session.Exit(1)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t}\n-\tlog.Debugf(\"SSH session ended\")\n-}\n-\n-func (srv *DefaultServer) stdInOut(file *os.File, session ssh.Session) {\n-\tgo func() {\n-\t\t// stdin\n-\t\t_, err := io.Copy(file, session)\n-\t\tif err != nil {\n-\t\t\t_ = session.Exit(1)\n-\t\t\treturn\n-\t\t}\n-\t}()\n-\n-\t// AWS Linux 2 machines need some time to open the terminal so we need to wait for it\n-\ttimer := time.NewTimer(TerminalTimeout)\n-\tfor {\n-\t\tselect {\n-\t\tcase <-timer.C:\n-\t\t\t_, _ = session.Write([]byte(\"Reached timeout while opening connection\\n\"))\n-\t\t\t_ = session.Exit(1)\n-\t\t\treturn\n-\t\tdefault:\n-\t\t\t// stdout\n-\t\t\twrittenBytes, err := io.Copy(session, file)\n-\t\t\tif err != nil && writtenBytes != 0 {\n-\t\t\t\t_ = session.Exit(0)\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\ttime.Sleep(TerminalBackoffDelay)\n-\t\t}\n-\t}\n-}\n-\n-// Start starts SSH server. Blocking\n-func (srv *DefaultServer) Start() error {\n-\tlog.Infof(\"starting SSH server on addr: %s\", srv.listener.Addr().String())\n-\n-\tpublicKeyOption := ssh.PublicKeyAuth(srv.publicKeyHandler)\n-\thostKeyPEM := ssh.HostKeyPEM(srv.hostKeyPEM)\n-\terr := ssh.Serve(srv.listener, srv.sessionHandler, publicKeyOption, hostKeyPEM)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\treturn nil\n-}\n-\n-func getUserShell(userID string) string {\n-\tif runtime.GOOS == \"linux\" {\n-\t\toutput, _ := exec.Command(\"getent\", \"passwd\", userID).Output()\n-\t\tline := strings.SplitN(string(output), \":\", 10)\n-\t\tif len(line) > 6 {\n-\t\t\treturn strings.TrimSpace(line[6])\n-\t\t}\n-\t}\n-\n-\tshell := os.Getenv(\"SHELL\")\n-\tif shell == \"\" {\n-\t\tshell = \"/bin/sh\"\n-\t}\n-\treturn shell\n-}\ndiff --git a/client/ssh/server/command_execution.go b/client/ssh/server/command_execution.go\nnew file mode 100644\nindex 00000000000..7a01ce4f665\n--- /dev/null\n+++ b/client/ssh/server/command_execution.go\n@@ -0,0 +1,206 @@\n+package server\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"time\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+)\n+\n+// handleCommand executes an SSH command with privilege validation\n+func (s *Server) handleCommand(logger *log.Entry, session ssh.Session, privilegeResult PrivilegeCheckResult, winCh <-chan ssh.Window) {\n+\thasPty := winCh != nil\n+\n+\tcommandType := \"command\"\n+\tif hasPty {\n+\t\tcommandType = \"Pty command\"\n+\t}\n+\n+\tlogger.Infof(\"executing %s: %s\", commandType, safeLogCommand(session.Command()))\n+\n+\texecCmd, cleanup, err := s.createCommand(privilegeResult, session, hasPty)\n+\tif err != nil {\n+\t\tlogger.Errorf(\"%s creation failed: %v\", commandType, err)\n+\n+\t\terrorMsg := fmt.Sprintf(\"Cannot create %s - platform may not support user switching\", commandType)\n+\t\tif hasPty {\n+\t\t\terrorMsg += \" with Pty\"\n+\t\t}\n+\t\terrorMsg += \"\\n\"\n+\n+\t\tif _, writeErr := fmt.Fprint(session.Stderr(), errorMsg); writeErr != nil {\n+\t\t\tlogger.Debugf(errWriteSession, writeErr)\n+\t\t}\n+\t\tif err := session.Exit(1); err != nil {\n+\t\t\tlogSessionExitError(logger, err)\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tif !hasPty {\n+\t\tif s.executeCommand(logger, session, execCmd, cleanup) {\n+\t\t\tlogger.Debugf(\"%s execution completed\", commandType)\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tdefer cleanup()\n+\n+\tptyReq, _, _ := session.Pty()\n+\tif s.executeCommandWithPty(logger, session, execCmd, privilegeResult, ptyReq, winCh) {\n+\t\tlogger.Debugf(\"%s execution completed\", commandType)\n+\t}\n+}\n+\n+func (s *Server) createCommand(privilegeResult PrivilegeCheckResult, session ssh.Session, hasPty bool) (*exec.Cmd, func(), error) {\n+\tlocalUser := privilegeResult.User\n+\tif localUser == nil {\n+\t\treturn nil, nil, errors.New(\"no user in privilege result\")\n+\t}\n+\n+\t// If PTY requested but su doesn't support --pty, skip su and use executor\n+\t// This ensures PTY functionality is provided (executor runs within our allocated PTY)\n+\tif hasPty && !s.suSupportsPty {\n+\t\tlog.Debugf(\"PTY requested but su doesn't support --pty, using executor for PTY functionality\")\n+\t\tcmd, cleanup, err := s.createExecutorCommand(session, localUser, hasPty)\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"create command with privileges: %w\", err)\n+\t\t}\n+\t\tcmd.Env = s.prepareCommandEnv(localUser, session)\n+\t\treturn cmd, cleanup, nil\n+\t}\n+\n+\t// Try su first for system integration (PAM/audit) when privileged\n+\tcmd, err := s.createSuCommand(session, localUser, hasPty)\n+\tif err != nil || privilegeResult.UsedFallback {\n+\t\tlog.Debugf(\"su command failed, falling back to executor: %v\", err)\n+\t\tcmd, cleanup, err := s.createExecutorCommand(session, localUser, hasPty)\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, fmt.Errorf(\"create command with privileges: %w\", err)\n+\t\t}\n+\t\tcmd.Env = s.prepareCommandEnv(localUser, session)\n+\t\treturn cmd, cleanup, nil\n+\t}\n+\n+\tcmd.Env = s.prepareCommandEnv(localUser, session)\n+\treturn cmd, func() {}, nil\n+}\n+\n+// executeCommand executes the command and handles I/O and exit codes\n+func (s *Server) executeCommand(logger *log.Entry, session ssh.Session, execCmd *exec.Cmd, cleanup func()) bool {\n+\tdefer cleanup()\n+\n+\ts.setupProcessGroup(execCmd)\n+\n+\tstdinPipe, err := execCmd.StdinPipe()\n+\tif err != nil {\n+\t\tlogger.Errorf(\"create stdin pipe: %v\", err)\n+\t\tif err := session.Exit(1); err != nil {\n+\t\t\tlogSessionExitError(logger, err)\n+\t\t}\n+\t\treturn false\n+\t}\n+\n+\texecCmd.Stdout = session\n+\texecCmd.Stderr = session.Stderr()\n+\n+\tif execCmd.Dir != \"\" {\n+\t\tif _, err := os.Stat(execCmd.Dir); err != nil {\n+\t\t\tlogger.Warnf(\"working directory does not exist: %s (%v)\", execCmd.Dir, err)\n+\t\t\texecCmd.Dir = \"/\"\n+\t\t}\n+\t}\n+\n+\tif err := execCmd.Start(); err != nil {\n+\t\tlogger.Errorf(\"command start failed: %v\", err)\n+\t\t// no user message for exec failure, just exit\n+\t\tif err := session.Exit(1); err != nil {\n+\t\t\tlogSessionExitError(logger, err)\n+\t\t}\n+\t\treturn false\n+\t}\n+\n+\tgo s.handleCommandIO(logger, stdinPipe, session)\n+\treturn s.waitForCommandCleanup(logger, session, execCmd)\n+}\n+\n+// handleCommandIO manages stdin/stdout copying in a goroutine\n+func (s *Server) handleCommandIO(logger *log.Entry, stdinPipe io.WriteCloser, session ssh.Session) {\n+\tdefer func() {\n+\t\tif err := stdinPipe.Close(); err != nil {\n+\t\t\tlogger.Debugf(\"stdin pipe close error: %v\", err)\n+\t\t}\n+\t}()\n+\tif _, err := io.Copy(stdinPipe, session); err != nil {\n+\t\tlogger.Debugf(\"stdin copy error: %v\", err)\n+\t}\n+}\n+\n+// waitForCommandCleanup waits for command completion with session disconnect handling\n+func (s *Server) waitForCommandCleanup(logger *log.Entry, session ssh.Session, execCmd *exec.Cmd) bool {\n+\tctx := session.Context()\n+\tdone := make(chan error, 1)\n+\tgo func() {\n+\t\tdone <- execCmd.Wait()\n+\t}()\n+\n+\tselect {\n+\tcase <-ctx.Done():\n+\t\tlogger.Debugf(\"session cancelled, terminating command\")\n+\t\ts.killProcessGroup(execCmd)\n+\n+\t\tselect {\n+\t\tcase err := <-done:\n+\t\t\tlogger.Tracef(\"command terminated after session cancellation: %v\", err)\n+\t\tcase <-time.After(5 * time.Second):\n+\t\t\tlogger.Warnf(\"command did not terminate within 5 seconds after session cancellation\")\n+\t\t}\n+\n+\t\tif err := session.Exit(130); err != nil {\n+\t\t\tlogSessionExitError(logger, err)\n+\t\t}\n+\t\treturn false\n+\n+\tcase err := <-done:\n+\t\treturn s.handleCommandCompletion(logger, session, err)\n+\t}\n+}\n+\n+// handleCommandCompletion handles command completion\n+func (s *Server) handleCommandCompletion(logger *log.Entry, session ssh.Session, err error) bool {\n+\tif err != nil {\n+\t\tlogger.Debugf(\"command execution failed: %v\", err)\n+\t\ts.handleSessionExit(session, err, logger)\n+\t\treturn false\n+\t}\n+\n+\ts.handleSessionExit(session, nil, logger)\n+\treturn true\n+}\n+\n+// handleSessionExit handles command errors and sets appropriate exit codes\n+func (s *Server) handleSessionExit(session ssh.Session, err error, logger *log.Entry) {\n+\tif err == nil {\n+\t\tif err := session.Exit(0); err != nil {\n+\t\t\tlogSessionExitError(logger, err)\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tvar exitError *exec.ExitError\n+\tif errors.As(err, &exitError) {\n+\t\tif err := session.Exit(exitError.ExitCode()); err != nil {\n+\t\t\tlogSessionExitError(logger, err)\n+\t\t}\n+\t} else {\n+\t\tlogger.Debugf(\"non-exit error in command execution: %v\", err)\n+\t\tif err := session.Exit(1); err != nil {\n+\t\t\tlogSessionExitError(logger, err)\n+\t\t}\n+\t}\n+}\ndiff --git a/client/ssh/server/command_execution_js.go b/client/ssh/server/command_execution_js.go\nnew file mode 100644\nindex 00000000000..6473f827354\n--- /dev/null\n+++ b/client/ssh/server/command_execution_js.go\n@@ -0,0 +1,52 @@\n+//go:build js\n+\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"os/exec\"\n+\t\"os/user\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+)\n+\n+var errNotSupported = errors.New(\"SSH server command execution not supported on WASM/JS platform\")\n+\n+// createSuCommand is not supported on JS/WASM\n+func (s *Server) createSuCommand(_ ssh.Session, _ *user.User, _ bool) (*exec.Cmd, error) {\n+\treturn nil, errNotSupported\n+}\n+\n+// createExecutorCommand is not supported on JS/WASM\n+func (s *Server) createExecutorCommand(_ ssh.Session, _ *user.User, _ bool) (*exec.Cmd, func(), error) {\n+\treturn nil, nil, errNotSupported\n+}\n+\n+// prepareCommandEnv is not supported on JS/WASM\n+func (s *Server) prepareCommandEnv(_ *user.User, _ ssh.Session) []string {\n+\treturn nil\n+}\n+\n+// setupProcessGroup is not supported on JS/WASM\n+func (s *Server) setupProcessGroup(_ *exec.Cmd) {\n+}\n+\n+// killProcessGroup is not supported on JS/WASM\n+func (s *Server) killProcessGroup(*exec.Cmd) {\n+}\n+\n+// detectSuPtySupport always returns false on JS/WASM\n+func (s *Server) detectSuPtySupport(context.Context) bool {\n+\treturn false\n+}\n+\n+// executeCommandWithPty is not supported on JS/WASM\n+func (s *Server) executeCommandWithPty(logger *log.Entry, session ssh.Session, execCmd *exec.Cmd, privilegeResult PrivilegeCheckResult, ptyReq ssh.Pty, winCh <-chan ssh.Window) bool {\n+\tlogger.Errorf(\"PTY command execution not supported on JS/WASM\")\n+\tif err := session.Exit(1); err != nil {\n+\t\tlogSessionExitError(logger, err)\n+\t}\n+\treturn false\n+}\ndiff --git a/client/ssh/server/command_execution_unix.go b/client/ssh/server/command_execution_unix.go\nnew file mode 100644\nindex 00000000000..da059fed9fc\n--- /dev/null\n+++ b/client/ssh/server/command_execution_unix.go\n@@ -0,0 +1,329 @@\n+//go:build unix\n+\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"os/user\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"syscall\"\n+\t\"time\"\n+\n+\t\"github.com/creack/pty\"\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+)\n+\n+// ptyManager manages Pty file operations with thread safety\n+type ptyManager struct {\n+\tfile     *os.File\n+\tmu       sync.RWMutex\n+\tclosed   bool\n+\tcloseErr error\n+\tonce     sync.Once\n+}\n+\n+func newPtyManager(file *os.File) *ptyManager {\n+\treturn &ptyManager{file: file}\n+}\n+\n+func (pm *ptyManager) Close() error {\n+\tpm.once.Do(func() {\n+\t\tpm.mu.Lock()\n+\t\tpm.closed = true\n+\t\tpm.closeErr = pm.file.Close()\n+\t\tpm.mu.Unlock()\n+\t})\n+\tpm.mu.RLock()\n+\tdefer pm.mu.RUnlock()\n+\treturn pm.closeErr\n+}\n+\n+func (pm *ptyManager) Setsize(ws *pty.Winsize) error {\n+\tpm.mu.RLock()\n+\tdefer pm.mu.RUnlock()\n+\tif pm.closed {\n+\t\treturn errors.New(\"pty is closed\")\n+\t}\n+\treturn pty.Setsize(pm.file, ws)\n+}\n+\n+func (pm *ptyManager) File() *os.File {\n+\treturn pm.file\n+}\n+\n+// detectSuPtySupport checks if su supports the --pty flag\n+func (s *Server) detectSuPtySupport(ctx context.Context) bool {\n+\tctx, cancel := context.WithTimeout(ctx, 500*time.Millisecond)\n+\tdefer cancel()\n+\n+\tcmd := exec.CommandContext(ctx, \"su\", \"--help\")\n+\toutput, err := cmd.CombinedOutput()\n+\tif err != nil {\n+\t\tlog.Debugf(\"su --help failed (may not support --help): %v\", err)\n+\t\treturn false\n+\t}\n+\n+\tsupported := strings.Contains(string(output), \"--pty\")\n+\tlog.Debugf(\"su --pty support detected: %v\", supported)\n+\treturn supported\n+}\n+\n+// createSuCommand creates a command using su -l -c for privilege switching\n+func (s *Server) createSuCommand(session ssh.Session, localUser *user.User, hasPty bool) (*exec.Cmd, error) {\n+\tsuPath, err := exec.LookPath(\"su\")\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"su command not available: %w\", err)\n+\t}\n+\n+\tcommand := session.RawCommand()\n+\tif command == \"\" {\n+\t\treturn nil, fmt.Errorf(\"no command specified for su execution\")\n+\t}\n+\n+\targs := []string{\"-l\"}\n+\tif hasPty && s.suSupportsPty {\n+\t\targs = append(args, \"--pty\")\n+\t}\n+\targs = append(args, localUser.Username, \"-c\", command)\n+\n+\tcmd := exec.CommandContext(session.Context(), suPath, args...)\n+\tcmd.Dir = localUser.HomeDir\n+\n+\treturn cmd, nil\n+}\n+\n+// getShellCommandArgs returns the shell command and arguments for executing a command string\n+func (s *Server) getShellCommandArgs(shell, cmdString string) []string {\n+\tif cmdString == \"\" {\n+\t\treturn []string{shell, \"-l\"}\n+\t}\n+\treturn []string{shell, \"-l\", \"-c\", cmdString}\n+}\n+\n+// prepareCommandEnv prepares environment variables for command execution on Unix\n+func (s *Server) prepareCommandEnv(localUser *user.User, session ssh.Session) []string {\n+\tenv := prepareUserEnv(localUser, getUserShell(localUser.Uid))\n+\tenv = append(env, prepareSSHEnv(session)...)\n+\tfor _, v := range session.Environ() {\n+\t\tif acceptEnv(v) {\n+\t\t\tenv = append(env, v)\n+\t\t}\n+\t}\n+\treturn env\n+}\n+\n+// executeCommandWithPty executes a command with PTY allocation\n+func (s *Server) executeCommandWithPty(logger *log.Entry, session ssh.Session, execCmd *exec.Cmd, privilegeResult PrivilegeCheckResult, ptyReq ssh.Pty, winCh <-chan ssh.Window) bool {\n+\ttermType := ptyReq.Term\n+\tif termType == \"\" {\n+\t\ttermType = \"xterm-256color\"\n+\t}\n+\texecCmd.Env = append(execCmd.Env, fmt.Sprintf(\"TERM=%s\", termType))\n+\n+\treturn s.runPtyCommand(logger, session, execCmd, ptyReq, winCh)\n+}\n+\n+func (s *Server) handlePty(logger *log.Entry, session ssh.Session, privilegeResult PrivilegeCheckResult, ptyReq ssh.Pty, winCh <-chan ssh.Window) bool {\n+\texecCmd, err := s.createPtyCommand(privilegeResult, ptyReq, session)\n+\tif err != nil {\n+\t\tlogger.Errorf(\"Pty command creation failed: %v\", err)\n+\t\terrorMsg := \"User switching failed - login command not available\\r\\n\"\n+\t\tif _, writeErr := fmt.Fprint(session.Stderr(), errorMsg); writeErr != nil {\n+\t\t\tlogger.Debugf(errWriteSession, writeErr)\n+\t\t}\n+\t\tif err := session.Exit(1); err != nil {\n+\t\t\tlogSessionExitError(logger, err)\n+\t\t}\n+\t\treturn false\n+\t}\n+\n+\tlogger.Infof(\"starting interactive shell: %s\", execCmd.Path)\n+\treturn s.runPtyCommand(logger, session, execCmd, ptyReq, winCh)\n+}\n+\n+// runPtyCommand runs a command with PTY management (common code for interactive and command execution)\n+func (s *Server) runPtyCommand(logger *log.Entry, session ssh.Session, execCmd *exec.Cmd, ptyReq ssh.Pty, winCh <-chan ssh.Window) bool {\n+\tptmx, err := s.startPtyCommandWithSize(execCmd, ptyReq)\n+\tif err != nil {\n+\t\tlogger.Errorf(\"Pty start failed: %v\", err)\n+\t\tif err := session.Exit(1); err != nil {\n+\t\t\tlogSessionExitError(logger, err)\n+\t\t}\n+\t\treturn false\n+\t}\n+\n+\tptyMgr := newPtyManager(ptmx)\n+\tdefer func() {\n+\t\tif err := ptyMgr.Close(); err != nil {\n+\t\t\tlogger.Debugf(\"Pty close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tgo s.handlePtyWindowResize(logger, session, ptyMgr, winCh)\n+\ts.handlePtyIO(logger, session, ptyMgr)\n+\ts.waitForPtyCompletion(logger, session, execCmd, ptyMgr)\n+\treturn true\n+}\n+\n+func (s *Server) startPtyCommandWithSize(execCmd *exec.Cmd, ptyReq ssh.Pty) (*os.File, error) {\n+\twinSize := &pty.Winsize{\n+\t\tCols: uint16(ptyReq.Window.Width),\n+\t\tRows: uint16(ptyReq.Window.Height),\n+\t}\n+\tif winSize.Cols == 0 {\n+\t\twinSize.Cols = 80\n+\t}\n+\tif winSize.Rows == 0 {\n+\t\twinSize.Rows = 24\n+\t}\n+\n+\tptmx, err := pty.StartWithSize(execCmd, winSize)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"start Pty: %w\", err)\n+\t}\n+\n+\treturn ptmx, nil\n+}\n+\n+func (s *Server) handlePtyWindowResize(logger *log.Entry, session ssh.Session, ptyMgr *ptyManager, winCh <-chan ssh.Window) {\n+\tfor {\n+\t\tselect {\n+\t\tcase <-session.Context().Done():\n+\t\t\treturn\n+\t\tcase win, ok := <-winCh:\n+\t\t\tif !ok {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif err := ptyMgr.Setsize(&pty.Winsize{Rows: uint16(win.Height), Cols: uint16(win.Width)}); err != nil {\n+\t\t\t\tlogger.Debugf(\"Pty resize to %dx%d: %v\", win.Width, win.Height, err)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func (s *Server) handlePtyIO(logger *log.Entry, session ssh.Session, ptyMgr *ptyManager) {\n+\tptmx := ptyMgr.File()\n+\n+\tgo func() {\n+\t\tif _, err := io.Copy(ptmx, session); err != nil {\n+\t\t\tif !errors.Is(err, io.EOF) && !errors.Is(err, syscall.EIO) {\n+\t\t\t\tlogger.Warnf(\"Pty input copy error: %v\", err)\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n+\tgo func() {\n+\t\tdefer func() {\n+\t\t\tif err := session.Close(); err != nil && !errors.Is(err, io.EOF) {\n+\t\t\t\tlogger.Debugf(\"session close error: %v\", err)\n+\t\t\t}\n+\t\t}()\n+\t\tif _, err := io.Copy(session, ptmx); err != nil {\n+\t\t\tif !errors.Is(err, io.EOF) && !errors.Is(err, syscall.EIO) {\n+\t\t\t\tlogger.Warnf(\"Pty output copy error: %v\", err)\n+\t\t\t}\n+\t\t}\n+\t}()\n+}\n+\n+func (s *Server) waitForPtyCompletion(logger *log.Entry, session ssh.Session, execCmd *exec.Cmd, ptyMgr *ptyManager) {\n+\tctx := session.Context()\n+\tdone := make(chan error, 1)\n+\tgo func() {\n+\t\tdone <- execCmd.Wait()\n+\t}()\n+\n+\tselect {\n+\tcase <-ctx.Done():\n+\t\ts.handlePtySessionCancellation(logger, session, execCmd, ptyMgr, done)\n+\tcase err := <-done:\n+\t\ts.handlePtyCommandCompletion(logger, session, err)\n+\t}\n+}\n+\n+func (s *Server) handlePtySessionCancellation(logger *log.Entry, session ssh.Session, execCmd *exec.Cmd, ptyMgr *ptyManager, done <-chan error) {\n+\tlogger.Debugf(\"Pty session cancelled, terminating command\")\n+\tif err := ptyMgr.Close(); err != nil {\n+\t\tlogger.Debugf(\"Pty close during session cancellation: %v\", err)\n+\t}\n+\n+\ts.killProcessGroup(execCmd)\n+\n+\tselect {\n+\tcase err := <-done:\n+\t\tif err != nil {\n+\t\t\tlogger.Debugf(\"Pty command terminated after session cancellation with error: %v\", err)\n+\t\t} else {\n+\t\t\tlogger.Debugf(\"Pty command terminated after session cancellation\")\n+\t\t}\n+\tcase <-time.After(5 * time.Second):\n+\t\tlogger.Warnf(\"Pty command did not terminate within 5 seconds after session cancellation\")\n+\t}\n+\n+\tif err := session.Exit(130); err != nil {\n+\t\tlogSessionExitError(logger, err)\n+\t}\n+}\n+\n+func (s *Server) handlePtyCommandCompletion(logger *log.Entry, session ssh.Session, err error) {\n+\tif err != nil {\n+\t\tlogger.Debugf(\"Pty command execution failed: %v\", err)\n+\t\ts.handleSessionExit(session, err, logger)\n+\t\treturn\n+\t}\n+\n+\t// Normal completion\n+\tlogger.Debugf(\"Pty command completed successfully\")\n+\tif err := session.Exit(0); err != nil {\n+\t\tlogSessionExitError(logger, err)\n+\t}\n+}\n+\n+func (s *Server) setupProcessGroup(cmd *exec.Cmd) {\n+\tcmd.SysProcAttr = &syscall.SysProcAttr{\n+\t\tSetpgid: true,\n+\t}\n+}\n+\n+func (s *Server) killProcessGroup(cmd *exec.Cmd) {\n+\tif cmd.Process == nil {\n+\t\treturn\n+\t}\n+\n+\tlogger := log.WithField(\"pid\", cmd.Process.Pid)\n+\tpgid := cmd.Process.Pid\n+\n+\tif err := syscall.Kill(-pgid, syscall.SIGTERM); err != nil {\n+\t\tlogger.Debugf(\"kill process group SIGTERM: %v\", err)\n+\t\treturn\n+\t}\n+\n+\tconst gracePeriod = 500 * time.Millisecond\n+\tconst checkInterval = 50 * time.Millisecond\n+\n+\tticker := time.NewTicker(checkInterval)\n+\tdefer ticker.Stop()\n+\n+\ttimeout := time.After(gracePeriod)\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase <-timeout:\n+\t\t\tif err := syscall.Kill(-pgid, syscall.SIGKILL); err != nil {\n+\t\t\t\tlogger.Debugf(\"kill process group SIGKILL: %v\", err)\n+\t\t\t}\n+\t\t\treturn\n+\t\tcase <-ticker.C:\n+\t\t\tif err := syscall.Kill(-pgid, 0); err != nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+}\ndiff --git a/client/ssh/server/command_execution_windows.go b/client/ssh/server/command_execution_windows.go\nnew file mode 100644\nindex 00000000000..37b3ae0eefe\n--- /dev/null\n+++ b/client/ssh/server/command_execution_windows.go\n@@ -0,0 +1,430 @@\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"os/user\"\n+\t\"path/filepath\"\n+\t\"strings\"\n+\t\"unsafe\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"golang.org/x/sys/windows\"\n+\t\"golang.org/x/sys/windows/registry\"\n+\n+\t\"github.com/netbirdio/netbird/client/ssh/server/winpty\"\n+)\n+\n+// getUserEnvironment retrieves the Windows environment for the target user.\n+// Follows OpenSSH's resilient approach with graceful degradation on failures.\n+func (s *Server) getUserEnvironment(username, domain string) ([]string, error) {\n+\tuserToken, err := s.getUserToken(username, domain)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"get user token: %w\", err)\n+\t}\n+\tdefer func() {\n+\t\tif err := windows.CloseHandle(userToken); err != nil {\n+\t\t\tlog.Debugf(\"close user token: %v\", err)\n+\t\t}\n+\t}()\n+\n+\treturn s.getUserEnvironmentWithToken(userToken, username, domain)\n+}\n+\n+// getUserEnvironmentWithToken retrieves the Windows environment using an existing token.\n+func (s *Server) getUserEnvironmentWithToken(userToken windows.Handle, username, domain string) ([]string, error) {\n+\tuserProfile, err := s.loadUserProfile(userToken, username, domain)\n+\tif err != nil {\n+\t\tlog.Debugf(\"failed to load user profile for %s\\\\%s: %v\", domain, username, err)\n+\t\tuserProfile = fmt.Sprintf(\"C:\\\\Users\\\\%s\", username)\n+\t}\n+\n+\tenvMap := make(map[string]string)\n+\n+\tif err := s.loadSystemEnvironment(envMap); err != nil {\n+\t\tlog.Debugf(\"failed to load system environment from registry: %v\", err)\n+\t}\n+\n+\ts.setUserEnvironmentVariables(envMap, userProfile, username, domain)\n+\n+\tvar env []string\n+\tfor key, value := range envMap {\n+\t\tenv = append(env, key+\"=\"+value)\n+\t}\n+\n+\treturn env, nil\n+}\n+\n+// getUserToken creates a user token for the specified user.\n+func (s *Server) getUserToken(username, domain string) (windows.Handle, error) {\n+\tprivilegeDropper := NewPrivilegeDropper()\n+\ttoken, err := privilegeDropper.createToken(username, domain)\n+\tif err != nil {\n+\t\treturn 0, fmt.Errorf(\"generate S4U user token: %w\", err)\n+\t}\n+\treturn token, nil\n+}\n+\n+// loadUserProfile loads the Windows user profile and returns the profile path.\n+func (s *Server) loadUserProfile(userToken windows.Handle, username, domain string) (string, error) {\n+\tusernamePtr, err := windows.UTF16PtrFromString(username)\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"convert username to UTF-16: %w\", err)\n+\t}\n+\n+\tvar domainUTF16 *uint16\n+\tif domain != \"\" && domain != \".\" {\n+\t\tdomainUTF16, err = windows.UTF16PtrFromString(domain)\n+\t\tif err != nil {\n+\t\t\treturn \"\", fmt.Errorf(\"convert domain to UTF-16: %w\", err)\n+\t\t}\n+\t}\n+\n+\ttype profileInfo struct {\n+\t\tdwSize        uint32\n+\t\tdwFlags       uint32\n+\t\tlpUserName    *uint16\n+\t\tlpProfilePath *uint16\n+\t\tlpDefaultPath *uint16\n+\t\tlpServerName  *uint16\n+\t\tlpPolicyPath  *uint16\n+\t\thProfile      windows.Handle\n+\t}\n+\n+\tconst PI_NOUI = 0x00000001\n+\n+\tprofile := profileInfo{\n+\t\tdwSize:       uint32(unsafe.Sizeof(profileInfo{})),\n+\t\tdwFlags:      PI_NOUI,\n+\t\tlpUserName:   usernamePtr,\n+\t\tlpServerName: domainUTF16,\n+\t}\n+\n+\tuserenv := windows.NewLazySystemDLL(\"userenv.dll\")\n+\tloadUserProfileW := userenv.NewProc(\"LoadUserProfileW\")\n+\n+\tret, _, err := loadUserProfileW.Call(\n+\t\tuintptr(userToken),\n+\t\tuintptr(unsafe.Pointer(&profile)),\n+\t)\n+\n+\tif ret == 0 {\n+\t\treturn \"\", fmt.Errorf(\"LoadUserProfileW: %w\", err)\n+\t}\n+\n+\tif profile.lpProfilePath == nil {\n+\t\treturn \"\", fmt.Errorf(\"LoadUserProfileW returned null profile path\")\n+\t}\n+\n+\tprofilePath := windows.UTF16PtrToString(profile.lpProfilePath)\n+\treturn profilePath, nil\n+}\n+\n+// loadSystemEnvironment loads system-wide environment variables from registry.\n+func (s *Server) loadSystemEnvironment(envMap map[string]string) error {\n+\tkey, err := registry.OpenKey(registry.LOCAL_MACHINE,\n+\t\t`SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment`,\n+\t\tregistry.QUERY_VALUE)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"open system environment registry key: %w\", err)\n+\t}\n+\tdefer func() {\n+\t\tif err := key.Close(); err != nil {\n+\t\t\tlog.Debugf(\"close registry key: %v\", err)\n+\t\t}\n+\t}()\n+\n+\treturn s.readRegistryEnvironment(key, envMap)\n+}\n+\n+// readRegistryEnvironment reads environment variables from a registry key.\n+func (s *Server) readRegistryEnvironment(key registry.Key, envMap map[string]string) error {\n+\tnames, err := key.ReadValueNames(0)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"read registry value names: %w\", err)\n+\t}\n+\n+\tfor _, name := range names {\n+\t\tvalue, valueType, err := key.GetStringValue(name)\n+\t\tif err != nil {\n+\t\t\tlog.Debugf(\"failed to read registry value %s: %v\", name, err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tfinalValue := s.expandRegistryValue(value, valueType, name)\n+\t\ts.setEnvironmentVariable(envMap, name, finalValue)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// expandRegistryValue expands registry values if they contain environment variables.\n+func (s *Server) expandRegistryValue(value string, valueType uint32, name string) string {\n+\tif valueType != registry.EXPAND_SZ {\n+\t\treturn value\n+\t}\n+\n+\tsourcePtr := windows.StringToUTF16Ptr(value)\n+\texpandedBuffer := make([]uint16, 1024)\n+\texpandedLen, err := windows.ExpandEnvironmentStrings(sourcePtr, &expandedBuffer[0], uint32(len(expandedBuffer)))\n+\tif err != nil {\n+\t\tlog.Debugf(\"failed to expand environment string for %s: %v\", name, err)\n+\t\treturn value\n+\t}\n+\n+\t// If buffer was too small, retry with larger buffer\n+\tif expandedLen > uint32(len(expandedBuffer)) {\n+\t\texpandedBuffer = make([]uint16, expandedLen)\n+\t\texpandedLen, err = windows.ExpandEnvironmentStrings(sourcePtr, &expandedBuffer[0], uint32(len(expandedBuffer)))\n+\t\tif err != nil {\n+\t\t\tlog.Debugf(\"failed to expand environment string for %s on retry: %v\", name, err)\n+\t\t\treturn value\n+\t\t}\n+\t}\n+\n+\tif expandedLen > 0 && expandedLen <= uint32(len(expandedBuffer)) {\n+\t\treturn windows.UTF16ToString(expandedBuffer[:expandedLen-1])\n+\t}\n+\treturn value\n+}\n+\n+// setEnvironmentVariable sets an environment variable with special handling for PATH.\n+func (s *Server) setEnvironmentVariable(envMap map[string]string, name, value string) {\n+\tupperName := strings.ToUpper(name)\n+\n+\tif upperName == \"PATH\" {\n+\t\tif existing, exists := envMap[\"PATH\"]; exists && existing != value {\n+\t\t\tenvMap[\"PATH\"] = existing + \";\" + value\n+\t\t} else {\n+\t\t\tenvMap[\"PATH\"] = value\n+\t\t}\n+\t} else {\n+\t\tenvMap[upperName] = value\n+\t}\n+}\n+\n+// setUserEnvironmentVariables sets critical user-specific environment variables.\n+func (s *Server) setUserEnvironmentVariables(envMap map[string]string, userProfile, username, domain string) {\n+\tenvMap[\"USERPROFILE\"] = userProfile\n+\n+\tif len(userProfile) >= 2 && userProfile[1] == ':' {\n+\t\tenvMap[\"HOMEDRIVE\"] = userProfile[:2]\n+\t\tenvMap[\"HOMEPATH\"] = userProfile[2:]\n+\t}\n+\n+\tenvMap[\"APPDATA\"] = filepath.Join(userProfile, \"AppData\", \"Roaming\")\n+\tenvMap[\"LOCALAPPDATA\"] = filepath.Join(userProfile, \"AppData\", \"Local\")\n+\n+\ttempDir := filepath.Join(userProfile, \"AppData\", \"Local\", \"Temp\")\n+\tenvMap[\"TEMP\"] = tempDir\n+\tenvMap[\"TMP\"] = tempDir\n+\n+\tenvMap[\"USERNAME\"] = username\n+\tif domain != \"\" && domain != \".\" {\n+\t\tenvMap[\"USERDOMAIN\"] = domain\n+\t\tenvMap[\"USERDNSDOMAIN\"] = domain\n+\t}\n+\n+\tsystemVars := []string{\n+\t\t\"PROCESSOR_ARCHITECTURE\", \"PROCESSOR_IDENTIFIER\", \"PROCESSOR_LEVEL\", \"PROCESSOR_REVISION\",\n+\t\t\"SYSTEMDRIVE\", \"SYSTEMROOT\", \"WINDIR\", \"COMPUTERNAME\", \"OS\", \"PATHEXT\",\n+\t\t\"PROGRAMFILES\", \"PROGRAMDATA\", \"ALLUSERSPROFILE\", \"COMSPEC\",\n+\t}\n+\n+\tfor _, sysVar := range systemVars {\n+\t\tif sysValue := os.Getenv(sysVar); sysValue != \"\" {\n+\t\t\tenvMap[sysVar] = sysValue\n+\t\t}\n+\t}\n+}\n+\n+// prepareCommandEnv prepares environment variables for command execution on Windows\n+func (s *Server) prepareCommandEnv(localUser *user.User, session ssh.Session) []string {\n+\tusername, domain := s.parseUsername(localUser.Username)\n+\tuserEnv, err := s.getUserEnvironment(username, domain)\n+\tif err != nil {\n+\t\tlog.Debugf(\"failed to get user environment for %s\\\\%s, using fallback: %v\", domain, username, err)\n+\t\tenv := prepareUserEnv(localUser, getUserShell(localUser.Uid))\n+\t\tenv = append(env, prepareSSHEnv(session)...)\n+\t\tfor _, v := range session.Environ() {\n+\t\t\tif acceptEnv(v) {\n+\t\t\t\tenv = append(env, v)\n+\t\t\t}\n+\t\t}\n+\t\treturn env\n+\t}\n+\n+\tenv := userEnv\n+\tenv = append(env, prepareSSHEnv(session)...)\n+\tfor _, v := range session.Environ() {\n+\t\tif acceptEnv(v) {\n+\t\t\tenv = append(env, v)\n+\t\t}\n+\t}\n+\treturn env\n+}\n+\n+func (s *Server) handlePty(logger *log.Entry, session ssh.Session, privilegeResult PrivilegeCheckResult, ptyReq ssh.Pty, winCh <-chan ssh.Window) bool {\n+\tif privilegeResult.User == nil {\n+\t\tlogger.Errorf(\"no user in privilege result\")\n+\t\treturn false\n+\t}\n+\n+\tcmd := session.Command()\n+\tshell := getUserShell(privilegeResult.User.Uid)\n+\n+\tif len(cmd) == 0 {\n+\t\tlogger.Infof(\"starting interactive shell: %s\", shell)\n+\t} else {\n+\t\tlogger.Infof(\"executing command: %s\", safeLogCommand(cmd))\n+\t}\n+\n+\ts.handlePtyWithUserSwitching(logger, session, privilegeResult, ptyReq, winCh, cmd)\n+\treturn true\n+}\n+\n+// getShellCommandArgs returns the shell command and arguments for executing a command string\n+func (s *Server) getShellCommandArgs(shell, cmdString string) []string {\n+\tif cmdString == \"\" {\n+\t\treturn []string{shell, \"-NoLogo\"}\n+\t}\n+\treturn []string{shell, \"-Command\", cmdString}\n+}\n+\n+func (s *Server) handlePtyWithUserSwitching(logger *log.Entry, session ssh.Session, privilegeResult PrivilegeCheckResult, ptyReq ssh.Pty, _ <-chan ssh.Window, _ []string) {\n+\tlogger.Info(\"starting interactive shell\")\n+\ts.executeConPtyCommand(logger, session, privilegeResult, ptyReq, session.RawCommand())\n+}\n+\n+type PtyExecutionRequest struct {\n+\tShell    string\n+\tCommand  string\n+\tWidth    int\n+\tHeight   int\n+\tUsername string\n+\tDomain   string\n+}\n+\n+func executePtyCommandWithUserToken(ctx context.Context, session ssh.Session, req PtyExecutionRequest) error {\n+\tlog.Tracef(\"executing Windows ConPty command with user switching: shell=%s, command=%s, user=%s\\\\%s, size=%dx%d\",\n+\t\treq.Shell, req.Command, req.Domain, req.Username, req.Width, req.Height)\n+\n+\tprivilegeDropper := NewPrivilegeDropper()\n+\tuserToken, err := privilegeDropper.createToken(req.Username, req.Domain)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"create user token: %w\", err)\n+\t}\n+\tdefer func() {\n+\t\tif err := windows.CloseHandle(userToken); err != nil {\n+\t\t\tlog.Debugf(\"close user token: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tserver := &Server{}\n+\tuserEnv, err := server.getUserEnvironmentWithToken(userToken, req.Username, req.Domain)\n+\tif err != nil {\n+\t\tlog.Debugf(\"failed to get user environment for %s\\\\%s, using system environment: %v\", req.Domain, req.Username, err)\n+\t\tuserEnv = os.Environ()\n+\t}\n+\n+\tworkingDir := getUserHomeFromEnv(userEnv)\n+\tif workingDir == \"\" {\n+\t\tworkingDir = fmt.Sprintf(`C:\\Users\\%s`, req.Username)\n+\t}\n+\n+\tptyConfig := winpty.PtyConfig{\n+\t\tShell:      req.Shell,\n+\t\tCommand:    req.Command,\n+\t\tWidth:      req.Width,\n+\t\tHeight:     req.Height,\n+\t\tWorkingDir: workingDir,\n+\t}\n+\n+\tuserConfig := winpty.UserConfig{\n+\t\tToken:       userToken,\n+\t\tEnvironment: userEnv,\n+\t}\n+\n+\tlog.Debugf(\"executePtyCommandWithUserToken: calling winpty execution with working dir: %s\", workingDir)\n+\treturn winpty.ExecutePtyWithUserToken(ctx, session, ptyConfig, userConfig)\n+}\n+\n+func getUserHomeFromEnv(env []string) string {\n+\tfor _, envVar := range env {\n+\t\tif len(envVar) > 12 && envVar[:12] == \"USERPROFILE=\" {\n+\t\t\treturn envVar[12:]\n+\t\t}\n+\t}\n+\treturn \"\"\n+}\n+\n+func (s *Server) setupProcessGroup(_ *exec.Cmd) {\n+\t// Windows doesn't support process groups in the same way as Unix\n+\t// Process creation groups are handled differently\n+}\n+\n+func (s *Server) killProcessGroup(cmd *exec.Cmd) {\n+\tif cmd.Process == nil {\n+\t\treturn\n+\t}\n+\n+\tlogger := log.WithField(\"pid\", cmd.Process.Pid)\n+\n+\tif err := cmd.Process.Kill(); err != nil {\n+\t\tlogger.Debugf(\"kill process failed: %v\", err)\n+\t}\n+}\n+\n+// detectSuPtySupport always returns false on Windows as su is not available\n+func (s *Server) detectSuPtySupport(context.Context) bool {\n+\treturn false\n+}\n+\n+// executeCommandWithPty executes a command with PTY allocation on Windows using ConPty\n+func (s *Server) executeCommandWithPty(logger *log.Entry, session ssh.Session, execCmd *exec.Cmd, privilegeResult PrivilegeCheckResult, ptyReq ssh.Pty, winCh <-chan ssh.Window) bool {\n+\tcommand := session.RawCommand()\n+\tif command == \"\" {\n+\t\tlogger.Error(\"no command specified for PTY execution\")\n+\t\tif err := session.Exit(1); err != nil {\n+\t\t\tlogSessionExitError(logger, err)\n+\t\t}\n+\t\treturn false\n+\t}\n+\n+\treturn s.executeConPtyCommand(logger, session, privilegeResult, ptyReq, command)\n+}\n+\n+// executeConPtyCommand executes a command using ConPty (common for interactive and command execution)\n+func (s *Server) executeConPtyCommand(logger *log.Entry, session ssh.Session, privilegeResult PrivilegeCheckResult, ptyReq ssh.Pty, command string) bool {\n+\tlocalUser := privilegeResult.User\n+\tif localUser == nil {\n+\t\tlogger.Errorf(\"no user in privilege result\")\n+\t\treturn false\n+\t}\n+\n+\tusername, domain := s.parseUsername(localUser.Username)\n+\tshell := getUserShell(localUser.Uid)\n+\n+\treq := PtyExecutionRequest{\n+\t\tShell:    shell,\n+\t\tCommand:  command,\n+\t\tWidth:    ptyReq.Window.Width,\n+\t\tHeight:   ptyReq.Window.Height,\n+\t\tUsername: username,\n+\t\tDomain:   domain,\n+\t}\n+\n+\tif err := executePtyCommandWithUserToken(session.Context(), session, req); err != nil {\n+\t\tlogger.Errorf(\"ConPty execution failed: %v\", err)\n+\t\tif err := session.Exit(1); err != nil {\n+\t\t\tlogSessionExitError(logger, err)\n+\t\t}\n+\t\treturn false\n+\t}\n+\n+\tlogger.Debug(\"ConPty execution completed\")\n+\treturn true\n+}\ndiff --git a/client/ssh/server/executor_unix.go b/client/ssh/server/executor_unix.go\nnew file mode 100644\nindex 00000000000..8adc824effe\n--- /dev/null\n+++ b/client/ssh/server/executor_unix.go\n@@ -0,0 +1,253 @@\n+//go:build unix\n+\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"syscall\"\n+\n+\tlog \"github.com/sirupsen/logrus\"\n+)\n+\n+// Exit codes for executor process communication\n+const (\n+\tExitCodeSuccess           = 0\n+\tExitCodePrivilegeDropFail = 10\n+\tExitCodeShellExecFail     = 11\n+\tExitCodeValidationFail    = 12\n+)\n+\n+// ExecutorConfig holds configuration for the executor process\n+type ExecutorConfig struct {\n+\tUID        uint32\n+\tGID        uint32\n+\tGroups     []uint32\n+\tWorkingDir string\n+\tShell      string\n+\tCommand    string\n+\tPTY        bool\n+}\n+\n+// PrivilegeDropper handles secure privilege dropping in child processes\n+type PrivilegeDropper struct{}\n+\n+// NewPrivilegeDropper creates a new privilege dropper\n+func NewPrivilegeDropper() *PrivilegeDropper {\n+\treturn &PrivilegeDropper{}\n+}\n+\n+// CreateExecutorCommand creates a command that spawns netbird ssh exec for privilege dropping\n+func (pd *PrivilegeDropper) CreateExecutorCommand(ctx context.Context, config ExecutorConfig) (*exec.Cmd, error) {\n+\tnetbirdPath, err := os.Executable()\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"get netbird executable path: %w\", err)\n+\t}\n+\n+\tif err := pd.validatePrivileges(config.UID, config.GID); err != nil {\n+\t\treturn nil, fmt.Errorf(\"invalid privileges: %w\", err)\n+\t}\n+\n+\targs := []string{\n+\t\t\"ssh\", \"exec\",\n+\t\t\"--uid\", fmt.Sprintf(\"%d\", config.UID),\n+\t\t\"--gid\", fmt.Sprintf(\"%d\", config.GID),\n+\t\t\"--working-dir\", config.WorkingDir,\n+\t\t\"--shell\", config.Shell,\n+\t}\n+\n+\tfor _, group := range config.Groups {\n+\t\targs = append(args, \"--groups\", fmt.Sprintf(\"%d\", group))\n+\t}\n+\n+\tif config.PTY {\n+\t\targs = append(args, \"--pty\")\n+\t}\n+\n+\tif config.Command != \"\" {\n+\t\targs = append(args, \"--cmd\", config.Command)\n+\t}\n+\n+\t// Log executor args safely - show all args except hide the command value\n+\tsafeArgs := make([]string, len(args))\n+\tcopy(safeArgs, args)\n+\tfor i := 0; i < len(safeArgs)-1; i++ {\n+\t\tif safeArgs[i] == \"--cmd\" {\n+\t\t\tcmdParts := strings.Fields(safeArgs[i+1])\n+\t\t\tsafeArgs[i+1] = safeLogCommand(cmdParts)\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tlog.Tracef(\"creating executor command: %s %v\", netbirdPath, safeArgs)\n+\treturn exec.CommandContext(ctx, netbirdPath, args...), nil\n+}\n+\n+// DropPrivileges performs privilege dropping with thread locking for security\n+func (pd *PrivilegeDropper) DropPrivileges(targetUID, targetGID uint32, supplementaryGroups []uint32) error {\n+\tif err := pd.validatePrivileges(targetUID, targetGID); err != nil {\n+\t\treturn fmt.Errorf(\"invalid privileges: %w\", err)\n+\t}\n+\n+\truntime.LockOSThread()\n+\tdefer runtime.UnlockOSThread()\n+\n+\toriginalUID := os.Geteuid()\n+\toriginalGID := os.Getegid()\n+\n+\tif originalUID != int(targetUID) || originalGID != int(targetGID) {\n+\t\tif err := pd.setGroupsAndIDs(targetUID, targetGID, supplementaryGroups); err != nil {\n+\t\t\treturn fmt.Errorf(\"set groups and IDs: %w\", err)\n+\t\t}\n+\t}\n+\n+\tif err := pd.validatePrivilegeDropSuccess(targetUID, targetGID, originalUID, originalGID); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tlog.Tracef(\"successfully dropped privileges to UID=%d, GID=%d\", targetUID, targetGID)\n+\treturn nil\n+}\n+\n+// setGroupsAndIDs sets the supplementary groups, GID, and UID\n+func (pd *PrivilegeDropper) setGroupsAndIDs(targetUID, targetGID uint32, supplementaryGroups []uint32) error {\n+\tgroups := make([]int, len(supplementaryGroups))\n+\tfor i, g := range supplementaryGroups {\n+\t\tgroups[i] = int(g)\n+\t}\n+\n+\tif runtime.GOOS == \"darwin\" || runtime.GOOS == \"freebsd\" {\n+\t\tif len(groups) == 0 || groups[0] != int(targetGID) {\n+\t\t\tgroups = append([]int{int(targetGID)}, groups...)\n+\t\t}\n+\t}\n+\n+\tif err := syscall.Setgroups(groups); err != nil {\n+\t\treturn fmt.Errorf(\"setgroups to %v: %w\", groups, err)\n+\t}\n+\n+\tif err := syscall.Setgid(int(targetGID)); err != nil {\n+\t\treturn fmt.Errorf(\"setgid to %d: %w\", targetGID, err)\n+\t}\n+\n+\tif err := syscall.Setuid(int(targetUID)); err != nil {\n+\t\treturn fmt.Errorf(\"setuid to %d: %w\", targetUID, err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// validatePrivilegeDropSuccess validates that privilege dropping was successful\n+func (pd *PrivilegeDropper) validatePrivilegeDropSuccess(targetUID, targetGID uint32, originalUID, originalGID int) error {\n+\tif err := pd.validatePrivilegeDropReversibility(targetUID, targetGID, originalUID, originalGID); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif err := pd.validateCurrentPrivileges(targetUID, targetGID); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn nil\n+}\n+\n+// validatePrivilegeDropReversibility ensures privileges cannot be restored\n+func (pd *PrivilegeDropper) validatePrivilegeDropReversibility(targetUID, targetGID uint32, originalUID, originalGID int) error {\n+\tif originalGID != int(targetGID) {\n+\t\tif err := syscall.Setegid(originalGID); err == nil {\n+\t\t\treturn fmt.Errorf(\"privilege drop validation failed: able to restore original GID %d\", originalGID)\n+\t\t}\n+\t}\n+\tif originalUID != int(targetUID) {\n+\t\tif err := syscall.Seteuid(originalUID); err == nil {\n+\t\t\treturn fmt.Errorf(\"privilege drop validation failed: able to restore original UID %d\", originalUID)\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// validateCurrentPrivileges validates the current UID and GID match the target\n+func (pd *PrivilegeDropper) validateCurrentPrivileges(targetUID, targetGID uint32) error {\n+\tcurrentUID := os.Geteuid()\n+\tif currentUID != int(targetUID) {\n+\t\treturn fmt.Errorf(\"privilege drop validation failed: current UID %d, expected %d\", currentUID, targetUID)\n+\t}\n+\n+\tcurrentGID := os.Getegid()\n+\tif currentGID != int(targetGID) {\n+\t\treturn fmt.Errorf(\"privilege drop validation failed: current GID %d, expected %d\", currentGID, targetGID)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// ExecuteWithPrivilegeDrop executes a command with privilege dropping, using exit codes to signal specific failures\n+func (pd *PrivilegeDropper) ExecuteWithPrivilegeDrop(ctx context.Context, config ExecutorConfig) {\n+\tlog.Tracef(\"dropping privileges to UID=%d, GID=%d, groups=%v\", config.UID, config.GID, config.Groups)\n+\n+\t// TODO: Implement Pty support for executor path\n+\tif config.PTY {\n+\t\tconfig.PTY = false\n+\t}\n+\n+\tif err := pd.DropPrivileges(config.UID, config.GID, config.Groups); err != nil {\n+\t\t_, _ = fmt.Fprintf(os.Stderr, \"privilege drop failed: %v\\n\", err)\n+\t\tos.Exit(ExitCodePrivilegeDropFail)\n+\t}\n+\n+\tif config.WorkingDir != \"\" {\n+\t\tif err := os.Chdir(config.WorkingDir); err != nil {\n+\t\t\tlog.Debugf(\"failed to change to working directory %s, continuing with current directory: %v\", config.WorkingDir, err)\n+\t\t}\n+\t}\n+\n+\tvar execCmd *exec.Cmd\n+\tif config.Command == \"\" {\n+\t\tos.Exit(ExitCodeSuccess)\n+\t}\n+\n+\texecCmd = exec.CommandContext(ctx, config.Shell, \"-c\", config.Command)\n+\texecCmd.Stdin = os.Stdin\n+\texecCmd.Stdout = os.Stdout\n+\texecCmd.Stderr = os.Stderr\n+\n+\tcmdParts := strings.Fields(config.Command)\n+\tsafeCmd := safeLogCommand(cmdParts)\n+\tlog.Tracef(\"executing %s -c %s\", execCmd.Path, safeCmd)\n+\tif err := execCmd.Run(); err != nil {\n+\t\tvar exitError *exec.ExitError\n+\t\tif errors.As(err, &exitError) {\n+\t\t\t// Normal command exit with non-zero code - not an SSH execution error\n+\t\t\tlog.Tracef(\"command exited with code %d\", exitError.ExitCode())\n+\t\t\tos.Exit(exitError.ExitCode())\n+\t\t}\n+\n+\t\t// Actual execution failure (command not found, permission denied, etc.)\n+\t\tlog.Debugf(\"command execution failed: %v\", err)\n+\t\tos.Exit(ExitCodeShellExecFail)\n+\t}\n+\n+\tos.Exit(ExitCodeSuccess)\n+}\n+\n+// validatePrivileges validates that privilege dropping to the target UID/GID is allowed\n+func (pd *PrivilegeDropper) validatePrivileges(uid, gid uint32) error {\n+\tcurrentUID := uint32(os.Geteuid())\n+\tcurrentGID := uint32(os.Getegid())\n+\n+\t// Allow same-user operations (no privilege dropping needed)\n+\tif uid == currentUID && gid == currentGID {\n+\t\treturn nil\n+\t}\n+\n+\t// Only root can drop privileges to other users\n+\tif currentUID != 0 {\n+\t\treturn fmt.Errorf(\"cannot drop privileges from non-root user (UID %d) to UID %d\", currentUID, uid)\n+\t}\n+\n+\t// Root can drop to any user (including root itself)\n+\treturn nil\n+}\ndiff --git a/client/ssh/server/executor_windows.go b/client/ssh/server/executor_windows.go\nnew file mode 100644\nindex 00000000000..d3504e05682\n--- /dev/null\n+++ b/client/ssh/server/executor_windows.go\n@@ -0,0 +1,570 @@\n+//go:build windows\n+\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"os/user\"\n+\t\"strings\"\n+\t\"syscall\"\n+\t\"unsafe\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"golang.org/x/sys/windows\"\n+)\n+\n+const (\n+\tExitCodeSuccess           = 0\n+\tExitCodeLogonFail         = 10\n+\tExitCodeCreateProcessFail = 11\n+\tExitCodeWorkingDirFail    = 12\n+\tExitCodeShellExecFail     = 13\n+\tExitCodeValidationFail    = 14\n+)\n+\n+type WindowsExecutorConfig struct {\n+\tUsername    string\n+\tDomain      string\n+\tWorkingDir  string\n+\tShell       string\n+\tCommand     string\n+\tArgs        []string\n+\tInteractive bool\n+\tPty         bool\n+\tPtyWidth    int\n+\tPtyHeight   int\n+}\n+\n+type PrivilegeDropper struct{}\n+\n+func NewPrivilegeDropper() *PrivilegeDropper {\n+\treturn &PrivilegeDropper{}\n+}\n+\n+var (\n+\tadvapi32                    = windows.NewLazyDLL(\"advapi32.dll\")\n+\tprocAllocateLocallyUniqueId = advapi32.NewProc(\"AllocateLocallyUniqueId\")\n+)\n+\n+const (\n+\tlogon32LogonNetwork = 3 // Network logon - no password required for authenticated users\n+\n+\t// Common error messages\n+\tcommandFlag          = \"-Command\"\n+\tcloseTokenErrorMsg   = \"close token error: %v\" // #nosec G101 -- This is an error message template, not credentials\n+\tconvertUsernameError = \"convert username to UTF16: %w\"\n+\tconvertDomainError   = \"convert domain to UTF16: %w\"\n+)\n+\n+// CreateWindowsExecutorCommand creates a Windows command with privilege dropping.\n+// The caller must close the returned token handle after starting the process.\n+func (pd *PrivilegeDropper) CreateWindowsExecutorCommand(ctx context.Context, config WindowsExecutorConfig) (*exec.Cmd, windows.Token, error) {\n+\tif config.Username == \"\" {\n+\t\treturn nil, 0, errors.New(\"username cannot be empty\")\n+\t}\n+\tif config.Shell == \"\" {\n+\t\treturn nil, 0, errors.New(\"shell cannot be empty\")\n+\t}\n+\n+\tshell := config.Shell\n+\n+\tvar shellArgs []string\n+\tif config.Command != \"\" {\n+\t\tshellArgs = []string{shell, commandFlag, config.Command}\n+\t} else {\n+\t\tshellArgs = []string{shell}\n+\t}\n+\n+\tlog.Tracef(\"creating Windows direct shell command: %s %v\", shellArgs[0], shellArgs)\n+\n+\tcmd, token, err := pd.CreateWindowsProcessAsUser(\n+\t\tctx, shellArgs[0], shellArgs, config.Username, config.Domain, config.WorkingDir)\n+\tif err != nil {\n+\t\treturn nil, 0, fmt.Errorf(\"create Windows process as user: %w\", err)\n+\t}\n+\n+\treturn cmd, token, nil\n+}\n+\n+const (\n+\t// StatusSuccess represents successful LSA operation\n+\tStatusSuccess = 0\n+\n+\t// KerbS4ULogonType message type for domain users with Kerberos\n+\tKerbS4ULogonType = 12\n+\t// Msv10s4ulogontype message type for local users with MSV1_0\n+\tMsv10s4ulogontype = 12\n+\n+\t// MicrosoftKerberosNameA is the authentication package name for Kerberos\n+\tMicrosoftKerberosNameA = \"Kerberos\"\n+\t// Msv10packagename is the authentication package name for MSV1_0\n+\tMsv10packagename = \"MICROSOFT_AUTHENTICATION_PACKAGE_V1_0\"\n+\n+\tNameSamCompatible = 2\n+\tNameUserPrincipal = 8\n+\tNameCanonical     = 7\n+\n+\tmaxUPNLen = 1024\n+)\n+\n+// kerbS4ULogon structure for S4U authentication (domain users)\n+type kerbS4ULogon struct {\n+\tMessageType uint32\n+\tFlags       uint32\n+\tClientUpn   unicodeString\n+\tClientRealm unicodeString\n+}\n+\n+// msv10s4ulogon structure for S4U authentication (local users)\n+type msv10s4ulogon struct {\n+\tMessageType       uint32\n+\tFlags             uint32\n+\tUserPrincipalName unicodeString\n+\tDomainName        unicodeString\n+}\n+\n+// unicodeString structure\n+type unicodeString struct {\n+\tLength        uint16\n+\tMaximumLength uint16\n+\tBuffer        *uint16\n+}\n+\n+// lsaString structure\n+type lsaString struct {\n+\tLength        uint16\n+\tMaximumLength uint16\n+\tBuffer        *byte\n+}\n+\n+// tokenSource structure\n+type tokenSource struct {\n+\tSourceName       [8]byte\n+\tSourceIdentifier windows.LUID\n+}\n+\n+// quotaLimits structure\n+type quotaLimits struct {\n+\tPagedPoolLimit        uint32\n+\tNonPagedPoolLimit     uint32\n+\tMinimumWorkingSetSize uint32\n+\tMaximumWorkingSetSize uint32\n+\tPagefileLimit         uint32\n+\tTimeLimit             int64\n+}\n+\n+var (\n+\tsecur32                            = windows.NewLazyDLL(\"secur32.dll\")\n+\tprocLsaRegisterLogonProcess        = secur32.NewProc(\"LsaRegisterLogonProcess\")\n+\tprocLsaLookupAuthenticationPackage = secur32.NewProc(\"LsaLookupAuthenticationPackage\")\n+\tprocLsaLogonUser                   = secur32.NewProc(\"LsaLogonUser\")\n+\tprocLsaFreeReturnBuffer            = secur32.NewProc(\"LsaFreeReturnBuffer\")\n+\tprocLsaDeregisterLogonProcess      = secur32.NewProc(\"LsaDeregisterLogonProcess\")\n+\tprocTranslateNameW                 = secur32.NewProc(\"TranslateNameW\")\n+)\n+\n+// newLsaString creates an LsaString from a Go string\n+func newLsaString(s string) lsaString {\n+\tb := append([]byte(s), 0)\n+\treturn lsaString{\n+\t\tLength:        uint16(len(s)),\n+\t\tMaximumLength: uint16(len(b)),\n+\t\tBuffer:        &b[0],\n+\t}\n+}\n+\n+// generateS4UUserToken creates a Windows token using S4U authentication\n+// This is the exact approach OpenSSH for Windows uses for public key authentication\n+func generateS4UUserToken(username, domain string) (windows.Handle, error) {\n+\tuserCpn := buildUserCpn(username, domain)\n+\n+\tpd := NewPrivilegeDropper()\n+\tisDomainUser := !pd.isLocalUser(domain)\n+\n+\tlsaHandle, err := initializeLsaConnection()\n+\tif err != nil {\n+\t\treturn 0, err\n+\t}\n+\tdefer cleanupLsaConnection(lsaHandle)\n+\n+\tauthPackageId, err := lookupAuthenticationPackage(lsaHandle, isDomainUser)\n+\tif err != nil {\n+\t\treturn 0, err\n+\t}\n+\n+\tlogonInfo, logonInfoSize, err := prepareS4ULogonStructure(username, domain, isDomainUser)\n+\tif err != nil {\n+\t\treturn 0, err\n+\t}\n+\n+\treturn performS4ULogon(lsaHandle, authPackageId, logonInfo, logonInfoSize, userCpn, isDomainUser)\n+}\n+\n+// buildUserCpn constructs the user principal name\n+func buildUserCpn(username, domain string) string {\n+\tif domain != \"\" && domain != \".\" {\n+\t\treturn fmt.Sprintf(`%s\\%s`, domain, username)\n+\t}\n+\treturn username\n+}\n+\n+// initializeLsaConnection establishes connection to LSA\n+func initializeLsaConnection() (windows.Handle, error) {\n+\n+\tprocessName := newLsaString(\"NetBird\")\n+\tvar mode uint32\n+\tvar lsaHandle windows.Handle\n+\tret, _, _ := procLsaRegisterLogonProcess.Call(\n+\t\tuintptr(unsafe.Pointer(&processName)),\n+\t\tuintptr(unsafe.Pointer(&lsaHandle)),\n+\t\tuintptr(unsafe.Pointer(&mode)),\n+\t)\n+\tif ret != StatusSuccess {\n+\t\treturn 0, fmt.Errorf(\"LsaRegisterLogonProcess: 0x%x\", ret)\n+\t}\n+\n+\treturn lsaHandle, nil\n+}\n+\n+// cleanupLsaConnection closes the LSA connection\n+func cleanupLsaConnection(lsaHandle windows.Handle) {\n+\tif ret, _, _ := procLsaDeregisterLogonProcess.Call(uintptr(lsaHandle)); ret != StatusSuccess {\n+\t\tlog.Debugf(\"LsaDeregisterLogonProcess failed: 0x%x\", ret)\n+\t}\n+}\n+\n+// lookupAuthenticationPackage finds the correct authentication package\n+func lookupAuthenticationPackage(lsaHandle windows.Handle, isDomainUser bool) (uint32, error) {\n+\tvar authPackageName lsaString\n+\tif isDomainUser {\n+\t\tauthPackageName = newLsaString(MicrosoftKerberosNameA)\n+\t} else {\n+\t\tauthPackageName = newLsaString(Msv10packagename)\n+\t}\n+\n+\tvar authPackageId uint32\n+\tret, _, _ := procLsaLookupAuthenticationPackage.Call(\n+\t\tuintptr(lsaHandle),\n+\t\tuintptr(unsafe.Pointer(&authPackageName)),\n+\t\tuintptr(unsafe.Pointer(&authPackageId)),\n+\t)\n+\tif ret != StatusSuccess {\n+\t\treturn 0, fmt.Errorf(\"LsaLookupAuthenticationPackage: 0x%x\", ret)\n+\t}\n+\n+\treturn authPackageId, nil\n+}\n+\n+// lookupPrincipalName converts DOMAIN\\username to username@domain.fqdn (UPN format)\n+func lookupPrincipalName(username, domain string) (string, error) {\n+\tsamAccountName := fmt.Sprintf(`%s\\%s`, domain, username)\n+\tsamAccountNameUtf16, err := windows.UTF16PtrFromString(samAccountName)\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"convert SAM account name to UTF-16: %w\", err)\n+\t}\n+\n+\tupnBuf := make([]uint16, maxUPNLen+1)\n+\tupnSize := uint32(len(upnBuf))\n+\n+\tret, _, _ := procTranslateNameW.Call(\n+\t\tuintptr(unsafe.Pointer(samAccountNameUtf16)),\n+\t\tuintptr(NameSamCompatible),\n+\t\tuintptr(NameUserPrincipal),\n+\t\tuintptr(unsafe.Pointer(&upnBuf[0])),\n+\t\tuintptr(unsafe.Pointer(&upnSize)),\n+\t)\n+\n+\tif ret != 0 {\n+\t\tupn := windows.UTF16ToString(upnBuf[:upnSize])\n+\t\tlog.Debugf(\"Translated %s to explicit UPN: %s\", samAccountName, upn)\n+\t\treturn upn, nil\n+\t}\n+\n+\tupnSize = uint32(len(upnBuf))\n+\tret, _, _ = procTranslateNameW.Call(\n+\t\tuintptr(unsafe.Pointer(samAccountNameUtf16)),\n+\t\tuintptr(NameSamCompatible),\n+\t\tuintptr(NameCanonical),\n+\t\tuintptr(unsafe.Pointer(&upnBuf[0])),\n+\t\tuintptr(unsafe.Pointer(&upnSize)),\n+\t)\n+\n+\tif ret != 0 {\n+\t\tcanonical := windows.UTF16ToString(upnBuf[:upnSize])\n+\t\tslashIdx := strings.IndexByte(canonical, '/')\n+\t\tif slashIdx > 0 {\n+\t\t\tfqdn := canonical[:slashIdx]\n+\t\t\tupn := fmt.Sprintf(\"%s@%s\", username, fqdn)\n+\t\t\tlog.Debugf(\"Translated %s to implicit UPN: %s (from canonical: %s)\", samAccountName, upn, canonical)\n+\t\t\treturn upn, nil\n+\t\t}\n+\t}\n+\n+\tlog.Debugf(\"Could not translate %s to UPN, using SAM format\", samAccountName)\n+\treturn samAccountName, nil\n+}\n+\n+// prepareS4ULogonStructure creates the appropriate S4U logon structure\n+func prepareS4ULogonStructure(username, domain string, isDomainUser bool) (unsafe.Pointer, uintptr, error) {\n+\tif isDomainUser {\n+\t\treturn prepareDomainS4ULogon(username, domain)\n+\t}\n+\treturn prepareLocalS4ULogon(username)\n+}\n+\n+// prepareDomainS4ULogon creates S4U logon structure for domain users\n+func prepareDomainS4ULogon(username, domain string) (unsafe.Pointer, uintptr, error) {\n+\tupn, err := lookupPrincipalName(username, domain)\n+\tif err != nil {\n+\t\treturn nil, 0, fmt.Errorf(\"lookup principal name: %w\", err)\n+\t}\n+\n+\tlog.Debugf(\"using KerbS4ULogon for domain user with UPN: %s\", upn)\n+\n+\tupnUtf16, err := windows.UTF16FromString(upn)\n+\tif err != nil {\n+\t\treturn nil, 0, fmt.Errorf(convertUsernameError, err)\n+\t}\n+\n+\tstructSize := unsafe.Sizeof(kerbS4ULogon{})\n+\tupnByteSize := len(upnUtf16) * 2\n+\tlogonInfoSize := structSize + uintptr(upnByteSize)\n+\n+\tbuffer := make([]byte, logonInfoSize)\n+\tlogonInfo := unsafe.Pointer(&buffer[0])\n+\n+\ts4uLogon := (*kerbS4ULogon)(logonInfo)\n+\ts4uLogon.MessageType = KerbS4ULogonType\n+\ts4uLogon.Flags = 0\n+\n+\tupnOffset := structSize\n+\tupnBuffer := (*uint16)(unsafe.Pointer(uintptr(logonInfo) + upnOffset))\n+\tcopy((*[1025]uint16)(unsafe.Pointer(upnBuffer))[:len(upnUtf16)], upnUtf16)\n+\n+\ts4uLogon.ClientUpn = unicodeString{\n+\t\tLength:        uint16((len(upnUtf16) - 1) * 2),\n+\t\tMaximumLength: uint16(len(upnUtf16) * 2),\n+\t\tBuffer:        upnBuffer,\n+\t}\n+\ts4uLogon.ClientRealm = unicodeString{}\n+\n+\treturn logonInfo, logonInfoSize, nil\n+}\n+\n+// prepareLocalS4ULogon creates S4U logon structure for local users\n+func prepareLocalS4ULogon(username string) (unsafe.Pointer, uintptr, error) {\n+\tlog.Debugf(\"using Msv1_0S4ULogon for local user: %s\", username)\n+\n+\tusernameUtf16, err := windows.UTF16FromString(username)\n+\tif err != nil {\n+\t\treturn nil, 0, fmt.Errorf(convertUsernameError, err)\n+\t}\n+\n+\tdomainUtf16, err := windows.UTF16FromString(\".\")\n+\tif err != nil {\n+\t\treturn nil, 0, fmt.Errorf(convertDomainError, err)\n+\t}\n+\n+\tstructSize := unsafe.Sizeof(msv10s4ulogon{})\n+\tusernameByteSize := len(usernameUtf16) * 2\n+\tdomainByteSize := len(domainUtf16) * 2\n+\tlogonInfoSize := structSize + uintptr(usernameByteSize) + uintptr(domainByteSize)\n+\n+\tbuffer := make([]byte, logonInfoSize)\n+\tlogonInfo := unsafe.Pointer(&buffer[0])\n+\n+\ts4uLogon := (*msv10s4ulogon)(logonInfo)\n+\ts4uLogon.MessageType = Msv10s4ulogontype\n+\ts4uLogon.Flags = 0x0\n+\n+\tusernameOffset := structSize\n+\tusernameBuffer := (*uint16)(unsafe.Pointer(uintptr(logonInfo) + usernameOffset))\n+\tcopy((*[256]uint16)(unsafe.Pointer(usernameBuffer))[:len(usernameUtf16)], usernameUtf16)\n+\n+\ts4uLogon.UserPrincipalName = unicodeString{\n+\t\tLength:        uint16((len(usernameUtf16) - 1) * 2),\n+\t\tMaximumLength: uint16(len(usernameUtf16) * 2),\n+\t\tBuffer:        usernameBuffer,\n+\t}\n+\n+\tdomainOffset := usernameOffset + uintptr(usernameByteSize)\n+\tdomainBuffer := (*uint16)(unsafe.Pointer(uintptr(logonInfo) + domainOffset))\n+\tcopy((*[16]uint16)(unsafe.Pointer(domainBuffer))[:len(domainUtf16)], domainUtf16)\n+\n+\ts4uLogon.DomainName = unicodeString{\n+\t\tLength:        uint16((len(domainUtf16) - 1) * 2),\n+\t\tMaximumLength: uint16(len(domainUtf16) * 2),\n+\t\tBuffer:        domainBuffer,\n+\t}\n+\n+\treturn logonInfo, logonInfoSize, nil\n+}\n+\n+// performS4ULogon executes the S4U logon operation\n+func performS4ULogon(lsaHandle windows.Handle, authPackageId uint32, logonInfo unsafe.Pointer, logonInfoSize uintptr, userCpn string, isDomainUser bool) (windows.Handle, error) {\n+\tvar tokenSource tokenSource\n+\tcopy(tokenSource.SourceName[:], \"netbird\")\n+\tif ret, _, _ := procAllocateLocallyUniqueId.Call(uintptr(unsafe.Pointer(&tokenSource.SourceIdentifier))); ret == 0 {\n+\t\tlog.Debugf(\"AllocateLocallyUniqueId failed\")\n+\t}\n+\n+\toriginName := newLsaString(\"netbird\")\n+\n+\tvar profile uintptr\n+\tvar profileSize uint32\n+\tvar logonId windows.LUID\n+\tvar token windows.Handle\n+\tvar quotas quotaLimits\n+\tvar subStatus int32\n+\n+\tret, _, _ := procLsaLogonUser.Call(\n+\t\tuintptr(lsaHandle),\n+\t\tuintptr(unsafe.Pointer(&originName)),\n+\t\tlogon32LogonNetwork,\n+\t\tuintptr(authPackageId),\n+\t\tuintptr(logonInfo),\n+\t\tlogonInfoSize,\n+\t\t0,\n+\t\tuintptr(unsafe.Pointer(&tokenSource)),\n+\t\tuintptr(unsafe.Pointer(&profile)),\n+\t\tuintptr(unsafe.Pointer(&profileSize)),\n+\t\tuintptr(unsafe.Pointer(&logonId)),\n+\t\tuintptr(unsafe.Pointer(&token)),\n+\t\tuintptr(unsafe.Pointer(&quotas)),\n+\t\tuintptr(unsafe.Pointer(&subStatus)),\n+\t)\n+\n+\tif profile != 0 {\n+\t\tif ret, _, _ := procLsaFreeReturnBuffer.Call(profile); ret != StatusSuccess {\n+\t\t\tlog.Debugf(\"LsaFreeReturnBuffer failed: 0x%x\", ret)\n+\t\t}\n+\t}\n+\n+\tif ret != StatusSuccess {\n+\t\treturn 0, fmt.Errorf(\"LsaLogonUser S4U for %s: NTSTATUS=0x%x, SubStatus=0x%x\", userCpn, ret, subStatus)\n+\t}\n+\n+\tlog.Debugf(\"created S4U %s token for user %s\",\n+\t\tmap[bool]string{true: \"domain\", false: \"local\"}[isDomainUser], userCpn)\n+\treturn token, nil\n+}\n+\n+// createToken implements NetBird trust-based authentication using S4U\n+func (pd *PrivilegeDropper) createToken(username, domain string) (windows.Handle, error) {\n+\tfullUsername := buildUserCpn(username, domain)\n+\n+\tif err := userExists(fullUsername, username, domain); err != nil {\n+\t\treturn 0, err\n+\t}\n+\n+\tisLocalUser := pd.isLocalUser(domain)\n+\n+\tif isLocalUser {\n+\t\treturn pd.authenticateLocalUser(username, fullUsername)\n+\t}\n+\treturn pd.authenticateDomainUser(username, domain, fullUsername)\n+}\n+\n+// userExists checks if the target useVerifier exists on the system\n+func userExists(fullUsername, username, domain string) error {\n+\tif _, err := lookupUser(fullUsername); err != nil {\n+\t\tlog.Debugf(\"User %s not found: %v\", fullUsername, err)\n+\t\tif domain != \"\" && domain != \".\" {\n+\t\t\t_, err = lookupUser(username)\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"target user %s not found: %w\", fullUsername, err)\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// isLocalUser determines if this is a local user vs domain user\n+func (pd *PrivilegeDropper) isLocalUser(domain string) bool {\n+\thostname, err := os.Hostname()\n+\tif err != nil {\n+\t\thostname = \"localhost\"\n+\t}\n+\n+\treturn domain == \"\" || domain == \".\" ||\n+\t\tstrings.EqualFold(domain, hostname)\n+}\n+\n+// authenticateLocalUser handles authentication for local users\n+func (pd *PrivilegeDropper) authenticateLocalUser(username, fullUsername string) (windows.Handle, error) {\n+\tlog.Debugf(\"using S4U authentication for local user %s\", fullUsername)\n+\ttoken, err := generateS4UUserToken(username, \".\")\n+\tif err != nil {\n+\t\treturn 0, fmt.Errorf(\"S4U authentication for local user %s: %w\", fullUsername, err)\n+\t}\n+\treturn token, nil\n+}\n+\n+// authenticateDomainUser handles authentication for domain users\n+func (pd *PrivilegeDropper) authenticateDomainUser(username, domain, fullUsername string) (windows.Handle, error) {\n+\tlog.Debugf(\"using S4U authentication for domain user %s\", fullUsername)\n+\ttoken, err := generateS4UUserToken(username, domain)\n+\tif err != nil {\n+\t\treturn 0, fmt.Errorf(\"S4U authentication for domain user %s: %w\", fullUsername, err)\n+\t}\n+\tlog.Debugf(\"Successfully created S4U token for domain user %s\", fullUsername)\n+\treturn token, nil\n+}\n+\n+// CreateWindowsProcessAsUser creates a process as user with safe argument passing (for SFTP and executables).\n+// The caller must close the returned token handle after starting the process.\n+func (pd *PrivilegeDropper) CreateWindowsProcessAsUser(ctx context.Context, executablePath string, args []string, username, domain, workingDir string) (*exec.Cmd, windows.Token, error) {\n+\ttoken, err := pd.createToken(username, domain)\n+\tif err != nil {\n+\t\treturn nil, 0, fmt.Errorf(\"user authentication: %w\", err)\n+\t}\n+\n+\tdefer func() {\n+\t\tif err := windows.CloseHandle(token); err != nil {\n+\t\t\tlog.Debugf(\"close impersonation token: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tcmd, primaryToken, err := pd.createProcessWithToken(ctx, windows.Token(token), executablePath, args, workingDir)\n+\tif err != nil {\n+\t\treturn nil, 0, err\n+\t}\n+\n+\treturn cmd, primaryToken, nil\n+}\n+\n+// createProcessWithToken creates process with the specified token and executable path.\n+// The caller must close the returned token handle after starting the process.\n+func (pd *PrivilegeDropper) createProcessWithToken(ctx context.Context, sourceToken windows.Token, executablePath string, args []string, workingDir string) (*exec.Cmd, windows.Token, error) {\n+\tcmd := exec.CommandContext(ctx, executablePath, args[1:]...)\n+\tcmd.Dir = workingDir\n+\n+\tvar primaryToken windows.Token\n+\terr := windows.DuplicateTokenEx(\n+\t\tsourceToken,\n+\t\twindows.TOKEN_ALL_ACCESS,\n+\t\tnil,\n+\t\twindows.SecurityIdentification,\n+\t\twindows.TokenPrimary,\n+\t\t&primaryToken,\n+\t)\n+\tif err != nil {\n+\t\treturn nil, 0, fmt.Errorf(\"duplicate token to primary token: %w\", err)\n+\t}\n+\n+\tcmd.SysProcAttr = &syscall.SysProcAttr{\n+\t\tToken: syscall.Token(primaryToken),\n+\t}\n+\n+\treturn cmd, primaryToken, nil\n+}\n+\n+// createSuCommand creates a command using su -l -c for privilege switching (Windows stub)\n+func (s *Server) createSuCommand(ssh.Session, *user.User, bool) (*exec.Cmd, error) {\n+\treturn nil, fmt.Errorf(\"su command not available on Windows\")\n+}\ndiff --git a/client/ssh/server/port_forwarding.go b/client/ssh/server/port_forwarding.go\nnew file mode 100644\nindex 00000000000..6138f9296f7\n--- /dev/null\n+++ b/client/ssh/server/port_forwarding.go\n@@ -0,0 +1,386 @@\n+package server\n+\n+import (\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net\"\n+\t\"strconv\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\tcryptossh \"golang.org/x/crypto/ssh\"\n+)\n+\n+// SessionKey uniquely identifies an SSH session\n+type SessionKey string\n+\n+// ConnectionKey uniquely identifies a port forwarding connection within a session\n+type ConnectionKey string\n+\n+// ForwardKey uniquely identifies a port forwarding listener\n+type ForwardKey string\n+\n+// tcpipForwardMsg represents the structure for tcpip-forward SSH requests\n+type tcpipForwardMsg struct {\n+\tHost string\n+\tPort uint32\n+}\n+\n+// SetAllowLocalPortForwarding configures local port forwarding\n+func (s *Server) SetAllowLocalPortForwarding(allow bool) {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\ts.allowLocalPortForwarding = allow\n+}\n+\n+// SetAllowRemotePortForwarding configures remote port forwarding\n+func (s *Server) SetAllowRemotePortForwarding(allow bool) {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\ts.allowRemotePortForwarding = allow\n+}\n+\n+// configurePortForwarding sets up port forwarding callbacks\n+func (s *Server) configurePortForwarding(server *ssh.Server) {\n+\tallowLocal := s.allowLocalPortForwarding\n+\tallowRemote := s.allowRemotePortForwarding\n+\n+\tserver.LocalPortForwardingCallback = func(ctx ssh.Context, dstHost string, dstPort uint32) bool {\n+\t\tif !allowLocal {\n+\t\t\tlog.Warnf(\"local port forwarding denied for %s from %s: disabled by configuration\",\n+\t\t\t\tnet.JoinHostPort(dstHost, fmt.Sprintf(\"%d\", dstPort)), ctx.RemoteAddr())\n+\t\t\treturn false\n+\t\t}\n+\n+\t\tif err := s.checkPortForwardingPrivileges(ctx, \"local\", dstPort); err != nil {\n+\t\t\tlog.Warnf(\"local port forwarding denied for %s:%d from %s: %v\", dstHost, dstPort, ctx.RemoteAddr(), err)\n+\t\t\treturn false\n+\t\t}\n+\n+\t\tlog.Debugf(\"local port forwarding allowed: %s:%d\", dstHost, dstPort)\n+\t\treturn true\n+\t}\n+\n+\tserver.ReversePortForwardingCallback = func(ctx ssh.Context, bindHost string, bindPort uint32) bool {\n+\t\tif !allowRemote {\n+\t\t\tlog.Warnf(\"remote port forwarding denied for %s from %s: disabled by configuration\",\n+\t\t\t\tnet.JoinHostPort(bindHost, fmt.Sprintf(\"%d\", bindPort)), ctx.RemoteAddr())\n+\t\t\treturn false\n+\t\t}\n+\n+\t\tif err := s.checkPortForwardingPrivileges(ctx, \"remote\", bindPort); err != nil {\n+\t\t\tlog.Warnf(\"remote port forwarding denied for %s:%d from %s: %v\", bindHost, bindPort, ctx.RemoteAddr(), err)\n+\t\t\treturn false\n+\t\t}\n+\n+\t\tlog.Debugf(\"remote port forwarding allowed: %s:%d\", bindHost, bindPort)\n+\t\treturn true\n+\t}\n+\n+\tlog.Debugf(\"SSH server configured with local_forwarding=%v, remote_forwarding=%v\", allowLocal, allowRemote)\n+}\n+\n+// checkPortForwardingPrivileges validates privilege requirements for port forwarding operations.\n+// Returns nil if allowed, error if denied.\n+func (s *Server) checkPortForwardingPrivileges(ctx ssh.Context, forwardType string, port uint32) error {\n+\tif ctx == nil {\n+\t\treturn fmt.Errorf(\"%s port forwarding denied: no context\", forwardType)\n+\t}\n+\n+\tusername := ctx.User()\n+\tremoteAddr := \"unknown\"\n+\tif ctx.RemoteAddr() != nil {\n+\t\tremoteAddr = ctx.RemoteAddr().String()\n+\t}\n+\n+\tlogger := log.WithFields(log.Fields{\"user\": username, \"remote\": remoteAddr, \"port\": port})\n+\n+\tresult := s.CheckPrivileges(PrivilegeCheckRequest{\n+\t\tRequestedUsername:         username,\n+\t\tFeatureSupportsUserSwitch: false,\n+\t\tFeatureName:               forwardType + \" port forwarding\",\n+\t})\n+\n+\tif !result.Allowed {\n+\t\treturn result.Error\n+\t}\n+\n+\tlogger.Debugf(\"%s port forwarding allowed: user %s validated (port %d)\",\n+\t\tforwardType, result.User.Username, port)\n+\n+\treturn nil\n+}\n+\n+// tcpipForwardHandler handles tcpip-forward requests for remote port forwarding.\n+func (s *Server) tcpipForwardHandler(ctx ssh.Context, _ *ssh.Server, req *cryptossh.Request) (bool, []byte) {\n+\tlogger := s.getRequestLogger(ctx)\n+\n+\tif !s.isRemotePortForwardingAllowed() {\n+\t\tlogger.Warnf(\"tcpip-forward request denied: remote port forwarding disabled\")\n+\t\treturn false, nil\n+\t}\n+\n+\tpayload, err := s.parseTcpipForwardRequest(req)\n+\tif err != nil {\n+\t\tlogger.Errorf(\"tcpip-forward unmarshal error: %v\", err)\n+\t\treturn false, nil\n+\t}\n+\n+\tif err := s.checkPortForwardingPrivileges(ctx, \"tcpip-forward\", payload.Port); err != nil {\n+\t\tlogger.Warnf(\"tcpip-forward denied: %v\", err)\n+\t\treturn false, nil\n+\t}\n+\n+\tlogger.Debugf(\"tcpip-forward request: %s:%d\", payload.Host, payload.Port)\n+\n+\tsshConn, err := s.getSSHConnection(ctx)\n+\tif err != nil {\n+\t\tlogger.Warnf(\"tcpip-forward request denied: %v\", err)\n+\t\treturn false, nil\n+\t}\n+\n+\treturn s.setupDirectForward(ctx, logger, sshConn, payload)\n+}\n+\n+// cancelTcpipForwardHandler handles cancel-tcpip-forward requests.\n+func (s *Server) cancelTcpipForwardHandler(ctx ssh.Context, _ *ssh.Server, req *cryptossh.Request) (bool, []byte) {\n+\tlogger := s.getRequestLogger(ctx)\n+\n+\tvar payload tcpipForwardMsg\n+\tif err := cryptossh.Unmarshal(req.Payload, &payload); err != nil {\n+\t\tlogger.Errorf(\"cancel-tcpip-forward unmarshal error: %v\", err)\n+\t\treturn false, nil\n+\t}\n+\n+\tkey := ForwardKey(fmt.Sprintf(\"%s:%d\", payload.Host, payload.Port))\n+\tif s.removeRemoteForwardListener(key) {\n+\t\tlogger.Infof(\"remote port forwarding cancelled: %s:%d\", payload.Host, payload.Port)\n+\t\treturn true, nil\n+\t}\n+\n+\tlogger.Warnf(\"cancel-tcpip-forward failed: no listener found for %s:%d\", payload.Host, payload.Port)\n+\treturn false, nil\n+}\n+\n+// handleRemoteForwardListener handles incoming connections for remote port forwarding.\n+func (s *Server) handleRemoteForwardListener(ctx ssh.Context, ln net.Listener, host string, port uint32) {\n+\tlog.Debugf(\"starting remote forward listener handler for %s:%d\", host, port)\n+\n+\tdefer func() {\n+\t\tlog.Debugf(\"cleaning up remote forward listener for %s:%d\", host, port)\n+\t\tif err := ln.Close(); err != nil {\n+\t\t\tlog.Debugf(\"remote forward listener close error: %v\", err)\n+\t\t} else {\n+\t\t\tlog.Debugf(\"remote forward listener closed successfully for %s:%d\", host, port)\n+\t\t}\n+\t}()\n+\n+\tacceptChan := make(chan acceptResult, 1)\n+\n+\tgo func() {\n+\t\tfor {\n+\t\t\tconn, err := ln.Accept()\n+\t\t\tselect {\n+\t\t\tcase acceptChan <- acceptResult{conn: conn, err: err}:\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\tcase <-ctx.Done():\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase result := <-acceptChan:\n+\t\t\tif result.err != nil {\n+\t\t\t\tlog.Debugf(\"remote forward accept error: %v\", result.err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tgo s.handleRemoteForwardConnection(ctx, result.conn, host, port)\n+\t\tcase <-ctx.Done():\n+\t\t\tlog.Debugf(\"remote forward listener shutting down due to context cancellation for %s:%d\", host, port)\n+\t\t\treturn\n+\t\t}\n+\t}\n+}\n+\n+// getRequestLogger creates a logger with user and remote address context\n+func (s *Server) getRequestLogger(ctx ssh.Context) *log.Entry {\n+\tremoteAddr := \"unknown\"\n+\tusername := \"unknown\"\n+\tif ctx != nil {\n+\t\tif ctx.RemoteAddr() != nil {\n+\t\t\tremoteAddr = ctx.RemoteAddr().String()\n+\t\t}\n+\t\tusername = ctx.User()\n+\t}\n+\treturn log.WithFields(log.Fields{\"user\": username, \"remote\": remoteAddr})\n+}\n+\n+// isRemotePortForwardingAllowed checks if remote port forwarding is enabled\n+func (s *Server) isRemotePortForwardingAllowed() bool {\n+\ts.mu.RLock()\n+\tdefer s.mu.RUnlock()\n+\treturn s.allowRemotePortForwarding\n+}\n+\n+// parseTcpipForwardRequest parses the SSH request payload\n+func (s *Server) parseTcpipForwardRequest(req *cryptossh.Request) (*tcpipForwardMsg, error) {\n+\tvar payload tcpipForwardMsg\n+\terr := cryptossh.Unmarshal(req.Payload, &payload)\n+\treturn &payload, err\n+}\n+\n+// getSSHConnection extracts SSH connection from context\n+func (s *Server) getSSHConnection(ctx ssh.Context) (*cryptossh.ServerConn, error) {\n+\tif ctx == nil {\n+\t\treturn nil, fmt.Errorf(\"no context\")\n+\t}\n+\tsshConnValue := ctx.Value(ssh.ContextKeyConn)\n+\tif sshConnValue == nil {\n+\t\treturn nil, fmt.Errorf(\"no SSH connection in context\")\n+\t}\n+\tsshConn, ok := sshConnValue.(*cryptossh.ServerConn)\n+\tif !ok || sshConn == nil {\n+\t\treturn nil, fmt.Errorf(\"invalid SSH connection in context\")\n+\t}\n+\treturn sshConn, nil\n+}\n+\n+// setupDirectForward sets up a direct port forward\n+func (s *Server) setupDirectForward(ctx ssh.Context, logger *log.Entry, sshConn *cryptossh.ServerConn, payload *tcpipForwardMsg) (bool, []byte) {\n+\tbindAddr := net.JoinHostPort(payload.Host, strconv.FormatUint(uint64(payload.Port), 10))\n+\n+\tln, err := net.Listen(\"tcp\", bindAddr)\n+\tif err != nil {\n+\t\tlogger.Errorf(\"tcpip-forward listen failed on %s: %v\", bindAddr, err)\n+\t\treturn false, nil\n+\t}\n+\n+\tactualPort := payload.Port\n+\tif payload.Port == 0 {\n+\t\ttcpAddr := ln.Addr().(*net.TCPAddr)\n+\t\tactualPort = uint32(tcpAddr.Port)\n+\t\tlogger.Debugf(\"tcpip-forward allocated port %d for %s\", actualPort, payload.Host)\n+\t}\n+\n+\tkey := ForwardKey(fmt.Sprintf(\"%s:%d\", payload.Host, payload.Port))\n+\ts.storeRemoteForwardListener(key, ln)\n+\n+\ts.markConnectionActivePortForward(sshConn, ctx.User(), ctx.RemoteAddr().String())\n+\tgo s.handleRemoteForwardListener(ctx, ln, payload.Host, actualPort)\n+\n+\tresponse := make([]byte, 4)\n+\tbinary.BigEndian.PutUint32(response, actualPort)\n+\n+\tlogger.Infof(\"remote port forwarding established: %s:%d\", payload.Host, actualPort)\n+\treturn true, response\n+}\n+\n+// acceptResult holds the result of a listener Accept() call\n+type acceptResult struct {\n+\tconn net.Conn\n+\terr  error\n+}\n+\n+// handleRemoteForwardConnection handles a single remote port forwarding connection\n+func (s *Server) handleRemoteForwardConnection(ctx ssh.Context, conn net.Conn, host string, port uint32) {\n+\tsessionKey := s.findSessionKeyByContext(ctx)\n+\tconnID := fmt.Sprintf(\"pf-%s->%s:%d\", conn.RemoteAddr(), host, port)\n+\tlogger := log.WithFields(log.Fields{\n+\t\t\"session\": sessionKey,\n+\t\t\"conn\":    connID,\n+\t})\n+\n+\tdefer func() {\n+\t\tif err := conn.Close(); err != nil {\n+\t\t\tlogger.Debugf(\"connection close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tsshConn := ctx.Value(ssh.ContextKeyConn).(*cryptossh.ServerConn)\n+\tif sshConn == nil {\n+\t\tlogger.Debugf(\"remote forward: no SSH connection in context\")\n+\t\treturn\n+\t}\n+\n+\tremoteAddr, ok := conn.RemoteAddr().(*net.TCPAddr)\n+\tif !ok {\n+\t\tlogger.Warnf(\"remote forward: non-TCP connection type: %T\", conn.RemoteAddr())\n+\t\treturn\n+\t}\n+\n+\tchannel, err := s.openForwardChannel(sshConn, host, port, remoteAddr, logger)\n+\tif err != nil {\n+\t\tlogger.Debugf(\"open forward channel: %v\", err)\n+\t\treturn\n+\t}\n+\n+\ts.proxyForwardConnection(ctx, logger, conn, channel)\n+}\n+\n+// openForwardChannel creates an SSH forwarded-tcpip channel\n+func (s *Server) openForwardChannel(sshConn *cryptossh.ServerConn, host string, port uint32, remoteAddr *net.TCPAddr, logger *log.Entry) (cryptossh.Channel, error) {\n+\tlogger.Tracef(\"opening forwarded-tcpip channel for %s:%d\", host, port)\n+\n+\tpayload := struct {\n+\t\tConnectedAddress  string\n+\t\tConnectedPort     uint32\n+\t\tOriginatorAddress string\n+\t\tOriginatorPort    uint32\n+\t}{\n+\t\tConnectedAddress:  host,\n+\t\tConnectedPort:     port,\n+\t\tOriginatorAddress: remoteAddr.IP.String(),\n+\t\tOriginatorPort:    uint32(remoteAddr.Port),\n+\t}\n+\n+\tchannel, reqs, err := sshConn.OpenChannel(\"forwarded-tcpip\", cryptossh.Marshal(&payload))\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"open SSH channel: %w\", err)\n+\t}\n+\n+\tgo cryptossh.DiscardRequests(reqs)\n+\treturn channel, nil\n+}\n+\n+// proxyForwardConnection handles bidirectional data transfer between connection and SSH channel\n+func (s *Server) proxyForwardConnection(ctx ssh.Context, logger *log.Entry, conn net.Conn, channel cryptossh.Channel) {\n+\tdone := make(chan struct{}, 2)\n+\n+\tgo func() {\n+\t\tif _, err := io.Copy(channel, conn); err != nil {\n+\t\t\tlogger.Debugf(\"copy error (conn->channel): %v\", err)\n+\t\t}\n+\t\tdone <- struct{}{}\n+\t}()\n+\n+\tgo func() {\n+\t\tif _, err := io.Copy(conn, channel); err != nil {\n+\t\t\tlogger.Debugf(\"copy error (channel->conn): %v\", err)\n+\t\t}\n+\t\tdone <- struct{}{}\n+\t}()\n+\n+\tselect {\n+\tcase <-ctx.Done():\n+\t\tlogger.Debugf(\"session ended, closing connections\")\n+\tcase <-done:\n+\t\t// First copy finished, wait for second copy or context cancellation\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\t\tlogger.Debugf(\"session ended, closing connections\")\n+\t\tcase <-done:\n+\t\t}\n+\t}\n+\n+\tif err := channel.Close(); err != nil {\n+\t\tlogger.Debugf(\"channel close error: %v\", err)\n+\t}\n+\tif err := conn.Close(); err != nil {\n+\t\tlogger.Debugf(\"connection close error: %v\", err)\n+\t}\n+}\ndiff --git a/client/ssh/server/server.go b/client/ssh/server/server.go\nnew file mode 100644\nindex 00000000000..44612532b8d\n--- /dev/null\n+++ b/client/ssh/server/server.go\n@@ -0,0 +1,712 @@\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"encoding/base64\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net\"\n+\t\"net/netip\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tgojwt \"github.com/golang-jwt/jwt/v5\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\tcryptossh \"golang.org/x/crypto/ssh\"\n+\t\"golang.org/x/exp/maps\"\n+\t\"golang.zx2c4.com/wireguard/tun/netstack\"\n+\n+\t\"github.com/netbirdio/netbird/client/iface/wgaddr\"\n+\t\"github.com/netbirdio/netbird/client/ssh/detection\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n+\t\"github.com/netbirdio/netbird/shared/auth/jwt\"\n+\t\"github.com/netbirdio/netbird/version\"\n+)\n+\n+// DefaultSSHPort is the default SSH port of the NetBird's embedded SSH server\n+const DefaultSSHPort = 22\n+\n+// InternalSSHPort is the port SSH server listens on and is redirected to\n+const InternalSSHPort = 22022\n+\n+const (\n+\terrWriteSession = \"write session error: %v\"\n+\terrExitSession  = \"exit session error: %v\"\n+\n+\tmsgPrivilegedUserDisabled = \"privileged user login is disabled\"\n+\n+\t// DefaultJWTMaxTokenAge is the default maximum age for JWT tokens accepted by the SSH server\n+\tDefaultJWTMaxTokenAge = 5 * 60\n+)\n+\n+var (\n+\tErrPrivilegedUserDisabled = errors.New(msgPrivilegedUserDisabled)\n+\tErrUserNotFound           = errors.New(\"user not found\")\n+)\n+\n+// PrivilegedUserError represents an error when privileged user login is disabled\n+type PrivilegedUserError struct {\n+\tUsername string\n+}\n+\n+func (e *PrivilegedUserError) Error() string {\n+\treturn fmt.Sprintf(\"%s for user: %s\", msgPrivilegedUserDisabled, e.Username)\n+}\n+\n+func (e *PrivilegedUserError) Is(target error) bool {\n+\treturn target == ErrPrivilegedUserDisabled\n+}\n+\n+// UserNotFoundError represents an error when a user cannot be found\n+type UserNotFoundError struct {\n+\tUsername string\n+\tCause    error\n+}\n+\n+func (e *UserNotFoundError) Error() string {\n+\tif e.Cause != nil {\n+\t\treturn fmt.Sprintf(\"user %s not found: %v\", e.Username, e.Cause)\n+\t}\n+\treturn fmt.Sprintf(\"user %s not found\", e.Username)\n+}\n+\n+func (e *UserNotFoundError) Is(target error) bool {\n+\treturn target == ErrUserNotFound\n+}\n+\n+func (e *UserNotFoundError) Unwrap() error {\n+\treturn e.Cause\n+}\n+\n+// logSessionExitError logs session exit errors, ignoring EOF (normal close) errors\n+func logSessionExitError(logger *log.Entry, err error) {\n+\tif err != nil && !errors.Is(err, io.EOF) {\n+\t\tlogger.Warnf(errExitSession, err)\n+\t}\n+}\n+\n+// safeLogCommand returns a safe representation of the command for logging\n+func safeLogCommand(cmd []string) string {\n+\tif len(cmd) == 0 {\n+\t\treturn \"<interactive shell>\"\n+\t}\n+\tif len(cmd) == 1 {\n+\t\treturn cmd[0]\n+\t}\n+\treturn fmt.Sprintf(\"%s [%d args]\", cmd[0], len(cmd)-1)\n+}\n+\n+type sshConnectionState struct {\n+\thasActivePortForward bool\n+\tusername             string\n+\tremoteAddr           string\n+}\n+\n+type authKey string\n+\n+func newAuthKey(username string, remoteAddr net.Addr) authKey {\n+\treturn authKey(fmt.Sprintf(\"%s@%s\", username, remoteAddr.String()))\n+}\n+\n+type Server struct {\n+\tsshServer       *ssh.Server\n+\tmu              sync.RWMutex\n+\thostKeyPEM      []byte\n+\tsessions        map[SessionKey]ssh.Session\n+\tsessionCancels  map[ConnectionKey]context.CancelFunc\n+\tsessionJWTUsers map[SessionKey]string\n+\tpendingAuthJWT  map[authKey]string\n+\n+\tallowLocalPortForwarding  bool\n+\tallowRemotePortForwarding bool\n+\tallowRootLogin            bool\n+\tallowSFTP                 bool\n+\tjwtEnabled                bool\n+\n+\tnetstackNet *netstack.Net\n+\n+\twgAddress wgaddr.Address\n+\n+\tremoteForwardListeners map[ForwardKey]net.Listener\n+\tsshConnections         map[*cryptossh.ServerConn]*sshConnectionState\n+\n+\tjwtValidator *jwt.Validator\n+\tjwtExtractor *jwt.ClaimsExtractor\n+\tjwtConfig    *JWTConfig\n+\n+\tsuSupportsPty bool\n+}\n+\n+type JWTConfig struct {\n+\tIssuer       string\n+\tAudience     string\n+\tKeysLocation string\n+\tMaxTokenAge  int64\n+}\n+\n+// Config contains all SSH server configuration options\n+type Config struct {\n+\t// JWT authentication configuration. If nil, JWT authentication is disabled\n+\tJWT *JWTConfig\n+\n+\t// HostKey is the SSH server host key in PEM format\n+\tHostKeyPEM []byte\n+}\n+\n+// SessionInfo contains information about an active SSH session\n+type SessionInfo struct {\n+\tUsername      string\n+\tRemoteAddress string\n+\tCommand       string\n+\tJWTUsername   string\n+}\n+\n+// New creates an SSH server instance with the provided host key and optional JWT configuration\n+// If jwtConfig is nil, JWT authentication is disabled\n+func New(config *Config) *Server {\n+\ts := &Server{\n+\t\tmu:                     sync.RWMutex{},\n+\t\thostKeyPEM:             config.HostKeyPEM,\n+\t\tsessions:               make(map[SessionKey]ssh.Session),\n+\t\tsessionJWTUsers:        make(map[SessionKey]string),\n+\t\tpendingAuthJWT:         make(map[authKey]string),\n+\t\tremoteForwardListeners: make(map[ForwardKey]net.Listener),\n+\t\tsshConnections:         make(map[*cryptossh.ServerConn]*sshConnectionState),\n+\t\tjwtEnabled:             config.JWT != nil,\n+\t\tjwtConfig:              config.JWT,\n+\t}\n+\n+\treturn s\n+}\n+\n+// Start runs the SSH server\n+func (s *Server) Start(ctx context.Context, addr netip.AddrPort) error {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n+\tif s.sshServer != nil {\n+\t\treturn errors.New(\"SSH server is already running\")\n+\t}\n+\n+\ts.suSupportsPty = s.detectSuPtySupport(ctx)\n+\n+\tln, addrDesc, err := s.createListener(ctx, addr)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"create listener: %w\", err)\n+\t}\n+\n+\tsshServer, err := s.createSSHServer(ln.Addr())\n+\tif err != nil {\n+\t\ts.closeListener(ln)\n+\t\treturn fmt.Errorf(\"create SSH server: %w\", err)\n+\t}\n+\n+\ts.sshServer = sshServer\n+\tlog.Infof(\"SSH server started on %s\", addrDesc)\n+\n+\tgo func() {\n+\t\tif err := sshServer.Serve(ln); err != nil && !errors.Is(err, ssh.ErrServerClosed) {\n+\t\t\tlog.Errorf(\"SSH server error: %v\", err)\n+\t\t}\n+\t}()\n+\treturn nil\n+}\n+\n+func (s *Server) createListener(ctx context.Context, addr netip.AddrPort) (net.Listener, string, error) {\n+\tif s.netstackNet != nil {\n+\t\tln, err := s.netstackNet.ListenTCPAddrPort(addr)\n+\t\tif err != nil {\n+\t\t\treturn nil, \"\", fmt.Errorf(\"listen on netstack: %w\", err)\n+\t\t}\n+\t\treturn ln, fmt.Sprintf(\"netstack %s\", addr), nil\n+\t}\n+\n+\ttcpAddr := net.TCPAddrFromAddrPort(addr)\n+\tlc := net.ListenConfig{}\n+\tln, err := lc.Listen(ctx, \"tcp\", tcpAddr.String())\n+\tif err != nil {\n+\t\treturn nil, \"\", fmt.Errorf(\"listen: %w\", err)\n+\t}\n+\treturn ln, addr.String(), nil\n+}\n+\n+func (s *Server) closeListener(ln net.Listener) {\n+\tif ln == nil {\n+\t\treturn\n+\t}\n+\tif err := ln.Close(); err != nil {\n+\t\tlog.Debugf(\"listener close error: %v\", err)\n+\t}\n+}\n+\n+// Stop closes the SSH server\n+func (s *Server) Stop() error {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n+\tif s.sshServer == nil {\n+\t\treturn nil\n+\t}\n+\n+\tif err := s.sshServer.Close(); err != nil {\n+\t\tlog.Debugf(\"close SSH server: %v\", err)\n+\t}\n+\n+\ts.sshServer = nil\n+\n+\tmaps.Clear(s.sessions)\n+\tmaps.Clear(s.sessionJWTUsers)\n+\tmaps.Clear(s.pendingAuthJWT)\n+\tmaps.Clear(s.sshConnections)\n+\n+\tfor _, cancelFunc := range s.sessionCancels {\n+\t\tcancelFunc()\n+\t}\n+\tmaps.Clear(s.sessionCancels)\n+\n+\tfor _, listener := range s.remoteForwardListeners {\n+\t\tif err := listener.Close(); err != nil {\n+\t\t\tlog.Debugf(\"close remote forward listener: %v\", err)\n+\t\t}\n+\t}\n+\tmaps.Clear(s.remoteForwardListeners)\n+\n+\treturn nil\n+}\n+\n+// GetStatus returns the current status of the SSH server and active sessions\n+func (s *Server) GetStatus() (enabled bool, sessions []SessionInfo) {\n+\ts.mu.RLock()\n+\tdefer s.mu.RUnlock()\n+\n+\tenabled = s.sshServer != nil\n+\n+\tfor sessionKey, session := range s.sessions {\n+\t\tcmd := \"<interactive shell>\"\n+\t\tif len(session.Command()) > 0 {\n+\t\t\tcmd = safeLogCommand(session.Command())\n+\t\t}\n+\n+\t\tjwtUsername := s.sessionJWTUsers[sessionKey]\n+\n+\t\tsessions = append(sessions, SessionInfo{\n+\t\t\tUsername:      session.User(),\n+\t\t\tRemoteAddress: session.RemoteAddr().String(),\n+\t\t\tCommand:       cmd,\n+\t\t\tJWTUsername:   jwtUsername,\n+\t\t})\n+\t}\n+\n+\treturn enabled, sessions\n+}\n+\n+// SetNetstackNet sets the netstack network for userspace networking\n+func (s *Server) SetNetstackNet(net *netstack.Net) {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\ts.netstackNet = net\n+}\n+\n+// SetNetworkValidation configures network-based connection filtering\n+func (s *Server) SetNetworkValidation(addr wgaddr.Address) {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\ts.wgAddress = addr\n+}\n+\n+// ensureJWTValidator initializes the JWT validator and extractor if not already initialized\n+func (s *Server) ensureJWTValidator() error {\n+\ts.mu.RLock()\n+\tif s.jwtValidator != nil && s.jwtExtractor != nil {\n+\t\ts.mu.RUnlock()\n+\t\treturn nil\n+\t}\n+\tconfig := s.jwtConfig\n+\ts.mu.RUnlock()\n+\n+\tif config == nil {\n+\t\treturn fmt.Errorf(\"JWT config not set\")\n+\t}\n+\n+\tlog.Debugf(\"Initializing JWT validator (issuer: %s, audience: %s)\", config.Issuer, config.Audience)\n+\n+\tvalidator := jwt.NewValidator(\n+\t\tconfig.Issuer,\n+\t\t[]string{config.Audience},\n+\t\tconfig.KeysLocation,\n+\t\ttrue,\n+\t)\n+\n+\textractor := jwt.NewClaimsExtractor(\n+\t\tjwt.WithAudience(config.Audience),\n+\t)\n+\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n+\tif s.jwtValidator != nil && s.jwtExtractor != nil {\n+\t\treturn nil\n+\t}\n+\n+\ts.jwtValidator = validator\n+\ts.jwtExtractor = extractor\n+\n+\tlog.Infof(\"JWT validator initialized successfully\")\n+\treturn nil\n+}\n+\n+func (s *Server) validateJWTToken(tokenString string) (*gojwt.Token, error) {\n+\ts.mu.RLock()\n+\tjwtValidator := s.jwtValidator\n+\tjwtConfig := s.jwtConfig\n+\ts.mu.RUnlock()\n+\n+\tif jwtValidator == nil {\n+\t\treturn nil, fmt.Errorf(\"JWT validator not initialized\")\n+\t}\n+\n+\ttoken, err := jwtValidator.ValidateAndParse(context.Background(), tokenString)\n+\tif err != nil {\n+\t\tif jwtConfig != nil {\n+\t\t\tif claims, parseErr := s.parseTokenWithoutValidation(tokenString); parseErr == nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"validate token (expected issuer=%s, audience=%s, actual issuer=%v, audience=%v): %w\",\n+\t\t\t\t\tjwtConfig.Issuer, jwtConfig.Audience, claims[\"iss\"], claims[\"aud\"], err)\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"validate token: %w\", err)\n+\t}\n+\n+\tif err := s.checkTokenAge(token, jwtConfig); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn token, nil\n+}\n+\n+func (s *Server) checkTokenAge(token *gojwt.Token, jwtConfig *JWTConfig) error {\n+\tif jwtConfig == nil {\n+\t\treturn nil\n+\t}\n+\n+\tmaxTokenAge := jwtConfig.MaxTokenAge\n+\tif maxTokenAge <= 0 {\n+\t\tmaxTokenAge = DefaultJWTMaxTokenAge\n+\t}\n+\n+\tclaims, ok := token.Claims.(gojwt.MapClaims)\n+\tif !ok {\n+\t\tuserID := extractUserID(token)\n+\t\treturn fmt.Errorf(\"token has invalid claims format (user=%s)\", userID)\n+\t}\n+\n+\tiat, ok := claims[\"iat\"].(float64)\n+\tif !ok {\n+\t\tuserID := extractUserID(token)\n+\t\treturn fmt.Errorf(\"token missing iat claim (user=%s)\", userID)\n+\t}\n+\n+\tissuedAt := time.Unix(int64(iat), 0)\n+\ttokenAge := time.Since(issuedAt)\n+\tmaxAge := time.Duration(maxTokenAge) * time.Second\n+\tif tokenAge > maxAge {\n+\t\tuserID := getUserIDFromClaims(claims)\n+\t\treturn fmt.Errorf(\"token expired for user=%s: age=%v, max=%v\", userID, tokenAge, maxAge)\n+\t}\n+\n+\treturn nil\n+}\n+\n+func (s *Server) extractAndValidateUser(token *gojwt.Token) (*auth.UserAuth, error) {\n+\ts.mu.RLock()\n+\tjwtExtractor := s.jwtExtractor\n+\ts.mu.RUnlock()\n+\n+\tif jwtExtractor == nil {\n+\t\tuserID := extractUserID(token)\n+\t\treturn nil, fmt.Errorf(\"JWT extractor not initialized (user=%s)\", userID)\n+\t}\n+\n+\tuserAuth, err := jwtExtractor.ToUserAuth(token)\n+\tif err != nil {\n+\t\tuserID := extractUserID(token)\n+\t\treturn nil, fmt.Errorf(\"extract user from token (user=%s): %w\", userID, err)\n+\t}\n+\n+\tif !s.hasSSHAccess(&userAuth) {\n+\t\treturn nil, fmt.Errorf(\"user %s does not have SSH access permissions\", userAuth.UserId)\n+\t}\n+\n+\treturn &userAuth, nil\n+}\n+\n+func (s *Server) hasSSHAccess(userAuth *auth.UserAuth) bool {\n+\treturn userAuth.UserId != \"\"\n+}\n+\n+func extractUserID(token *gojwt.Token) string {\n+\tif token == nil {\n+\t\treturn \"unknown\"\n+\t}\n+\tclaims, ok := token.Claims.(gojwt.MapClaims)\n+\tif !ok {\n+\t\treturn \"unknown\"\n+\t}\n+\treturn getUserIDFromClaims(claims)\n+}\n+\n+func getUserIDFromClaims(claims gojwt.MapClaims) string {\n+\tif sub, ok := claims[\"sub\"].(string); ok && sub != \"\" {\n+\t\treturn sub\n+\t}\n+\tif userID, ok := claims[\"user_id\"].(string); ok && userID != \"\" {\n+\t\treturn userID\n+\t}\n+\tif email, ok := claims[\"email\"].(string); ok && email != \"\" {\n+\t\treturn email\n+\t}\n+\treturn \"unknown\"\n+}\n+\n+func (s *Server) parseTokenWithoutValidation(tokenString string) (map[string]interface{}, error) {\n+\tparts := strings.Split(tokenString, \".\")\n+\tif len(parts) != 3 {\n+\t\treturn nil, fmt.Errorf(\"invalid token format\")\n+\t}\n+\n+\tpayload, err := base64.RawURLEncoding.DecodeString(parts[1])\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"decode payload: %w\", err)\n+\t}\n+\n+\tvar claims map[string]interface{}\n+\tif err := json.Unmarshal(payload, &claims); err != nil {\n+\t\treturn nil, fmt.Errorf(\"parse claims: %w\", err)\n+\t}\n+\n+\treturn claims, nil\n+}\n+\n+func (s *Server) passwordHandler(ctx ssh.Context, password string) bool {\n+\tif err := s.ensureJWTValidator(); err != nil {\n+\t\tlog.Errorf(\"JWT validator initialization failed for user %s from %s: %v\", ctx.User(), ctx.RemoteAddr(), err)\n+\t\treturn false\n+\t}\n+\n+\ttoken, err := s.validateJWTToken(password)\n+\tif err != nil {\n+\t\tlog.Warnf(\"JWT authentication failed for user %s from %s: %v\", ctx.User(), ctx.RemoteAddr(), err)\n+\t\treturn false\n+\t}\n+\n+\tuserAuth, err := s.extractAndValidateUser(token)\n+\tif err != nil {\n+\t\tlog.Warnf(\"User validation failed for user %s from %s: %v\", ctx.User(), ctx.RemoteAddr(), err)\n+\t\treturn false\n+\t}\n+\n+\tkey := newAuthKey(ctx.User(), ctx.RemoteAddr())\n+\ts.mu.Lock()\n+\ts.pendingAuthJWT[key] = userAuth.UserId\n+\ts.mu.Unlock()\n+\n+\tlog.Infof(\"JWT authentication successful for user %s (JWT user ID: %s) from %s\", ctx.User(), userAuth.UserId, ctx.RemoteAddr())\n+\treturn true\n+}\n+\n+func (s *Server) markConnectionActivePortForward(sshConn *cryptossh.ServerConn, username, remoteAddr string) {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n+\tif state, exists := s.sshConnections[sshConn]; exists {\n+\t\tstate.hasActivePortForward = true\n+\t} else {\n+\t\ts.sshConnections[sshConn] = &sshConnectionState{\n+\t\t\thasActivePortForward: true,\n+\t\t\tusername:             username,\n+\t\t\tremoteAddr:           remoteAddr,\n+\t\t}\n+\t}\n+}\n+\n+func (s *Server) connectionCloseHandler(conn net.Conn, err error) {\n+\t// We can't extract the SSH connection from net.Conn directly\n+\t// Connection cleanup will happen during session cleanup or via timeout\n+\tlog.Debugf(\"SSH connection failed for %s: %v\", conn.RemoteAddr(), err)\n+}\n+\n+func (s *Server) findSessionKeyByContext(ctx ssh.Context) SessionKey {\n+\tif ctx == nil {\n+\t\treturn \"unknown\"\n+\t}\n+\n+\t// Try to match by SSH connection\n+\tsshConn := ctx.Value(ssh.ContextKeyConn)\n+\tif sshConn == nil {\n+\t\treturn \"unknown\"\n+\t}\n+\n+\ts.mu.RLock()\n+\tdefer s.mu.RUnlock()\n+\n+\t// Look through sessions to find one with matching connection\n+\tfor sessionKey, session := range s.sessions {\n+\t\tif session.Context().Value(ssh.ContextKeyConn) == sshConn {\n+\t\t\treturn sessionKey\n+\t\t}\n+\t}\n+\n+\t// If no session found, this might be during early connection setup\n+\t// Return a temporary key that we'll fix up later\n+\tif ctx.User() != \"\" && ctx.RemoteAddr() != nil {\n+\t\ttempKey := SessionKey(fmt.Sprintf(\"%s@%s\", ctx.User(), ctx.RemoteAddr().String()))\n+\t\tlog.Debugf(\"Using temporary session key for early port forward tracking: %s (will be updated when session established)\", tempKey)\n+\t\treturn tempKey\n+\t}\n+\n+\treturn \"unknown\"\n+}\n+\n+func (s *Server) connectionValidator(_ ssh.Context, conn net.Conn) net.Conn {\n+\ts.mu.RLock()\n+\tnetbirdNetwork := s.wgAddress.Network\n+\tlocalIP := s.wgAddress.IP\n+\ts.mu.RUnlock()\n+\n+\tif !netbirdNetwork.IsValid() || !localIP.IsValid() {\n+\t\treturn conn\n+\t}\n+\n+\tremoteAddr := conn.RemoteAddr()\n+\ttcpAddr, ok := remoteAddr.(*net.TCPAddr)\n+\tif !ok {\n+\t\tlog.Warnf(\"SSH connection rejected: non-TCP address %s\", remoteAddr)\n+\t\treturn nil\n+\t}\n+\n+\tremoteIP, ok := netip.AddrFromSlice(tcpAddr.IP)\n+\tif !ok {\n+\t\tlog.Warnf(\"SSH connection rejected: invalid remote IP %s\", tcpAddr.IP)\n+\t\treturn nil\n+\t}\n+\n+\t// Block connections from our own IP (prevent local apps from connecting to ourselves)\n+\tif remoteIP == localIP {\n+\t\tlog.Warnf(\"SSH connection rejected from own IP %s\", remoteIP)\n+\t\treturn nil\n+\t}\n+\n+\tif !netbirdNetwork.Contains(remoteIP) {\n+\t\tlog.Warnf(\"SSH connection rejected from non-NetBird IP %s\", remoteIP)\n+\t\treturn nil\n+\t}\n+\n+\tlog.Infof(\"SSH connection from NetBird peer %s allowed\", tcpAddr)\n+\treturn conn\n+}\n+\n+func (s *Server) createSSHServer(addr net.Addr) (*ssh.Server, error) {\n+\tif err := enableUserSwitching(); err != nil {\n+\t\tlog.Warnf(\"failed to enable user switching: %v\", err)\n+\t}\n+\n+\tserverVersion := fmt.Sprintf(\"%s-%s\", detection.ServerIdentifier, version.NetbirdVersion())\n+\tif s.jwtEnabled {\n+\t\tserverVersion += \" \" + detection.JWTRequiredMarker\n+\t}\n+\n+\tserver := &ssh.Server{\n+\t\tAddr:    addr.String(),\n+\t\tHandler: s.sessionHandler,\n+\t\tSubsystemHandlers: map[string]ssh.SubsystemHandler{\n+\t\t\t\"sftp\": s.sftpSubsystemHandler,\n+\t\t},\n+\t\tHostSigners: []ssh.Signer{},\n+\t\tChannelHandlers: map[string]ssh.ChannelHandler{\n+\t\t\t\"session\":      ssh.DefaultSessionHandler,\n+\t\t\t\"direct-tcpip\": s.directTCPIPHandler,\n+\t\t},\n+\t\tRequestHandlers: map[string]ssh.RequestHandler{\n+\t\t\t\"tcpip-forward\":        s.tcpipForwardHandler,\n+\t\t\t\"cancel-tcpip-forward\": s.cancelTcpipForwardHandler,\n+\t\t},\n+\t\tConnCallback:             s.connectionValidator,\n+\t\tConnectionFailedCallback: s.connectionCloseHandler,\n+\t\tVersion:                  serverVersion,\n+\t}\n+\n+\tif s.jwtEnabled {\n+\t\tserver.PasswordHandler = s.passwordHandler\n+\t}\n+\n+\thostKeyPEM := ssh.HostKeyPEM(s.hostKeyPEM)\n+\tif err := server.SetOption(hostKeyPEM); err != nil {\n+\t\treturn nil, fmt.Errorf(\"set host key: %w\", err)\n+\t}\n+\n+\ts.configurePortForwarding(server)\n+\treturn server, nil\n+}\n+\n+func (s *Server) storeRemoteForwardListener(key ForwardKey, ln net.Listener) {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\ts.remoteForwardListeners[key] = ln\n+}\n+\n+func (s *Server) removeRemoteForwardListener(key ForwardKey) bool {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n+\tln, exists := s.remoteForwardListeners[key]\n+\tif !exists {\n+\t\treturn false\n+\t}\n+\n+\tdelete(s.remoteForwardListeners, key)\n+\tif err := ln.Close(); err != nil {\n+\t\tlog.Debugf(\"remote forward listener close error: %v\", err)\n+\t}\n+\n+\treturn true\n+}\n+\n+func (s *Server) directTCPIPHandler(srv *ssh.Server, conn *cryptossh.ServerConn, newChan cryptossh.NewChannel, ctx ssh.Context) {\n+\tvar payload struct {\n+\t\tHost           string\n+\t\tPort           uint32\n+\t\tOriginatorAddr string\n+\t\tOriginatorPort uint32\n+\t}\n+\n+\tif err := cryptossh.Unmarshal(newChan.ExtraData(), &payload); err != nil {\n+\t\tif err := newChan.Reject(cryptossh.ConnectionFailed, \"parse payload\"); err != nil {\n+\t\t\tlog.Debugf(\"channel reject error: %v\", err)\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\ts.mu.RLock()\n+\tallowLocal := s.allowLocalPortForwarding\n+\ts.mu.RUnlock()\n+\n+\tif !allowLocal {\n+\t\tlog.Warnf(\"local port forwarding denied for %s:%d: disabled by configuration\", payload.Host, payload.Port)\n+\t\t_ = newChan.Reject(cryptossh.Prohibited, \"local port forwarding disabled\")\n+\t\treturn\n+\t}\n+\n+\t// Check privilege requirements for the destination port\n+\tif err := s.checkPortForwardingPrivileges(ctx, \"local\", payload.Port); err != nil {\n+\t\tlog.Warnf(\"local port forwarding denied for %s:%d: %v\", payload.Host, payload.Port, err)\n+\t\t_ = newChan.Reject(cryptossh.Prohibited, \"insufficient privileges\")\n+\t\treturn\n+\t}\n+\n+\tlog.Infof(\"local port forwarding: %s:%d\", payload.Host, payload.Port)\n+\n+\tssh.DirectTCPIPHandler(srv, conn, newChan, ctx)\n+}\ndiff --git a/client/ssh/server/session_handlers.go b/client/ssh/server/session_handlers.go\nnew file mode 100644\nindex 00000000000..4e6d720980e\n--- /dev/null\n+++ b/client/ssh/server/session_handlers.go\n@@ -0,0 +1,168 @@\n+package server\n+\n+import (\n+\t\"crypto/sha256\"\n+\t\"encoding/hex\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\tcryptossh \"golang.org/x/crypto/ssh\"\n+)\n+\n+// sessionHandler handles SSH sessions\n+func (s *Server) sessionHandler(session ssh.Session) {\n+\tsessionKey := s.registerSession(session)\n+\n+\tkey := newAuthKey(session.User(), session.RemoteAddr())\n+\ts.mu.Lock()\n+\tjwtUsername := s.pendingAuthJWT[key]\n+\tif jwtUsername != \"\" {\n+\t\ts.sessionJWTUsers[sessionKey] = jwtUsername\n+\t\tdelete(s.pendingAuthJWT, key)\n+\t}\n+\ts.mu.Unlock()\n+\n+\tlogger := log.WithField(\"session\", sessionKey)\n+\tif jwtUsername != \"\" {\n+\t\tlogger = logger.WithField(\"jwt_user\", jwtUsername)\n+\t\tlogger.Infof(\"SSH session started (JWT user: %s)\", jwtUsername)\n+\t} else {\n+\t\tlogger.Infof(\"SSH session started\")\n+\t}\n+\tsessionStart := time.Now()\n+\n+\tdefer s.unregisterSession(sessionKey, session)\n+\tdefer func() {\n+\t\tduration := time.Since(sessionStart).Round(time.Millisecond)\n+\t\tif err := session.Close(); err != nil && !errors.Is(err, io.EOF) {\n+\t\t\tlogger.Warnf(\"close session after %v: %v\", duration, err)\n+\t\t}\n+\t\tlogger.Infof(\"SSH session closed after %v\", duration)\n+\t}()\n+\n+\tprivilegeResult, err := s.userPrivilegeCheck(session.User())\n+\tif err != nil {\n+\t\ts.handlePrivError(logger, session, err)\n+\t\treturn\n+\t}\n+\n+\tptyReq, winCh, isPty := session.Pty()\n+\thasCommand := len(session.Command()) > 0\n+\n+\tswitch {\n+\tcase isPty && hasCommand:\n+\t\t// ssh -t <host> <cmd> - Pty command execution\n+\t\ts.handleCommand(logger, session, privilegeResult, winCh)\n+\tcase isPty:\n+\t\t// ssh <host> - Pty interactive session (login)\n+\t\ts.handlePty(logger, session, privilegeResult, ptyReq, winCh)\n+\tcase hasCommand:\n+\t\t// ssh <host> <cmd> - non-Pty command execution\n+\t\ts.handleCommand(logger, session, privilegeResult, nil)\n+\tdefault:\n+\t\ts.rejectInvalidSession(logger, session)\n+\t}\n+}\n+\n+func (s *Server) rejectInvalidSession(logger *log.Entry, session ssh.Session) {\n+\tif _, err := io.WriteString(session, \"no command specified and Pty not requested\\n\"); err != nil {\n+\t\tlogger.Debugf(errWriteSession, err)\n+\t}\n+\tif err := session.Exit(1); err != nil {\n+\t\tlogSessionExitError(logger, err)\n+\t}\n+\tlogger.Infof(\"rejected non-Pty session without command from %s\", session.RemoteAddr())\n+}\n+\n+func (s *Server) registerSession(session ssh.Session) SessionKey {\n+\tsessionID := session.Context().Value(ssh.ContextKeySessionID)\n+\tif sessionID == nil {\n+\t\tsessionID = fmt.Sprintf(\"%p\", session)\n+\t}\n+\n+\t// Create a short 4-byte identifier from the full session ID\n+\thasher := sha256.New()\n+\thasher.Write([]byte(fmt.Sprintf(\"%v\", sessionID)))\n+\thash := hasher.Sum(nil)\n+\tshortID := hex.EncodeToString(hash[:4])\n+\n+\tremoteAddr := session.RemoteAddr().String()\n+\tusername := session.User()\n+\tsessionKey := SessionKey(fmt.Sprintf(\"%s@%s-%s\", username, remoteAddr, shortID))\n+\n+\ts.mu.Lock()\n+\ts.sessions[sessionKey] = session\n+\ts.mu.Unlock()\n+\n+\treturn sessionKey\n+}\n+\n+func (s *Server) unregisterSession(sessionKey SessionKey, session ssh.Session) {\n+\ts.mu.Lock()\n+\tdelete(s.sessions, sessionKey)\n+\tdelete(s.sessionJWTUsers, sessionKey)\n+\n+\t// Cancel all port forwarding connections for this session\n+\tvar connectionsToCancel []ConnectionKey\n+\tfor key := range s.sessionCancels {\n+\t\tif strings.HasPrefix(string(key), string(sessionKey)+\"-\") {\n+\t\t\tconnectionsToCancel = append(connectionsToCancel, key)\n+\t\t}\n+\t}\n+\n+\tfor _, key := range connectionsToCancel {\n+\t\tif cancelFunc, exists := s.sessionCancels[key]; exists {\n+\t\t\tlog.WithField(\"session\", sessionKey).Debugf(\"cancelling port forwarding context: %s\", key)\n+\t\t\tcancelFunc()\n+\t\t\tdelete(s.sessionCancels, key)\n+\t\t}\n+\t}\n+\n+\tif sshConnValue := session.Context().Value(ssh.ContextKeyConn); sshConnValue != nil {\n+\t\tif sshConn, ok := sshConnValue.(*cryptossh.ServerConn); ok {\n+\t\t\tdelete(s.sshConnections, sshConn)\n+\t\t}\n+\t}\n+\n+\ts.mu.Unlock()\n+}\n+\n+func (s *Server) handlePrivError(logger *log.Entry, session ssh.Session, err error) {\n+\tlogger.Warnf(\"user privilege check failed: %v\", err)\n+\n+\terrorMsg := s.buildUserLookupErrorMessage(err)\n+\n+\tif _, writeErr := fmt.Fprint(session, errorMsg); writeErr != nil {\n+\t\tlogger.Debugf(errWriteSession, writeErr)\n+\t}\n+\tif exitErr := session.Exit(1); exitErr != nil {\n+\t\tlogSessionExitError(logger, exitErr)\n+\t}\n+}\n+\n+// buildUserLookupErrorMessage creates appropriate user-facing error messages based on error type\n+func (s *Server) buildUserLookupErrorMessage(err error) string {\n+\tvar privilegedErr *PrivilegedUserError\n+\n+\tswitch {\n+\tcase errors.As(err, &privilegedErr):\n+\t\tif privilegedErr.Username == \"root\" {\n+\t\t\treturn \"root login is disabled on this SSH server\\n\"\n+\t\t}\n+\t\treturn \"privileged user access is disabled on this SSH server\\n\"\n+\n+\tcase errors.Is(err, ErrPrivilegeRequired):\n+\t\treturn \"Windows user switching failed - NetBird must run with elevated privileges for user switching\\n\"\n+\n+\tcase errors.Is(err, ErrPrivilegedUserSwitch):\n+\t\treturn \"Cannot switch to privileged user - current user lacks required privileges\\n\"\n+\n+\tdefault:\n+\t\treturn \"User authentication failed\\n\"\n+\t}\n+}\ndiff --git a/client/ssh/server/session_handlers_js.go b/client/ssh/server/session_handlers_js.go\nnew file mode 100644\nindex 00000000000..c35e4da0b6e\n--- /dev/null\n+++ b/client/ssh/server/session_handlers_js.go\n@@ -0,0 +1,22 @@\n+//go:build js\n+\n+package server\n+\n+import (\n+\t\"fmt\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+)\n+\n+// handlePty is not supported on JS/WASM\n+func (s *Server) handlePty(logger *log.Entry, session ssh.Session, _ PrivilegeCheckResult, _ ssh.Pty, _ <-chan ssh.Window) bool {\n+\terrorMsg := \"PTY sessions are not supported on WASM/JS platform\\n\"\n+\tif _, err := fmt.Fprint(session.Stderr(), errorMsg); err != nil {\n+\t\tlogger.Debugf(errWriteSession, err)\n+\t}\n+\tif err := session.Exit(1); err != nil {\n+\t\tlogSessionExitError(logger, err)\n+\t}\n+\treturn false\n+}\ndiff --git a/client/ssh/server/sftp.go b/client/ssh/server/sftp.go\nnew file mode 100644\nindex 00000000000..c2b9f552bf2\n--- /dev/null\n+++ b/client/ssh/server/sftp.go\n@@ -0,0 +1,81 @@\n+package server\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\t\"github.com/pkg/sftp\"\n+\tlog \"github.com/sirupsen/logrus\"\n+)\n+\n+// SetAllowSFTP enables or disables SFTP support\n+func (s *Server) SetAllowSFTP(allow bool) {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\ts.allowSFTP = allow\n+}\n+\n+// sftpSubsystemHandler handles SFTP subsystem requests\n+func (s *Server) sftpSubsystemHandler(sess ssh.Session) {\n+\ts.mu.RLock()\n+\tallowSFTP := s.allowSFTP\n+\ts.mu.RUnlock()\n+\n+\tif !allowSFTP {\n+\t\tlog.Debugf(\"SFTP subsystem request denied: SFTP disabled\")\n+\t\tif err := sess.Exit(1); err != nil {\n+\t\t\tlog.Debugf(\"SFTP session exit failed: %v\", err)\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tresult := s.CheckPrivileges(PrivilegeCheckRequest{\n+\t\tRequestedUsername:         sess.User(),\n+\t\tFeatureSupportsUserSwitch: true,\n+\t\tFeatureName:               FeatureSFTP,\n+\t})\n+\n+\tif !result.Allowed {\n+\t\tlog.Warnf(\"SFTP access denied for user %s from %s: %v\", sess.User(), sess.RemoteAddr(), result.Error)\n+\t\tif err := sess.Exit(1); err != nil {\n+\t\t\tlog.Debugf(\"exit SFTP session: %v\", err)\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tlog.Debugf(\"SFTP subsystem request from user %s (effective user %s)\", sess.User(), result.User.Username)\n+\n+\tif !result.RequiresUserSwitching {\n+\t\tif err := s.executeSftpDirect(sess); err != nil {\n+\t\t\tlog.Errorf(\"SFTP direct execution: %v\", err)\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tif err := s.executeSftpWithPrivilegeDrop(sess, result.User); err != nil {\n+\t\tlog.Errorf(\"SFTP privilege drop execution: %v\", err)\n+\t}\n+}\n+\n+// executeSftpDirect executes SFTP directly without privilege dropping\n+func (s *Server) executeSftpDirect(sess ssh.Session) error {\n+\tlog.Debugf(\"starting SFTP session for user %s (no privilege dropping)\", sess.User())\n+\n+\tsftpServer, err := sftp.NewServer(sess)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"SFTP server creation: %w\", err)\n+\t}\n+\n+\tdefer func() {\n+\t\tif err := sftpServer.Close(); err != nil {\n+\t\t\tlog.Debugf(\"failed to close sftp server: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tif err := sftpServer.Serve(); err != nil && err != io.EOF {\n+\t\treturn fmt.Errorf(\"serve: %w\", err)\n+\t}\n+\n+\treturn nil\n+}\ndiff --git a/client/ssh/server/sftp_js.go b/client/ssh/server/sftp_js.go\nnew file mode 100644\nindex 00000000000..3b27aeff4c1\n--- /dev/null\n+++ b/client/ssh/server/sftp_js.go\n@@ -0,0 +1,12 @@\n+//go:build js\n+\n+package server\n+\n+import (\n+\t\"os/user\"\n+)\n+\n+// parseUserCredentials is not supported on JS/WASM\n+func (s *Server) parseUserCredentials(_ *user.User) (uint32, uint32, []uint32, error) {\n+\treturn 0, 0, nil, errNotSupported\n+}\ndiff --git a/client/ssh/server/sftp_unix.go b/client/ssh/server/sftp_unix.go\nnew file mode 100644\nindex 00000000000..44202bead8f\n--- /dev/null\n+++ b/client/ssh/server/sftp_unix.go\n@@ -0,0 +1,71 @@\n+//go:build !windows\n+\n+package server\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"os/user\"\n+\t\"strconv\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+)\n+\n+// executeSftpWithPrivilegeDrop executes SFTP using Unix privilege dropping\n+func (s *Server) executeSftpWithPrivilegeDrop(sess ssh.Session, targetUser *user.User) error {\n+\tuid, gid, groups, err := s.parseUserCredentials(targetUser)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"parse user credentials: %w\", err)\n+\t}\n+\n+\tsftpCmd, err := s.createSftpExecutorCommand(sess, uid, gid, groups, targetUser.HomeDir)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"create executor: %w\", err)\n+\t}\n+\n+\tsftpCmd.Stdin = sess\n+\tsftpCmd.Stdout = sess\n+\tsftpCmd.Stderr = sess.Stderr()\n+\n+\tlog.Tracef(\"starting SFTP with privilege dropping to user %s (UID=%d, GID=%d)\", targetUser.Username, uid, gid)\n+\n+\tif err := sftpCmd.Start(); err != nil {\n+\t\treturn fmt.Errorf(\"starting SFTP executor: %w\", err)\n+\t}\n+\n+\tif err := sftpCmd.Wait(); err != nil {\n+\t\tvar exitError *exec.ExitError\n+\t\tif errors.As(err, &exitError) {\n+\t\t\tlog.Tracef(\"SFTP process exited with code %d\", exitError.ExitCode())\n+\t\t\treturn nil\n+\t\t}\n+\t\treturn fmt.Errorf(\"exec: %w\", err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// createSftpExecutorCommand creates a command that spawns netbird ssh sftp for privilege dropping\n+func (s *Server) createSftpExecutorCommand(sess ssh.Session, uid, gid uint32, groups []uint32, workingDir string) (*exec.Cmd, error) {\n+\tnetbirdPath, err := os.Executable()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\targs := []string{\n+\t\t\"ssh\", \"sftp\",\n+\t\t\"--uid\", strconv.FormatUint(uint64(uid), 10),\n+\t\t\"--gid\", strconv.FormatUint(uint64(gid), 10),\n+\t\t\"--working-dir\", workingDir,\n+\t}\n+\n+\tfor _, group := range groups {\n+\t\targs = append(args, \"--groups\", strconv.FormatUint(uint64(group), 10))\n+\t}\n+\n+\tlog.Tracef(\"creating SFTP executor command: %s %v\", netbirdPath, args)\n+\treturn exec.CommandContext(sess.Context(), netbirdPath, args...), nil\n+}\ndiff --git a/client/ssh/server/sftp_windows.go b/client/ssh/server/sftp_windows.go\nnew file mode 100644\nindex 00000000000..dc532b9e766\n--- /dev/null\n+++ b/client/ssh/server/sftp_windows.go\n@@ -0,0 +1,91 @@\n+//go:build windows\n+\n+package server\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"os/user\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"golang.org/x/sys/windows\"\n+)\n+\n+// createSftpCommand creates a Windows SFTP command with user switching.\n+// The caller must close the returned token handle after starting the process.\n+func (s *Server) createSftpCommand(targetUser *user.User, sess ssh.Session) (*exec.Cmd, windows.Token, error) {\n+\tusername, domain := s.parseUsername(targetUser.Username)\n+\n+\tnetbirdPath, err := os.Executable()\n+\tif err != nil {\n+\t\treturn nil, 0, fmt.Errorf(\"get netbird executable path: %w\", err)\n+\t}\n+\n+\targs := []string{\n+\t\t\"ssh\", \"sftp\",\n+\t\t\"--working-dir\", targetUser.HomeDir,\n+\t\t\"--windows-username\", username,\n+\t\t\"--windows-domain\", domain,\n+\t}\n+\n+\tpd := NewPrivilegeDropper()\n+\ttoken, err := pd.createToken(username, domain)\n+\tif err != nil {\n+\t\treturn nil, 0, fmt.Errorf(\"create token: %w\", err)\n+\t}\n+\n+\tdefer func() {\n+\t\tif err := windows.CloseHandle(token); err != nil {\n+\t\t\tlog.Warnf(\"failed to close impersonation token: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tcmd, primaryToken, err := pd.createProcessWithToken(sess.Context(), windows.Token(token), netbirdPath, append([]string{netbirdPath}, args...), targetUser.HomeDir)\n+\tif err != nil {\n+\t\treturn nil, 0, fmt.Errorf(\"create SFTP command: %w\", err)\n+\t}\n+\n+\tlog.Debugf(\"Created Windows SFTP command with user switching for %s\", targetUser.Username)\n+\treturn cmd, primaryToken, nil\n+}\n+\n+// executeSftpCommand executes a Windows SFTP command with proper I/O handling\n+func (s *Server) executeSftpCommand(sess ssh.Session, sftpCmd *exec.Cmd, token windows.Token) error {\n+\tdefer func() {\n+\t\tif err := windows.CloseHandle(windows.Handle(token)); err != nil {\n+\t\t\tlog.Debugf(\"close primary token: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tsftpCmd.Stdin = sess\n+\tsftpCmd.Stdout = sess\n+\tsftpCmd.Stderr = sess.Stderr()\n+\n+\tif err := sftpCmd.Start(); err != nil {\n+\t\treturn fmt.Errorf(\"starting sftp executor: %w\", err)\n+\t}\n+\n+\tif err := sftpCmd.Wait(); err != nil {\n+\t\tvar exitError *exec.ExitError\n+\t\tif errors.As(err, &exitError) {\n+\t\t\tlog.Tracef(\"sftp process exited with code %d\", exitError.ExitCode())\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\treturn fmt.Errorf(\"exec sftp: %w\", err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// executeSftpWithPrivilegeDrop executes SFTP using Windows privilege dropping\n+func (s *Server) executeSftpWithPrivilegeDrop(sess ssh.Session, targetUser *user.User) error {\n+\tsftpCmd, token, err := s.createSftpCommand(targetUser, sess)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"create sftp: %w\", err)\n+\t}\n+\treturn s.executeSftpCommand(sess, sftpCmd, token)\n+}\ndiff --git a/client/ssh/server/shell.go b/client/ssh/server/shell.go\nnew file mode 100644\nindex 00000000000..fea9d291097\n--- /dev/null\n+++ b/client/ssh/server/shell.go\n@@ -0,0 +1,180 @@\n+package server\n+\n+import (\n+\t\"bufio\"\n+\t\"fmt\"\n+\t\"net\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"os/user\"\n+\t\"runtime\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+)\n+\n+const (\n+\tdefaultUnixShell = \"/bin/sh\"\n+\n+\tpwshExe       = \"pwsh.exe\" // #nosec G101 - This is not a credential, just executable name\n+\tpowershellExe = \"powershell.exe\"\n+)\n+\n+// getUserShell returns the appropriate shell for the given user ID\n+// Handles all platform-specific logic and fallbacks consistently\n+func getUserShell(userID string) string {\n+\tswitch runtime.GOOS {\n+\tcase \"windows\":\n+\t\treturn getWindowsUserShell()\n+\tdefault:\n+\t\treturn getUnixUserShell(userID)\n+\t}\n+}\n+\n+// getWindowsUserShell returns the best shell for Windows users.\n+// We intentionally do not support cmd.exe or COMSPEC fallbacks to avoid command injection\n+// vulnerabilities that arise from cmd.exe's complex command line parsing and special characters.\n+// PowerShell provides safer argument handling and is available on all modern Windows systems.\n+// Order: pwsh.exe -> powershell.exe\n+func getWindowsUserShell() string {\n+\tif path, err := exec.LookPath(pwshExe); err == nil {\n+\t\treturn path\n+\t}\n+\tif path, err := exec.LookPath(powershellExe); err == nil {\n+\t\treturn path\n+\t}\n+\n+\treturn `C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe`\n+}\n+\n+// getUnixUserShell returns the shell for Unix-like systems\n+func getUnixUserShell(userID string) string {\n+\tshell := getShellFromPasswd(userID)\n+\tif shell != \"\" {\n+\t\treturn shell\n+\t}\n+\n+\tif shell := os.Getenv(\"SHELL\"); shell != \"\" {\n+\t\treturn shell\n+\t}\n+\n+\treturn defaultUnixShell\n+}\n+\n+// getShellFromPasswd reads the shell from /etc/passwd for the given user ID\n+func getShellFromPasswd(userID string) string {\n+\tfile, err := os.Open(\"/etc/passwd\")\n+\tif err != nil {\n+\t\treturn \"\"\n+\t}\n+\tdefer func() {\n+\t\tif err := file.Close(); err != nil {\n+\t\t\tlog.Warnf(\"close /etc/passwd file: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tscanner := bufio.NewScanner(file)\n+\tfor scanner.Scan() {\n+\t\tline := scanner.Text()\n+\t\tfields := strings.Split(line, \":\")\n+\t\tif len(fields) < 7 {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// field 2 is UID\n+\t\tif fields[2] == userID {\n+\t\t\tshell := strings.TrimSpace(fields[6])\n+\t\t\treturn shell\n+\t\t}\n+\t}\n+\n+\tif err := scanner.Err(); err != nil {\n+\t\tlog.Warnf(\"error reading /etc/passwd: %v\", err)\n+\t}\n+\n+\treturn \"\"\n+}\n+\n+// prepareUserEnv prepares environment variables for user execution\n+func prepareUserEnv(user *user.User, shell string) []string {\n+\tpathValue := \"/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games\"\n+\tif runtime.GOOS == \"windows\" {\n+\t\tpathValue = `C:\\Windows\\System32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0`\n+\t}\n+\n+\treturn []string{\n+\t\tfmt.Sprint(\"SHELL=\" + shell),\n+\t\tfmt.Sprint(\"USER=\" + user.Username),\n+\t\tfmt.Sprint(\"LOGNAME=\" + user.Username),\n+\t\tfmt.Sprint(\"HOME=\" + user.HomeDir),\n+\t\t\"PATH=\" + pathValue,\n+\t}\n+}\n+\n+// acceptEnv checks if environment variable from SSH client should be accepted\n+// This is a whitelist of variables that SSH clients can send to the server\n+func acceptEnv(envVar string) bool {\n+\tvarName := envVar\n+\tif idx := strings.Index(envVar, \"=\"); idx != -1 {\n+\t\tvarName = envVar[:idx]\n+\t}\n+\n+\texactMatches := []string{\n+\t\t\"LANG\",\n+\t\t\"LANGUAGE\",\n+\t\t\"TERM\",\n+\t\t\"COLORTERM\",\n+\t\t\"EDITOR\",\n+\t\t\"VISUAL\",\n+\t\t\"PAGER\",\n+\t\t\"LESS\",\n+\t\t\"LESSCHARSET\",\n+\t\t\"TZ\",\n+\t}\n+\n+\tprefixMatches := []string{\n+\t\t\"LC_\",\n+\t}\n+\n+\tfor _, exact := range exactMatches {\n+\t\tif varName == exact {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\tfor _, prefix := range prefixMatches {\n+\t\tif strings.HasPrefix(varName, prefix) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\treturn false\n+}\n+\n+// prepareSSHEnv prepares SSH protocol-specific environment variables\n+// These variables provide information about the SSH connection itself\n+func prepareSSHEnv(session ssh.Session) []string {\n+\tremoteAddr := session.RemoteAddr()\n+\tlocalAddr := session.LocalAddr()\n+\n+\tremoteHost, remotePort, err := net.SplitHostPort(remoteAddr.String())\n+\tif err != nil {\n+\t\tremoteHost = remoteAddr.String()\n+\t\tremotePort = \"0\"\n+\t}\n+\n+\tlocalHost, localPort, err := net.SplitHostPort(localAddr.String())\n+\tif err != nil {\n+\t\tlocalHost = localAddr.String()\n+\t\tlocalPort = strconv.Itoa(InternalSSHPort)\n+\t}\n+\n+\treturn []string{\n+\t\t// SSH_CLIENT format: \"client_ip client_port server_port\"\n+\t\tfmt.Sprintf(\"SSH_CLIENT=%s %s %s\", remoteHost, remotePort, localPort),\n+\t\t// SSH_CONNECTION format: \"client_ip client_port server_ip server_port\"\n+\t\tfmt.Sprintf(\"SSH_CONNECTION=%s %s %s %s\", remoteHost, remotePort, localHost, localPort),\n+\t}\n+}\ndiff --git a/client/ssh/server/user_utils.go b/client/ssh/server/user_utils.go\nnew file mode 100644\nindex 00000000000..799882cbb51\n--- /dev/null\n+++ b/client/ssh/server/user_utils.go\n@@ -0,0 +1,411 @@\n+package server\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"os/user\"\n+\t\"runtime\"\n+\t\"strings\"\n+\n+\tlog \"github.com/sirupsen/logrus\"\n+)\n+\n+var (\n+\tErrPrivilegeRequired    = errors.New(\"SeAssignPrimaryTokenPrivilege required for user switching - NetBird must run with elevated privileges\")\n+\tErrPrivilegedUserSwitch = errors.New(\"cannot switch to privileged user - current user lacks required privileges\")\n+)\n+\n+// isPlatformUnix returns true for Unix-like platforms (Linux, macOS, etc.)\n+func isPlatformUnix() bool {\n+\treturn getCurrentOS() != \"windows\"\n+}\n+\n+// Dependency injection variables for testing - allows mocking dynamic runtime checks\n+var (\n+\tgetCurrentUser         = user.Current\n+\tlookupUser             = user.Lookup\n+\tgetCurrentOS           = func() string { return runtime.GOOS }\n+\tgetIsProcessPrivileged = isCurrentProcessPrivileged\n+\n+\tgetEuid = os.Geteuid\n+)\n+\n+const (\n+\t// FeatureSSHLogin represents SSH login operations for privilege checking\n+\tFeatureSSHLogin = \"SSH login\"\n+\t// FeatureSFTP represents SFTP operations for privilege checking\n+\tFeatureSFTP = \"SFTP\"\n+)\n+\n+// PrivilegeCheckRequest represents a privilege check request\n+type PrivilegeCheckRequest struct {\n+\t// Username being requested (empty = current user)\n+\tRequestedUsername         string\n+\tFeatureSupportsUserSwitch bool // Does this feature/operation support user switching?\n+\tFeatureName               string\n+}\n+\n+// PrivilegeCheckResult represents the result of a privilege check\n+type PrivilegeCheckResult struct {\n+\t// Allowed indicates whether the privilege check passed\n+\tAllowed bool\n+\t// User is the effective user to use for the operation (nil if not allowed)\n+\tUser *user.User\n+\t// Error contains the reason for denial (nil if allowed)\n+\tError error\n+\t// UsedFallback indicates we fell back to current user instead of requested user.\n+\t// This happens on Unix when running as an unprivileged user (e.g., in containers)\n+\t// where there's no point in user switching since we lack privileges anyway.\n+\t// When true, all privilege checks have already been performed and no additional\n+\t// privilege dropping or root checks are needed - the current user is the target.\n+\tUsedFallback bool\n+\t// RequiresUserSwitching indicates whether user switching will actually occur\n+\t// (false for fallback cases where no actual switching happens)\n+\tRequiresUserSwitching bool\n+}\n+\n+// CheckPrivileges performs comprehensive privilege checking for all SSH features.\n+// This is the single source of truth for privilege decisions across the SSH server.\n+func (s *Server) CheckPrivileges(req PrivilegeCheckRequest) PrivilegeCheckResult {\n+\tcontext, err := s.buildPrivilegeCheckContext(req.FeatureName)\n+\tif err != nil {\n+\t\treturn PrivilegeCheckResult{Allowed: false, Error: err}\n+\t}\n+\n+\t// Handle empty username case - but still check root access controls\n+\tif req.RequestedUsername == \"\" {\n+\t\tif isPrivilegedUsername(context.currentUser.Username) && !context.allowRoot {\n+\t\t\treturn PrivilegeCheckResult{\n+\t\t\t\tAllowed: false,\n+\t\t\t\tError:   &PrivilegedUserError{Username: context.currentUser.Username},\n+\t\t\t}\n+\t\t}\n+\t\treturn PrivilegeCheckResult{\n+\t\t\tAllowed:               true,\n+\t\t\tUser:                  context.currentUser,\n+\t\t\tRequiresUserSwitching: false,\n+\t\t}\n+\t}\n+\n+\treturn s.checkUserRequest(context, req)\n+}\n+\n+// buildPrivilegeCheckContext gathers all the context needed for privilege checking\n+func (s *Server) buildPrivilegeCheckContext(featureName string) (*privilegeCheckContext, error) {\n+\tcurrentUser, err := getCurrentUser()\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"get current user for %s: %w\", featureName, err)\n+\t}\n+\n+\ts.mu.RLock()\n+\tallowRoot := s.allowRootLogin\n+\ts.mu.RUnlock()\n+\n+\treturn &privilegeCheckContext{\n+\t\tcurrentUser:           currentUser,\n+\t\tcurrentUserPrivileged: getIsProcessPrivileged(),\n+\t\tallowRoot:             allowRoot,\n+\t}, nil\n+}\n+\n+// checkUserRequest handles normal privilege checking flow for specific usernames\n+func (s *Server) checkUserRequest(ctx *privilegeCheckContext, req PrivilegeCheckRequest) PrivilegeCheckResult {\n+\tif !ctx.currentUserPrivileged && isPlatformUnix() {\n+\t\tlog.Debugf(\"Unix non-privileged shortcut: falling back to current user %s for %s (requested: %s)\",\n+\t\t\tctx.currentUser.Username, req.FeatureName, req.RequestedUsername)\n+\t\treturn PrivilegeCheckResult{\n+\t\t\tAllowed:               true,\n+\t\t\tUser:                  ctx.currentUser,\n+\t\t\tUsedFallback:          true,\n+\t\t\tRequiresUserSwitching: false,\n+\t\t}\n+\t}\n+\n+\tresolvedUser, err := s.resolveRequestedUser(req.RequestedUsername)\n+\tif err != nil {\n+\t\t// Calculate if user switching would be required even if lookup failed\n+\t\tneedsUserSwitching := !isSameUser(req.RequestedUsername, ctx.currentUser.Username)\n+\t\treturn PrivilegeCheckResult{\n+\t\t\tAllowed:               false,\n+\t\t\tError:                 err,\n+\t\t\tRequiresUserSwitching: needsUserSwitching,\n+\t\t}\n+\t}\n+\n+\tneedsUserSwitching := !isSameResolvedUser(resolvedUser, ctx.currentUser)\n+\n+\tif isPrivilegedUsername(resolvedUser.Username) && !ctx.allowRoot {\n+\t\treturn PrivilegeCheckResult{\n+\t\t\tAllowed:               false,\n+\t\t\tError:                 &PrivilegedUserError{Username: resolvedUser.Username},\n+\t\t\tRequiresUserSwitching: needsUserSwitching,\n+\t\t}\n+\t}\n+\n+\tif needsUserSwitching && !req.FeatureSupportsUserSwitch {\n+\t\treturn PrivilegeCheckResult{\n+\t\t\tAllowed:               false,\n+\t\t\tError:                 fmt.Errorf(\"%s: user switching not supported by this feature\", req.FeatureName),\n+\t\t\tRequiresUserSwitching: needsUserSwitching,\n+\t\t}\n+\t}\n+\n+\treturn PrivilegeCheckResult{\n+\t\tAllowed:               true,\n+\t\tUser:                  resolvedUser,\n+\t\tRequiresUserSwitching: needsUserSwitching,\n+\t}\n+}\n+\n+// resolveRequestedUser resolves a username to its canonical user identity\n+func (s *Server) resolveRequestedUser(requestedUsername string) (*user.User, error) {\n+\tif requestedUsername == \"\" {\n+\t\treturn getCurrentUser()\n+\t}\n+\n+\tif err := validateUsername(requestedUsername); err != nil {\n+\t\treturn nil, fmt.Errorf(\"invalid username %q: %w\", requestedUsername, err)\n+\t}\n+\n+\tu, err := lookupUser(requestedUsername)\n+\tif err != nil {\n+\t\treturn nil, &UserNotFoundError{Username: requestedUsername, Cause: err}\n+\t}\n+\treturn u, nil\n+}\n+\n+// isSameResolvedUser compares two resolved user identities\n+func isSameResolvedUser(user1, user2 *user.User) bool {\n+\tif user1 == nil || user2 == nil {\n+\t\treturn user1 == user2\n+\t}\n+\treturn user1.Uid == user2.Uid\n+}\n+\n+// privilegeCheckContext holds all context needed for privilege checking\n+type privilegeCheckContext struct {\n+\tcurrentUser           *user.User\n+\tcurrentUserPrivileged bool\n+\tallowRoot             bool\n+}\n+\n+// isSameUser checks if two usernames refer to the same user\n+// SECURITY: This function must be conservative - it should only return true\n+// when we're certain both usernames refer to the exact same user identity\n+func isSameUser(requestedUsername, currentUsername string) bool {\n+\t// Empty requested username means current user\n+\tif requestedUsername == \"\" {\n+\t\treturn true\n+\t}\n+\n+\t// Exact match (most common case)\n+\tif getCurrentOS() == \"windows\" {\n+\t\tif strings.EqualFold(requestedUsername, currentUsername) {\n+\t\t\treturn true\n+\t\t}\n+\t} else {\n+\t\tif requestedUsername == currentUsername {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\t// Windows domain resolution: only allow domain stripping when comparing\n+\t// a bare username against the current user's domain-qualified name\n+\tif getCurrentOS() == \"windows\" {\n+\t\treturn isWindowsSameUser(requestedUsername, currentUsername)\n+\t}\n+\n+\treturn false\n+}\n+\n+// isWindowsSameUser handles Windows-specific user comparison with domain logic\n+func isWindowsSameUser(requestedUsername, currentUsername string) bool {\n+\t// Extract domain and username parts\n+\textractParts := func(name string) (domain, user string) {\n+\t\t// Handle DOMAIN\\username format\n+\t\tif idx := strings.LastIndex(name, `\\`); idx != -1 {\n+\t\t\treturn name[:idx], name[idx+1:]\n+\t\t}\n+\t\t// Handle user@domain.com format\n+\t\tif idx := strings.Index(name, \"@\"); idx != -1 {\n+\t\t\treturn name[idx+1:], name[:idx]\n+\t\t}\n+\t\t// No domain specified - local machine\n+\t\treturn \"\", name\n+\t}\n+\n+\treqDomain, reqUser := extractParts(requestedUsername)\n+\tcurDomain, curUser := extractParts(currentUsername)\n+\n+\t// Case-insensitive username comparison\n+\tif !strings.EqualFold(reqUser, curUser) {\n+\t\treturn false\n+\t}\n+\n+\t// If requested username has no domain, it refers to local machine user\n+\t// Allow this to match the current user regardless of current user's domain\n+\tif reqDomain == \"\" {\n+\t\treturn true\n+\t}\n+\n+\t// If both have domains, they must match exactly (case-insensitive)\n+\treturn strings.EqualFold(reqDomain, curDomain)\n+}\n+\n+// SetAllowRootLogin configures root login access\n+func (s *Server) SetAllowRootLogin(allow bool) {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\ts.allowRootLogin = allow\n+}\n+\n+// userNameLookup performs user lookup with root login permission check\n+func (s *Server) userNameLookup(username string) (*user.User, error) {\n+\tresult := s.CheckPrivileges(PrivilegeCheckRequest{\n+\t\tRequestedUsername:         username,\n+\t\tFeatureSupportsUserSwitch: true,\n+\t\tFeatureName:               FeatureSSHLogin,\n+\t})\n+\n+\tif !result.Allowed {\n+\t\treturn nil, result.Error\n+\t}\n+\n+\treturn result.User, nil\n+}\n+\n+// userPrivilegeCheck performs user lookup with full privilege check result\n+func (s *Server) userPrivilegeCheck(username string) (PrivilegeCheckResult, error) {\n+\tresult := s.CheckPrivileges(PrivilegeCheckRequest{\n+\t\tRequestedUsername:         username,\n+\t\tFeatureSupportsUserSwitch: true,\n+\t\tFeatureName:               FeatureSSHLogin,\n+\t})\n+\n+\tif !result.Allowed {\n+\t\treturn result, result.Error\n+\t}\n+\n+\treturn result, nil\n+}\n+\n+// isPrivilegedUsername checks if the given username represents a privileged user across platforms.\n+// On Unix: root\n+// On Windows: Administrator, SYSTEM (case-insensitive)\n+// Handles domain-qualified usernames like \"DOMAIN\\Administrator\" or \"user@domain.com\"\n+func isPrivilegedUsername(username string) bool {\n+\tif getCurrentOS() != \"windows\" {\n+\t\treturn username == \"root\"\n+\t}\n+\n+\tbareUsername := username\n+\t// Handle Windows domain format: DOMAIN\\username\n+\tif idx := strings.LastIndex(username, `\\`); idx != -1 {\n+\t\tbareUsername = username[idx+1:]\n+\t}\n+\t// Handle email-style format: username@domain.com\n+\tif idx := strings.Index(bareUsername, \"@\"); idx != -1 {\n+\t\tbareUsername = bareUsername[:idx]\n+\t}\n+\n+\treturn isWindowsPrivilegedUser(bareUsername)\n+}\n+\n+// isWindowsPrivilegedUser checks if a bare username (domain already stripped) represents a Windows privileged account\n+func isWindowsPrivilegedUser(bareUsername string) bool {\n+\t// common privileged usernames (case insensitive)\n+\tprivilegedNames := []string{\n+\t\t\"administrator\",\n+\t\t\"admin\",\n+\t\t\"root\",\n+\t\t\"system\",\n+\t\t\"localsystem\",\n+\t\t\"networkservice\",\n+\t\t\"localservice\",\n+\t}\n+\n+\tusernameLower := strings.ToLower(bareUsername)\n+\tfor _, privilegedName := range privilegedNames {\n+\t\tif usernameLower == privilegedName {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\t// computer accounts (ending with $) are not privileged by themselves\n+\t// They only gain privileges through group membership or specific SIDs\n+\n+\tif targetUser, err := lookupUser(bareUsername); err == nil {\n+\t\treturn isWindowsPrivilegedSID(targetUser.Uid)\n+\t}\n+\n+\treturn false\n+}\n+\n+// isWindowsPrivilegedSID checks if a Windows SID represents a privileged account\n+func isWindowsPrivilegedSID(sid string) bool {\n+\tprivilegedSIDs := []string{\n+\t\t\"S-1-5-18\",     // Local System (SYSTEM)\n+\t\t\"S-1-5-19\",     // Local Service (NT AUTHORITY\\LOCAL SERVICE)\n+\t\t\"S-1-5-20\",     // Network Service (NT AUTHORITY\\NETWORK SERVICE)\n+\t\t\"S-1-5-32-544\", // Administrators group (BUILTIN\\Administrators)\n+\t\t\"S-1-5-500\",    // Built-in Administrator account (local machine RID 500)\n+\t}\n+\n+\tfor _, privilegedSID := range privilegedSIDs {\n+\t\tif sid == privilegedSID {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\t// Check for domain administrator accounts (RID 500 in any domain)\n+\t// Format: S-1-5-21-domain-domain-domain-500\n+\t// This is reliable as RID 500 is reserved for the domain Administrator account\n+\tif strings.HasPrefix(sid, \"S-1-5-21-\") && strings.HasSuffix(sid, \"-500\") {\n+\t\treturn true\n+\t}\n+\n+\t// Check for other well-known privileged RIDs in domain contexts\n+\t// RID 512 = Domain Admins group, RID 516 = Domain Controllers group\n+\tif strings.HasPrefix(sid, \"S-1-5-21-\") {\n+\t\tif strings.HasSuffix(sid, \"-512\") || // Domain Admins group\n+\t\t\tstrings.HasSuffix(sid, \"-516\") || // Domain Controllers group\n+\t\t\tstrings.HasSuffix(sid, \"-519\") { // Enterprise Admins group\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\treturn false\n+}\n+\n+// isCurrentProcessPrivileged checks if the current process is running with elevated privileges.\n+// On Unix systems, this means running as root (UID 0).\n+// On Windows, this means running as Administrator or SYSTEM.\n+func isCurrentProcessPrivileged() bool {\n+\tif getCurrentOS() == \"windows\" {\n+\t\treturn isWindowsElevated()\n+\t}\n+\treturn getEuid() == 0\n+}\n+\n+// isWindowsElevated checks if the current process is running with elevated privileges on Windows\n+func isWindowsElevated() bool {\n+\tcurrentUser, err := getCurrentUser()\n+\tif err != nil {\n+\t\tlog.Errorf(\"failed to get current user for privilege check, assuming non-privileged: %v\", err)\n+\t\treturn false\n+\t}\n+\n+\tif isWindowsPrivilegedSID(currentUser.Uid) {\n+\t\tlog.Debugf(\"Windows user switching supported: running as privileged SID %s\", currentUser.Uid)\n+\t\treturn true\n+\t}\n+\n+\tif isPrivilegedUsername(currentUser.Username) {\n+\t\tlog.Debugf(\"Windows user switching supported: running as privileged username %s\", currentUser.Username)\n+\t\treturn true\n+\t}\n+\n+\tlog.Debugf(\"Windows user switching not supported: not running as privileged user (current: %s)\", currentUser.Uid)\n+\treturn false\n+}\ndiff --git a/client/ssh/server/user_utils_js.go b/client/ssh/server/user_utils_js.go\nnew file mode 100644\nindex 00000000000..163b24c6ce4\n--- /dev/null\n+++ b/client/ssh/server/user_utils_js.go\n@@ -0,0 +1,8 @@\n+//go:build js\n+\n+package server\n+\n+// validateUsername is not supported on JS/WASM\n+func validateUsername(_ string) error {\n+\treturn errNotSupported\n+}\ndiff --git a/client/ssh/server/userswitching_js.go b/client/ssh/server/userswitching_js.go\nnew file mode 100644\nindex 00000000000..333c19259a9\n--- /dev/null\n+++ b/client/ssh/server/userswitching_js.go\n@@ -0,0 +1,8 @@\n+//go:build js\n+\n+package server\n+\n+// enableUserSwitching is not supported on JS/WASM\n+func enableUserSwitching() error {\n+\treturn errNotSupported\n+}\ndiff --git a/client/ssh/server/userswitching_unix.go b/client/ssh/server/userswitching_unix.go\nnew file mode 100644\nindex 00000000000..06fefabd75e\n--- /dev/null\n+++ b/client/ssh/server/userswitching_unix.go\n@@ -0,0 +1,233 @@\n+//go:build unix\n+\n+package server\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"net\"\n+\t\"net/netip\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"os/user\"\n+\t\"regexp\"\n+\t\"runtime\"\n+\t\"strconv\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+)\n+\n+// POSIX portable filename character set regex: [a-zA-Z0-9._-]\n+// First character cannot be hyphen (POSIX requirement)\n+var posixUsernameRegex = regexp.MustCompile(`^[a-zA-Z0-9._][a-zA-Z0-9._-]*$`)\n+\n+// validateUsername validates that a username conforms to POSIX standards with security considerations\n+func validateUsername(username string) error {\n+\tif username == \"\" {\n+\t\treturn errors.New(\"username cannot be empty\")\n+\t}\n+\n+\t// POSIX allows up to 256 characters, but practical limit is 32 for compatibility\n+\tif len(username) > 32 {\n+\t\treturn errors.New(\"username too long (max 32 characters)\")\n+\t}\n+\n+\tif !posixUsernameRegex.MatchString(username) {\n+\t\treturn errors.New(\"username contains invalid characters (must match POSIX portable filename character set)\")\n+\t}\n+\n+\tif username == \".\" || username == \"..\" {\n+\t\treturn fmt.Errorf(\"username cannot be '.' or '..'\")\n+\t}\n+\n+\t// Warn if username is fully numeric (can cause issues with UID/username ambiguity)\n+\tif isFullyNumeric(username) {\n+\t\tlog.Warnf(\"fully numeric username '%s' may cause issues with some commands\", username)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// isFullyNumeric checks if username contains only digits\n+func isFullyNumeric(username string) bool {\n+\tfor _, char := range username {\n+\t\tif char < '0' || char > '9' {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+// createPtyLoginCommand creates a Pty command using login for privileged processes\n+func (s *Server) createPtyLoginCommand(localUser *user.User, ptyReq ssh.Pty, session ssh.Session) (*exec.Cmd, error) {\n+\tloginPath, args, err := s.getLoginCmd(localUser.Username, session.RemoteAddr())\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"get login command: %w\", err)\n+\t}\n+\n+\texecCmd := exec.CommandContext(session.Context(), loginPath, args...)\n+\texecCmd.Dir = localUser.HomeDir\n+\texecCmd.Env = s.preparePtyEnv(localUser, ptyReq, session)\n+\n+\treturn execCmd, nil\n+}\n+\n+// getLoginCmd returns the login command and args for privileged Pty user switching\n+func (s *Server) getLoginCmd(username string, remoteAddr net.Addr) (string, []string, error) {\n+\tloginPath, err := exec.LookPath(\"login\")\n+\tif err != nil {\n+\t\treturn \"\", nil, fmt.Errorf(\"login command not available: %w\", err)\n+\t}\n+\n+\taddrPort, err := netip.ParseAddrPort(remoteAddr.String())\n+\tif err != nil {\n+\t\treturn \"\", nil, fmt.Errorf(\"parse remote address: %w\", err)\n+\t}\n+\n+\tswitch runtime.GOOS {\n+\tcase \"linux\":\n+\t\t// Special handling for Arch Linux without /etc/pam.d/remote\n+\t\tif s.fileExists(\"/etc/arch-release\") && !s.fileExists(\"/etc/pam.d/remote\") {\n+\t\t\treturn loginPath, []string{\"-f\", username, \"-p\"}, nil\n+\t\t}\n+\t\treturn loginPath, []string{\"-f\", username, \"-h\", addrPort.Addr().String(), \"-p\"}, nil\n+\tcase \"darwin\", \"freebsd\", \"openbsd\", \"netbsd\", \"dragonfly\":\n+\t\treturn loginPath, []string{\"-fp\", \"-h\", addrPort.Addr().String(), username}, nil\n+\tdefault:\n+\t\treturn \"\", nil, fmt.Errorf(\"unsupported Unix platform for login command: %s\", runtime.GOOS)\n+\t}\n+}\n+\n+// fileExists checks if a file exists (helper for login command logic)\n+func (s *Server) fileExists(path string) bool {\n+\t_, err := os.Stat(path)\n+\treturn err == nil\n+}\n+\n+// parseUserCredentials extracts numeric UID, GID, and supplementary groups\n+func (s *Server) parseUserCredentials(localUser *user.User) (uint32, uint32, []uint32, error) {\n+\tuid64, err := strconv.ParseUint(localUser.Uid, 10, 32)\n+\tif err != nil {\n+\t\treturn 0, 0, nil, fmt.Errorf(\"invalid UID %s: %w\", localUser.Uid, err)\n+\t}\n+\tuid := uint32(uid64)\n+\n+\tgid64, err := strconv.ParseUint(localUser.Gid, 10, 32)\n+\tif err != nil {\n+\t\treturn 0, 0, nil, fmt.Errorf(\"invalid GID %s: %w\", localUser.Gid, err)\n+\t}\n+\tgid := uint32(gid64)\n+\n+\tgroups, err := s.getSupplementaryGroups(localUser.Username)\n+\tif err != nil {\n+\t\tlog.Warnf(\"failed to get supplementary groups for user %s: %v\", localUser.Username, err)\n+\t\tgroups = []uint32{gid}\n+\t}\n+\n+\treturn uid, gid, groups, nil\n+}\n+\n+// getSupplementaryGroups retrieves supplementary group IDs for a user\n+func (s *Server) getSupplementaryGroups(username string) ([]uint32, error) {\n+\tu, err := user.Lookup(username)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"lookup user %s: %w\", username, err)\n+\t}\n+\n+\tgroupIDStrings, err := u.GroupIds()\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"get group IDs for user %s: %w\", username, err)\n+\t}\n+\n+\tgroups := make([]uint32, len(groupIDStrings))\n+\tfor i, gidStr := range groupIDStrings {\n+\t\tgid64, err := strconv.ParseUint(gidStr, 10, 32)\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"invalid group ID %s for user %s: %w\", gidStr, username, err)\n+\t\t}\n+\t\tgroups[i] = uint32(gid64)\n+\t}\n+\n+\treturn groups, nil\n+}\n+\n+// createExecutorCommand creates a command that spawns netbird ssh exec for privilege dropping.\n+// Returns the command and a cleanup function (no-op on Unix).\n+func (s *Server) createExecutorCommand(session ssh.Session, localUser *user.User, hasPty bool) (*exec.Cmd, func(), error) {\n+\tlog.Debugf(\"creating executor command for user %s (Pty: %v)\", localUser.Username, hasPty)\n+\n+\tif err := validateUsername(localUser.Username); err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"invalid username %q: %w\", localUser.Username, err)\n+\t}\n+\n+\tuid, gid, groups, err := s.parseUserCredentials(localUser)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"parse user credentials: %w\", err)\n+\t}\n+\tprivilegeDropper := NewPrivilegeDropper()\n+\tconfig := ExecutorConfig{\n+\t\tUID:        uid,\n+\t\tGID:        gid,\n+\t\tGroups:     groups,\n+\t\tWorkingDir: localUser.HomeDir,\n+\t\tShell:      getUserShell(localUser.Uid),\n+\t\tCommand:    session.RawCommand(),\n+\t\tPTY:        hasPty,\n+\t}\n+\n+\tcmd, err := privilegeDropper.CreateExecutorCommand(session.Context(), config)\n+\treturn cmd, func() {}, err\n+}\n+\n+// enableUserSwitching is a no-op on Unix systems\n+func enableUserSwitching() error {\n+\treturn nil\n+}\n+\n+// createPtyCommand creates the exec.Cmd for Pty execution respecting privilege check results\n+func (s *Server) createPtyCommand(privilegeResult PrivilegeCheckResult, ptyReq ssh.Pty, session ssh.Session) (*exec.Cmd, error) {\n+\tlocalUser := privilegeResult.User\n+\tif localUser == nil {\n+\t\treturn nil, errors.New(\"no user in privilege result\")\n+\t}\n+\n+\tif privilegeResult.UsedFallback {\n+\t\treturn s.createDirectPtyCommand(session, localUser, ptyReq), nil\n+\t}\n+\n+\treturn s.createPtyLoginCommand(localUser, ptyReq, session)\n+}\n+\n+// createDirectPtyCommand creates a direct Pty command without privilege dropping\n+func (s *Server) createDirectPtyCommand(session ssh.Session, localUser *user.User, ptyReq ssh.Pty) *exec.Cmd {\n+\tlog.Debugf(\"creating direct Pty command for user %s (no user switching needed)\", localUser.Username)\n+\n+\tshell := getUserShell(localUser.Uid)\n+\targs := s.getShellCommandArgs(shell, session.RawCommand())\n+\n+\tcmd := exec.CommandContext(session.Context(), args[0], args[1:]...)\n+\tcmd.Dir = localUser.HomeDir\n+\tcmd.Env = s.preparePtyEnv(localUser, ptyReq, session)\n+\n+\treturn cmd\n+}\n+\n+// preparePtyEnv prepares environment variables for Pty execution\n+func (s *Server) preparePtyEnv(localUser *user.User, ptyReq ssh.Pty, session ssh.Session) []string {\n+\ttermType := ptyReq.Term\n+\tif termType == \"\" {\n+\t\ttermType = \"xterm-256color\"\n+\t}\n+\n+\tenv := prepareUserEnv(localUser, getUserShell(localUser.Uid))\n+\tenv = append(env, prepareSSHEnv(session)...)\n+\tenv = append(env, fmt.Sprintf(\"TERM=%s\", termType))\n+\n+\tfor _, v := range session.Environ() {\n+\t\tif acceptEnv(v) {\n+\t\t\tenv = append(env, v)\n+\t\t}\n+\t}\n+\treturn env\n+}\ndiff --git a/client/ssh/server/userswitching_windows.go b/client/ssh/server/userswitching_windows.go\nnew file mode 100644\nindex 00000000000..5a5f75fa4c5\n--- /dev/null\n+++ b/client/ssh/server/userswitching_windows.go\n@@ -0,0 +1,274 @@\n+//go:build windows\n+\n+package server\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"os/exec\"\n+\t\"os/user\"\n+\t\"strings\"\n+\t\"unsafe\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"golang.org/x/sys/windows\"\n+)\n+\n+// validateUsername validates Windows usernames according to SAM Account Name rules\n+func validateUsername(username string) error {\n+\tif username == \"\" {\n+\t\treturn fmt.Errorf(\"username cannot be empty\")\n+\t}\n+\n+\tusernameToValidate := extractUsernameFromDomain(username)\n+\n+\tif err := validateUsernameLength(usernameToValidate); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif err := validateUsernameCharacters(usernameToValidate); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif err := validateUsernameFormat(usernameToValidate); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn nil\n+}\n+\n+// extractUsernameFromDomain extracts the username part from domain\\username or username@domain format\n+func extractUsernameFromDomain(username string) string {\n+\tif idx := strings.LastIndex(username, `\\`); idx != -1 {\n+\t\treturn username[idx+1:]\n+\t}\n+\tif idx := strings.Index(username, \"@\"); idx != -1 {\n+\t\treturn username[:idx]\n+\t}\n+\treturn username\n+}\n+\n+// validateUsernameLength checks if username length is within Windows limits\n+func validateUsernameLength(username string) error {\n+\tif len(username) > 20 {\n+\t\treturn fmt.Errorf(\"username too long (max 20 characters for Windows)\")\n+\t}\n+\treturn nil\n+}\n+\n+// validateUsernameCharacters checks for invalid characters in Windows usernames\n+func validateUsernameCharacters(username string) error {\n+\tinvalidChars := []rune{'\"', '/', '[', ']', ':', ';', '|', '=', ',', '+', '*', '?', '<', '>', ' ', '`', '&', '\\n'}\n+\tfor _, char := range username {\n+\t\tfor _, invalid := range invalidChars {\n+\t\t\tif char == invalid {\n+\t\t\t\treturn fmt.Errorf(\"username contains invalid characters\")\n+\t\t\t}\n+\t\t}\n+\t\tif char < 32 || char == 127 {\n+\t\t\treturn fmt.Errorf(\"username contains control characters\")\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// validateUsernameFormat checks for invalid username formats and patterns\n+func validateUsernameFormat(username string) error {\n+\tif username == \".\" || username == \"..\" {\n+\t\treturn fmt.Errorf(\"username cannot be '.' or '..'\")\n+\t}\n+\n+\tif strings.HasSuffix(username, \".\") {\n+\t\treturn fmt.Errorf(\"username cannot end with a period\")\n+\t}\n+\n+\treturn nil\n+}\n+\n+// createExecutorCommand creates a command using Windows executor for privilege dropping.\n+// Returns the command and a cleanup function that must be called after starting the process.\n+func (s *Server) createExecutorCommand(session ssh.Session, localUser *user.User, hasPty bool) (*exec.Cmd, func(), error) {\n+\tlog.Debugf(\"creating Windows executor command for user %s (Pty: %v)\", localUser.Username, hasPty)\n+\n+\tusername, _ := s.parseUsername(localUser.Username)\n+\tif err := validateUsername(username); err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"invalid username %q: %w\", username, err)\n+\t}\n+\n+\treturn s.createUserSwitchCommand(localUser, session, hasPty)\n+}\n+\n+// createUserSwitchCommand creates a command with Windows user switching.\n+// Returns the command and a cleanup function that must be called after starting the process.\n+func (s *Server) createUserSwitchCommand(localUser *user.User, session ssh.Session, interactive bool) (*exec.Cmd, func(), error) {\n+\tusername, domain := s.parseUsername(localUser.Username)\n+\n+\tshell := getUserShell(localUser.Uid)\n+\n+\trawCmd := session.RawCommand()\n+\tvar command string\n+\tif rawCmd != \"\" {\n+\t\tcommand = rawCmd\n+\t}\n+\n+\tconfig := WindowsExecutorConfig{\n+\t\tUsername:    username,\n+\t\tDomain:      domain,\n+\t\tWorkingDir:  localUser.HomeDir,\n+\t\tShell:       shell,\n+\t\tCommand:     command,\n+\t\tInteractive: interactive || (rawCmd == \"\"),\n+\t}\n+\n+\tdropper := NewPrivilegeDropper()\n+\tcmd, token, err := dropper.CreateWindowsExecutorCommand(session.Context(), config)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tcleanup := func() {\n+\t\tif token != 0 {\n+\t\t\tif err := windows.CloseHandle(windows.Handle(token)); err != nil {\n+\t\t\t\tlog.Debugf(\"close primary token: %v\", err)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn cmd, cleanup, nil\n+}\n+\n+// parseUsername extracts username and domain from a Windows username\n+func (s *Server) parseUsername(fullUsername string) (username, domain string) {\n+\t// Handle DOMAIN\\username format\n+\tif idx := strings.LastIndex(fullUsername, `\\`); idx != -1 {\n+\t\tdomain = fullUsername[:idx]\n+\t\tusername = fullUsername[idx+1:]\n+\t\treturn username, domain\n+\t}\n+\n+\t// Handle username@domain format\n+\tif username, domain, ok := strings.Cut(fullUsername, \"@\"); ok {\n+\t\treturn username, domain\n+\t}\n+\n+\t// Local user (no domain)\n+\treturn fullUsername, \".\"\n+}\n+\n+// hasPrivilege checks if the current process has a specific privilege\n+func hasPrivilege(token windows.Handle, privilegeName string) (bool, error) {\n+\tvar luid windows.LUID\n+\tif err := windows.LookupPrivilegeValue(nil, windows.StringToUTF16Ptr(privilegeName), &luid); err != nil {\n+\t\treturn false, fmt.Errorf(\"lookup privilege value: %w\", err)\n+\t}\n+\n+\tvar returnLength uint32\n+\terr := windows.GetTokenInformation(\n+\t\twindows.Token(token),\n+\t\twindows.TokenPrivileges,\n+\t\tnil, // null buffer to get size\n+\t\t0,\n+\t\t&returnLength,\n+\t)\n+\n+\tif err != nil && !errors.Is(err, windows.ERROR_INSUFFICIENT_BUFFER) {\n+\t\treturn false, fmt.Errorf(\"get token information size: %w\", err)\n+\t}\n+\n+\tbuffer := make([]byte, returnLength)\n+\terr = windows.GetTokenInformation(\n+\t\twindows.Token(token),\n+\t\twindows.TokenPrivileges,\n+\t\t&buffer[0],\n+\t\treturnLength,\n+\t\t&returnLength,\n+\t)\n+\tif err != nil {\n+\t\treturn false, fmt.Errorf(\"get token information: %w\", err)\n+\t}\n+\n+\tprivileges := (*windows.Tokenprivileges)(unsafe.Pointer(&buffer[0]))\n+\n+\t// Check if the privilege is present and enabled\n+\tfor i := uint32(0); i < privileges.PrivilegeCount; i++ {\n+\t\tprivilege := (*windows.LUIDAndAttributes)(unsafe.Pointer(\n+\t\t\tuintptr(unsafe.Pointer(&privileges.Privileges[0])) +\n+\t\t\t\tuintptr(i)*unsafe.Sizeof(windows.LUIDAndAttributes{}),\n+\t\t))\n+\t\tif privilege.Luid == luid {\n+\t\t\treturn (privilege.Attributes & windows.SE_PRIVILEGE_ENABLED) != 0, nil\n+\t\t}\n+\t}\n+\n+\treturn false, nil\n+}\n+\n+// enablePrivilege enables a specific privilege for the current process token\n+// This is required because privileges like SeAssignPrimaryTokenPrivilege are present\n+// but disabled by default, even for the SYSTEM account\n+func enablePrivilege(token windows.Handle, privilegeName string) error {\n+\tvar luid windows.LUID\n+\tif err := windows.LookupPrivilegeValue(nil, windows.StringToUTF16Ptr(privilegeName), &luid); err != nil {\n+\t\treturn fmt.Errorf(\"lookup privilege value for %s: %w\", privilegeName, err)\n+\t}\n+\n+\tprivileges := windows.Tokenprivileges{\n+\t\tPrivilegeCount: 1,\n+\t\tPrivileges: [1]windows.LUIDAndAttributes{\n+\t\t\t{\n+\t\t\t\tLuid:       luid,\n+\t\t\t\tAttributes: windows.SE_PRIVILEGE_ENABLED,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\terr := windows.AdjustTokenPrivileges(\n+\t\twindows.Token(token),\n+\t\tfalse,\n+\t\t&privileges,\n+\t\t0,\n+\t\tnil,\n+\t\tnil,\n+\t)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"adjust token privileges for %s: %w\", privilegeName, err)\n+\t}\n+\n+\thasPriv, err := hasPrivilege(token, privilegeName)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"verify privilege %s after enabling: %w\", privilegeName, err)\n+\t}\n+\tif !hasPriv {\n+\t\treturn fmt.Errorf(\"privilege %s could not be enabled (may not be granted to account)\", privilegeName)\n+\t}\n+\n+\tlog.Debugf(\"Successfully enabled privilege %s for current process\", privilegeName)\n+\treturn nil\n+}\n+\n+// enableUserSwitching enables required privileges for Windows user switching\n+func enableUserSwitching() error {\n+\tprocess := windows.CurrentProcess()\n+\n+\tvar token windows.Token\n+\terr := windows.OpenProcessToken(\n+\t\tprocess,\n+\t\twindows.TOKEN_ADJUST_PRIVILEGES|windows.TOKEN_QUERY,\n+\t\t&token,\n+\t)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"open process token: %w\", err)\n+\t}\n+\tdefer func() {\n+\t\tif err := windows.CloseHandle(windows.Handle(token)); err != nil {\n+\t\t\tlog.Debugf(\"Failed to close process token: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tif err := enablePrivilege(windows.Handle(token), \"SeAssignPrimaryTokenPrivilege\"); err != nil {\n+\t\treturn fmt.Errorf(\"enable SeAssignPrimaryTokenPrivilege: %w\", err)\n+\t}\n+\tlog.Infof(\"Windows user switching privileges enabled successfully\")\n+\treturn nil\n+}\ndiff --git a/client/ssh/server/winpty/conpty.go b/client/ssh/server/winpty/conpty.go\nnew file mode 100644\nindex 00000000000..0f3659ffe86\n--- /dev/null\n+++ b/client/ssh/server/winpty/conpty.go\n@@ -0,0 +1,487 @@\n+//go:build windows\n+\n+package winpty\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"syscall\"\n+\t\"unsafe\"\n+\n+\t\"github.com/gliderlabs/ssh\"\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"golang.org/x/sys/windows\"\n+)\n+\n+var (\n+\tErrEmptyEnvironment = errors.New(\"empty environment\")\n+)\n+\n+const (\n+\textendedStartupInfoPresent       = 0x00080000\n+\tcreateUnicodeEnvironment         = 0x00000400\n+\tprocThreadAttributePseudoConsole = 0x00020016\n+\n+\tPowerShellCommandFlag = \"-Command\"\n+\n+\terrCloseInputRead     = \"close input read handle: %v\"\n+\terrCloseConPtyCleanup = \"close ConPty handle during cleanup\"\n+)\n+\n+// PtyConfig holds configuration for Pty execution.\n+type PtyConfig struct {\n+\tShell      string\n+\tCommand    string\n+\tWidth      int\n+\tHeight     int\n+\tWorkingDir string\n+}\n+\n+// UserConfig holds user execution configuration.\n+type UserConfig struct {\n+\tToken       windows.Handle\n+\tEnvironment []string\n+}\n+\n+var (\n+\tkernel32                              = windows.NewLazySystemDLL(\"kernel32.dll\")\n+\tprocClosePseudoConsole                = kernel32.NewProc(\"ClosePseudoConsole\")\n+\tprocInitializeProcThreadAttributeList = kernel32.NewProc(\"InitializeProcThreadAttributeList\")\n+\tprocUpdateProcThreadAttribute         = kernel32.NewProc(\"UpdateProcThreadAttribute\")\n+\tprocDeleteProcThreadAttributeList     = kernel32.NewProc(\"DeleteProcThreadAttributeList\")\n+)\n+\n+// ExecutePtyWithUserToken executes a command with ConPty using user token.\n+func ExecutePtyWithUserToken(ctx context.Context, session ssh.Session, ptyConfig PtyConfig, userConfig UserConfig) error {\n+\targs := buildShellArgs(ptyConfig.Shell, ptyConfig.Command)\n+\tcommandLine := buildCommandLine(args)\n+\n+\tconfig := ExecutionConfig{\n+\t\tPty:     ptyConfig,\n+\t\tUser:    userConfig,\n+\t\tSession: session,\n+\t\tContext: ctx,\n+\t}\n+\n+\treturn executeConPtyWithConfig(commandLine, config)\n+}\n+\n+// ExecutionConfig holds all execution configuration.\n+type ExecutionConfig struct {\n+\tPty     PtyConfig\n+\tUser    UserConfig\n+\tSession ssh.Session\n+\tContext context.Context\n+}\n+\n+// executeConPtyWithConfig creates ConPty and executes process with configuration.\n+func executeConPtyWithConfig(commandLine string, config ExecutionConfig) error {\n+\tctx := config.Context\n+\tsession := config.Session\n+\twidth := config.Pty.Width\n+\theight := config.Pty.Height\n+\tuserToken := config.User.Token\n+\tuserEnv := config.User.Environment\n+\tworkingDir := config.Pty.WorkingDir\n+\n+\tinputRead, inputWrite, outputRead, outputWrite, err := createConPtyPipes()\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"create ConPty pipes: %w\", err)\n+\t}\n+\n+\thPty, err := createConPty(width, height, inputRead, outputWrite)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"create ConPty: %w\", err)\n+\t}\n+\n+\tprimaryToken, err := duplicateToPrimaryToken(userToken)\n+\tif err != nil {\n+\t\tif closeErr, _, _ := procClosePseudoConsole.Call(uintptr(hPty)); closeErr == 0 {\n+\t\t\tlog.Debugf(errCloseConPtyCleanup)\n+\t\t}\n+\t\tcloseHandles(inputRead, inputWrite, outputRead, outputWrite)\n+\t\treturn fmt.Errorf(\"duplicate to primary token: %w\", err)\n+\t}\n+\tdefer func() {\n+\t\tif err := windows.CloseHandle(primaryToken); err != nil {\n+\t\t\tlog.Debugf(\"close primary token: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tsiEx, err := setupConPtyStartupInfo(hPty)\n+\tif err != nil {\n+\t\tif closeErr, _, _ := procClosePseudoConsole.Call(uintptr(hPty)); closeErr == 0 {\n+\t\t\tlog.Debugf(errCloseConPtyCleanup)\n+\t\t}\n+\t\tcloseHandles(inputRead, inputWrite, outputRead, outputWrite)\n+\t\treturn fmt.Errorf(\"setup startup info: %w\", err)\n+\t}\n+\tdefer func() {\n+\t\t_, _, _ = procDeleteProcThreadAttributeList.Call(uintptr(unsafe.Pointer(siEx.ProcThreadAttributeList)))\n+\t}()\n+\n+\tpi, err := createConPtyProcess(commandLine, primaryToken, userEnv, workingDir, siEx)\n+\tif err != nil {\n+\t\tif closeErr, _, _ := procClosePseudoConsole.Call(uintptr(hPty)); closeErr == 0 {\n+\t\t\tlog.Debugf(errCloseConPtyCleanup)\n+\t\t}\n+\t\tcloseHandles(inputRead, inputWrite, outputRead, outputWrite)\n+\t\treturn fmt.Errorf(\"create process as user with ConPty: %w\", err)\n+\t}\n+\tdefer closeProcessInfo(pi)\n+\n+\tif err := windows.CloseHandle(inputRead); err != nil {\n+\t\tlog.Debugf(errCloseInputRead, err)\n+\t}\n+\tif err := windows.CloseHandle(outputWrite); err != nil {\n+\t\tlog.Debugf(\"close output write handle: %v\", err)\n+\t}\n+\n+\treturn bridgeConPtyIO(ctx, hPty, inputWrite, outputRead, session, session, session, pi.Process)\n+}\n+\n+// createConPtyPipes creates input/output pipes for ConPty.\n+func createConPtyPipes() (inputRead, inputWrite, outputRead, outputWrite windows.Handle, err error) {\n+\tif err := windows.CreatePipe(&inputRead, &inputWrite, nil, 0); err != nil {\n+\t\treturn 0, 0, 0, 0, fmt.Errorf(\"create input pipe: %w\", err)\n+\t}\n+\n+\tif err := windows.CreatePipe(&outputRead, &outputWrite, nil, 0); err != nil {\n+\t\tif closeErr := windows.CloseHandle(inputRead); closeErr != nil {\n+\t\t\tlog.Debugf(errCloseInputRead, closeErr)\n+\t\t}\n+\t\tif closeErr := windows.CloseHandle(inputWrite); closeErr != nil {\n+\t\t\tlog.Debugf(\"close input write handle: %v\", closeErr)\n+\t\t}\n+\t\treturn 0, 0, 0, 0, fmt.Errorf(\"create output pipe: %w\", err)\n+\t}\n+\n+\treturn inputRead, inputWrite, outputRead, outputWrite, nil\n+}\n+\n+// createConPty creates a Windows ConPty with the specified size and pipe handles.\n+func createConPty(width, height int, inputRead, outputWrite windows.Handle) (windows.Handle, error) {\n+\tsize := windows.Coord{X: int16(width), Y: int16(height)}\n+\n+\tvar hPty windows.Handle\n+\tif err := windows.CreatePseudoConsole(size, inputRead, outputWrite, 0, &hPty); err != nil {\n+\t\treturn 0, fmt.Errorf(\"CreatePseudoConsole: %w\", err)\n+\t}\n+\n+\treturn hPty, nil\n+}\n+\n+// setupConPtyStartupInfo prepares the STARTUPINFOEX with ConPty attributes.\n+func setupConPtyStartupInfo(hPty windows.Handle) (*windows.StartupInfoEx, error) {\n+\tvar siEx windows.StartupInfoEx\n+\tsiEx.StartupInfo.Cb = uint32(unsafe.Sizeof(siEx))\n+\n+\tvar attrListSize uintptr\n+\tret, _, _ := procInitializeProcThreadAttributeList.Call(0, 1, 0, uintptr(unsafe.Pointer(&attrListSize)))\n+\tif ret == 0 && attrListSize == 0 {\n+\t\treturn nil, fmt.Errorf(\"get attribute list size\")\n+\t}\n+\n+\tattrListBytes := make([]byte, attrListSize)\n+\tsiEx.ProcThreadAttributeList = (*windows.ProcThreadAttributeList)(unsafe.Pointer(&attrListBytes[0]))\n+\n+\tret, _, err := procInitializeProcThreadAttributeList.Call(\n+\t\tuintptr(unsafe.Pointer(siEx.ProcThreadAttributeList)),\n+\t\t1,\n+\t\t0,\n+\t\tuintptr(unsafe.Pointer(&attrListSize)),\n+\t)\n+\tif ret == 0 {\n+\t\treturn nil, fmt.Errorf(\"initialize attribute list: %w\", err)\n+\t}\n+\n+\tret, _, err = procUpdateProcThreadAttribute.Call(\n+\t\tuintptr(unsafe.Pointer(siEx.ProcThreadAttributeList)),\n+\t\t0,\n+\t\tprocThreadAttributePseudoConsole,\n+\t\tuintptr(hPty),\n+\t\tunsafe.Sizeof(hPty),\n+\t\t0,\n+\t\t0,\n+\t)\n+\tif ret == 0 {\n+\t\treturn nil, fmt.Errorf(\"update thread attribute: %w\", err)\n+\t}\n+\n+\treturn &siEx, nil\n+}\n+\n+// createConPtyProcess creates the actual process with ConPty.\n+func createConPtyProcess(commandLine string, userToken windows.Handle, userEnv []string, workingDir string, siEx *windows.StartupInfoEx) (*windows.ProcessInformation, error) {\n+\tvar pi windows.ProcessInformation\n+\tcreationFlags := uint32(extendedStartupInfoPresent | createUnicodeEnvironment)\n+\n+\tcommandLinePtr, err := windows.UTF16PtrFromString(commandLine)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"convert command line to UTF16: %w\", err)\n+\t}\n+\n+\tenvPtr, err := convertEnvironmentToUTF16(userEnv)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar workingDirPtr *uint16\n+\tif workingDir != \"\" {\n+\t\tworkingDirPtr, err = windows.UTF16PtrFromString(workingDir)\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"convert working directory to UTF16: %w\", err)\n+\t\t}\n+\t}\n+\n+\tsiEx.StartupInfo.Flags |= windows.STARTF_USESTDHANDLES\n+\tsiEx.StartupInfo.StdInput = windows.Handle(0)\n+\tsiEx.StartupInfo.StdOutput = windows.Handle(0)\n+\tsiEx.StartupInfo.StdErr = siEx.StartupInfo.StdOutput\n+\n+\tif userToken != windows.InvalidHandle {\n+\t\terr = windows.CreateProcessAsUser(\n+\t\t\twindows.Token(userToken),\n+\t\t\tnil,\n+\t\t\tcommandLinePtr,\n+\t\t\tnil,\n+\t\t\tnil,\n+\t\t\ttrue,\n+\t\t\tcreationFlags,\n+\t\t\tenvPtr,\n+\t\t\tworkingDirPtr,\n+\t\t\t&siEx.StartupInfo,\n+\t\t\t&pi,\n+\t\t)\n+\t} else {\n+\t\terr = windows.CreateProcess(\n+\t\t\tnil,\n+\t\t\tcommandLinePtr,\n+\t\t\tnil,\n+\t\t\tnil,\n+\t\t\ttrue,\n+\t\t\tcreationFlags,\n+\t\t\tenvPtr,\n+\t\t\tworkingDirPtr,\n+\t\t\t&siEx.StartupInfo,\n+\t\t\t&pi,\n+\t\t)\n+\t}\n+\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"create process: %w\", err)\n+\t}\n+\n+\treturn &pi, nil\n+}\n+\n+// convertEnvironmentToUTF16 converts environment variables to Windows UTF16 format.\n+func convertEnvironmentToUTF16(userEnv []string) (*uint16, error) {\n+\tif len(userEnv) == 0 {\n+\t\t// Return nil pointer for empty environment - Windows API will inherit parent environment\n+\t\treturn nil, nil //nolint:nilnil // Intentional nil,nil for empty environment\n+\t}\n+\n+\tvar envUTF16 []uint16\n+\tfor _, envVar := range userEnv {\n+\t\tif envVar != \"\" {\n+\t\t\tutf16Str, err := windows.UTF16FromString(envVar)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Debugf(\"skipping invalid environment variable: %s (error: %v)\", envVar, err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tenvUTF16 = append(envUTF16, utf16Str[:len(utf16Str)-1]...)\n+\t\t\tenvUTF16 = append(envUTF16, 0)\n+\t\t}\n+\t}\n+\tenvUTF16 = append(envUTF16, 0)\n+\n+\tif len(envUTF16) > 0 {\n+\t\treturn &envUTF16[0], nil\n+\t}\n+\t// Return nil pointer when no valid environment variables found\n+\treturn nil, nil //nolint:nilnil // Intentional nil,nil for empty environment\n+}\n+\n+// duplicateToPrimaryToken converts an impersonation token to a primary token.\n+func duplicateToPrimaryToken(token windows.Handle) (windows.Handle, error) {\n+\tvar primaryToken windows.Handle\n+\tif err := windows.DuplicateTokenEx(\n+\t\twindows.Token(token),\n+\t\twindows.TOKEN_ALL_ACCESS,\n+\t\tnil,\n+\t\twindows.SecurityImpersonation,\n+\t\twindows.TokenPrimary,\n+\t\t(*windows.Token)(&primaryToken),\n+\t); err != nil {\n+\t\treturn 0, fmt.Errorf(\"duplicate token: %w\", err)\n+\t}\n+\treturn primaryToken, nil\n+}\n+\n+// SessionExiter provides the Exit method for reporting process exit status.\n+type SessionExiter interface {\n+\tExit(code int) error\n+}\n+\n+// bridgeConPtyIO handles I/O bridging between ConPty and readers/writers.\n+func bridgeConPtyIO(ctx context.Context, hPty, inputWrite, outputRead windows.Handle, reader io.ReadCloser, writer io.Writer, session SessionExiter, process windows.Handle) error {\n+\tif err := ctx.Err(); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tvar wg sync.WaitGroup\n+\tstartIOBridging(ctx, &wg, inputWrite, outputRead, reader, writer)\n+\n+\tprocessErr := waitForProcess(ctx, process)\n+\tif processErr != nil {\n+\t\treturn processErr\n+\t}\n+\n+\tvar exitCode uint32\n+\tif err := windows.GetExitCodeProcess(process, &exitCode); err != nil {\n+\t\tlog.Debugf(\"get exit code: %v\", err)\n+\t} else {\n+\t\tif err := session.Exit(int(exitCode)); err != nil {\n+\t\t\tlog.Debugf(\"report exit code: %v\", err)\n+\t\t}\n+\t}\n+\n+\t// Clean up in the original order after process completes\n+\tif err := reader.Close(); err != nil {\n+\t\tlog.Debugf(\"close reader: %v\", err)\n+\t}\n+\n+\tret, _, err := procClosePseudoConsole.Call(uintptr(hPty))\n+\tif ret == 0 {\n+\t\tlog.Debugf(\"close ConPty handle: %v\", err)\n+\t}\n+\n+\twg.Wait()\n+\n+\tif err := windows.CloseHandle(outputRead); err != nil {\n+\t\tlog.Debugf(\"close output read handle: %v\", err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// startIOBridging starts the I/O bridging goroutines.\n+func startIOBridging(ctx context.Context, wg *sync.WaitGroup, inputWrite, outputRead windows.Handle, reader io.ReadCloser, writer io.Writer) {\n+\twg.Add(2)\n+\n+\t// Input: reader (SSH session) -> inputWrite (ConPty)\n+\tgo func() {\n+\t\tdefer wg.Done()\n+\t\tdefer func() {\n+\t\t\tif err := windows.CloseHandle(inputWrite); err != nil {\n+\t\t\t\tlog.Debugf(\"close input write handle in goroutine: %v\", err)\n+\t\t\t}\n+\t\t}()\n+\n+\t\tif _, err := io.Copy(&windowsHandleWriter{handle: inputWrite}, reader); err != nil {\n+\t\t\tlog.Debugf(\"input copy ended with error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\t// Output: outputRead (ConPty) -> writer (SSH session)\n+\tgo func() {\n+\t\tdefer wg.Done()\n+\t\tif _, err := io.Copy(writer, &windowsHandleReader{handle: outputRead}); err != nil {\n+\t\t\tlog.Debugf(\"output copy ended with error: %v\", err)\n+\t\t}\n+\t}()\n+}\n+\n+// waitForProcess waits for process completion with context cancellation.\n+func waitForProcess(ctx context.Context, process windows.Handle) error {\n+\tif _, err := windows.WaitForSingleObject(process, windows.INFINITE); err != nil {\n+\t\treturn fmt.Errorf(\"wait for process %d: %w\", process, err)\n+\t}\n+\treturn nil\n+}\n+\n+// buildShellArgs builds shell arguments for ConPty execution.\n+func buildShellArgs(shell, command string) []string {\n+\tif command != \"\" {\n+\t\treturn []string{shell, PowerShellCommandFlag, command}\n+\t}\n+\treturn []string{shell}\n+}\n+\n+// buildCommandLine builds a Windows command line from arguments using proper escaping.\n+func buildCommandLine(args []string) string {\n+\tif len(args) == 0 {\n+\t\treturn \"\"\n+\t}\n+\n+\tvar result strings.Builder\n+\tfor i, arg := range args {\n+\t\tif i > 0 {\n+\t\t\tresult.WriteString(\" \")\n+\t\t}\n+\t\tresult.WriteString(syscall.EscapeArg(arg))\n+\t}\n+\treturn result.String()\n+}\n+\n+// closeHandles closes multiple Windows handles.\n+func closeHandles(handles ...windows.Handle) {\n+\tfor _, handle := range handles {\n+\t\tif handle != windows.InvalidHandle {\n+\t\t\tif err := windows.CloseHandle(handle); err != nil {\n+\t\t\t\tlog.Debugf(\"close handle: %v\", err)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// closeProcessInfo closes process and thread handles.\n+func closeProcessInfo(pi *windows.ProcessInformation) {\n+\tif pi != nil {\n+\t\tif err := windows.CloseHandle(pi.Process); err != nil {\n+\t\t\tlog.Debugf(\"close process handle: %v\", err)\n+\t\t}\n+\t\tif err := windows.CloseHandle(pi.Thread); err != nil {\n+\t\t\tlog.Debugf(\"close thread handle: %v\", err)\n+\t\t}\n+\t}\n+}\n+\n+// windowsHandleReader wraps a Windows handle for reading.\n+type windowsHandleReader struct {\n+\thandle windows.Handle\n+}\n+\n+func (r *windowsHandleReader) Read(p []byte) (n int, err error) {\n+\tvar bytesRead uint32\n+\tif err := windows.ReadFile(r.handle, p, &bytesRead, nil); err != nil {\n+\t\treturn 0, err\n+\t}\n+\treturn int(bytesRead), nil\n+}\n+\n+func (r *windowsHandleReader) Close() error {\n+\treturn windows.CloseHandle(r.handle)\n+}\n+\n+// windowsHandleWriter wraps a Windows handle for writing.\n+type windowsHandleWriter struct {\n+\thandle windows.Handle\n+}\n+\n+func (w *windowsHandleWriter) Write(p []byte) (n int, err error) {\n+\tvar bytesWritten uint32\n+\tif err := windows.WriteFile(w.handle, p, &bytesWritten, nil); err != nil {\n+\t\treturn 0, err\n+\t}\n+\treturn int(bytesWritten), nil\n+}\n+\n+func (w *windowsHandleWriter) Close() error {\n+\treturn windows.CloseHandle(w.handle)\n+}\ndiff --git a/client/ssh/server_mock.go b/client/ssh/server_mock.go\ndeleted file mode 100644\nindex 76f43fd4e03..00000000000\n--- a/client/ssh/server_mock.go\n+++ /dev/null\n@@ -1,46 +0,0 @@\n-//go:build !js\n-\n-package ssh\n-\n-import \"context\"\n-\n-// MockServer mocks ssh.Server\n-type MockServer struct {\n-\tCtx                     context.Context\n-\tStopFunc                func() error\n-\tStartFunc               func() error\n-\tAddAuthorizedKeyFunc    func(peer, newKey string) error\n-\tRemoveAuthorizedKeyFunc func(peer string)\n-}\n-\n-// RemoveAuthorizedKey removes SSH key of a given peer from the authorized keys\n-func (srv *MockServer) RemoveAuthorizedKey(peer string) {\n-\tif srv.RemoveAuthorizedKeyFunc == nil {\n-\t\treturn\n-\t}\n-\tsrv.RemoveAuthorizedKeyFunc(peer)\n-}\n-\n-// AddAuthorizedKey add a given peer key to server authorized keys\n-func (srv *MockServer) AddAuthorizedKey(peer, newKey string) error {\n-\tif srv.AddAuthorizedKeyFunc == nil {\n-\t\treturn nil\n-\t}\n-\treturn srv.AddAuthorizedKeyFunc(peer, newKey)\n-}\n-\n-// Stop stops SSH server.\n-func (srv *MockServer) Stop() error {\n-\tif srv.StopFunc == nil {\n-\t\treturn nil\n-\t}\n-\treturn srv.StopFunc()\n-}\n-\n-// Start starts SSH server. Blocking\n-func (srv *MockServer) Start() error {\n-\tif srv.StartFunc == nil {\n-\t\treturn nil\n-\t}\n-\treturn srv.StartFunc()\n-}\ndiff --git a/client/ssh/util.go b/client/ssh/ssh.go\nsimilarity index 86%\nrename from client/ssh/util.go\nrename to client/ssh/ssh.go\nindex a54a609bc28..c0024c5999d 100644\n--- a/client/ssh/util.go\n+++ b/client/ssh/ssh.go\n@@ -32,9 +32,8 @@ const RSA KeyType = \"rsa\"\n // RSAKeySize is a size of newly generated RSA key\n const RSAKeySize = 2048\n \n-// GeneratePrivateKey creates RSA Private Key of specified byte size\n+// GeneratePrivateKey creates a private key of the specified type.\n func GeneratePrivateKey(keyType KeyType) ([]byte, error) {\n-\n \tvar key crypto.Signer\n \tvar err error\n \tswitch keyType {\n@@ -59,7 +58,7 @@ func GeneratePrivateKey(keyType KeyType) ([]byte, error) {\n \treturn pemBytes, nil\n }\n \n-// GeneratePublicKey returns the public part of the private key\n+// GeneratePublicKey returns the public part of the private key.\n func GeneratePublicKey(key []byte) ([]byte, error) {\n \tsigner, err := gossh.ParsePrivateKey(key)\n \tif err != nil {\n@@ -70,20 +69,17 @@ func GeneratePublicKey(key []byte) ([]byte, error) {\n \treturn []byte(strKey), nil\n }\n \n-// EncodePrivateKeyToPEM encodes Private Key from RSA to PEM format\n+// EncodePrivateKeyToPEM encodes a private key to PEM format.\n func EncodePrivateKeyToPEM(privateKey crypto.Signer) ([]byte, error) {\n \tmk, err := x509.MarshalPKCS8PrivateKey(privateKey)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\t// pem.Block\n \tprivBlock := pem.Block{\n \t\tType:  \"PRIVATE KEY\",\n \t\tBytes: mk,\n \t}\n-\n-\t// Private key in PEM format\n \tprivatePEM := pem.EncodeToMemory(&privBlock)\n \treturn privatePEM, nil\n }\ndiff --git a/client/ssh/window_freebsd.go b/client/ssh/window_freebsd.go\ndeleted file mode 100644\nindex ef4848341c6..00000000000\n--- a/client/ssh/window_freebsd.go\n+++ /dev/null\n@@ -1,10 +0,0 @@\n-//go:build freebsd\n-\n-package ssh\n-\n-import (\n-\t\"os\"\n-)\n-\n-func setWinSize(file *os.File, width, height int) {\n-}\ndiff --git a/client/ssh/window_unix.go b/client/ssh/window_unix.go\ndeleted file mode 100644\nindex 2891eb70e1b..00000000000\n--- a/client/ssh/window_unix.go\n+++ /dev/null\n@@ -1,14 +0,0 @@\n-//go:build linux || darwin\n-\n-package ssh\n-\n-import (\n-\t\"os\"\n-\t\"syscall\"\n-\t\"unsafe\"\n-)\n-\n-func setWinSize(file *os.File, width, height int) {\n-\tsyscall.Syscall(syscall.SYS_IOCTL, file.Fd(), uintptr(syscall.TIOCSWINSZ), //nolint\n-\t\tuintptr(unsafe.Pointer(&struct{ h, w, x, y uint16 }{uint16(height), uint16(width), 0, 0})))\n-}\ndiff --git a/client/ssh/window_windows.go b/client/ssh/window_windows.go\ndeleted file mode 100644\nindex 5abd41f271a..00000000000\n--- a/client/ssh/window_windows.go\n+++ /dev/null\n@@ -1,9 +0,0 @@\n-package ssh\n-\n-import (\n-\t\"os\"\n-)\n-\n-func setWinSize(file *os.File, width, height int) {\n-\n-}\ndiff --git a/client/status/status.go b/client/status/status.go\nindex 8a0b7bae0ab..d975f0e2944 100644\n--- a/client/status/status.go\n+++ b/client/status/status.go\n@@ -81,6 +81,18 @@ type NsServerGroupStateOutput struct {\n \tError   string   `json:\"error\" yaml:\"error\"`\n }\n \n+type SSHSessionOutput struct {\n+\tUsername      string `json:\"username\" yaml:\"username\"`\n+\tRemoteAddress string `json:\"remoteAddress\" yaml:\"remoteAddress\"`\n+\tCommand       string `json:\"command\" yaml:\"command\"`\n+\tJWTUsername   string `json:\"jwtUsername,omitempty\" yaml:\"jwtUsername,omitempty\"`\n+}\n+\n+type SSHServerStateOutput struct {\n+\tEnabled  bool               `json:\"enabled\" yaml:\"enabled\"`\n+\tSessions []SSHSessionOutput `json:\"sessions\" yaml:\"sessions\"`\n+}\n+\n type OutputOverview struct {\n \tPeers                   PeersStateOutput           `json:\"peers\" yaml:\"peers\"`\n \tCliVersion              string                     `json:\"cliVersion\" yaml:\"cliVersion\"`\n@@ -100,6 +112,7 @@ type OutputOverview struct {\n \tEvents                  []SystemEventOutput        `json:\"events\" yaml:\"events\"`\n \tLazyConnectionEnabled   bool                       `json:\"lazyConnectionEnabled\" yaml:\"lazyConnectionEnabled\"`\n \tProfileName             string                     `json:\"profileName\" yaml:\"profileName\"`\n+\tSSHServerState          SSHServerStateOutput       `json:\"sshServer\" yaml:\"sshServer\"`\n }\n \n func ConvertToStatusOutputOverview(resp *proto.StatusResponse, anon bool, statusFilter string, prefixNamesFilter []string, prefixNamesFilterMap map[string]struct{}, ipsFilter map[string]struct{}, connectionTypeFilter string, profName string) OutputOverview {\n@@ -121,6 +134,7 @@ func ConvertToStatusOutputOverview(resp *proto.StatusResponse, anon bool, status\n \n \trelayOverview := mapRelays(pbFullStatus.GetRelays())\n \tpeersOverview := mapPeers(resp.GetFullStatus().GetPeers(), statusFilter, prefixNamesFilter, prefixNamesFilterMap, ipsFilter, connectionTypeFilter)\n+\tsshServerOverview := mapSSHServer(pbFullStatus.GetSshServerState())\n \n \toverview := OutputOverview{\n \t\tPeers:                   peersOverview,\n@@ -141,6 +155,7 @@ func ConvertToStatusOutputOverview(resp *proto.StatusResponse, anon bool, status\n \t\tEvents:                  mapEvents(pbFullStatus.GetEvents()),\n \t\tLazyConnectionEnabled:   pbFullStatus.GetLazyConnectionEnabled(),\n \t\tProfileName:             profName,\n+\t\tSSHServerState:          sshServerOverview,\n \t}\n \n \tif anon {\n@@ -190,6 +205,30 @@ func mapNSGroups(servers []*proto.NSGroupState) []NsServerGroupStateOutput {\n \treturn mappedNSGroups\n }\n \n+func mapSSHServer(sshServerState *proto.SSHServerState) SSHServerStateOutput {\n+\tif sshServerState == nil {\n+\t\treturn SSHServerStateOutput{\n+\t\t\tEnabled:  false,\n+\t\t\tSessions: []SSHSessionOutput{},\n+\t\t}\n+\t}\n+\n+\tsessions := make([]SSHSessionOutput, 0, len(sshServerState.GetSessions()))\n+\tfor _, session := range sshServerState.GetSessions() {\n+\t\tsessions = append(sessions, SSHSessionOutput{\n+\t\t\tUsername:      session.GetUsername(),\n+\t\t\tRemoteAddress: session.GetRemoteAddress(),\n+\t\t\tCommand:       session.GetCommand(),\n+\t\t\tJWTUsername:   session.GetJwtUsername(),\n+\t\t})\n+\t}\n+\n+\treturn SSHServerStateOutput{\n+\t\tEnabled:  sshServerState.GetEnabled(),\n+\t\tSessions: sessions,\n+\t}\n+}\n+\n func mapPeers(\n \tpeers []*proto.PeerState,\n \tstatusFilter string,\n@@ -300,7 +339,7 @@ func ParseToYAML(overview OutputOverview) (string, error) {\n \treturn string(yamlBytes), nil\n }\n \n-func ParseGeneralSummary(overview OutputOverview, showURL bool, showRelays bool, showNameServers bool) string {\n+func ParseGeneralSummary(overview OutputOverview, showURL bool, showRelays bool, showNameServers bool, showSSHSessions bool) string {\n \tvar managementConnString string\n \tif overview.ManagementState.Connected {\n \t\tmanagementConnString = \"Connected\"\n@@ -405,6 +444,41 @@ func ParseGeneralSummary(overview OutputOverview, showURL bool, showRelays bool,\n \t\tlazyConnectionEnabledStatus = \"true\"\n \t}\n \n+\tsshServerStatus := \"Disabled\"\n+\tif overview.SSHServerState.Enabled {\n+\t\tsessionCount := len(overview.SSHServerState.Sessions)\n+\t\tif sessionCount > 0 {\n+\t\t\tsessionWord := \"session\"\n+\t\t\tif sessionCount > 1 {\n+\t\t\t\tsessionWord = \"sessions\"\n+\t\t\t}\n+\t\t\tsshServerStatus = fmt.Sprintf(\"Enabled (%d active %s)\", sessionCount, sessionWord)\n+\t\t} else {\n+\t\t\tsshServerStatus = \"Enabled\"\n+\t\t}\n+\n+\t\tif showSSHSessions && sessionCount > 0 {\n+\t\t\tfor _, session := range overview.SSHServerState.Sessions {\n+\t\t\t\tvar sessionDisplay string\n+\t\t\t\tif session.JWTUsername != \"\" {\n+\t\t\t\t\tsessionDisplay = fmt.Sprintf(\"[%s@%s -> %s] %s\",\n+\t\t\t\t\t\tsession.JWTUsername,\n+\t\t\t\t\t\tsession.RemoteAddress,\n+\t\t\t\t\t\tsession.Username,\n+\t\t\t\t\t\tsession.Command,\n+\t\t\t\t\t)\n+\t\t\t\t} else {\n+\t\t\t\t\tsessionDisplay = fmt.Sprintf(\"[%s@%s] %s\",\n+\t\t\t\t\t\tsession.Username,\n+\t\t\t\t\t\tsession.RemoteAddress,\n+\t\t\t\t\t\tsession.Command,\n+\t\t\t\t\t)\n+\t\t\t\t}\n+\t\t\t\tsshServerStatus += \"\\n  \" + sessionDisplay\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tpeersCountString := fmt.Sprintf(\"%d/%d Connected\", overview.Peers.Connected, overview.Peers.Total)\n \n \tgoos := runtime.GOOS\n@@ -428,6 +502,7 @@ func ParseGeneralSummary(overview OutputOverview, showURL bool, showRelays bool,\n \t\t\t\"Interface type: %s\\n\"+\n \t\t\t\"Quantum resistance: %s\\n\"+\n \t\t\t\"Lazy connection: %s\\n\"+\n+\t\t\t\"SSH Server: %s\\n\"+\n \t\t\t\"Networks: %s\\n\"+\n \t\t\t\"Forwarding rules: %d\\n\"+\n \t\t\t\"Peers count: %s\\n\",\n@@ -444,6 +519,7 @@ func ParseGeneralSummary(overview OutputOverview, showURL bool, showRelays bool,\n \t\tinterfaceTypeString,\n \t\trosenpassEnabledStatus,\n \t\tlazyConnectionEnabledStatus,\n+\t\tsshServerStatus,\n \t\tnetworks,\n \t\toverview.NumberOfForwardingRules,\n \t\tpeersCountString,\n@@ -454,7 +530,7 @@ func ParseGeneralSummary(overview OutputOverview, showURL bool, showRelays bool,\n func ParseToFullDetailSummary(overview OutputOverview) string {\n \tparsedPeersString := parsePeers(overview.Peers, overview.RosenpassEnabled, overview.RosenpassPermissive)\n \tparsedEventsString := parseEvents(overview.Events)\n-\tsummary := ParseGeneralSummary(overview, true, true, true)\n+\tsummary := ParseGeneralSummary(overview, true, true, true, true)\n \n \treturn fmt.Sprintf(\n \t\t\"Peers detail:\"+\n@@ -746,4 +822,13 @@ func anonymizeOverview(a *anonymize.Anonymizer, overview *OutputOverview) {\n \t\t\tevent.Metadata[k] = a.AnonymizeString(v)\n \t\t}\n \t}\n+\n+\tfor i, session := range overview.SSHServerState.Sessions {\n+\t\tif host, port, err := net.SplitHostPort(session.RemoteAddress); err == nil {\n+\t\t\toverview.SSHServerState.Sessions[i].RemoteAddress = fmt.Sprintf(\"%s:%s\", a.AnonymizeIPString(host), port)\n+\t\t} else {\n+\t\t\toverview.SSHServerState.Sessions[i].RemoteAddress = a.AnonymizeIPString(session.RemoteAddress)\n+\t\t}\n+\t\toverview.SSHServerState.Sessions[i].Command = a.AnonymizeString(session.Command)\n+\t}\n }\ndiff --git a/client/system/info.go b/client/system/info.go\nindex a180be4c0d6..01176e76512 100644\n--- a/client/system/info.go\n+++ b/client/system/info.go\n@@ -72,6 +72,12 @@ type Info struct {\n \tBlockInbound        bool\n \n \tLazyConnectionEnabled bool\n+\n+\tEnableSSHRoot                 bool\n+\tEnableSSHSFTP                 bool\n+\tEnableSSHLocalPortForwarding  bool\n+\tEnableSSHRemotePortForwarding bool\n+\tDisableSSHAuth                bool\n }\n \n func (i *Info) SetFlags(\n@@ -79,6 +85,8 @@ func (i *Info) SetFlags(\n \tserverSSHAllowed *bool,\n \tdisableClientRoutes, disableServerRoutes,\n \tdisableDNS, disableFirewall, blockLANAccess, blockInbound, lazyConnectionEnabled bool,\n+\tenableSSHRoot, enableSSHSFTP, enableSSHLocalPortForwarding, enableSSHRemotePortForwarding *bool,\n+\tdisableSSHAuth *bool,\n ) {\n \ti.RosenpassEnabled = rosenpassEnabled\n \ti.RosenpassPermissive = rosenpassPermissive\n@@ -94,6 +102,22 @@ func (i *Info) SetFlags(\n \ti.BlockInbound = blockInbound\n \n \ti.LazyConnectionEnabled = lazyConnectionEnabled\n+\n+\tif enableSSHRoot != nil {\n+\t\ti.EnableSSHRoot = *enableSSHRoot\n+\t}\n+\tif enableSSHSFTP != nil {\n+\t\ti.EnableSSHSFTP = *enableSSHSFTP\n+\t}\n+\tif enableSSHLocalPortForwarding != nil {\n+\t\ti.EnableSSHLocalPortForwarding = *enableSSHLocalPortForwarding\n+\t}\n+\tif enableSSHRemotePortForwarding != nil {\n+\t\ti.EnableSSHRemotePortForwarding = *enableSSHRemotePortForwarding\n+\t}\n+\tif disableSSHAuth != nil {\n+\t\ti.DisableSSHAuth = *disableSSHAuth\n+\t}\n }\n \n // extractUserAgent extracts Netbird's agent (client) name and version from the outgoing context\ndiff --git a/client/ui/client_ui.go b/client/ui/client_ui.go\nindex d3ab424233e..44643616d32 100644\n--- a/client/ui/client_ui.go\n+++ b/client/ui/client_ui.go\n@@ -55,6 +55,7 @@ const (\n \n const (\n \tcensoredPreSharedKey = \"**********\"\n+\tmaxSSHJWTCacheTTL    = 86_400 // 24 hours in seconds\n )\n \n func main() {\n@@ -265,25 +266,38 @@ type serviceClient struct {\n \tiMTU           *widget.Entry\n \n \t// switch elements for settings form\n-\tsRosenpassPermissive *widget.Check\n-\tsNetworkMonitor      *widget.Check\n-\tsDisableDNS          *widget.Check\n-\tsDisableClientRoutes *widget.Check\n-\tsDisableServerRoutes *widget.Check\n-\tsBlockLANAccess      *widget.Check\n+\tsRosenpassPermissive        *widget.Check\n+\tsNetworkMonitor             *widget.Check\n+\tsDisableDNS                 *widget.Check\n+\tsDisableClientRoutes        *widget.Check\n+\tsDisableServerRoutes        *widget.Check\n+\tsBlockLANAccess             *widget.Check\n+\tsEnableSSHRoot              *widget.Check\n+\tsEnableSSHSFTP              *widget.Check\n+\tsEnableSSHLocalPortForward  *widget.Check\n+\tsEnableSSHRemotePortForward *widget.Check\n+\tsDisableSSHAuth             *widget.Check\n+\tiSSHJWTCacheTTL             *widget.Entry\n \n \t// observable settings over corresponding iMngURL and iPreSharedKey values.\n-\tmanagementURL       string\n-\tpreSharedKey        string\n-\tRosenpassPermissive bool\n-\tinterfaceName       string\n-\tinterfacePort       int\n-\tmtu                 uint16\n-\tnetworkMonitor      bool\n-\tdisableDNS          bool\n-\tdisableClientRoutes bool\n-\tdisableServerRoutes bool\n-\tblockLANAccess      bool\n+\tmanagementURL string\n+\tpreSharedKey  string\n+\n+\tRosenpassPermissive        bool\n+\tinterfaceName              string\n+\tinterfacePort              int\n+\tmtu                        uint16\n+\tnetworkMonitor             bool\n+\tdisableDNS                 bool\n+\tdisableClientRoutes        bool\n+\tdisableServerRoutes        bool\n+\tblockLANAccess             bool\n+\tenableSSHRoot              bool\n+\tenableSSHSFTP              bool\n+\tenableSSHLocalPortForward  bool\n+\tenableSSHRemotePortForward bool\n+\tdisableSSHAuth             bool\n+\tsshJWTCacheTTL             int\n \n \tconnected            bool\n \tupdate               *version.Update\n@@ -435,18 +449,22 @@ func (s *serviceClient) showSettingsUI() {\n \ts.sDisableClientRoutes = widget.NewCheck(\"This peer won't route traffic to other peers\", nil)\n \ts.sDisableServerRoutes = widget.NewCheck(\"This peer won't act as router for others\", nil)\n \ts.sBlockLANAccess = widget.NewCheck(\"Blocks local network access when used as exit node\", nil)\n+\ts.sEnableSSHRoot = widget.NewCheck(\"Enable SSH Root Login\", nil)\n+\ts.sEnableSSHSFTP = widget.NewCheck(\"Enable SSH SFTP\", nil)\n+\ts.sEnableSSHLocalPortForward = widget.NewCheck(\"Enable SSH Local Port Forwarding\", nil)\n+\ts.sEnableSSHRemotePortForward = widget.NewCheck(\"Enable SSH Remote Port Forwarding\", nil)\n+\ts.sDisableSSHAuth = widget.NewCheck(\"Disable SSH Authentication\", nil)\n+\ts.iSSHJWTCacheTTL = widget.NewEntry()\n \n \ts.wSettings.SetContent(s.getSettingsForm())\n-\ts.wSettings.Resize(fyne.NewSize(600, 500))\n+\ts.wSettings.Resize(fyne.NewSize(600, 400))\n \ts.wSettings.SetFixedSize(true)\n \n \ts.getSrvConfig()\n \ts.wSettings.Show()\n }\n \n-// getSettingsForm to embed it into settings window.\n-func (s *serviceClient) getSettingsForm() *widget.Form {\n-\n+func (s *serviceClient) getConnectionForm() *widget.Form {\n \tvar activeProfName string\n \tactiveProf, err := s.profileManager.GetActiveProfile()\n \tif err != nil {\n@@ -457,153 +475,277 @@ func (s *serviceClient) getSettingsForm() *widget.Form {\n \treturn &widget.Form{\n \t\tItems: []*widget.FormItem{\n \t\t\t{Text: \"Profile\", Widget: widget.NewLabel(activeProfName)},\n+\t\t\t{Text: \"Management URL\", Widget: s.iMngURL},\n+\t\t\t{Text: \"Pre-shared Key\", Widget: s.iPreSharedKey},\n \t\t\t{Text: \"Quantum-Resistance\", Widget: s.sRosenpassPermissive},\n \t\t\t{Text: \"Interface Name\", Widget: s.iInterfaceName},\n \t\t\t{Text: \"Interface Port\", Widget: s.iInterfacePort},\n \t\t\t{Text: \"MTU\", Widget: s.iMTU},\n-\t\t\t{Text: \"Management URL\", Widget: s.iMngURL},\n-\t\t\t{Text: \"Pre-shared Key\", Widget: s.iPreSharedKey},\n \t\t\t{Text: \"Log File\", Widget: s.iLogFile},\n-\t\t\t{Text: \"Network Monitor\", Widget: s.sNetworkMonitor},\n-\t\t\t{Text: \"Disable DNS\", Widget: s.sDisableDNS},\n-\t\t\t{Text: \"Disable Client Routes\", Widget: s.sDisableClientRoutes},\n-\t\t\t{Text: \"Disable Server Routes\", Widget: s.sDisableServerRoutes},\n-\t\t\t{Text: \"Disable LAN Access\", Widget: s.sBlockLANAccess},\n \t\t},\n-\t\tSubmitText: \"Save\",\n-\t\tOnSubmit: func() {\n-\t\t\t// Check if update settings are disabled by daemon\n-\t\t\tfeatures, err := s.getFeatures()\n-\t\t\tif err != nil {\n-\t\t\t\tlog.Errorf(\"failed to get features from daemon: %v\", err)\n-\t\t\t\t// Continue with default behavior if features can't be retrieved\n-\t\t\t} else if features != nil && features.DisableUpdateSettings {\n-\t\t\t\tlog.Warn(\"Configuration updates are disabled by daemon\")\n-\t\t\t\tdialog.ShowError(fmt.Errorf(\"Configuration updates are disabled by daemon\"), s.wSettings)\n-\t\t\t\treturn\n-\t\t\t}\n+\t}\n+}\n \n-\t\t\tif s.iPreSharedKey.Text != \"\" && s.iPreSharedKey.Text != censoredPreSharedKey {\n-\t\t\t\t// validate preSharedKey if it added\n-\t\t\t\tif _, err := wgtypes.ParseKey(s.iPreSharedKey.Text); err != nil {\n-\t\t\t\t\tdialog.ShowError(fmt.Errorf(\"Invalid Pre-shared Key Value\"), s.wSettings)\n-\t\t\t\t\treturn\n-\t\t\t\t}\n-\t\t\t}\n+func (s *serviceClient) saveSettings() {\n+\t// Check if update settings are disabled by daemon\n+\tfeatures, err := s.getFeatures()\n+\tif err != nil {\n+\t\tlog.Errorf(\"failed to get features from daemon: %v\", err)\n+\t\t// Continue with default behavior if features can't be retrieved\n+\t} else if features != nil && features.DisableUpdateSettings {\n+\t\tlog.Warn(\"Configuration updates are disabled by daemon\")\n+\t\tdialog.ShowError(fmt.Errorf(\"Configuration updates are disabled by daemon\"), s.wSettings)\n+\t\treturn\n+\t}\n \n-\t\t\tport, err := strconv.ParseInt(s.iInterfacePort.Text, 10, 64)\n-\t\t\tif err != nil {\n-\t\t\t\tdialog.ShowError(errors.New(\"Invalid interface port\"), s.wSettings)\n-\t\t\t\treturn\n-\t\t\t}\n+\tif err := s.validateSettings(); err != nil {\n+\t\tdialog.ShowError(err, s.wSettings)\n+\t\treturn\n+\t}\n \n-\t\t\tvar mtu int64\n-\t\t\tmtuText := strings.TrimSpace(s.iMTU.Text)\n-\t\t\tif mtuText != \"\" {\n-\t\t\t\tvar err error\n-\t\t\t\tmtu, err = strconv.ParseInt(mtuText, 10, 64)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tdialog.ShowError(errors.New(\"Invalid MTU value\"), s.wSettings)\n-\t\t\t\t\treturn\n-\t\t\t\t}\n-\t\t\t\tif mtu < iface.MinMTU || mtu > iface.MaxMTU {\n-\t\t\t\t\tdialog.ShowError(fmt.Errorf(\"MTU must be between %d and %d bytes\", iface.MinMTU, iface.MaxMTU), s.wSettings)\n-\t\t\t\t\treturn\n-\t\t\t\t}\n-\t\t\t}\n+\tport, mtu, err := s.parseNumericSettings()\n+\tif err != nil {\n+\t\tdialog.ShowError(err, s.wSettings)\n+\t\treturn\n+\t}\n+\n+\tiMngURL := strings.TrimSpace(s.iMngURL.Text)\n+\n+\tif s.hasSettingsChanged(iMngURL, port, mtu) {\n+\t\tif err := s.applySettingsChanges(iMngURL, port, mtu); err != nil {\n+\t\t\tdialog.ShowError(err, s.wSettings)\n+\t\t\treturn\n+\t\t}\n+\t}\n \n-\t\t\tiMngURL := strings.TrimSpace(s.iMngURL.Text)\n+\ts.wSettings.Close()\n+}\n \n-\t\t\tdefer s.wSettings.Close()\n+func (s *serviceClient) validateSettings() error {\n+\tif s.iPreSharedKey.Text != \"\" && s.iPreSharedKey.Text != censoredPreSharedKey {\n+\t\tif _, err := wgtypes.ParseKey(s.iPreSharedKey.Text); err != nil {\n+\t\t\treturn fmt.Errorf(\"Invalid Pre-shared Key Value\")\n+\t\t}\n+\t}\n+\treturn nil\n+}\n \n-\t\t\t// Check if any settings have changed\n-\t\t\tif s.managementURL != iMngURL || s.preSharedKey != s.iPreSharedKey.Text ||\n-\t\t\t\ts.RosenpassPermissive != s.sRosenpassPermissive.Checked ||\n-\t\t\t\ts.interfaceName != s.iInterfaceName.Text || s.interfacePort != int(port) ||\n-\t\t\t\ts.mtu != uint16(mtu) ||\n-\t\t\t\ts.networkMonitor != s.sNetworkMonitor.Checked ||\n-\t\t\t\ts.disableDNS != s.sDisableDNS.Checked ||\n-\t\t\t\ts.disableClientRoutes != s.sDisableClientRoutes.Checked ||\n-\t\t\t\ts.disableServerRoutes != s.sDisableServerRoutes.Checked ||\n-\t\t\t\ts.blockLANAccess != s.sBlockLANAccess.Checked {\n+func (s *serviceClient) parseNumericSettings() (int64, int64, error) {\n+\tport, err := strconv.ParseInt(s.iInterfacePort.Text, 10, 64)\n+\tif err != nil {\n+\t\treturn 0, 0, errors.New(\"Invalid interface port\")\n+\t}\n+\tif port < 1 || port > 65535 {\n+\t\treturn 0, 0, errors.New(\"Invalid interface port: out of range 1-65535\")\n+\t}\n \n-\t\t\t\ts.managementURL = iMngURL\n-\t\t\t\ts.preSharedKey = s.iPreSharedKey.Text\n-\t\t\t\ts.mtu = uint16(mtu)\n+\tvar mtu int64\n+\tmtuText := strings.TrimSpace(s.iMTU.Text)\n+\tif mtuText != \"\" {\n+\t\tmtu, err = strconv.ParseInt(mtuText, 10, 64)\n+\t\tif err != nil {\n+\t\t\treturn 0, 0, errors.New(\"Invalid MTU value\")\n+\t\t}\n+\t\tif mtu < iface.MinMTU || mtu > iface.MaxMTU {\n+\t\t\treturn 0, 0, fmt.Errorf(\"MTU must be between %d and %d bytes\", iface.MinMTU, iface.MaxMTU)\n+\t\t}\n+\t}\n \n-\t\t\t\tcurrUser, err := user.Current()\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tlog.Errorf(\"get current user: %v\", err)\n-\t\t\t\t\treturn\n-\t\t\t\t}\n+\treturn port, mtu, nil\n+}\n \n-\t\t\t\tvar req proto.SetConfigRequest\n-\t\t\t\treq.ProfileName = activeProf.Name\n-\t\t\t\treq.Username = currUser.Username\n+func (s *serviceClient) hasSettingsChanged(iMngURL string, port, mtu int64) bool {\n+\treturn s.managementURL != iMngURL ||\n+\t\ts.preSharedKey != s.iPreSharedKey.Text ||\n+\t\ts.RosenpassPermissive != s.sRosenpassPermissive.Checked ||\n+\t\ts.interfaceName != s.iInterfaceName.Text ||\n+\t\ts.interfacePort != int(port) ||\n+\t\ts.mtu != uint16(mtu) ||\n+\t\ts.networkMonitor != s.sNetworkMonitor.Checked ||\n+\t\ts.disableDNS != s.sDisableDNS.Checked ||\n+\t\ts.disableClientRoutes != s.sDisableClientRoutes.Checked ||\n+\t\ts.disableServerRoutes != s.sDisableServerRoutes.Checked ||\n+\t\ts.blockLANAccess != s.sBlockLANAccess.Checked ||\n+\t\ts.hasSSHChanges()\n+}\n \n-\t\t\t\tif iMngURL != \"\" {\n-\t\t\t\t\treq.ManagementUrl = iMngURL\n-\t\t\t\t}\n+func (s *serviceClient) applySettingsChanges(iMngURL string, port, mtu int64) error {\n+\ts.managementURL = iMngURL\n+\ts.preSharedKey = s.iPreSharedKey.Text\n+\ts.mtu = uint16(mtu)\n \n-\t\t\t\treq.RosenpassPermissive = &s.sRosenpassPermissive.Checked\n-\t\t\t\treq.InterfaceName = &s.iInterfaceName.Text\n-\t\t\t\treq.WireguardPort = &port\n-\t\t\t\tif mtu > 0 {\n-\t\t\t\t\treq.Mtu = &mtu\n-\t\t\t\t}\n-\t\t\t\treq.NetworkMonitor = &s.sNetworkMonitor.Checked\n-\t\t\t\treq.DisableDns = &s.sDisableDNS.Checked\n-\t\t\t\treq.DisableClientRoutes = &s.sDisableClientRoutes.Checked\n-\t\t\t\treq.DisableServerRoutes = &s.sDisableServerRoutes.Checked\n-\t\t\t\treq.BlockLanAccess = &s.sBlockLANAccess.Checked\n-\n-\t\t\t\tif s.iPreSharedKey.Text != censoredPreSharedKey {\n-\t\t\t\t\treq.OptionalPreSharedKey = &s.iPreSharedKey.Text\n-\t\t\t\t}\n+\treq, err := s.buildSetConfigRequest(iMngURL, port, mtu)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"build config request: %w\", err)\n+\t}\n \n-\t\t\t\tconn, err := s.getSrvClient(failFastTimeout)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tlog.Errorf(\"get client: %v\", err)\n-\t\t\t\t\tdialog.ShowError(fmt.Errorf(\"Failed to connect to the service: %v\", err), s.wSettings)\n-\t\t\t\t\treturn\n-\t\t\t\t}\n-\t\t\t\t_, err = conn.SetConfig(s.ctx, &req)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tlog.Errorf(\"set config: %v\", err)\n-\t\t\t\t\tdialog.ShowError(fmt.Errorf(\"Failed to set configuration: %v\", err), s.wSettings)\n-\t\t\t\t\treturn\n-\t\t\t\t}\n+\tif err := s.sendConfigUpdate(req); err != nil {\n+\t\treturn fmt.Errorf(\"set configuration: %w\", err)\n+\t}\n \n-\t\t\t\tgo func() {\n-\t\t\t\t\tstatus, err := conn.Status(s.ctx, &proto.StatusRequest{})\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\tlog.Errorf(\"get service status: %v\", err)\n-\t\t\t\t\t\tdialog.ShowError(fmt.Errorf(\"Failed to get service status: %v\", err), s.wSettings)\n-\t\t\t\t\t\treturn\n-\t\t\t\t\t}\n-\t\t\t\t\tif status.Status == string(internal.StatusConnected) {\n-\t\t\t\t\t\t// run down & up\n-\t\t\t\t\t\t_, err = conn.Down(s.ctx, &proto.DownRequest{})\n-\t\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\t\tlog.Errorf(\"down service: %v\", err)\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t_, err = conn.Up(s.ctx, &proto.UpRequest{})\n-\t\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\t\tlog.Errorf(\"up service: %v\", err)\n-\t\t\t\t\t\t\tdialog.ShowError(fmt.Errorf(\"Failed to reconnect: %v\", err), s.wSettings)\n-\t\t\t\t\t\t\treturn\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}()\n+\treturn nil\n+}\n+\n+func (s *serviceClient) buildSetConfigRequest(iMngURL string, port, mtu int64) (*proto.SetConfigRequest, error) {\n+\tcurrUser, err := user.Current()\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"get current user: %w\", err)\n+\t}\n+\n+\tactiveProf, err := s.profileManager.GetActiveProfile()\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"get active profile: %w\", err)\n+\t}\n+\n+\treq := &proto.SetConfigRequest{\n+\t\tProfileName: activeProf.Name,\n+\t\tUsername:    currUser.Username,\n+\t}\n+\n+\tif iMngURL != \"\" {\n+\t\treq.ManagementUrl = iMngURL\n+\t}\n+\n+\treq.RosenpassPermissive = &s.sRosenpassPermissive.Checked\n+\treq.InterfaceName = &s.iInterfaceName.Text\n+\treq.WireguardPort = &port\n+\tif mtu > 0 {\n+\t\treq.Mtu = &mtu\n+\t}\n+\n+\treq.NetworkMonitor = &s.sNetworkMonitor.Checked\n+\treq.DisableDns = &s.sDisableDNS.Checked\n+\treq.DisableClientRoutes = &s.sDisableClientRoutes.Checked\n+\treq.DisableServerRoutes = &s.sDisableServerRoutes.Checked\n+\treq.BlockLanAccess = &s.sBlockLANAccess.Checked\n+\n+\treq.EnableSSHRoot = &s.sEnableSSHRoot.Checked\n+\treq.EnableSSHSFTP = &s.sEnableSSHSFTP.Checked\n+\treq.EnableSSHLocalPortForwarding = &s.sEnableSSHLocalPortForward.Checked\n+\treq.EnableSSHRemotePortForwarding = &s.sEnableSSHRemotePortForward.Checked\n+\treq.DisableSSHAuth = &s.sDisableSSHAuth.Checked\n+\n+\tsshJWTCacheTTLText := strings.TrimSpace(s.iSSHJWTCacheTTL.Text)\n+\tif sshJWTCacheTTLText != \"\" {\n+\t\tsshJWTCacheTTL, err := strconv.ParseInt(sshJWTCacheTTLText, 10, 32)\n+\t\tif err != nil {\n+\t\t\treturn nil, errors.New(\"Invalid SSH JWT Cache TTL value\")\n+\t\t}\n+\t\tif sshJWTCacheTTL < 0 || sshJWTCacheTTL > maxSSHJWTCacheTTL {\n+\t\t\treturn nil, fmt.Errorf(\"SSH JWT Cache TTL must be between 0 and %d seconds\", maxSSHJWTCacheTTL)\n+\t\t}\n+\t\tsshJWTCacheTTL32 := int32(sshJWTCacheTTL)\n+\t\treq.SshJWTCacheTTL = &sshJWTCacheTTL32\n+\t}\n+\n+\tif s.iPreSharedKey.Text != censoredPreSharedKey {\n+\t\treq.OptionalPreSharedKey = &s.iPreSharedKey.Text\n+\t}\n+\n+\treturn req, nil\n+}\n+\n+func (s *serviceClient) sendConfigUpdate(req *proto.SetConfigRequest) error {\n+\tconn, err := s.getSrvClient(failFastTimeout)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"get client: %w\", err)\n+\t}\n+\n+\t_, err = conn.SetConfig(s.ctx, req)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"set config: %w\", err)\n+\t}\n+\n+\t// Reconnect if connected to apply the new settings\n+\tgo func() {\n+\t\tstatus, err := conn.Status(s.ctx, &proto.StatusRequest{})\n+\t\tif err != nil {\n+\t\t\tlog.Errorf(\"get service status: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t\tif status.Status == string(internal.StatusConnected) {\n+\t\t\t// run down & up\n+\t\t\t_, err = conn.Down(s.ctx, &proto.DownRequest{})\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Errorf(\"down service: %v\", err)\n+\t\t\t}\n+\n+\t\t\t_, err = conn.Up(s.ctx, &proto.UpRequest{})\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Errorf(\"up service: %v\", err)\n+\t\t\t\treturn\n \t\t\t}\n+\t\t}\n+\t}()\n+\n+\treturn nil\n+}\n+\n+func (s *serviceClient) getSettingsForm() fyne.CanvasObject {\n+\tconnectionForm := s.getConnectionForm()\n+\tnetworkForm := s.getNetworkForm()\n+\tsshForm := s.getSSHForm()\n+\ttabs := container.NewAppTabs(\n+\t\tcontainer.NewTabItem(\"Connection\", connectionForm),\n+\t\tcontainer.NewTabItem(\"Network\", networkForm),\n+\t\tcontainer.NewTabItem(\"SSH\", sshForm),\n+\t)\n+\tsaveButton := widget.NewButtonWithIcon(\"Save\", theme.ConfirmIcon(), s.saveSettings)\n+\tsaveButton.Importance = widget.HighImportance\n+\tcancelButton := widget.NewButtonWithIcon(\"Cancel\", theme.CancelIcon(), func() {\n+\t\ts.wSettings.Close()\n+\t})\n+\tbuttonContainer := container.NewHBox(\n+\t\tlayout.NewSpacer(),\n+\t\tcancelButton,\n+\t\tsaveButton,\n+\t)\n+\treturn container.NewBorder(nil, buttonContainer, nil, nil, tabs)\n+}\n+\n+func (s *serviceClient) getNetworkForm() *widget.Form {\n+\treturn &widget.Form{\n+\t\tItems: []*widget.FormItem{\n+\t\t\t{Text: \"Network Monitor\", Widget: s.sNetworkMonitor},\n+\t\t\t{Text: \"Disable DNS\", Widget: s.sDisableDNS},\n+\t\t\t{Text: \"Disable Client Routes\", Widget: s.sDisableClientRoutes},\n+\t\t\t{Text: \"Disable Server Routes\", Widget: s.sDisableServerRoutes},\n+\t\t\t{Text: \"Disable LAN Access\", Widget: s.sBlockLANAccess},\n \t\t},\n-\t\tOnCancel: func() {\n-\t\t\ts.wSettings.Close()\n+\t}\n+}\n+\n+func (s *serviceClient) getSSHForm() *widget.Form {\n+\treturn &widget.Form{\n+\t\tItems: []*widget.FormItem{\n+\t\t\t{Text: \"Enable SSH Root Login\", Widget: s.sEnableSSHRoot},\n+\t\t\t{Text: \"Enable SSH SFTP\", Widget: s.sEnableSSHSFTP},\n+\t\t\t{Text: \"Enable SSH Local Port Forwarding\", Widget: s.sEnableSSHLocalPortForward},\n+\t\t\t{Text: \"Enable SSH Remote Port Forwarding\", Widget: s.sEnableSSHRemotePortForward},\n+\t\t\t{Text: \"Disable SSH Authentication\", Widget: s.sDisableSSHAuth},\n+\t\t\t{Text: \"JWT Cache TTL (seconds, 0=disabled)\", Widget: s.iSSHJWTCacheTTL},\n \t\t},\n \t}\n }\n \n+func (s *serviceClient) hasSSHChanges() bool {\n+\tcurrentSSHJWTCacheTTL := s.sshJWTCacheTTL\n+\tif text := strings.TrimSpace(s.iSSHJWTCacheTTL.Text); text != \"\" {\n+\t\tval, err := strconv.Atoi(text)\n+\t\tif err != nil {\n+\t\t\treturn true\n+\t\t}\n+\t\tcurrentSSHJWTCacheTTL = val\n+\t}\n+\n+\treturn s.enableSSHRoot != s.sEnableSSHRoot.Checked ||\n+\t\ts.enableSSHSFTP != s.sEnableSSHSFTP.Checked ||\n+\t\ts.enableSSHLocalPortForward != s.sEnableSSHLocalPortForward.Checked ||\n+\t\ts.enableSSHRemotePortForward != s.sEnableSSHRemotePortForward.Checked ||\n+\t\ts.disableSSHAuth != s.sDisableSSHAuth.Checked ||\n+\t\ts.sshJWTCacheTTL != currentSSHJWTCacheTTL\n+}\n+\n func (s *serviceClient) login(ctx context.Context, openURL bool) (*proto.LoginResponse, error) {\n \tconn, err := s.getSrvClient(defaultFailTimeout)\n \tif err != nil {\n@@ -1123,6 +1265,25 @@ func (s *serviceClient) getSrvConfig() {\n \ts.disableServerRoutes = cfg.DisableServerRoutes\n \ts.blockLANAccess = cfg.BlockLANAccess\n \n+\tif cfg.EnableSSHRoot != nil {\n+\t\ts.enableSSHRoot = *cfg.EnableSSHRoot\n+\t}\n+\tif cfg.EnableSSHSFTP != nil {\n+\t\ts.enableSSHSFTP = *cfg.EnableSSHSFTP\n+\t}\n+\tif cfg.EnableSSHLocalPortForwarding != nil {\n+\t\ts.enableSSHLocalPortForward = *cfg.EnableSSHLocalPortForwarding\n+\t}\n+\tif cfg.EnableSSHRemotePortForwarding != nil {\n+\t\ts.enableSSHRemotePortForward = *cfg.EnableSSHRemotePortForwarding\n+\t}\n+\tif cfg.DisableSSHAuth != nil {\n+\t\ts.disableSSHAuth = *cfg.DisableSSHAuth\n+\t}\n+\tif cfg.SSHJWTCacheTTL != nil {\n+\t\ts.sshJWTCacheTTL = *cfg.SSHJWTCacheTTL\n+\t}\n+\n \tif s.showAdvancedSettings {\n \t\ts.iMngURL.SetText(s.managementURL)\n \t\ts.iPreSharedKey.SetText(cfg.PreSharedKey)\n@@ -1143,6 +1304,24 @@ func (s *serviceClient) getSrvConfig() {\n \t\ts.sDisableClientRoutes.SetChecked(cfg.DisableClientRoutes)\n \t\ts.sDisableServerRoutes.SetChecked(cfg.DisableServerRoutes)\n \t\ts.sBlockLANAccess.SetChecked(cfg.BlockLANAccess)\n+\t\tif cfg.EnableSSHRoot != nil {\n+\t\t\ts.sEnableSSHRoot.SetChecked(*cfg.EnableSSHRoot)\n+\t\t}\n+\t\tif cfg.EnableSSHSFTP != nil {\n+\t\t\ts.sEnableSSHSFTP.SetChecked(*cfg.EnableSSHSFTP)\n+\t\t}\n+\t\tif cfg.EnableSSHLocalPortForwarding != nil {\n+\t\t\ts.sEnableSSHLocalPortForward.SetChecked(*cfg.EnableSSHLocalPortForwarding)\n+\t\t}\n+\t\tif cfg.EnableSSHRemotePortForwarding != nil {\n+\t\t\ts.sEnableSSHRemotePortForward.SetChecked(*cfg.EnableSSHRemotePortForwarding)\n+\t\t}\n+\t\tif cfg.DisableSSHAuth != nil {\n+\t\t\ts.sDisableSSHAuth.SetChecked(*cfg.DisableSSHAuth)\n+\t\t}\n+\t\tif cfg.SSHJWTCacheTTL != nil {\n+\t\t\ts.iSSHJWTCacheTTL.SetText(strconv.Itoa(*cfg.SSHJWTCacheTTL))\n+\t\t}\n \t}\n \n \tif s.mNotifications == nil {\n@@ -1213,6 +1392,15 @@ func protoConfigToConfig(cfg *proto.GetConfigResponse) *profilemanager.Config {\n \tconfig.DisableServerRoutes = cfg.DisableServerRoutes\n \tconfig.BlockLANAccess = cfg.BlockLanAccess\n \n+\tconfig.EnableSSHRoot = &cfg.EnableSSHRoot\n+\tconfig.EnableSSHSFTP = &cfg.EnableSSHSFTP\n+\tconfig.EnableSSHLocalPortForwarding = &cfg.EnableSSHLocalPortForwarding\n+\tconfig.EnableSSHRemotePortForwarding = &cfg.EnableSSHRemotePortForwarding\n+\tconfig.DisableSSHAuth = &cfg.DisableSSHAuth\n+\n+\tttl := int(cfg.SshJWTCacheTTL)\n+\tconfig.SSHJWTCacheTTL = &ttl\n+\n \treturn &config\n }\n \ndiff --git a/client/wasm/cmd/main.go b/client/wasm/cmd/main.go\nindex d542e273960..4dc14a1ca01 100644\n--- a/client/wasm/cmd/main.go\n+++ b/client/wasm/cmd/main.go\n@@ -11,6 +11,7 @@ import (\n \tlog \"github.com/sirupsen/logrus\"\n \n \tnetbird \"github.com/netbirdio/netbird/client/embed\"\n+\tsshdetection \"github.com/netbirdio/netbird/client/ssh/detection\"\n \t\"github.com/netbirdio/netbird/client/wasm/internal/http\"\n \t\"github.com/netbirdio/netbird/client/wasm/internal/rdp\"\n \t\"github.com/netbirdio/netbird/client/wasm/internal/ssh\"\n@@ -125,10 +126,15 @@ func createSSHMethod(client *netbird.Client) js.Func {\n \t\t\tusername = args[2].String()\n \t\t}\n \n+\t\tvar jwtToken string\n+\t\tif len(args) > 3 && !args[3].IsNull() && !args[3].IsUndefined() {\n+\t\t\tjwtToken = args[3].String()\n+\t\t}\n+\n \t\treturn createPromise(func(resolve, reject js.Value) {\n \t\t\tsshClient := ssh.NewClient(client)\n \n-\t\t\tif err := sshClient.Connect(host, port, username); err != nil {\n+\t\t\tif err := sshClient.Connect(host, port, username, jwtToken); err != nil {\n \t\t\t\treject.Invoke(err.Error())\n \t\t\t\treturn\n \t\t\t}\n@@ -191,12 +197,43 @@ func createPromise(handler func(resolve, reject js.Value)) js.Value {\n \t}))\n }\n \n+// createDetectSSHServerMethod creates the SSH server detection method\n+func createDetectSSHServerMethod(client *netbird.Client) js.Func {\n+\treturn js.FuncOf(func(this js.Value, args []js.Value) any {\n+\t\tif len(args) < 2 {\n+\t\t\treturn js.ValueOf(\"error: requires host and port\")\n+\t\t}\n+\n+\t\thost := args[0].String()\n+\t\tport := args[1].Int()\n+\n+\t\treturn createPromise(func(resolve, reject js.Value) {\n+\t\t\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n+\t\t\tdefer cancel()\n+\n+\t\t\tserverType, err := detectSSHServerType(ctx, client, host, port)\n+\t\t\tif err != nil {\n+\t\t\t\treject.Invoke(err.Error())\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tresolve.Invoke(js.ValueOf(serverType.RequiresJWT()))\n+\t\t})\n+\t})\n+}\n+\n+// detectSSHServerType detects SSH server type using NetBird network connection\n+func detectSSHServerType(ctx context.Context, client *netbird.Client, host string, port int) (sshdetection.ServerType, error) {\n+\treturn sshdetection.DetectSSHServerType(ctx, client, host, port)\n+}\n+\n // createClientObject wraps the NetBird client in a JavaScript object\n func createClientObject(client *netbird.Client) js.Value {\n \tobj := make(map[string]interface{})\n \n \tobj[\"start\"] = createStartMethod(client)\n \tobj[\"stop\"] = createStopMethod(client)\n+\tobj[\"detectSSHServerType\"] = createDetectSSHServerMethod(client)\n \tobj[\"createSSHConnection\"] = createSSHMethod(client)\n \tobj[\"proxyRequest\"] = createProxyRequestMethod(client)\n \tobj[\"createRDPProxy\"] = createRDPProxyMethod(client)\ndiff --git a/client/wasm/internal/ssh/client.go b/client/wasm/internal/ssh/client.go\nindex ca35525ebd4..568437e56bc 100644\n--- a/client/wasm/internal/ssh/client.go\n+++ b/client/wasm/internal/ssh/client.go\n@@ -13,6 +13,7 @@ import (\n \t\"golang.org/x/crypto/ssh\"\n \n \tnetbird \"github.com/netbirdio/netbird/client/embed\"\n+\tnbssh \"github.com/netbirdio/netbird/client/ssh\"\n )\n \n const (\n@@ -45,34 +46,19 @@ func NewClient(nbClient *netbird.Client) *Client {\n }\n \n // Connect establishes an SSH connection through NetBird network\n-func (c *Client) Connect(host string, port int, username string) error {\n+func (c *Client) Connect(host string, port int, username, jwtToken string) error {\n \taddr := fmt.Sprintf(\"%s:%d\", host, port)\n \tlogrus.Infof(\"SSH: Connecting to %s as %s\", addr, username)\n \n-\tvar authMethods []ssh.AuthMethod\n-\n-\tnbConfig, err := c.nbClient.GetConfig()\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"get NetBird config: %w\", err)\n-\t}\n-\tif nbConfig.SSHKey == \"\" {\n-\t\treturn fmt.Errorf(\"no NetBird SSH key available - key should be generated during client initialization\")\n-\t}\n-\n-\tsigner, err := parseSSHPrivateKey([]byte(nbConfig.SSHKey))\n+\tauthMethods, err := c.getAuthMethods(jwtToken)\n \tif err != nil {\n-\t\treturn fmt.Errorf(\"parse NetBird SSH private key: %w\", err)\n+\t\treturn err\n \t}\n \n-\tpubKey := signer.PublicKey()\n-\tlogrus.Infof(\"SSH: Using NetBird key authentication with public key type: %s\", pubKey.Type())\n-\n-\tauthMethods = append(authMethods, ssh.PublicKeys(signer))\n-\n \tconfig := &ssh.ClientConfig{\n \t\tUser:            username,\n \t\tAuth:            authMethods,\n-\t\tHostKeyCallback: ssh.InsecureIgnoreHostKey(),\n+\t\tHostKeyCallback: nbssh.CreateHostKeyCallback(c.nbClient),\n \t\tTimeout:         sshDialTimeout,\n \t}\n \n@@ -96,6 +82,33 @@ func (c *Client) Connect(host string, port int, username string) error {\n \treturn nil\n }\n \n+// getAuthMethods returns SSH authentication methods, preferring JWT if available\n+func (c *Client) getAuthMethods(jwtToken string) ([]ssh.AuthMethod, error) {\n+\tif jwtToken != \"\" {\n+\t\tlogrus.Debugf(\"SSH: Using JWT password authentication\")\n+\t\treturn []ssh.AuthMethod{ssh.Password(jwtToken)}, nil\n+\t}\n+\n+\tlogrus.Debugf(\"SSH: No JWT token, using public key authentication\")\n+\n+\tnbConfig, err := c.nbClient.GetConfig()\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"get NetBird config: %w\", err)\n+\t}\n+\n+\tif nbConfig.SSHKey == \"\" {\n+\t\treturn nil, fmt.Errorf(\"no NetBird SSH key available\")\n+\t}\n+\n+\tsigner, err := ssh.ParsePrivateKey([]byte(nbConfig.SSHKey))\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"parse NetBird SSH private key: %w\", err)\n+\t}\n+\n+\tlogrus.Debugf(\"SSH: Added public key auth\")\n+\treturn []ssh.AuthMethod{ssh.PublicKeys(signer)}, nil\n+}\n+\n // StartSession starts an SSH session with PTY\n func (c *Client) StartSession(cols, rows int) error {\n \tif c.sshClient == nil {\ndiff --git a/client/wasm/internal/ssh/key.go b/client/wasm/internal/ssh/key.go\ndeleted file mode 100644\nindex 4868ba30ae0..00000000000\n--- a/client/wasm/internal/ssh/key.go\n+++ /dev/null\n@@ -1,50 +0,0 @@\n-//go:build js\n-\n-package ssh\n-\n-import (\n-\t\"crypto/x509\"\n-\t\"encoding/pem\"\n-\t\"fmt\"\n-\t\"strings\"\n-\n-\t\"github.com/sirupsen/logrus\"\n-\t\"golang.org/x/crypto/ssh\"\n-)\n-\n-// parseSSHPrivateKey parses a private key in either SSH or PKCS8 format\n-func parseSSHPrivateKey(keyPEM []byte) (ssh.Signer, error) {\n-\tkeyStr := string(keyPEM)\n-\tif !strings.Contains(keyStr, \"-----BEGIN\") {\n-\t\tkeyPEM = []byte(\"-----BEGIN PRIVATE KEY-----\\n\" + keyStr + \"\\n-----END PRIVATE KEY-----\")\n-\t}\n-\n-\tsigner, err := ssh.ParsePrivateKey(keyPEM)\n-\tif err == nil {\n-\t\treturn signer, nil\n-\t}\n-\tlogrus.Debugf(\"SSH: Failed to parse as SSH format: %v\", err)\n-\n-\tblock, _ := pem.Decode(keyPEM)\n-\tif block == nil {\n-\t\tkeyPreview := string(keyPEM)\n-\t\tif len(keyPreview) > 100 {\n-\t\t\tkeyPreview = keyPreview[:100]\n-\t\t}\n-\t\treturn nil, fmt.Errorf(\"decode PEM block from key: %s\", keyPreview)\n-\t}\n-\n-\tkey, err := x509.ParsePKCS8PrivateKey(block.Bytes)\n-\tif err != nil {\n-\t\tlogrus.Debugf(\"SSH: Failed to parse as PKCS8: %v\", err)\n-\t\tif rsaKey, err := x509.ParsePKCS1PrivateKey(block.Bytes); err == nil {\n-\t\t\treturn ssh.NewSignerFromKey(rsaKey)\n-\t\t}\n-\t\tif ecKey, err := x509.ParseECPrivateKey(block.Bytes); err == nil {\n-\t\t\treturn ssh.NewSignerFromKey(ecKey)\n-\t\t}\n-\t\treturn nil, fmt.Errorf(\"parse private key: %w\", err)\n-\t}\n-\n-\treturn ssh.NewSignerFromKey(key)\n-}\ndiff --git a/go.mod b/go.mod\nindex 2d7e0d31ca4..45a36190dd3 100644\n--- a/go.mod\n+++ b/go.mod\n@@ -1,6 +1,6 @@\n module github.com/netbirdio/netbird\n \n-go 1.23.0\n+go 1.23.1\n \n require (\n \tcunicu.li/go-rosenpass v0.4.0\n@@ -17,8 +17,8 @@ require (\n \tgithub.com/spf13/cobra v1.7.0\n \tgithub.com/spf13/pflag v1.0.5\n \tgithub.com/vishvananda/netlink v1.3.1\n-\tgolang.org/x/crypto v0.40.0\n-\tgolang.org/x/sys v0.34.0\n+\tgolang.org/x/crypto v0.41.0\n+\tgolang.org/x/sys v0.35.0\n \tgolang.zx2c4.com/wireguard v0.0.0-20230704135630-469159ecf7d1\n \tgolang.zx2c4.com/wireguard/wgctrl v0.0.0-20230429144221-925a1e7659e6\n \tgolang.zx2c4.com/wireguard/windows v0.5.3\n@@ -31,6 +31,7 @@ require (\n \tfyne.io/fyne/v2 v2.7.0\n \tfyne.io/systray v1.11.1-0.20250603113521-ca66a66d8b58\n \tgithub.com/TheJumpCloud/jcapi-go v3.0.0+incompatible\n+\tgithub.com/awnumar/memguard v0.23.0\n \tgithub.com/aws/aws-sdk-go-v2 v1.36.3\n \tgithub.com/aws/aws-sdk-go-v2/config v1.29.14\n \tgithub.com/aws/aws-sdk-go-v2/service/s3 v1.79.2\n@@ -76,6 +77,7 @@ require (\n \tgithub.com/pion/stun/v3 v3.0.0\n \tgithub.com/pion/transport/v3 v3.0.7\n \tgithub.com/pion/turn/v3 v3.0.1\n+\tgithub.com/pkg/sftp v1.13.9\n \tgithub.com/prometheus/client_golang v1.22.0\n \tgithub.com/quic-go/quic-go v0.49.1\n \tgithub.com/redis/go-redis/v9 v9.7.3\n@@ -108,7 +110,7 @@ require (\n \tgolang.org/x/net v0.42.0\n \tgolang.org/x/oauth2 v0.30.0\n \tgolang.org/x/sync v0.16.0\n-\tgolang.org/x/term v0.33.0\n+\tgolang.org/x/term v0.34.0\n \tgolang.org/x/time v0.12.0\n \tgoogle.golang.org/api v0.177.0\n \tgopkg.in/yaml.v3 v3.0.1\n@@ -130,6 +132,7 @@ require (\n \tgithub.com/Microsoft/go-winio v0.6.2 // indirect\n \tgithub.com/Microsoft/hcsshim v0.12.3 // indirect\n \tgithub.com/anmitsu/go-shlex v0.0.0-20200514113438-38f4b401e2be // indirect\n+\tgithub.com/awnumar/memcall v0.4.0 // indirect\n \tgithub.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.6.10 // indirect\n \tgithub.com/aws/aws-sdk-go-v2/credentials v1.17.67 // indirect\n \tgithub.com/aws/aws-sdk-go-v2/feature/ec2/imds v1.16.30 // indirect\n@@ -197,6 +200,7 @@ require (\n \tgithub.com/kelseyhightower/envconfig v1.4.0 // indirect\n \tgithub.com/klauspost/compress v1.18.0 // indirect\n \tgithub.com/klauspost/cpuid/v2 v2.2.7 // indirect\n+\tgithub.com/kr/fs v0.1.0 // indirect\n \tgithub.com/libdns/libdns v0.2.2 // indirect\n \tgithub.com/lufia/plan9stats v0.0.0-20240513124658-fba389f38bae // indirect\n \tgithub.com/magiconair/properties v1.8.7 // indirect\n@@ -248,8 +252,8 @@ require (\n \tgo.opentelemetry.io/otel/trace v1.35.0 // indirect\n \tgo.uber.org/multierr v1.11.0 // indirect\n \tgolang.org/x/image v0.24.0 // indirect\n-\tgolang.org/x/text v0.27.0 // indirect\n-\tgolang.org/x/tools v0.34.0 // indirect\n+\tgolang.org/x/text v0.28.0 // indirect\n+\tgolang.org/x/tools v0.35.0 // indirect\n \tgolang.zx2c4.com/wintun v0.0.0-20230126152724-0fa3db229ce2 // indirect\n \tgoogle.golang.org/genproto/googleapis/rpc v0.0.0-20250707201910-8d1bb00bc6a7 // indirect\n \tgopkg.in/square/go-jose.v2 v2.6.0 // indirect\ndiff --git a/go.sum b/go.sum\nindex f4b62dff0bf..ec68a8f59a7 100644\n--- a/go.sum\n+++ b/go.sum\n@@ -31,6 +31,10 @@ github.com/TheJumpCloud/jcapi-go v3.0.0+incompatible h1:hqcTK6ZISdip65SR792lwYJT\n github.com/TheJumpCloud/jcapi-go v3.0.0+incompatible/go.mod h1:6B1nuc1MUs6c62ODZDl7hVE5Pv7O2XGSkgg2olnq34I=\n github.com/anmitsu/go-shlex v0.0.0-20200514113438-38f4b401e2be h1:9AeTilPcZAjCFIImctFaOjnTIavg87rW78vTPkQqLI8=\n github.com/anmitsu/go-shlex v0.0.0-20200514113438-38f4b401e2be/go.mod h1:ySMOLuWl6zY27l47sB3qLNK6tF2fkHG55UZxx8oIVo4=\n+github.com/awnumar/memcall v0.4.0 h1:B7hgZYdfH6Ot1Goaz8jGne/7i8xD4taZie/PNSFZ29g=\n+github.com/awnumar/memcall v0.4.0/go.mod h1:8xOx1YbfyuCg3Fy6TO8DK0kZUua3V42/goA5Ru47E8w=\n+github.com/awnumar/memguard v0.23.0 h1:sJ3a1/SWlcuKIQ7MV+R9p0Pvo9CWsMbGZvcZQtmc68A=\n+github.com/awnumar/memguard v0.23.0/go.mod h1:olVofBrsPdITtJ2HgxQKrEYEMyIBAIciVG4wNnZhW9M=\n github.com/aws/aws-sdk-go-v2 v1.36.3 h1:mJoei2CxPutQVxaATCzDUjcZEjVRdpsiiXi2o38yqWM=\n github.com/aws/aws-sdk-go-v2 v1.36.3/go.mod h1:LLXuLpgzEbD766Z5ECcRmi8AzSwfZItDtmABVkRLGzg=\n github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.6.10 h1:zAybnyUQXIZ5mok5Jqwlf58/TFE7uvd3IAsa1aF9cXs=\n@@ -303,6 +307,8 @@ github.com/klauspost/compress v1.18.0/go.mod h1:2Pp+KzxcywXVXMr50+X0Q/Lsb43OQHYW\n github.com/klauspost/cpuid/v2 v2.0.12/go.mod h1:g2LTdtYhdyuGPqyWyv7qRAmj1WBqxuObKfj5c0PQa7c=\n github.com/klauspost/cpuid/v2 v2.2.7 h1:ZWSB3igEs+d0qvnxR/ZBzXVmxkgt8DdzP6m9pfuVLDM=\n github.com/klauspost/cpuid/v2 v2.2.7/go.mod h1:Lcz8mBdAVJIBVzewtcLocK12l3Y+JytZYpaMropDUws=\n+github.com/kr/fs v0.1.0 h1:Jskdu9ieNAYnjxsi0LbQp1ulIKZV1LAFgK1tWhpZgl8=\n+github.com/kr/fs v0.1.0/go.mod h1:FFnZGqtBN9Gxj7eW1uZ42v5BccTP0vu6NEaFoC2HwRg=\n github.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\n github.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\n github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\n@@ -432,6 +438,8 @@ github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\n github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\n github.com/pkg/profile v1.7.0 h1:hnbDkaNWPCLMO9wGLdBFTIZvzDrDfBM2072E1S9gJkA=\n github.com/pkg/profile v1.7.0/go.mod h1:8Uer0jas47ZQMJ7VD+OHknK4YDY07LPUC6dEvqDjvNo=\n+github.com/pkg/sftp v1.13.9 h1:4NGkvGudBL7GteO3m6qnaQ4pC0Kvf0onSVc9gR3EWBw=\n+github.com/pkg/sftp v1.13.9/go.mod h1:OBN7bVXdstkFFN/gdnHPUb5TE8eb8G1Rp9wCItqjkkA=\n github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\n github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\n github.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c/go.mod h1:OmDBASR4679mdNQnz2pUhc2G8CO2JrUAVFDRBDP/hJE=\n@@ -587,9 +595,13 @@ golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPh\n golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\n golang.org/x/crypto v0.8.0/go.mod h1:mRqEX+O9/h5TFCrQhkgjo2yKi0yYA+9ecGkdQoHrywE=\n golang.org/x/crypto v0.12.0/go.mod h1:NF0Gs7EO5K4qLn+Ylc+fih8BSTeIjAP05siRnAh98yw=\n+golang.org/x/crypto v0.13.0/go.mod h1:y6Z2r+Rw4iayiXXAIxJIDAJ1zMW4yaTpebo8fPOliYc=\n golang.org/x/crypto v0.18.0/go.mod h1:R0j02AL6hcrfOiy9T4ZYp/rcWeMxM3L6QYxlOuEG1mg=\n-golang.org/x/crypto v0.40.0 h1:r4x+VvoG5Fm+eJcxMaY8CQM7Lb0l1lsmjGBQ6s8BfKM=\n-golang.org/x/crypto v0.40.0/go.mod h1:Qr1vMER5WyS2dfPHAlsOj01wgLbsyWtFn/aY+5+ZdxY=\n+golang.org/x/crypto v0.19.0/go.mod h1:Iy9bg/ha4yyC70EfRS8jz+B6ybOBKMaSxLj6P6oBDfU=\n+golang.org/x/crypto v0.23.0/go.mod h1:CKFgDieR+mRhux2Lsu27y0fO304Db0wZe70UKqHu0v8=\n+golang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\n+golang.org/x/crypto v0.41.0 h1:WKYxWedPGCTVVl5+WHSSrOBT0O8lx32+zxmHxijgXp4=\n+golang.org/x/crypto v0.41.0/go.mod h1:pO5AFd7FA68rFak7rOAGVuygIISepHftHnr8dr6+sUc=\n golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\n golang.org/x/exp v0.0.0-20240506185415-9bf2ced13842 h1:vr/HnozRka3pE4EsMEg1lgkXJkTFJCVUX+S/ZT6wYzM=\n golang.org/x/exp v0.0.0-20240506185415-9bf2ced13842/go.mod h1:XtvwrStGgqGPLc4cjQfWqZHG1YFdYs6swckp8vpsjnc=\n@@ -607,6 +619,9 @@ golang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\n golang.org/x/mod v0.4.2/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\n golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\n golang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\n+golang.org/x/mod v0.12.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\n+golang.org/x/mod v0.15.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\n+golang.org/x/mod v0.17.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\n golang.org/x/mod v0.26.0 h1:EGMPT//Ezu+ylkCijjPc+f4Aih7sZvaAr+O3EHBxvZg=\n golang.org/x/mod v0.26.0/go.mod h1:/j6NAhSk8iQ723BGAUyoAcn7SlD7s15Dp9Nd/SfeaFQ=\n golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\n@@ -628,7 +643,10 @@ golang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=\n golang.org/x/net v0.9.0/go.mod h1:d48xBJpPfHeWQsugry2m+kC02ZBRGRgulfHnEXEuWns=\n golang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=\n golang.org/x/net v0.14.0/go.mod h1:PpSgVXXLK0OxS0F31C1/tv6XNguvCrnXIDrFMspZIUI=\n+golang.org/x/net v0.15.0/go.mod h1:idbUs1IY1+zTqbi8yxTbhexhEEk5ur9LInksu6HrEpk=\n golang.org/x/net v0.20.0/go.mod h1:z8BVo6PvndSri0LbOE3hAn0apkU+1YvI6E70E9jsnvY=\n+golang.org/x/net v0.21.0/go.mod h1:bIjVDfnllIU7BJ2DNgfnXvpSvtn8VRwhlsaeUTyUS44=\n+golang.org/x/net v0.25.0/go.mod h1:JkAGAh7GEvH74S6FOH42FLoXpXbE/aqXSrIQjXgsiwM=\n golang.org/x/net v0.42.0 h1:jzkYrhi3YQWD6MLBJcsklgQsoAcw89EcZbJw8Z614hs=\n golang.org/x/net v0.42.0/go.mod h1:FF1RA5d3u7nAYA4z2TkclSCKh68eSXtiFwcWQpPXdt8=\n golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\n@@ -643,6 +661,10 @@ golang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJ\n golang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n golang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n+golang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=\n+golang.org/x/sync v0.6.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\n+golang.org/x/sync v0.7.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\n+golang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\n golang.org/x/sync v0.16.0 h1:ycBJEhp9p4vXvUZNszeOq0kGTPghopOL8q0fq3vstxw=\n golang.org/x/sync v0.16.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=\n golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n@@ -675,19 +697,28 @@ golang.org/x/sys v0.7.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.10.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.11.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n+golang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n golang.org/x/sys v0.16.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\n+golang.org/x/sys v0.17.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\n golang.org/x/sys v0.19.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\n-golang.org/x/sys v0.34.0 h1:H5Y5sJ2L2JRdyv7ROF1he/lPdvFsd0mJHFw2ThKHxLA=\n-golang.org/x/sys v0.34.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=\n+golang.org/x/sys v0.20.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\n+golang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\n+golang.org/x/sys v0.35.0 h1:vz1N37gP5bs89s7He8XuIYXpyY0+QlsKmzipCbUtyxI=\n+golang.org/x/sys v0.35.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=\n+golang.org/x/telemetry v0.0.0-20240228155512-f48c80bd79b2/go.mod h1:TeRTkGYfJXctD9OcfyVLyj2J3IxLnKwHJR8f4D8a3YE=\n golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\n golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\n golang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=\n golang.org/x/term v0.7.0/go.mod h1:P32HKFT3hSsZrRxla30E9HqToFYAQPCMs/zFMBUFqPY=\n golang.org/x/term v0.8.0/go.mod h1:xPskH00ivmX89bAKVGSKKtLOWNx2+17Eiy94tnKShWo=\n golang.org/x/term v0.11.0/go.mod h1:zC9APTIj3jG3FdV/Ons+XE1riIZXG4aZ4GTHiPZJPIU=\n+golang.org/x/term v0.12.0/go.mod h1:owVbMEjm3cBLCHdkQu9b1opXd4ETQWc3BhuQGKgXgvU=\n golang.org/x/term v0.16.0/go.mod h1:yn7UURbUtPyrVJPGPq404EukNFxcm/foM+bV/bfcDsY=\n-golang.org/x/term v0.33.0 h1:NuFncQrRcaRvVmgRkvM3j/F00gWIAlcmlB8ACEKmGIg=\n-golang.org/x/term v0.33.0/go.mod h1:s18+ql9tYWp1IfpV9DmCtQDDSRBUjKaw9M1eAv5UeF0=\n+golang.org/x/term v0.17.0/go.mod h1:lLRBjIVuehSbZlaOtGMbcMncT+aqLLLmKrsjNrUguwk=\n+golang.org/x/term v0.20.0/go.mod h1:8UkIAJTvZgivsXaD6/pH6U9ecQzZ45awqEOzuCvwpFY=\n+golang.org/x/term v0.27.0/go.mod h1:iMsnZpn0cago0GOrHO2+Y7u7JPn5AylBrcoWkElMTSM=\n+golang.org/x/term v0.34.0 h1:O/2T7POpk0ZZ7MAzMeWFSg6S5IpWd/RXDlM9hgM3DR4=\n+golang.org/x/term v0.34.0/go.mod h1:5jC53AEywhIVebHgPVeg0mj8OD3VO9OzclacVrqpaAw=\n golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\n golang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=\n golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\n@@ -695,9 +726,12 @@ golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\n golang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\n golang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=\n golang.org/x/text v0.12.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=\n+golang.org/x/text v0.13.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=\n golang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\n-golang.org/x/text v0.27.0 h1:4fGWRpyh641NLlecmyl4LOe6yDdfaYNrGb2zdfo4JV4=\n-golang.org/x/text v0.27.0/go.mod h1:1D28KMCvyooCX9hBiosv5Tz/+YLxj0j7XhWjpSUF7CU=\n+golang.org/x/text v0.15.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\n+golang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\n+golang.org/x/text v0.28.0 h1:rhazDwis8INMIwQ4tpjLDzUhx6RlXqZNPEM0huQojng=\n+golang.org/x/text v0.28.0/go.mod h1:U8nCwOR8jO/marOQ0QbDiOngZVEBB7MAiitBuMjXiNU=\n golang.org/x/time v0.12.0 h1:ScB/8o8olJvc+CQPWrK3fPZNfh7qgwCrY0zJmoEQLSE=\n golang.org/x/time v0.12.0/go.mod h1:CDIdPxbZBQxdj6cxyCIdrNogrJKMJ7pr37NYpMcMDSg=\n golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\n@@ -713,8 +747,10 @@ golang.org/x/tools v0.0.0-20210106214847-113979e3529a/go.mod h1:emZCQorbCU4vsT4f\n golang.org/x/tools v0.1.1/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\n golang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\n golang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=\n-golang.org/x/tools v0.34.0 h1:qIpSLOxeCYGg9TrcJokLBG4KFA6d795g0xkBkiESGlo=\n-golang.org/x/tools v0.34.0/go.mod h1:pAP9OwEaY1CAW3HOmg3hLZC5Z0CCmzjAF2UQMSqNARg=\n+golang.org/x/tools v0.13.0/go.mod h1:HvlwmtVNQAhOuCjW7xxvovg8wbNq7LwfXh/k7wXUl58=\n+golang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d/go.mod h1:aiJjzUbINMkxbQROHiO6hDPo2LHcIPhhQsa9DLh0yGk=\n+golang.org/x/tools v0.35.0 h1:mBffYraMEf7aa0sB+NuKnuCy8qI/9Bughn8dC2Gu5r0=\n+golang.org/x/tools v0.35.0/go.mod h1:NKdj5HkL/73byiZSJjqJgKn3ep7KjFkBOkR/Hps3VPw=\n golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ndiff --git a/management/internals/server/modules.go b/management/internals/server/modules.go\nindex 409bdaaba00..18a8427be87 100644\n--- a/management/internals/server/modules.go\n+++ b/management/internals/server/modules.go\n@@ -66,7 +66,7 @@ func (s *BaseServer) PeersManager() peers.Manager {\n \n func (s *BaseServer) AccountManager() account.Manager {\n \treturn Create(s, func() account.Manager {\n-\t\taccountManager, err := server.BuildManager(context.Background(), s.Store(), s.NetworkMapController(), s.IdpManager(), s.mgmtSingleAccModeDomain, s.EventStore(), s.GeoLocationManager(), s.userDeleteFromIDPEnabled, s.IntegratedValidator(), s.Metrics(), s.ProxyController(), s.SettingsManager(), s.PermissionsManager(), s.config.DisableDefaultPolicy)\n+\t\taccountManager, err := server.BuildManager(context.Background(), s.config, s.Store(), s.NetworkMapController(), s.IdpManager(), s.mgmtSingleAccModeDomain, s.EventStore(), s.GeoLocationManager(), s.userDeleteFromIDPEnabled, s.IntegratedValidator(), s.Metrics(), s.ProxyController(), s.SettingsManager(), s.PermissionsManager(), s.config.DisableDefaultPolicy)\n \t\tif err != nil {\n \t\t\tlog.Fatalf(\"failed to create account manager: %v\", err)\n \t\t}\ndiff --git a/management/internals/shared/grpc/conversion.go b/management/internals/shared/grpc/conversion.go\nindex 9a4681eae7b..7f64034dfa8 100644\n--- a/management/internals/shared/grpc/conversion.go\n+++ b/management/internals/shared/grpc/conversion.go\n@@ -3,6 +3,8 @@ package grpc\n import (\n \t\"context\"\n \t\"fmt\"\n+\t\"net/url\"\n+\t\"strings\"\n \n \tintegrationsConfig \"github.com/netbirdio/management-integrations/integrations/config\"\n \tnbdns \"github.com/netbirdio/netbird/dns\"\n@@ -81,12 +83,21 @@ func toNetbirdConfig(config *nbconfig.Config, turnCredentials *Token, relayToken\n \treturn nbConfig\n }\n \n-func toPeerConfig(peer *nbpeer.Peer, network *types.Network, dnsName string, settings *types.Settings) *proto.PeerConfig {\n+func toPeerConfig(peer *nbpeer.Peer, network *types.Network, dnsName string, settings *types.Settings, config *nbconfig.Config) *proto.PeerConfig {\n \tnetmask, _ := network.Net.Mask.Size()\n \tfqdn := peer.FQDN(dnsName)\n+\n+\tsshConfig := &proto.SSHConfig{\n+\t\tSshEnabled: peer.SSHEnabled,\n+\t}\n+\n+\tif peer.SSHEnabled {\n+\t\tsshConfig.JwtConfig = buildJWTConfig(config)\n+\t}\n+\n \treturn &proto.PeerConfig{\n-\t\tAddress:                         fmt.Sprintf(\"%s/%d\", peer.IP.String(), netmask), // take it from the network\n-\t\tSshConfig:                       &proto.SSHConfig{SshEnabled: peer.SSHEnabled},\n+\t\tAddress:                         fmt.Sprintf(\"%s/%d\", peer.IP.String(), netmask),\n+\t\tSshConfig:                       sshConfig,\n \t\tFqdn:                            fqdn,\n \t\tRoutingPeerDnsResolutionEnabled: settings.RoutingPeerDNSResolutionEnabled,\n \t\tLazyConnectionEnabled:           settings.LazyConnectionEnabled,\n@@ -95,7 +106,7 @@ func toPeerConfig(peer *nbpeer.Peer, network *types.Network, dnsName string, set\n \n func ToSyncResponse(ctx context.Context, config *nbconfig.Config, peer *nbpeer.Peer, turnCredentials *Token, relayCredentials *Token, networkMap *types.NetworkMap, dnsName string, checks []*posture.Checks, dnsCache *cache.DNSConfigCache, settings *types.Settings, extraSettings *types.ExtraSettings, peerGroups []string, dnsFwdPort int64) *proto.SyncResponse {\n \tresponse := &proto.SyncResponse{\n-\t\tPeerConfig: toPeerConfig(peer, networkMap.Network, dnsName, settings),\n+\t\tPeerConfig: toPeerConfig(peer, networkMap.Network, dnsName, settings, config),\n \t\tNetworkMap: &proto.NetworkMap{\n \t\t\tSerial:    networkMap.Network.CurrentSerial(),\n \t\t\tRoutes:    toProtocolRoutes(networkMap.Routes),\n@@ -350,3 +361,51 @@ func convertToProtoNameServerGroup(nsGroup *nbdns.NameServerGroup) *proto.NameSe\n \t}\n \treturn protoGroup\n }\n+\n+// buildJWTConfig constructs JWT configuration for SSH servers from management server config\n+func buildJWTConfig(config *nbconfig.Config) *proto.JWTConfig {\n+\tif config == nil {\n+\t\treturn nil\n+\t}\n+\n+\tif config.HttpConfig == nil || config.HttpConfig.AuthAudience == \"\" {\n+\t\treturn nil\n+\t}\n+\n+\tissuer := strings.TrimSpace(config.HttpConfig.AuthIssuer)\n+\tif issuer == \"\" {\n+\t\tif config.DeviceAuthorizationFlow != nil {\n+\t\t\tif d := deriveIssuerFromTokenEndpoint(config.DeviceAuthorizationFlow.ProviderConfig.TokenEndpoint); d != \"\" {\n+\t\t\t\tissuer = d\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif issuer == \"\" {\n+\t\treturn nil\n+\t}\n+\n+\tkeysLocation := strings.TrimSpace(config.HttpConfig.AuthKeysLocation)\n+\tif keysLocation == \"\" {\n+\t\tkeysLocation = strings.TrimSuffix(issuer, \"/\") + \"/.well-known/jwks.json\"\n+\t}\n+\n+\treturn &proto.JWTConfig{\n+\t\tIssuer:       issuer,\n+\t\tAudience:     config.HttpConfig.AuthAudience,\n+\t\tKeysLocation: keysLocation,\n+\t}\n+}\n+\n+// deriveIssuerFromTokenEndpoint extracts the issuer URL from a token endpoint\n+func deriveIssuerFromTokenEndpoint(tokenEndpoint string) string {\n+\tif tokenEndpoint == \"\" {\n+\t\treturn \"\"\n+\t}\n+\n+\tu, err := url.Parse(tokenEndpoint)\n+\tif err != nil {\n+\t\treturn \"\"\n+\t}\n+\n+\treturn fmt.Sprintf(\"%s://%s/\", u.Scheme, u.Host)\n+}\ndiff --git a/management/internals/shared/grpc/server.go b/management/internals/shared/grpc/server.go\nindex 08a840316d9..4364272a080 100644\n--- a/management/internals/shared/grpc/server.go\n+++ b/management/internals/shared/grpc/server.go\n@@ -646,7 +646,7 @@ func (s *Server) prepareLoginResponse(ctx context.Context, peer *nbpeer.Peer, ne\n \t// if peer has reached this point then it has logged in\n \tloginResp := &proto.LoginResponse{\n \t\tNetbirdConfig: toNetbirdConfig(s.config, nil, relayToken, nil),\n-\t\tPeerConfig:    toPeerConfig(peer, netMap.Network, s.networkMapController.GetDNSDomain(settings), settings),\n+\t\tPeerConfig:    toPeerConfig(peer, netMap.Network, s.networkMapController.GetDNSDomain(settings), settings, s.config),\n \t\tChecks:        toProtocolChecks(ctx, postureChecks),\n \t}\n \ndiff --git a/management/server/account.go b/management/server/account.go\nindex a4b2a752b9a..3e498536ce5 100644\n--- a/management/server/account.go\n+++ b/management/server/account.go\n@@ -15,6 +15,8 @@ import (\n \t\"sync\"\n \t\"time\"\n \n+\t\"github.com/netbirdio/netbird/shared/auth\"\n+\n \tcacheStore \"github.com/eko/gocache/lib/v4/store\"\n \t\"github.com/eko/gocache/store/redis/v4\"\n \t\"github.com/rs/xid\"\n@@ -25,6 +27,7 @@ import (\n \tnbdns \"github.com/netbirdio/netbird/dns\"\n \t\"github.com/netbirdio/netbird/formatter/hook\"\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map\"\n+\tnbconfig \"github.com/netbirdio/netbird/management/internals/server/config\"\n \t\"github.com/netbirdio/netbird/management/server/account\"\n \t\"github.com/netbirdio/netbird/management/server/activity\"\n \tnbcache \"github.com/netbirdio/netbird/management/server/cache\"\n@@ -81,6 +84,9 @@ type DefaultAccountManager struct {\n \tproxyController port_forwarding.Controller\n \tsettingsManager settings.Manager\n \n+\t// config contains the management server configuration\n+\tconfig *nbconfig.Config\n+\n \t// singleAccountMode indicates whether the instance has a single account.\n \t// If true, then every new user will end up under the same account.\n \t// This value will be set to false if management service has more than one account.\n@@ -171,6 +177,7 @@ func (am *DefaultAccountManager) getJWTGroupsChanges(user *types.User, groups []\n // BuildManager creates a new DefaultAccountManager with a provided Store\n func BuildManager(\n \tctx context.Context,\n+\tconfig *nbconfig.Config,\n \tstore store.Store,\n \tnetworkMapController network_map.Controller,\n \tidpManager idp.Manager,\n@@ -192,6 +199,7 @@ func BuildManager(\n \n \tam := &DefaultAccountManager{\n \t\tStore:                    store,\n+\t\tconfig:                   config,\n \t\tgeo:                      geo,\n \t\tnetworkMapController:     networkMapController,\n \t\tidpManager:               idpManager,\n@@ -1006,7 +1014,7 @@ func (am *DefaultAccountManager) removeUserFromCache(ctx context.Context, accoun\n }\n \n // updateAccountDomainAttributesIfNotUpToDate updates the account domain attributes if they are not up to date and then, saves the account changes\n-func (am *DefaultAccountManager) updateAccountDomainAttributesIfNotUpToDate(ctx context.Context, accountID string, userAuth nbcontext.UserAuth,\n+func (am *DefaultAccountManager) updateAccountDomainAttributesIfNotUpToDate(ctx context.Context, accountID string, userAuth auth.UserAuth,\n \tprimaryDomain bool,\n ) error {\n \tif userAuth.Domain == \"\" {\n@@ -1055,7 +1063,7 @@ func (am *DefaultAccountManager) handleExistingUserAccount(\n \tctx context.Context,\n \tuserAccountID string,\n \tdomainAccountID string,\n-\tuserAuth nbcontext.UserAuth,\n+\tuserAuth auth.UserAuth,\n ) error {\n \tprimaryDomain := domainAccountID == \"\" || userAccountID == domainAccountID\n \terr := am.updateAccountDomainAttributesIfNotUpToDate(ctx, userAccountID, userAuth, primaryDomain)\n@@ -1074,7 +1082,7 @@ func (am *DefaultAccountManager) handleExistingUserAccount(\n \n // addNewPrivateAccount validates if there is an existing primary account for the domain, if so it adds the new user to that account,\n // otherwise it will create a new account and make it primary account for the domain.\n-func (am *DefaultAccountManager) addNewPrivateAccount(ctx context.Context, domainAccountID string, userAuth nbcontext.UserAuth) (string, error) {\n+func (am *DefaultAccountManager) addNewPrivateAccount(ctx context.Context, domainAccountID string, userAuth auth.UserAuth) (string, error) {\n \tif userAuth.UserId == \"\" {\n \t\treturn \"\", fmt.Errorf(\"user ID is empty\")\n \t}\n@@ -1105,7 +1113,7 @@ func (am *DefaultAccountManager) addNewPrivateAccount(ctx context.Context, domai\n \treturn newAccount.Id, nil\n }\n \n-func (am *DefaultAccountManager) addNewUserToDomainAccount(ctx context.Context, domainAccountID string, userAuth nbcontext.UserAuth) (string, error) {\n+func (am *DefaultAccountManager) addNewUserToDomainAccount(ctx context.Context, domainAccountID string, userAuth auth.UserAuth) (string, error) {\n \tnewUser := types.NewRegularUser(userAuth.UserId)\n \tnewUser.AccountID = domainAccountID\n \n@@ -1217,7 +1225,7 @@ func (am *DefaultAccountManager) GetAccountOnboarding(ctx context.Context, accou\n \n \tonboarding, err := am.Store.GetAccountOnboarding(ctx, accountID)\n \tif err != nil && err.Error() != status.NewAccountOnboardingNotFoundError(accountID).Error() {\n-\t\tlog.Errorf(\"failed to get account onboarding for accountssssssss %s: %v\", accountID, err)\n+\t\tlog.Errorf(\"failed to get account onboarding for account %s: %v\", accountID, err)\n \t\treturn nil, err\n \t}\n \n@@ -1269,7 +1277,7 @@ func (am *DefaultAccountManager) UpdateAccountOnboarding(ctx context.Context, ac\n \treturn newOnboarding, nil\n }\n \n-func (am *DefaultAccountManager) GetAccountIDFromUserAuth(ctx context.Context, userAuth nbcontext.UserAuth) (string, string, error) {\n+func (am *DefaultAccountManager) GetAccountIDFromUserAuth(ctx context.Context, userAuth auth.UserAuth) (string, string, error) {\n \tif userAuth.UserId == \"\" {\n \t\treturn \"\", \"\", errors.New(emptyUserID)\n \t}\n@@ -1313,7 +1321,7 @@ func (am *DefaultAccountManager) GetAccountIDFromUserAuth(ctx context.Context, u\n // syncJWTGroups processes the JWT groups for a user, updates the account based on the groups,\n // and propagates changes to peers if group propagation is enabled.\n // requires userAuth to have been ValidateAndParseToken and EnsureUserAccessByJWTGroups by the AuthManager\n-func (am *DefaultAccountManager) SyncUserJWTGroups(ctx context.Context, userAuth nbcontext.UserAuth) error {\n+func (am *DefaultAccountManager) SyncUserJWTGroups(ctx context.Context, userAuth auth.UserAuth) error {\n \tif userAuth.IsChild || userAuth.IsPAT {\n \t\treturn nil\n \t}\n@@ -1471,7 +1479,7 @@ func (am *DefaultAccountManager) SyncUserJWTGroups(ctx context.Context, userAuth\n // Existing user + Existing account + Existing domain reclassified Domain as private -> Nothing changes (index domain)\n //\n // UserAuth IsChild -> checks that account exists\n-func (am *DefaultAccountManager) getAccountIDWithAuthorizationClaims(ctx context.Context, userAuth nbcontext.UserAuth) (string, error) {\n+func (am *DefaultAccountManager) getAccountIDWithAuthorizationClaims(ctx context.Context, userAuth auth.UserAuth) (string, error) {\n \tlog.WithContext(ctx).Tracef(\"getting account with authorization claims. User ID: \\\"%s\\\", Account ID: \\\"%s\\\", Domain: \\\"%s\\\", Domain Category: \\\"%s\\\"\",\n \t\tuserAuth.UserId, userAuth.AccountId, userAuth.Domain, userAuth.DomainCategory)\n \n@@ -1550,7 +1558,7 @@ func (am *DefaultAccountManager) getPrivateDomainWithGlobalLock(ctx context.Cont\n \treturn domainAccountID, cancel, nil\n }\n \n-func (am *DefaultAccountManager) handlePrivateAccountWithIDFromClaim(ctx context.Context, userAuth nbcontext.UserAuth) (string, error) {\n+func (am *DefaultAccountManager) handlePrivateAccountWithIDFromClaim(ctx context.Context, userAuth auth.UserAuth) (string, error) {\n \tuserAccountID, err := am.Store.GetAccountIDByUserID(ctx, store.LockingStrengthNone, userAuth.UserId)\n \tif err != nil {\n \t\tlog.WithContext(ctx).Errorf(\"error getting account ID by user ID: %v\", err)\n@@ -1598,7 +1606,7 @@ func handleNotFound(err error) error {\n \treturn nil\n }\n \n-func domainIsUpToDate(domain string, domainCategory string, userAuth nbcontext.UserAuth) bool {\n+func domainIsUpToDate(domain string, domainCategory string, userAuth auth.UserAuth) bool {\n \treturn domainCategory == types.PrivateCategory || userAuth.DomainCategory != types.PrivateCategory || domain != userAuth.Domain\n }\n \ndiff --git a/management/server/account/manager.go b/management/server/account/manager.go\nindex 7c174a48195..9b3902d87d2 100644\n--- a/management/server/account/manager.go\n+++ b/management/server/account/manager.go\n@@ -6,10 +6,11 @@ import (\n \t\"net/netip\"\n \t\"time\"\n \n+\t\"github.com/netbirdio/netbird/shared/auth\"\n+\n \tnbdns \"github.com/netbirdio/netbird/dns\"\n \t\"github.com/netbirdio/netbird/management/server/activity\"\n \tnbcache \"github.com/netbirdio/netbird/management/server/cache\"\n-\tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/idp\"\n \tnbpeer \"github.com/netbirdio/netbird/management/server/peer\"\n \t\"github.com/netbirdio/netbird/management/server/peers/ephemeral\"\n@@ -45,10 +46,10 @@ type Manager interface {\n \tGetAccountOnboarding(ctx context.Context, accountID string, userID string) (*types.AccountOnboarding, error)\n \tAccountExists(ctx context.Context, accountID string) (bool, error)\n \tGetAccountIDByUserID(ctx context.Context, userID, domain string) (string, error)\n-\tGetAccountIDFromUserAuth(ctx context.Context, userAuth nbcontext.UserAuth) (string, string, error)\n+\tGetAccountIDFromUserAuth(ctx context.Context, userAuth auth.UserAuth) (string, string, error)\n \tDeleteAccount(ctx context.Context, accountID, userID string) error\n \tGetUserByID(ctx context.Context, id string) (*types.User, error)\n-\tGetUserFromUserAuth(ctx context.Context, userAuth nbcontext.UserAuth) (*types.User, error)\n+\tGetUserFromUserAuth(ctx context.Context, userAuth auth.UserAuth) (*types.User, error)\n \tListUsers(ctx context.Context, accountID string) ([]*types.User, error)\n \tGetPeers(ctx context.Context, accountID, userID, nameFilter, ipFilter string) ([]*nbpeer.Peer, error)\n \tMarkPeerConnected(ctx context.Context, peerKey string, connected bool, realIP net.IP, accountID string) error\n@@ -117,11 +118,11 @@ type Manager interface {\n \tUpdateAccountPeers(ctx context.Context, accountID string)\n \tBufferUpdateAccountPeers(ctx context.Context, accountID string)\n \tBuildUserInfosForAccount(ctx context.Context, accountID, initiatorUserID string, accountUsers []*types.User) (map[string]*types.UserInfo, error)\n-\tSyncUserJWTGroups(ctx context.Context, userAuth nbcontext.UserAuth) error\n+\tSyncUserJWTGroups(ctx context.Context, userAuth auth.UserAuth) error\n \tGetStore() store.Store\n \tGetOrCreateAccountByPrivateDomain(ctx context.Context, initiatorId, domain string) (*types.Account, bool, error)\n \tUpdateToPrimaryAccount(ctx context.Context, accountId string) error\n \tGetOwnerInfo(ctx context.Context, accountId string) (*types.UserInfo, error)\n-\tGetCurrentUserInfo(ctx context.Context, userAuth nbcontext.UserAuth) (*users.UserInfoWithPermissions, error)\n+\tGetCurrentUserInfo(ctx context.Context, userAuth auth.UserAuth) (*users.UserInfoWithPermissions, error)\n \tSetEphemeralManager(em ephemeral.Manager)\n }\ndiff --git a/management/server/auth/manager.go b/management/server/auth/manager.go\nindex ece9dc32110..0c62357dcc0 100644\n--- a/management/server/auth/manager.go\n+++ b/management/server/auth/manager.go\n@@ -9,18 +9,19 @@ import (\n \n \t\"github.com/golang-jwt/jwt/v5\"\n \n+\t\"github.com/netbirdio/netbird/shared/auth\"\n+\n \t\"github.com/netbirdio/netbird/base62\"\n-\tnbjwt \"github.com/netbirdio/netbird/management/server/auth/jwt\"\n-\tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/store\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n+\tnbjwt \"github.com/netbirdio/netbird/shared/auth/jwt\"\n )\n \n var _ Manager = (*manager)(nil)\n \n type Manager interface {\n-\tValidateAndParseToken(ctx context.Context, value string) (nbcontext.UserAuth, *jwt.Token, error)\n-\tEnsureUserAccessByJWTGroups(ctx context.Context, userAuth nbcontext.UserAuth, token *jwt.Token) (nbcontext.UserAuth, error)\n+\tValidateAndParseToken(ctx context.Context, value string) (auth.UserAuth, *jwt.Token, error)\n+\tEnsureUserAccessByJWTGroups(ctx context.Context, userAuth auth.UserAuth, token *jwt.Token) (auth.UserAuth, error)\n \tMarkPATUsed(ctx context.Context, tokenID string) error\n \tGetPATInfo(ctx context.Context, token string) (user *types.User, pat *types.PersonalAccessToken, domain string, category string, err error)\n }\n@@ -55,20 +56,20 @@ func NewManager(store store.Store, issuer, audience, keysLocation, userIdClaim s\n \t}\n }\n \n-func (m *manager) ValidateAndParseToken(ctx context.Context, value string) (nbcontext.UserAuth, *jwt.Token, error) {\n+func (m *manager) ValidateAndParseToken(ctx context.Context, value string) (auth.UserAuth, *jwt.Token, error) {\n \ttoken, err := m.validator.ValidateAndParse(ctx, value)\n \tif err != nil {\n-\t\treturn nbcontext.UserAuth{}, nil, err\n+\t\treturn auth.UserAuth{}, nil, err\n \t}\n \n \tuserAuth, err := m.extractor.ToUserAuth(token)\n \tif err != nil {\n-\t\treturn nbcontext.UserAuth{}, nil, err\n+\t\treturn auth.UserAuth{}, nil, err\n \t}\n \treturn userAuth, token, err\n }\n \n-func (m *manager) EnsureUserAccessByJWTGroups(ctx context.Context, userAuth nbcontext.UserAuth, token *jwt.Token) (nbcontext.UserAuth, error) {\n+func (m *manager) EnsureUserAccessByJWTGroups(ctx context.Context, userAuth auth.UserAuth, token *jwt.Token) (auth.UserAuth, error) {\n \tif userAuth.IsChild || userAuth.IsPAT {\n \t\treturn userAuth, nil\n \t}\ndiff --git a/management/server/auth/manager_mock.go b/management/server/auth/manager_mock.go\nindex 30a7a716190..edf158a4978 100644\n--- a/management/server/auth/manager_mock.go\n+++ b/management/server/auth/manager_mock.go\n@@ -3,9 +3,10 @@ package auth\n import (\n \t\"context\"\n \n+\t\"github.com/netbirdio/netbird/shared/auth\"\n+\n \t\"github.com/golang-jwt/jwt/v5\"\n \n-\tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n )\n \n@@ -15,18 +16,18 @@ var (\n \n // @note really dislike this mocking approach but rather than have to do additional test refactoring.\n type MockManager struct {\n-\tValidateAndParseTokenFunc       func(ctx context.Context, value string) (nbcontext.UserAuth, *jwt.Token, error)\n-\tEnsureUserAccessByJWTGroupsFunc func(ctx context.Context, userAuth nbcontext.UserAuth, token *jwt.Token) (nbcontext.UserAuth, error)\n+\tValidateAndParseTokenFunc       func(ctx context.Context, value string) (auth.UserAuth, *jwt.Token, error)\n+\tEnsureUserAccessByJWTGroupsFunc func(ctx context.Context, userAuth auth.UserAuth, token *jwt.Token) (auth.UserAuth, error)\n \tMarkPATUsedFunc                 func(ctx context.Context, tokenID string) error\n \tGetPATInfoFunc                  func(ctx context.Context, token string) (user *types.User, pat *types.PersonalAccessToken, domain string, category string, err error)\n }\n \n // EnsureUserAccessByJWTGroups implements Manager.\n-func (m *MockManager) EnsureUserAccessByJWTGroups(ctx context.Context, userAuth nbcontext.UserAuth, token *jwt.Token) (nbcontext.UserAuth, error) {\n+func (m *MockManager) EnsureUserAccessByJWTGroups(ctx context.Context, userAuth auth.UserAuth, token *jwt.Token) (auth.UserAuth, error) {\n \tif m.EnsureUserAccessByJWTGroupsFunc != nil {\n \t\treturn m.EnsureUserAccessByJWTGroupsFunc(ctx, userAuth, token)\n \t}\n-\treturn nbcontext.UserAuth{}, nil\n+\treturn auth.UserAuth{}, nil\n }\n \n // GetPATInfo implements Manager.\n@@ -46,9 +47,9 @@ func (m *MockManager) MarkPATUsed(ctx context.Context, tokenID string) error {\n }\n \n // ValidateAndParseToken implements Manager.\n-func (m *MockManager) ValidateAndParseToken(ctx context.Context, value string) (nbcontext.UserAuth, *jwt.Token, error) {\n+func (m *MockManager) ValidateAndParseToken(ctx context.Context, value string) (auth.UserAuth, *jwt.Token, error) {\n \tif m.ValidateAndParseTokenFunc != nil {\n \t\treturn m.ValidateAndParseTokenFunc(ctx, value)\n \t}\n-\treturn nbcontext.UserAuth{}, &jwt.Token{}, nil\n+\treturn auth.UserAuth{}, &jwt.Token{}, nil\n }\ndiff --git a/management/server/context/auth.go b/management/server/context/auth.go\nindex 5cb28ddb7cb..cc59b8a63d0 100644\n--- a/management/server/context/auth.go\n+++ b/management/server/context/auth.go\n@@ -4,7 +4,8 @@ import (\n \t\"context\"\n \t\"fmt\"\n \t\"net/http\"\n-\t\"time\"\n+\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n )\n \n type key int\n@@ -13,45 +14,22 @@ const (\n \tUserAuthContextKey key = iota\n )\n \n-type UserAuth struct {\n-\t// The account id the user is accessing\n-\tAccountId string\n-\t// The account domain\n-\tDomain string\n-\t// The account domain category, TBC values\n-\tDomainCategory string\n-\t// Indicates whether this user was invited, TBC logic\n-\tInvited bool\n-\t// Indicates whether this is a child account\n-\tIsChild bool\n-\n-\t// The user id\n-\tUserId string\n-\t// Last login time for this user\n-\tLastLogin time.Time\n-\t// The Groups the user belongs to on this account\n-\tGroups []string\n-\n-\t// Indicates whether this user has authenticated with a Personal Access Token\n-\tIsPAT bool\n-}\n-\n-func GetUserAuthFromRequest(r *http.Request) (UserAuth, error) {\n+func GetUserAuthFromRequest(r *http.Request) (auth.UserAuth, error) {\n \treturn GetUserAuthFromContext(r.Context())\n }\n \n-func SetUserAuthInRequest(r *http.Request, userAuth UserAuth) *http.Request {\n+func SetUserAuthInRequest(r *http.Request, userAuth auth.UserAuth) *http.Request {\n \treturn r.WithContext(SetUserAuthInContext(r.Context(), userAuth))\n }\n \n-func GetUserAuthFromContext(ctx context.Context) (UserAuth, error) {\n-\tif userAuth, ok := ctx.Value(UserAuthContextKey).(UserAuth); ok {\n+func GetUserAuthFromContext(ctx context.Context) (auth.UserAuth, error) {\n+\tif userAuth, ok := ctx.Value(UserAuthContextKey).(auth.UserAuth); ok {\n \t\treturn userAuth, nil\n \t}\n-\treturn UserAuth{}, fmt.Errorf(\"user auth not in context\")\n+\treturn auth.UserAuth{}, fmt.Errorf(\"user auth not in context\")\n }\n \n-func SetUserAuthInContext(ctx context.Context, userAuth UserAuth) context.Context {\n+func SetUserAuthInContext(ctx context.Context, userAuth auth.UserAuth) context.Context {\n \t//nolint\n \tctx = context.WithValue(ctx, UserIDKey, userAuth.UserId)\n \t//nolint\ndiff --git a/management/server/http/handlers/dns/dns_settings_handler.go b/management/server/http/handlers/dns/dns_settings_handler.go\nindex 08a0b2afd2d..67638aea5ad 100644\n--- a/management/server/http/handlers/dns/dns_settings_handler.go\n+++ b/management/server/http/handlers/dns/dns_settings_handler.go\n@@ -9,9 +9,9 @@ import (\n \n \t\"github.com/netbirdio/netbird/management/server/account\"\n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n+\t\"github.com/netbirdio/netbird/management/server/types\"\n \t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/shared/management/http/util\"\n-\t\"github.com/netbirdio/netbird/management/server/types\"\n )\n \n // dnsSettingsHandler is a handler that returns the DNS settings of the account\ndiff --git a/management/server/http/handlers/groups/groups_handler.go b/management/server/http/handlers/groups/groups_handler.go\nindex e861e873c1e..208a2e8288f 100644\n--- a/management/server/http/handlers/groups/groups_handler.go\n+++ b/management/server/http/handlers/groups/groups_handler.go\n@@ -11,10 +11,10 @@ import (\n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \tnbpeer \"github.com/netbirdio/netbird/management/server/peer\"\n \n+\t\"github.com/netbirdio/netbird/management/server/types\"\n \t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/shared/management/http/util\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n-\t\"github.com/netbirdio/netbird/management/server/types\"\n )\n \n // handler is a handler that returns groups of the account\ndiff --git a/management/server/http/handlers/networks/handler.go b/management/server/http/handlers/networks/handler.go\nindex d7b598a5d7b..f99eca7941f 100644\n--- a/management/server/http/handlers/networks/handler.go\n+++ b/management/server/http/handlers/networks/handler.go\n@@ -12,15 +12,15 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/account\"\n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/groups\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/util\"\n \t\"github.com/netbirdio/netbird/management/server/networks\"\n \t\"github.com/netbirdio/netbird/management/server/networks/resources\"\n \t\"github.com/netbirdio/netbird/management/server/networks/routers\"\n \trouterTypes \"github.com/netbirdio/netbird/management/server/networks/routers/types\"\n \t\"github.com/netbirdio/netbird/management/server/networks/types\"\n-\t\"github.com/netbirdio/netbird/shared/management/status\"\n \tnbtypes \"github.com/netbirdio/netbird/management/server/types\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/util\"\n+\t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n \n // handler is a handler that returns networks of the account\ndiff --git a/management/server/http/handlers/networks/resources_handler.go b/management/server/http/handlers/networks/resources_handler.go\nindex 59396dcebb6..c31729a39c7 100644\n--- a/management/server/http/handlers/networks/resources_handler.go\n+++ b/management/server/http/handlers/networks/resources_handler.go\n@@ -8,10 +8,10 @@ import (\n \n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/groups\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/util\"\n \t\"github.com/netbirdio/netbird/management/server/networks/resources\"\n \t\"github.com/netbirdio/netbird/management/server/networks/resources/types\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/util\"\n )\n \n type resourceHandler struct {\ndiff --git a/management/server/http/handlers/networks/routers_handler.go b/management/server/http/handlers/networks/routers_handler.go\nindex 2e64c637ff5..c311a29feb4 100644\n--- a/management/server/http/handlers/networks/routers_handler.go\n+++ b/management/server/http/handlers/networks/routers_handler.go\n@@ -7,10 +7,10 @@ import (\n \t\"github.com/gorilla/mux\"\n \n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/util\"\n \t\"github.com/netbirdio/netbird/management/server/networks/routers\"\n \t\"github.com/netbirdio/netbird/management/server/networks/routers/types\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/util\"\n )\n \n type routersHandler struct {\ndiff --git a/management/server/http/handlers/policies/geolocations_handler.go b/management/server/http/handlers/policies/geolocations_handler.go\nindex cb699579305..a2d656a4716 100644\n--- a/management/server/http/handlers/policies/geolocations_handler.go\n+++ b/management/server/http/handlers/policies/geolocations_handler.go\n@@ -9,11 +9,11 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/account\"\n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/geolocation\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/util\"\n \t\"github.com/netbirdio/netbird/management/server/permissions\"\n \t\"github.com/netbirdio/netbird/management/server/permissions/modules\"\n \t\"github.com/netbirdio/netbird/management/server/permissions/operations\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/util\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n \ndiff --git a/management/server/http/handlers/policies/policies_handler.go b/management/server/http/handlers/policies/policies_handler.go\nindex 4d6bad5e390..ab1639ab146 100644\n--- a/management/server/http/handlers/policies/policies_handler.go\n+++ b/management/server/http/handlers/policies/policies_handler.go\n@@ -10,10 +10,10 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/account\"\n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/geolocation\"\n+\t\"github.com/netbirdio/netbird/management/server/types\"\n \t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/shared/management/http/util\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n-\t\"github.com/netbirdio/netbird/management/server/types\"\n )\n \n // handler is a handler that returns policy of the account\ndiff --git a/management/server/http/handlers/policies/posture_checks_handler.go b/management/server/http/handlers/policies/posture_checks_handler.go\nindex 3ebc4d1e105..744cde10b0e 100644\n--- a/management/server/http/handlers/policies/posture_checks_handler.go\n+++ b/management/server/http/handlers/policies/posture_checks_handler.go\n@@ -9,9 +9,9 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/account\"\n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/geolocation\"\n+\t\"github.com/netbirdio/netbird/management/server/posture\"\n \t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/shared/management/http/util\"\n-\t\"github.com/netbirdio/netbird/management/server/posture\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n \ndiff --git a/management/server/http/handlers/setup_keys/setupkeys_handler.go b/management/server/http/handlers/setup_keys/setupkeys_handler.go\nindex 2287dadfe22..d267b6eea2a 100644\n--- a/management/server/http/handlers/setup_keys/setupkeys_handler.go\n+++ b/management/server/http/handlers/setup_keys/setupkeys_handler.go\n@@ -10,10 +10,10 @@ import (\n \n \t\"github.com/netbirdio/netbird/management/server/account\"\n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n+\t\"github.com/netbirdio/netbird/management/server/types\"\n \t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/shared/management/http/util\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n-\t\"github.com/netbirdio/netbird/management/server/types\"\n )\n \n // handler is a handler that returns a list of setup keys of the account\ndiff --git a/management/server/http/handlers/users/pat_handler.go b/management/server/http/handlers/users/pat_handler.go\nindex bae07af4a58..867db3ca9f7 100644\n--- a/management/server/http/handlers/users/pat_handler.go\n+++ b/management/server/http/handlers/users/pat_handler.go\n@@ -8,10 +8,10 @@ import (\n \n \t\"github.com/netbirdio/netbird/management/server/account\"\n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n+\t\"github.com/netbirdio/netbird/management/server/types\"\n \t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/shared/management/http/util\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n-\t\"github.com/netbirdio/netbird/management/server/types\"\n )\n \n // patHandler is the nameserver group handler of the account\ndiff --git a/management/server/http/middleware/auth_middleware.go b/management/server/http/middleware/auth_middleware.go\nindex bce917a2552..9439165a46f 100644\n--- a/management/server/http/middleware/auth_middleware.go\n+++ b/management/server/http/middleware/auth_middleware.go\n@@ -10,22 +10,23 @@ import (\n \n \tlog \"github.com/sirupsen/logrus\"\n \n-\t\"github.com/netbirdio/netbird/management/server/auth\"\n+\tserverauth \"github.com/netbirdio/netbird/management/server/auth\"\n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/http/middleware/bypass\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n \t\"github.com/netbirdio/netbird/shared/management/http/util\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n \n-type EnsureAccountFunc func(ctx context.Context, userAuth nbcontext.UserAuth) (string, string, error)\n-type SyncUserJWTGroupsFunc func(ctx context.Context, userAuth nbcontext.UserAuth) error\n+type EnsureAccountFunc func(ctx context.Context, userAuth auth.UserAuth) (string, string, error)\n+type SyncUserJWTGroupsFunc func(ctx context.Context, userAuth auth.UserAuth) error\n \n-type GetUserFromUserAuthFunc func(ctx context.Context, userAuth nbcontext.UserAuth) (*types.User, error)\n+type GetUserFromUserAuthFunc func(ctx context.Context, userAuth auth.UserAuth) (*types.User, error)\n \n // AuthMiddleware middleware to verify personal access tokens (PAT) and JWT tokens\n type AuthMiddleware struct {\n-\tauthManager         auth.Manager\n+\tauthManager         serverauth.Manager\n \tensureAccount       EnsureAccountFunc\n \tgetUserFromUserAuth GetUserFromUserAuthFunc\n \tsyncUserJWTGroups   SyncUserJWTGroupsFunc\n@@ -34,7 +35,7 @@ type AuthMiddleware struct {\n \n // NewAuthMiddleware instance constructor\n func NewAuthMiddleware(\n-\tauthManager auth.Manager,\n+\tauthManager serverauth.Manager,\n \tensureAccount EnsureAccountFunc,\n \tsyncUserJWTGroups SyncUserJWTGroupsFunc,\n \tgetUserFromUserAuth GetUserFromUserAuthFunc,\n@@ -61,18 +62,18 @@ func (m *AuthMiddleware) Handler(h http.Handler) http.Handler {\n \t\t\treturn\n \t\t}\n \n-\t\tauth := strings.Split(r.Header.Get(\"Authorization\"), \" \")\n-\t\tauthType := strings.ToLower(auth[0])\n+\t\tauthHeader := strings.Split(r.Header.Get(\"Authorization\"), \" \")\n+\t\tauthType := strings.ToLower(authHeader[0])\n \n \t\t// fallback to token when receive pat as bearer\n-\t\tif len(auth) >= 2 && authType == \"bearer\" && strings.HasPrefix(auth[1], \"nbp_\") {\n+\t\tif len(authHeader) >= 2 && authType == \"bearer\" && strings.HasPrefix(authHeader[1], \"nbp_\") {\n \t\t\tauthType = \"token\"\n-\t\t\tauth[0] = authType\n+\t\t\tauthHeader[0] = authType\n \t\t}\n \n \t\tswitch authType {\n \t\tcase \"bearer\":\n-\t\t\trequest, err := m.checkJWTFromRequest(r, auth)\n+\t\t\trequest, err := m.checkJWTFromRequest(r, authHeader)\n \t\t\tif err != nil {\n \t\t\t\tlog.WithContext(r.Context()).Errorf(\"Error when validating JWT: %s\", err.Error())\n \t\t\t\tutil.WriteError(r.Context(), status.Errorf(status.Unauthorized, \"token invalid\"), w)\n@@ -81,7 +82,7 @@ func (m *AuthMiddleware) Handler(h http.Handler) http.Handler {\n \n \t\t\th.ServeHTTP(w, request)\n \t\tcase \"token\":\n-\t\t\trequest, err := m.checkPATFromRequest(r, auth)\n+\t\t\trequest, err := m.checkPATFromRequest(r, authHeader)\n \t\t\tif err != nil {\n \t\t\t\tlog.WithContext(r.Context()).Debugf(\"Error when validating PAT: %s\", err.Error())\n \t\t\t\t// Check if it's a status error, otherwise default to Unauthorized\n@@ -100,8 +101,8 @@ func (m *AuthMiddleware) Handler(h http.Handler) http.Handler {\n }\n \n // CheckJWTFromRequest checks if the JWT is valid\n-func (m *AuthMiddleware) checkJWTFromRequest(r *http.Request, auth []string) (*http.Request, error) {\n-\ttoken, err := getTokenFromJWTRequest(auth)\n+func (m *AuthMiddleware) checkJWTFromRequest(r *http.Request, authHeaderParts []string) (*http.Request, error) {\n+\ttoken, err := getTokenFromJWTRequest(authHeaderParts)\n \n \t// If an error occurs, call the error handler and return an error\n \tif err != nil {\n@@ -151,8 +152,8 @@ func (m *AuthMiddleware) checkJWTFromRequest(r *http.Request, auth []string) (*h\n }\n \n // CheckPATFromRequest checks if the PAT is valid\n-func (m *AuthMiddleware) checkPATFromRequest(r *http.Request, auth []string) (*http.Request, error) {\n-\ttoken, err := getTokenFromPATRequest(auth)\n+func (m *AuthMiddleware) checkPATFromRequest(r *http.Request, authHeaderParts []string) (*http.Request, error) {\n+\ttoken, err := getTokenFromPATRequest(authHeaderParts)\n \tif err != nil {\n \t\treturn r, fmt.Errorf(\"error extracting token: %w\", err)\n \t}\n@@ -177,7 +178,7 @@ func (m *AuthMiddleware) checkPATFromRequest(r *http.Request, auth []string) (*h\n \t\treturn r, err\n \t}\n \n-\tuserAuth := nbcontext.UserAuth{\n+\tuserAuth := auth.UserAuth{\n \t\tUserId:         user.Id,\n \t\tAccountId:      user.AccountID,\n \t\tDomain:         accDomain,\ndiff --git a/management/server/mock_server/account_mock.go b/management/server/mock_server/account_mock.go\nindex 781d84f5f2c..0178e51f506 100644\n--- a/management/server/mock_server/account_mock.go\n+++ b/management/server/mock_server/account_mock.go\n@@ -2,6 +2,7 @@ package mock_server\n \n import (\n \t\"context\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n \t\"net\"\n \t\"net/netip\"\n \t\"time\"\n@@ -12,7 +13,6 @@ import (\n \tnbdns \"github.com/netbirdio/netbird/dns\"\n \t\"github.com/netbirdio/netbird/management/server/account\"\n \t\"github.com/netbirdio/netbird/management/server/activity\"\n-\tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/idp\"\n \tnbpeer \"github.com/netbirdio/netbird/management/server/peer\"\n \t\"github.com/netbirdio/netbird/management/server/peers/ephemeral\"\n@@ -34,7 +34,7 @@ type MockAccountManager struct {\n \tGetSetupKeyFunc                       func(ctx context.Context, accountID, userID, keyID string) (*types.SetupKey, error)\n \tAccountExistsFunc                     func(ctx context.Context, accountID string) (bool, error)\n \tGetAccountIDByUserIdFunc              func(ctx context.Context, userId, domain string) (string, error)\n-\tGetUserFromUserAuthFunc               func(ctx context.Context, userAuth nbcontext.UserAuth) (*types.User, error)\n+\tGetUserFromUserAuthFunc               func(ctx context.Context, userAuth auth.UserAuth) (*types.User, error)\n \tListUsersFunc                         func(ctx context.Context, accountID string) ([]*types.User, error)\n \tGetPeersFunc                          func(ctx context.Context, accountID, userID, nameFilter, ipFilter string) ([]*nbpeer.Peer, error)\n \tMarkPeerConnectedFunc                 func(ctx context.Context, peerKey string, connected bool, realIP net.IP) error\n@@ -84,7 +84,7 @@ type MockAccountManager struct {\n \tDeleteNameServerGroupFunc             func(ctx context.Context, accountID, nsGroupID, userID string) error\n \tListNameServerGroupsFunc              func(ctx context.Context, accountID string, userID string) ([]*nbdns.NameServerGroup, error)\n \tCreateUserFunc                        func(ctx context.Context, accountID, userID string, key *types.UserInfo) (*types.UserInfo, error)\n-\tGetAccountIDFromUserAuthFunc          func(ctx context.Context, userAuth nbcontext.UserAuth) (string, string, error)\n+\tGetAccountIDFromUserAuthFunc          func(ctx context.Context, userAuth auth.UserAuth) (string, string, error)\n \tDeleteAccountFunc                     func(ctx context.Context, accountID, userID string) error\n \tGetDNSDomainFunc                      func(settings *types.Settings) string\n \tStoreEventFunc                        func(ctx context.Context, initiatorID, targetID, accountID string, activityID activity.ActivityDescriber, meta map[string]any)\n@@ -119,7 +119,7 @@ type MockAccountManager struct {\n \tGetStoreFunc                          func() store.Store\n \tUpdateToPrimaryAccountFunc            func(ctx context.Context, accountId string) error\n \tGetOwnerInfoFunc                      func(ctx context.Context, accountID string) (*types.UserInfo, error)\n-\tGetCurrentUserInfoFunc                func(ctx context.Context, userAuth nbcontext.UserAuth) (*users.UserInfoWithPermissions, error)\n+\tGetCurrentUserInfoFunc                func(ctx context.Context, userAuth auth.UserAuth) (*users.UserInfoWithPermissions, error)\n \tGetAccountMetaFunc                    func(ctx context.Context, accountID, userID string) (*types.AccountMeta, error)\n \tGetAccountOnboardingFunc              func(ctx context.Context, accountID, userID string) (*types.AccountOnboarding, error)\n \tUpdateAccountOnboardingFunc           func(ctx context.Context, accountID, userID string, onboarding *types.AccountOnboarding) (*types.AccountOnboarding, error)\n@@ -470,7 +470,7 @@ func (am *MockAccountManager) UpdatePeerMeta(ctx context.Context, peerID string,\n }\n \n // GetUser mock implementation of GetUser from server.AccountManager interface\n-func (am *MockAccountManager) GetUserFromUserAuth(ctx context.Context, userAuth nbcontext.UserAuth) (*types.User, error) {\n+func (am *MockAccountManager) GetUserFromUserAuth(ctx context.Context, userAuth auth.UserAuth) (*types.User, error) {\n \tif am.GetUserFromUserAuthFunc != nil {\n \t\treturn am.GetUserFromUserAuthFunc(ctx, userAuth)\n \t}\n@@ -675,7 +675,7 @@ func (am *MockAccountManager) CreateUser(ctx context.Context, accountID, userID\n \treturn nil, status.Errorf(codes.Unimplemented, \"method CreateUser is not implemented\")\n }\n \n-func (am *MockAccountManager) GetAccountIDFromUserAuth(ctx context.Context, userAuth nbcontext.UserAuth) (string, string, error) {\n+func (am *MockAccountManager) GetAccountIDFromUserAuth(ctx context.Context, userAuth auth.UserAuth) (string, string, error) {\n \tif am.GetAccountIDFromUserAuthFunc != nil {\n \t\treturn am.GetAccountIDFromUserAuthFunc(ctx, userAuth)\n \t}\n@@ -937,7 +937,7 @@ func (am *MockAccountManager) BuildUserInfosForAccount(ctx context.Context, acco\n \treturn nil, status.Errorf(codes.Unimplemented, \"method BuildUserInfosForAccount is not implemented\")\n }\n \n-func (am *MockAccountManager) SyncUserJWTGroups(ctx context.Context, userAuth nbcontext.UserAuth) error {\n+func (am *MockAccountManager) SyncUserJWTGroups(ctx context.Context, userAuth auth.UserAuth) error {\n \treturn status.Errorf(codes.Unimplemented, \"method SyncUserJWTGroups is not implemented\")\n }\n \n@@ -969,7 +969,7 @@ func (am *MockAccountManager) GetOwnerInfo(ctx context.Context, accountId string\n \treturn nil, status.Errorf(codes.Unimplemented, \"method GetOwnerInfo is not implemented\")\n }\n \n-func (am *MockAccountManager) GetCurrentUserInfo(ctx context.Context, userAuth nbcontext.UserAuth) (*users.UserInfoWithPermissions, error) {\n+func (am *MockAccountManager) GetCurrentUserInfo(ctx context.Context, userAuth auth.UserAuth) (*users.UserInfoWithPermissions, error) {\n \tif am.GetCurrentUserInfoFunc != nil {\n \t\treturn am.GetCurrentUserInfoFunc(ctx, userAuth)\n \t}\ndiff --git a/management/server/networks/resources/types/resource.go b/management/server/networks/resources/types/resource.go\nindex 7874be85865..6b8cf94129c 100644\n--- a/management/server/networks/resources/types/resource.go\n+++ b/management/server/networks/resources/types/resource.go\n@@ -8,11 +8,11 @@ import (\n \n \t\"github.com/rs/xid\"\n \n-\tnbDomain \"github.com/netbirdio/netbird/shared/management/domain\"\n \trouterTypes \"github.com/netbirdio/netbird/management/server/networks/routers/types\"\n \tnetworkTypes \"github.com/netbirdio/netbird/management/server/networks/types\"\n \tnbpeer \"github.com/netbirdio/netbird/management/server/peer\"\n \t\"github.com/netbirdio/netbird/route\"\n+\tnbDomain \"github.com/netbirdio/netbird/shared/management/domain\"\n \n \t\"github.com/netbirdio/netbird/shared/management/http/api\"\n )\ndiff --git a/management/server/networks/routers/types/router.go b/management/server/networks/routers/types/router.go\nindex 72b15fd9a9a..e90c61a97e1 100644\n--- a/management/server/networks/routers/types/router.go\n+++ b/management/server/networks/routers/types/router.go\n@@ -5,8 +5,8 @@ import (\n \n \t\"github.com/rs/xid\"\n \n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/management/server/networks/types\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n )\n \n type NetworkRouter struct {\ndiff --git a/management/server/posture/checks.go b/management/server/posture/checks.go\nindex d65dc50456d..f0bbbc32e10 100644\n--- a/management/server/posture/checks.go\n+++ b/management/server/posture/checks.go\n@@ -7,8 +7,8 @@ import (\n \t\"regexp\"\n \n \t\"github.com/hashicorp/go-version\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \tnbpeer \"github.com/netbirdio/netbird/management/server/peer\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n \ndiff --git a/management/server/types/route_firewall_rule.go b/management/server/types/route_firewall_rule.go\nindex 6eb391cb5fd..da29e1d87f4 100644\n--- a/management/server/types/route_firewall_rule.go\n+++ b/management/server/types/route_firewall_rule.go\n@@ -1,8 +1,8 @@\n package types\n \n import (\n-\t\"github.com/netbirdio/netbird/shared/management/domain\"\n \t\"github.com/netbirdio/netbird/route\"\n+\t\"github.com/netbirdio/netbird/shared/management/domain\"\n )\n \n // RouteFirewallRule a firewall rule applicable for a routed network.\ndiff --git a/management/server/user.go b/management/server/user.go\nindex be4e491a809..6b8bcbcad41 100644\n--- a/management/server/user.go\n+++ b/management/server/user.go\n@@ -7,12 +7,13 @@ import (\n \t\"strings\"\n \t\"time\"\n \n+\tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n+\n \t\"github.com/google/uuid\"\n \tlog \"github.com/sirupsen/logrus\"\n \n \t\"github.com/netbirdio/netbird/management/server/activity\"\n-\tnbContext \"github.com/netbirdio/netbird/management/server/context\"\n-\tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/idp\"\n \tnbpeer \"github.com/netbirdio/netbird/management/server/peer\"\n \t\"github.com/netbirdio/netbird/management/server/permissions/modules\"\n@@ -175,9 +176,9 @@ func (am *DefaultAccountManager) GetUserByID(ctx context.Context, id string) (*t\n \treturn am.Store.GetUserByUserID(ctx, store.LockingStrengthNone, id)\n }\n \n-// GetUser looks up a user by provided nbContext.UserAuths.\n+// GetUser looks up a user by provided auth.UserAuths.\n // Expects account to have been created already.\n-func (am *DefaultAccountManager) GetUserFromUserAuth(ctx context.Context, userAuth nbContext.UserAuth) (*types.User, error) {\n+func (am *DefaultAccountManager) GetUserFromUserAuth(ctx context.Context, userAuth auth.UserAuth) (*types.User, error) {\n \tuser, err := am.Store.GetUserByUserID(ctx, store.LockingStrengthNone, userAuth.UserId)\n \tif err != nil {\n \t\treturn nil, err\n@@ -970,7 +971,7 @@ func (am *DefaultAccountManager) expireAndUpdatePeers(ctx context.Context, accou\n \tvar peerIDs []string\n \tfor _, peer := range peers {\n \t\t// nolint:staticcheck\n-\t\tctx = context.WithValue(ctx, nbContext.PeerIDKey, peer.Key)\n+\t\tctx = context.WithValue(ctx, nbcontext.PeerIDKey, peer.Key)\n \n \t\tif peer.UserID == \"\" {\n \t\t\t// we do not want to expire peers that are added via setup key\n@@ -1214,7 +1215,7 @@ func validateUserInvite(invite *types.UserInfo) error {\n }\n \n // GetCurrentUserInfo retrieves the account's current user info and permissions\n-func (am *DefaultAccountManager) GetCurrentUserInfo(ctx context.Context, userAuth nbcontext.UserAuth) (*users.UserInfoWithPermissions, error) {\n+func (am *DefaultAccountManager) GetCurrentUserInfo(ctx context.Context, userAuth auth.UserAuth) (*users.UserInfoWithPermissions, error) {\n \taccountID, userID := userAuth.AccountId, userAuth.UserId\n \n \tuser, err := am.Store.GetUserByUserID(ctx, store.LockingStrengthNone, userID)\ndiff --git a/relay/server/peer.go b/relay/server/peer.go\nindex c47f2e96038..c5ff41857e3 100644\n--- a/relay/server/peer.go\n+++ b/relay/server/peer.go\n@@ -9,10 +9,10 @@ import (\n \n \tlog \"github.com/sirupsen/logrus\"\n \n-\t\"github.com/netbirdio/netbird/shared/relay/healthcheck\"\n-\t\"github.com/netbirdio/netbird/shared/relay/messages\"\n \t\"github.com/netbirdio/netbird/relay/metrics\"\n \t\"github.com/netbirdio/netbird/relay/server/store\"\n+\t\"github.com/netbirdio/netbird/shared/relay/healthcheck\"\n+\t\"github.com/netbirdio/netbird/shared/relay/messages\"\n )\n \n const (\ndiff --git a/management/server/auth/jwt/extractor.go b/shared/auth/jwt/extractor.go\nsimilarity index 92%\nrename from management/server/auth/jwt/extractor.go\nrename to shared/auth/jwt/extractor.go\nindex d270d0ff173..a41d5f07a60 100644\n--- a/management/server/auth/jwt/extractor.go\n+++ b/shared/auth/jwt/extractor.go\n@@ -8,7 +8,7 @@ import (\n \t\"github.com/golang-jwt/jwt/v5\"\n \tlog \"github.com/sirupsen/logrus\"\n \n-\tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n )\n \n const (\n@@ -87,9 +87,10 @@ func (c ClaimsExtractor) audienceClaim(claimName string) string {\n \treturn url\n }\n \n-func (c *ClaimsExtractor) ToUserAuth(token *jwt.Token) (nbcontext.UserAuth, error) {\n+// ToUserAuth extracts user authentication information from a JWT token\n+func (c *ClaimsExtractor) ToUserAuth(token *jwt.Token) (auth.UserAuth, error) {\n \tclaims := token.Claims.(jwt.MapClaims)\n-\tuserAuth := nbcontext.UserAuth{}\n+\tuserAuth := auth.UserAuth{}\n \n \tuserID, ok := claims[c.userIDClaim].(string)\n \tif !ok {\n@@ -122,6 +123,7 @@ func (c *ClaimsExtractor) ToUserAuth(token *jwt.Token) (nbcontext.UserAuth, erro\n \treturn userAuth, nil\n }\n \n+// ToGroups extracts group information from a JWT token\n func (c *ClaimsExtractor) ToGroups(token *jwt.Token, claimName string) []string {\n \tclaims := token.Claims.(jwt.MapClaims)\n \tuserJWTGroups := make([]string, 0)\ndiff --git a/management/server/auth/jwt/validator.go b/shared/auth/jwt/validator.go\nsimilarity index 100%\nrename from management/server/auth/jwt/validator.go\nrename to shared/auth/jwt/validator.go\ndiff --git a/shared/auth/user.go b/shared/auth/user.go\nnew file mode 100644\nindex 00000000000..c1bae808e20\n--- /dev/null\n+++ b/shared/auth/user.go\n@@ -0,0 +1,28 @@\n+package auth\n+\n+import (\n+\t\"time\"\n+)\n+\n+type UserAuth struct {\n+\t// The account id the user is accessing\n+\tAccountId string\n+\t// The account domain\n+\tDomain string\n+\t// The account domain category, TBC values\n+\tDomainCategory string\n+\t// Indicates whether this user was invited, TBC logic\n+\tInvited bool\n+\t// Indicates whether this is a child account\n+\tIsChild bool\n+\n+\t// The user id\n+\tUserId string\n+\t// Last login time for this user\n+\tLastLogin time.Time\n+\t// The Groups the user belongs to on this account\n+\tGroups []string\n+\n+\t// Indicates whether this user has authenticated with a Personal Access Token\n+\tIsPAT bool\n+}\ndiff --git a/shared/context/keys.go b/shared/context/keys.go\nindex 5345ee214c4..c5b5da044e7 100644\n--- a/shared/context/keys.go\n+++ b/shared/context/keys.go\n@@ -5,4 +5,4 @@ const (\n \tAccountIDKey = \"accountID\"\n \tUserIDKey    = \"userID\"\n \tPeerIDKey    = \"peerID\"\n-)\n\\ No newline at end of file\n+)\ndiff --git a/shared/management/operations/operation.go b/shared/management/operations/operation.go\nindex b9b50036254..b1ba128154c 100644\n--- a/shared/management/operations/operation.go\n+++ b/shared/management/operations/operation.go\n@@ -1,4 +1,4 @@\n package operations\n \n // Operation represents a permission operation type\n-type Operation string\n\\ No newline at end of file\n+type Operation string\ndiff --git a/shared/management/proto/management.pb.go b/shared/management/proto/management.pb.go\nindex 0de00ec0c9c..ca12cf48cb7 100644\n--- a/shared/management/proto/management.pb.go\n+++ b/shared/management/proto/management.pb.go\n@@ -1,19 +1,18 @@\n // Code generated by protoc-gen-go. DO NOT EDIT.\n // versions:\n // \tprotoc-gen-go v1.26.0\n-// \tprotoc        v6.32.0\n+// \tprotoc        v6.32.1\n // source: management.proto\n \n package proto\n \n import (\n-\treflect \"reflect\"\n-\tsync \"sync\"\n-\n \tprotoreflect \"google.golang.org/protobuf/reflect/protoreflect\"\n \tprotoimpl \"google.golang.org/protobuf/runtime/protoimpl\"\n \tdurationpb \"google.golang.org/protobuf/types/known/durationpb\"\n \ttimestamppb \"google.golang.org/protobuf/types/known/timestamppb\"\n+\treflect \"reflect\"\n+\tsync \"sync\"\n )\n \n const (\n@@ -268,7 +267,7 @@ func (x DeviceAuthorizationFlowProvider) Number() protoreflect.EnumNumber {\n \n // Deprecated: Use DeviceAuthorizationFlowProvider.Descriptor instead.\n func (DeviceAuthorizationFlowProvider) EnumDescriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{23, 0}\n+\treturn file_management_proto_rawDescGZIP(), []int{24, 0}\n }\n \n type EncryptedMessage struct {\n@@ -799,16 +798,21 @@ type Flags struct {\n \tsizeCache     protoimpl.SizeCache\n \tunknownFields protoimpl.UnknownFields\n \n-\tRosenpassEnabled      bool `protobuf:\"varint,1,opt,name=rosenpassEnabled,proto3\" json:\"rosenpassEnabled,omitempty\"`\n-\tRosenpassPermissive   bool `protobuf:\"varint,2,opt,name=rosenpassPermissive,proto3\" json:\"rosenpassPermissive,omitempty\"`\n-\tServerSSHAllowed      bool `protobuf:\"varint,3,opt,name=serverSSHAllowed,proto3\" json:\"serverSSHAllowed,omitempty\"`\n-\tDisableClientRoutes   bool `protobuf:\"varint,4,opt,name=disableClientRoutes,proto3\" json:\"disableClientRoutes,omitempty\"`\n-\tDisableServerRoutes   bool `protobuf:\"varint,5,opt,name=disableServerRoutes,proto3\" json:\"disableServerRoutes,omitempty\"`\n-\tDisableDNS            bool `protobuf:\"varint,6,opt,name=disableDNS,proto3\" json:\"disableDNS,omitempty\"`\n-\tDisableFirewall       bool `protobuf:\"varint,7,opt,name=disableFirewall,proto3\" json:\"disableFirewall,omitempty\"`\n-\tBlockLANAccess        bool `protobuf:\"varint,8,opt,name=blockLANAccess,proto3\" json:\"blockLANAccess,omitempty\"`\n-\tBlockInbound          bool `protobuf:\"varint,9,opt,name=blockInbound,proto3\" json:\"blockInbound,omitempty\"`\n-\tLazyConnectionEnabled bool `protobuf:\"varint,10,opt,name=lazyConnectionEnabled,proto3\" json:\"lazyConnectionEnabled,omitempty\"`\n+\tRosenpassEnabled              bool `protobuf:\"varint,1,opt,name=rosenpassEnabled,proto3\" json:\"rosenpassEnabled,omitempty\"`\n+\tRosenpassPermissive           bool `protobuf:\"varint,2,opt,name=rosenpassPermissive,proto3\" json:\"rosenpassPermissive,omitempty\"`\n+\tServerSSHAllowed              bool `protobuf:\"varint,3,opt,name=serverSSHAllowed,proto3\" json:\"serverSSHAllowed,omitempty\"`\n+\tDisableClientRoutes           bool `protobuf:\"varint,4,opt,name=disableClientRoutes,proto3\" json:\"disableClientRoutes,omitempty\"`\n+\tDisableServerRoutes           bool `protobuf:\"varint,5,opt,name=disableServerRoutes,proto3\" json:\"disableServerRoutes,omitempty\"`\n+\tDisableDNS                    bool `protobuf:\"varint,6,opt,name=disableDNS,proto3\" json:\"disableDNS,omitempty\"`\n+\tDisableFirewall               bool `protobuf:\"varint,7,opt,name=disableFirewall,proto3\" json:\"disableFirewall,omitempty\"`\n+\tBlockLANAccess                bool `protobuf:\"varint,8,opt,name=blockLANAccess,proto3\" json:\"blockLANAccess,omitempty\"`\n+\tBlockInbound                  bool `protobuf:\"varint,9,opt,name=blockInbound,proto3\" json:\"blockInbound,omitempty\"`\n+\tLazyConnectionEnabled         bool `protobuf:\"varint,10,opt,name=lazyConnectionEnabled,proto3\" json:\"lazyConnectionEnabled,omitempty\"`\n+\tEnableSSHRoot                 bool `protobuf:\"varint,11,opt,name=enableSSHRoot,proto3\" json:\"enableSSHRoot,omitempty\"`\n+\tEnableSSHSFTP                 bool `protobuf:\"varint,12,opt,name=enableSSHSFTP,proto3\" json:\"enableSSHSFTP,omitempty\"`\n+\tEnableSSHLocalPortForwarding  bool `protobuf:\"varint,13,opt,name=enableSSHLocalPortForwarding,proto3\" json:\"enableSSHLocalPortForwarding,omitempty\"`\n+\tEnableSSHRemotePortForwarding bool `protobuf:\"varint,14,opt,name=enableSSHRemotePortForwarding,proto3\" json:\"enableSSHRemotePortForwarding,omitempty\"`\n+\tDisableSSHAuth                bool `protobuf:\"varint,15,opt,name=disableSSHAuth,proto3\" json:\"disableSSHAuth,omitempty\"`\n }\n \n func (x *Flags) Reset() {\n@@ -913,6 +917,41 @@ func (x *Flags) GetLazyConnectionEnabled() bool {\n \treturn false\n }\n \n+func (x *Flags) GetEnableSSHRoot() bool {\n+\tif x != nil {\n+\t\treturn x.EnableSSHRoot\n+\t}\n+\treturn false\n+}\n+\n+func (x *Flags) GetEnableSSHSFTP() bool {\n+\tif x != nil {\n+\t\treturn x.EnableSSHSFTP\n+\t}\n+\treturn false\n+}\n+\n+func (x *Flags) GetEnableSSHLocalPortForwarding() bool {\n+\tif x != nil {\n+\t\treturn x.EnableSSHLocalPortForwarding\n+\t}\n+\treturn false\n+}\n+\n+func (x *Flags) GetEnableSSHRemotePortForwarding() bool {\n+\tif x != nil {\n+\t\treturn x.EnableSSHRemotePortForwarding\n+\t}\n+\treturn false\n+}\n+\n+func (x *Flags) GetDisableSSHAuth() bool {\n+\tif x != nil {\n+\t\treturn x.DisableSSHAuth\n+\t}\n+\treturn false\n+}\n+\n // PeerSystemMeta is machine meta data like OS and version.\n type PeerSystemMeta struct {\n \tstate         protoimpl.MessageState\n@@ -1273,6 +1312,7 @@ type NetbirdConfig struct {\n \tSignal *HostConfig  `protobuf:\"bytes,3,opt,name=signal,proto3\" json:\"signal,omitempty\"`\n \tRelay  *RelayConfig `protobuf:\"bytes,4,opt,name=relay,proto3\" json:\"relay,omitempty\"`\n \tFlow   *FlowConfig  `protobuf:\"bytes,5,opt,name=flow,proto3\" json:\"flow,omitempty\"`\n+\tJwt    *JWTConfig   `protobuf:\"bytes,6,opt,name=jwt,proto3\" json:\"jwt,omitempty\"`\n }\n \n func (x *NetbirdConfig) Reset() {\n@@ -1342,6 +1382,13 @@ func (x *NetbirdConfig) GetFlow() *FlowConfig {\n \treturn nil\n }\n \n+func (x *NetbirdConfig) GetJwt() *JWTConfig {\n+\tif x != nil {\n+\t\treturn x.Jwt\n+\t}\n+\treturn nil\n+}\n+\n // HostConfig describes connection properties of some server (e.g. STUN, Signal, Management)\n type HostConfig struct {\n \tstate         protoimpl.MessageState\n@@ -1568,6 +1615,78 @@ func (x *FlowConfig) GetDnsCollection() bool {\n \treturn false\n }\n \n+// JWTConfig represents JWT authentication configuration\n+type JWTConfig struct {\n+\tstate         protoimpl.MessageState\n+\tsizeCache     protoimpl.SizeCache\n+\tunknownFields protoimpl.UnknownFields\n+\n+\tIssuer       string `protobuf:\"bytes,1,opt,name=issuer,proto3\" json:\"issuer,omitempty\"`\n+\tAudience     string `protobuf:\"bytes,2,opt,name=audience,proto3\" json:\"audience,omitempty\"`\n+\tKeysLocation string `protobuf:\"bytes,3,opt,name=keysLocation,proto3\" json:\"keysLocation,omitempty\"`\n+\tMaxTokenAge  int64  `protobuf:\"varint,4,opt,name=maxTokenAge,proto3\" json:\"maxTokenAge,omitempty\"`\n+}\n+\n+func (x *JWTConfig) Reset() {\n+\t*x = JWTConfig{}\n+\tif protoimpl.UnsafeEnabled {\n+\t\tmi := &file_management_proto_msgTypes[17]\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tms.StoreMessageInfo(mi)\n+\t}\n+}\n+\n+func (x *JWTConfig) String() string {\n+\treturn protoimpl.X.MessageStringOf(x)\n+}\n+\n+func (*JWTConfig) ProtoMessage() {}\n+\n+func (x *JWTConfig) ProtoReflect() protoreflect.Message {\n+\tmi := &file_management_proto_msgTypes[17]\n+\tif protoimpl.UnsafeEnabled && x != nil {\n+\t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n+\t\tif ms.LoadMessageInfo() == nil {\n+\t\t\tms.StoreMessageInfo(mi)\n+\t\t}\n+\t\treturn ms\n+\t}\n+\treturn mi.MessageOf(x)\n+}\n+\n+// Deprecated: Use JWTConfig.ProtoReflect.Descriptor instead.\n+func (*JWTConfig) Descriptor() ([]byte, []int) {\n+\treturn file_management_proto_rawDescGZIP(), []int{17}\n+}\n+\n+func (x *JWTConfig) GetIssuer() string {\n+\tif x != nil {\n+\t\treturn x.Issuer\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *JWTConfig) GetAudience() string {\n+\tif x != nil {\n+\t\treturn x.Audience\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *JWTConfig) GetKeysLocation() string {\n+\tif x != nil {\n+\t\treturn x.KeysLocation\n+\t}\n+\treturn \"\"\n+}\n+\n+func (x *JWTConfig) GetMaxTokenAge() int64 {\n+\tif x != nil {\n+\t\treturn x.MaxTokenAge\n+\t}\n+\treturn 0\n+}\n+\n // ProtectedHostConfig is similar to HostConfig but has additional user and password\n // Mostly used for TURN servers\n type ProtectedHostConfig struct {\n@@ -1583,7 +1702,7 @@ type ProtectedHostConfig struct {\n func (x *ProtectedHostConfig) Reset() {\n \t*x = ProtectedHostConfig{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[17]\n+\t\tmi := &file_management_proto_msgTypes[18]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -1596,7 +1715,7 @@ func (x *ProtectedHostConfig) String() string {\n func (*ProtectedHostConfig) ProtoMessage() {}\n \n func (x *ProtectedHostConfig) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[17]\n+\tmi := &file_management_proto_msgTypes[18]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -1609,7 +1728,7 @@ func (x *ProtectedHostConfig) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use ProtectedHostConfig.ProtoReflect.Descriptor instead.\n func (*ProtectedHostConfig) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{17}\n+\treturn file_management_proto_rawDescGZIP(), []int{18}\n }\n \n func (x *ProtectedHostConfig) GetHostConfig() *HostConfig {\n@@ -1656,7 +1775,7 @@ type PeerConfig struct {\n func (x *PeerConfig) Reset() {\n \t*x = PeerConfig{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[18]\n+\t\tmi := &file_management_proto_msgTypes[19]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -1669,7 +1788,7 @@ func (x *PeerConfig) String() string {\n func (*PeerConfig) ProtoMessage() {}\n \n func (x *PeerConfig) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[18]\n+\tmi := &file_management_proto_msgTypes[19]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -1682,7 +1801,7 @@ func (x *PeerConfig) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use PeerConfig.ProtoReflect.Descriptor instead.\n func (*PeerConfig) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{18}\n+\treturn file_management_proto_rawDescGZIP(), []int{19}\n }\n \n func (x *PeerConfig) GetAddress() string {\n@@ -1770,7 +1889,7 @@ type NetworkMap struct {\n func (x *NetworkMap) Reset() {\n \t*x = NetworkMap{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[19]\n+\t\tmi := &file_management_proto_msgTypes[20]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -1783,7 +1902,7 @@ func (x *NetworkMap) String() string {\n func (*NetworkMap) ProtoMessage() {}\n \n func (x *NetworkMap) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[19]\n+\tmi := &file_management_proto_msgTypes[20]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -1796,7 +1915,7 @@ func (x *NetworkMap) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use NetworkMap.ProtoReflect.Descriptor instead.\n func (*NetworkMap) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{19}\n+\treturn file_management_proto_rawDescGZIP(), []int{20}\n }\n \n func (x *NetworkMap) GetSerial() uint64 {\n@@ -1904,7 +2023,7 @@ type RemotePeerConfig struct {\n func (x *RemotePeerConfig) Reset() {\n \t*x = RemotePeerConfig{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[20]\n+\t\tmi := &file_management_proto_msgTypes[21]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -1917,7 +2036,7 @@ func (x *RemotePeerConfig) String() string {\n func (*RemotePeerConfig) ProtoMessage() {}\n \n func (x *RemotePeerConfig) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[20]\n+\tmi := &file_management_proto_msgTypes[21]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -1930,7 +2049,7 @@ func (x *RemotePeerConfig) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use RemotePeerConfig.ProtoReflect.Descriptor instead.\n func (*RemotePeerConfig) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{20}\n+\treturn file_management_proto_rawDescGZIP(), []int{21}\n }\n \n func (x *RemotePeerConfig) GetWgPubKey() string {\n@@ -1978,13 +2097,14 @@ type SSHConfig struct {\n \tSshEnabled bool `protobuf:\"varint,1,opt,name=sshEnabled,proto3\" json:\"sshEnabled,omitempty\"`\n \t// sshPubKey is a SSH public key of a peer to be added to authorized_hosts.\n \t// This property should be ignore if SSHConfig comes from PeerConfig.\n-\tSshPubKey []byte `protobuf:\"bytes,2,opt,name=sshPubKey,proto3\" json:\"sshPubKey,omitempty\"`\n+\tSshPubKey []byte     `protobuf:\"bytes,2,opt,name=sshPubKey,proto3\" json:\"sshPubKey,omitempty\"`\n+\tJwtConfig *JWTConfig `protobuf:\"bytes,3,opt,name=jwtConfig,proto3\" json:\"jwtConfig,omitempty\"`\n }\n \n func (x *SSHConfig) Reset() {\n \t*x = SSHConfig{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[21]\n+\t\tmi := &file_management_proto_msgTypes[22]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -1997,7 +2117,7 @@ func (x *SSHConfig) String() string {\n func (*SSHConfig) ProtoMessage() {}\n \n func (x *SSHConfig) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[21]\n+\tmi := &file_management_proto_msgTypes[22]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2010,7 +2130,7 @@ func (x *SSHConfig) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SSHConfig.ProtoReflect.Descriptor instead.\n func (*SSHConfig) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{21}\n+\treturn file_management_proto_rawDescGZIP(), []int{22}\n }\n \n func (x *SSHConfig) GetSshEnabled() bool {\n@@ -2027,6 +2147,13 @@ func (x *SSHConfig) GetSshPubKey() []byte {\n \treturn nil\n }\n \n+func (x *SSHConfig) GetJwtConfig() *JWTConfig {\n+\tif x != nil {\n+\t\treturn x.JwtConfig\n+\t}\n+\treturn nil\n+}\n+\n // DeviceAuthorizationFlowRequest empty struct for future expansion\n type DeviceAuthorizationFlowRequest struct {\n \tstate         protoimpl.MessageState\n@@ -2037,7 +2164,7 @@ type DeviceAuthorizationFlowRequest struct {\n func (x *DeviceAuthorizationFlowRequest) Reset() {\n \t*x = DeviceAuthorizationFlowRequest{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[22]\n+\t\tmi := &file_management_proto_msgTypes[23]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2050,7 +2177,7 @@ func (x *DeviceAuthorizationFlowRequest) String() string {\n func (*DeviceAuthorizationFlowRequest) ProtoMessage() {}\n \n func (x *DeviceAuthorizationFlowRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[22]\n+\tmi := &file_management_proto_msgTypes[23]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2063,7 +2190,7 @@ func (x *DeviceAuthorizationFlowRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use DeviceAuthorizationFlowRequest.ProtoReflect.Descriptor instead.\n func (*DeviceAuthorizationFlowRequest) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{22}\n+\treturn file_management_proto_rawDescGZIP(), []int{23}\n }\n \n // DeviceAuthorizationFlow represents Device Authorization Flow information\n@@ -2082,7 +2209,7 @@ type DeviceAuthorizationFlow struct {\n func (x *DeviceAuthorizationFlow) Reset() {\n \t*x = DeviceAuthorizationFlow{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[23]\n+\t\tmi := &file_management_proto_msgTypes[24]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2095,7 +2222,7 @@ func (x *DeviceAuthorizationFlow) String() string {\n func (*DeviceAuthorizationFlow) ProtoMessage() {}\n \n func (x *DeviceAuthorizationFlow) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[23]\n+\tmi := &file_management_proto_msgTypes[24]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2108,7 +2235,7 @@ func (x *DeviceAuthorizationFlow) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use DeviceAuthorizationFlow.ProtoReflect.Descriptor instead.\n func (*DeviceAuthorizationFlow) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{23}\n+\treturn file_management_proto_rawDescGZIP(), []int{24}\n }\n \n func (x *DeviceAuthorizationFlow) GetProvider() DeviceAuthorizationFlowProvider {\n@@ -2135,7 +2262,7 @@ type PKCEAuthorizationFlowRequest struct {\n func (x *PKCEAuthorizationFlowRequest) Reset() {\n \t*x = PKCEAuthorizationFlowRequest{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[24]\n+\t\tmi := &file_management_proto_msgTypes[25]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2148,7 +2275,7 @@ func (x *PKCEAuthorizationFlowRequest) String() string {\n func (*PKCEAuthorizationFlowRequest) ProtoMessage() {}\n \n func (x *PKCEAuthorizationFlowRequest) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[24]\n+\tmi := &file_management_proto_msgTypes[25]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2161,7 +2288,7 @@ func (x *PKCEAuthorizationFlowRequest) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use PKCEAuthorizationFlowRequest.ProtoReflect.Descriptor instead.\n func (*PKCEAuthorizationFlowRequest) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{24}\n+\treturn file_management_proto_rawDescGZIP(), []int{25}\n }\n \n // PKCEAuthorizationFlow represents Authorization Code Flow information\n@@ -2178,7 +2305,7 @@ type PKCEAuthorizationFlow struct {\n func (x *PKCEAuthorizationFlow) Reset() {\n \t*x = PKCEAuthorizationFlow{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[25]\n+\t\tmi := &file_management_proto_msgTypes[26]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2191,7 +2318,7 @@ func (x *PKCEAuthorizationFlow) String() string {\n func (*PKCEAuthorizationFlow) ProtoMessage() {}\n \n func (x *PKCEAuthorizationFlow) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[25]\n+\tmi := &file_management_proto_msgTypes[26]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2204,7 +2331,7 @@ func (x *PKCEAuthorizationFlow) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use PKCEAuthorizationFlow.ProtoReflect.Descriptor instead.\n func (*PKCEAuthorizationFlow) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{25}\n+\treturn file_management_proto_rawDescGZIP(), []int{26}\n }\n \n func (x *PKCEAuthorizationFlow) GetProviderConfig() *ProviderConfig {\n@@ -2250,7 +2377,7 @@ type ProviderConfig struct {\n func (x *ProviderConfig) Reset() {\n \t*x = ProviderConfig{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[26]\n+\t\tmi := &file_management_proto_msgTypes[27]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2263,7 +2390,7 @@ func (x *ProviderConfig) String() string {\n func (*ProviderConfig) ProtoMessage() {}\n \n func (x *ProviderConfig) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[26]\n+\tmi := &file_management_proto_msgTypes[27]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2276,7 +2403,7 @@ func (x *ProviderConfig) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use ProviderConfig.ProtoReflect.Descriptor instead.\n func (*ProviderConfig) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{26}\n+\treturn file_management_proto_rawDescGZIP(), []int{27}\n }\n \n func (x *ProviderConfig) GetClientID() string {\n@@ -2384,7 +2511,7 @@ type Route struct {\n func (x *Route) Reset() {\n \t*x = Route{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[27]\n+\t\tmi := &file_management_proto_msgTypes[28]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2397,7 +2524,7 @@ func (x *Route) String() string {\n func (*Route) ProtoMessage() {}\n \n func (x *Route) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[27]\n+\tmi := &file_management_proto_msgTypes[28]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2410,7 +2537,7 @@ func (x *Route) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use Route.ProtoReflect.Descriptor instead.\n func (*Route) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{27}\n+\treturn file_management_proto_rawDescGZIP(), []int{28}\n }\n \n func (x *Route) GetID() string {\n@@ -2498,7 +2625,7 @@ type DNSConfig struct {\n func (x *DNSConfig) Reset() {\n \t*x = DNSConfig{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[28]\n+\t\tmi := &file_management_proto_msgTypes[29]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2511,7 +2638,7 @@ func (x *DNSConfig) String() string {\n func (*DNSConfig) ProtoMessage() {}\n \n func (x *DNSConfig) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[28]\n+\tmi := &file_management_proto_msgTypes[29]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2524,7 +2651,7 @@ func (x *DNSConfig) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use DNSConfig.ProtoReflect.Descriptor instead.\n func (*DNSConfig) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{28}\n+\treturn file_management_proto_rawDescGZIP(), []int{29}\n }\n \n func (x *DNSConfig) GetServiceEnable() bool {\n@@ -2568,7 +2695,7 @@ type CustomZone struct {\n func (x *CustomZone) Reset() {\n \t*x = CustomZone{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[29]\n+\t\tmi := &file_management_proto_msgTypes[30]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2581,7 +2708,7 @@ func (x *CustomZone) String() string {\n func (*CustomZone) ProtoMessage() {}\n \n func (x *CustomZone) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[29]\n+\tmi := &file_management_proto_msgTypes[30]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2594,7 +2721,7 @@ func (x *CustomZone) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use CustomZone.ProtoReflect.Descriptor instead.\n func (*CustomZone) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{29}\n+\treturn file_management_proto_rawDescGZIP(), []int{30}\n }\n \n func (x *CustomZone) GetDomain() string {\n@@ -2627,7 +2754,7 @@ type SimpleRecord struct {\n func (x *SimpleRecord) Reset() {\n \t*x = SimpleRecord{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[30]\n+\t\tmi := &file_management_proto_msgTypes[31]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2640,7 +2767,7 @@ func (x *SimpleRecord) String() string {\n func (*SimpleRecord) ProtoMessage() {}\n \n func (x *SimpleRecord) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[30]\n+\tmi := &file_management_proto_msgTypes[31]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2653,7 +2780,7 @@ func (x *SimpleRecord) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use SimpleRecord.ProtoReflect.Descriptor instead.\n func (*SimpleRecord) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{30}\n+\treturn file_management_proto_rawDescGZIP(), []int{31}\n }\n \n func (x *SimpleRecord) GetName() string {\n@@ -2706,7 +2833,7 @@ type NameServerGroup struct {\n func (x *NameServerGroup) Reset() {\n \t*x = NameServerGroup{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[31]\n+\t\tmi := &file_management_proto_msgTypes[32]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2719,7 +2846,7 @@ func (x *NameServerGroup) String() string {\n func (*NameServerGroup) ProtoMessage() {}\n \n func (x *NameServerGroup) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[31]\n+\tmi := &file_management_proto_msgTypes[32]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2732,7 +2859,7 @@ func (x *NameServerGroup) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use NameServerGroup.ProtoReflect.Descriptor instead.\n func (*NameServerGroup) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{31}\n+\treturn file_management_proto_rawDescGZIP(), []int{32}\n }\n \n func (x *NameServerGroup) GetNameServers() []*NameServer {\n@@ -2777,7 +2904,7 @@ type NameServer struct {\n func (x *NameServer) Reset() {\n \t*x = NameServer{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[32]\n+\t\tmi := &file_management_proto_msgTypes[33]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2790,7 +2917,7 @@ func (x *NameServer) String() string {\n func (*NameServer) ProtoMessage() {}\n \n func (x *NameServer) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[32]\n+\tmi := &file_management_proto_msgTypes[33]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2803,7 +2930,7 @@ func (x *NameServer) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use NameServer.ProtoReflect.Descriptor instead.\n func (*NameServer) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{32}\n+\treturn file_management_proto_rawDescGZIP(), []int{33}\n }\n \n func (x *NameServer) GetIP() string {\n@@ -2846,7 +2973,7 @@ type FirewallRule struct {\n func (x *FirewallRule) Reset() {\n \t*x = FirewallRule{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[33]\n+\t\tmi := &file_management_proto_msgTypes[34]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2859,7 +2986,7 @@ func (x *FirewallRule) String() string {\n func (*FirewallRule) ProtoMessage() {}\n \n func (x *FirewallRule) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[33]\n+\tmi := &file_management_proto_msgTypes[34]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2872,7 +2999,7 @@ func (x *FirewallRule) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use FirewallRule.ProtoReflect.Descriptor instead.\n func (*FirewallRule) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{33}\n+\treturn file_management_proto_rawDescGZIP(), []int{34}\n }\n \n func (x *FirewallRule) GetPeerIP() string {\n@@ -2936,7 +3063,7 @@ type NetworkAddress struct {\n func (x *NetworkAddress) Reset() {\n \t*x = NetworkAddress{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[34]\n+\t\tmi := &file_management_proto_msgTypes[35]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -2949,7 +3076,7 @@ func (x *NetworkAddress) String() string {\n func (*NetworkAddress) ProtoMessage() {}\n \n func (x *NetworkAddress) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[34]\n+\tmi := &file_management_proto_msgTypes[35]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -2962,7 +3089,7 @@ func (x *NetworkAddress) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use NetworkAddress.ProtoReflect.Descriptor instead.\n func (*NetworkAddress) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{34}\n+\treturn file_management_proto_rawDescGZIP(), []int{35}\n }\n \n func (x *NetworkAddress) GetNetIP() string {\n@@ -2990,7 +3117,7 @@ type Checks struct {\n func (x *Checks) Reset() {\n \t*x = Checks{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[35]\n+\t\tmi := &file_management_proto_msgTypes[36]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -3003,7 +3130,7 @@ func (x *Checks) String() string {\n func (*Checks) ProtoMessage() {}\n \n func (x *Checks) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[35]\n+\tmi := &file_management_proto_msgTypes[36]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3016,7 +3143,7 @@ func (x *Checks) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use Checks.ProtoReflect.Descriptor instead.\n func (*Checks) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{35}\n+\treturn file_management_proto_rawDescGZIP(), []int{36}\n }\n \n func (x *Checks) GetFiles() []string {\n@@ -3041,7 +3168,7 @@ type PortInfo struct {\n func (x *PortInfo) Reset() {\n \t*x = PortInfo{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[36]\n+\t\tmi := &file_management_proto_msgTypes[37]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -3054,7 +3181,7 @@ func (x *PortInfo) String() string {\n func (*PortInfo) ProtoMessage() {}\n \n func (x *PortInfo) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[36]\n+\tmi := &file_management_proto_msgTypes[37]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3067,7 +3194,7 @@ func (x *PortInfo) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use PortInfo.ProtoReflect.Descriptor instead.\n func (*PortInfo) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{36}\n+\treturn file_management_proto_rawDescGZIP(), []int{37}\n }\n \n func (m *PortInfo) GetPortSelection() isPortInfo_PortSelection {\n@@ -3138,7 +3265,7 @@ type RouteFirewallRule struct {\n func (x *RouteFirewallRule) Reset() {\n \t*x = RouteFirewallRule{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[37]\n+\t\tmi := &file_management_proto_msgTypes[38]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -3151,7 +3278,7 @@ func (x *RouteFirewallRule) String() string {\n func (*RouteFirewallRule) ProtoMessage() {}\n \n func (x *RouteFirewallRule) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[37]\n+\tmi := &file_management_proto_msgTypes[38]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3164,7 +3291,7 @@ func (x *RouteFirewallRule) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use RouteFirewallRule.ProtoReflect.Descriptor instead.\n func (*RouteFirewallRule) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{37}\n+\treturn file_management_proto_rawDescGZIP(), []int{38}\n }\n \n func (x *RouteFirewallRule) GetSourceRanges() []string {\n@@ -3255,7 +3382,7 @@ type ForwardingRule struct {\n func (x *ForwardingRule) Reset() {\n \t*x = ForwardingRule{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[38]\n+\t\tmi := &file_management_proto_msgTypes[39]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -3268,7 +3395,7 @@ func (x *ForwardingRule) String() string {\n func (*ForwardingRule) ProtoMessage() {}\n \n func (x *ForwardingRule) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[38]\n+\tmi := &file_management_proto_msgTypes[39]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3281,7 +3408,7 @@ func (x *ForwardingRule) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use ForwardingRule.ProtoReflect.Descriptor instead.\n func (*ForwardingRule) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{38}\n+\treturn file_management_proto_rawDescGZIP(), []int{39}\n }\n \n func (x *ForwardingRule) GetProtocol() RuleProtocol {\n@@ -3324,7 +3451,7 @@ type PortInfo_Range struct {\n func (x *PortInfo_Range) Reset() {\n \t*x = PortInfo_Range{}\n \tif protoimpl.UnsafeEnabled {\n-\t\tmi := &file_management_proto_msgTypes[39]\n+\t\tmi := &file_management_proto_msgTypes[40]\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tms.StoreMessageInfo(mi)\n \t}\n@@ -3337,7 +3464,7 @@ func (x *PortInfo_Range) String() string {\n func (*PortInfo_Range) ProtoMessage() {}\n \n func (x *PortInfo_Range) ProtoReflect() protoreflect.Message {\n-\tmi := &file_management_proto_msgTypes[39]\n+\tmi := &file_management_proto_msgTypes[40]\n \tif protoimpl.UnsafeEnabled && x != nil {\n \t\tms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))\n \t\tif ms.LoadMessageInfo() == nil {\n@@ -3350,7 +3477,7 @@ func (x *PortInfo_Range) ProtoReflect() protoreflect.Message {\n \n // Deprecated: Use PortInfo_Range.ProtoReflect.Descriptor instead.\n func (*PortInfo_Range) Descriptor() ([]byte, []int) {\n-\treturn file_management_proto_rawDescGZIP(), []int{36, 0}\n+\treturn file_management_proto_rawDescGZIP(), []int{37, 0}\n }\n \n func (x *PortInfo_Range) GetStart() uint32 {\n@@ -3438,7 +3565,7 @@ var file_management_proto_rawDesc = []byte{\n \t0x73, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x05, 0x65, 0x78, 0x69, 0x73, 0x74, 0x12,\n \t0x2a, 0x0a, 0x10, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x49, 0x73, 0x52, 0x75, 0x6e, 0x6e,\n \t0x69, 0x6e, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x10, 0x70, 0x72, 0x6f, 0x63, 0x65,\n-\t0x73, 0x73, 0x49, 0x73, 0x52, 0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x22, 0xc1, 0x03, 0x0a, 0x05,\n+\t0x73, 0x73, 0x49, 0x73, 0x52, 0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x22, 0xbf, 0x05, 0x0a, 0x05,\n \t0x46, 0x6c, 0x61, 0x67, 0x73, 0x12, 0x2a, 0x0a, 0x10, 0x72, 0x6f, 0x73, 0x65, 0x6e, 0x70, 0x61,\n \t0x73, 0x73, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52,\n \t0x10, 0x72, 0x6f, 0x73, 0x65, 0x6e, 0x70, 0x61, 0x73, 0x73, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65,\n@@ -3466,435 +3593,465 @@ var file_management_proto_rawDesc = []byte{\n \t0x63, 0x6b, 0x49, 0x6e, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x12, 0x34, 0x0a, 0x15, 0x6c, 0x61, 0x7a,\n \t0x79, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c,\n \t0x65, 0x64, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x08, 0x52, 0x15, 0x6c, 0x61, 0x7a, 0x79, 0x43, 0x6f,\n-\t0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x22,\n-\t0xf2, 0x04, 0x0a, 0x0e, 0x50, 0x65, 0x65, 0x72, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x4d, 0x65,\n-\t0x74, 0x61, 0x12, 0x1a, 0x0a, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01,\n-\t0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x12,\n-\t0x0a, 0x04, 0x67, 0x6f, 0x4f, 0x53, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x67, 0x6f,\n-\t0x4f, 0x53, 0x12, 0x16, 0x0a, 0x06, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x18, 0x03, 0x20, 0x01,\n-\t0x28, 0x09, 0x52, 0x06, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x12, 0x12, 0x0a, 0x04, 0x63, 0x6f,\n-\t0x72, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x63, 0x6f, 0x72, 0x65, 0x12, 0x1a,\n-\t0x0a, 0x08, 0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09,\n-\t0x52, 0x08, 0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x12, 0x0e, 0x0a, 0x02, 0x4f, 0x53,\n-\t0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x4f, 0x53, 0x12, 0x26, 0x0a, 0x0e, 0x6e, 0x65,\n-\t0x74, 0x62, 0x69, 0x72, 0x64, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x07, 0x20, 0x01,\n-\t0x28, 0x09, 0x52, 0x0e, 0x6e, 0x65, 0x74, 0x62, 0x69, 0x72, 0x64, 0x56, 0x65, 0x72, 0x73, 0x69,\n-\t0x6f, 0x6e, 0x12, 0x1c, 0x0a, 0x09, 0x75, 0x69, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18,\n-\t0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x75, 0x69, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,\n-\t0x12, 0x24, 0x0a, 0x0d, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f,\n-\t0x6e, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x56,\n-\t0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x1c, 0x0a, 0x09, 0x4f, 0x53, 0x56, 0x65, 0x72, 0x73,\n-\t0x69, 0x6f, 0x6e, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x4f, 0x53, 0x56, 0x65, 0x72,\n-\t0x73, 0x69, 0x6f, 0x6e, 0x12, 0x46, 0x0a, 0x10, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x41,\n-\t0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x18, 0x0b, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a,\n-\t0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4e, 0x65, 0x74, 0x77,\n-\t0x6f, 0x72, 0x6b, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x10, 0x6e, 0x65, 0x74, 0x77,\n-\t0x6f, 0x72, 0x6b, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x12, 0x28, 0x0a, 0x0f,\n-\t0x73, 0x79, 0x73, 0x53, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18,\n-\t0x0c, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x73, 0x79, 0x73, 0x53, 0x65, 0x72, 0x69, 0x61, 0x6c,\n-\t0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x12, 0x26, 0x0a, 0x0e, 0x73, 0x79, 0x73, 0x50, 0x72, 0x6f,\n-\t0x64, 0x75, 0x63, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e,\n-\t0x73, 0x79, 0x73, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x28,\n-\t0x0a, 0x0f, 0x73, 0x79, 0x73, 0x4d, 0x61, 0x6e, 0x75, 0x66, 0x61, 0x63, 0x74, 0x75, 0x72, 0x65,\n-\t0x72, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x73, 0x79, 0x73, 0x4d, 0x61, 0x6e, 0x75,\n-\t0x66, 0x61, 0x63, 0x74, 0x75, 0x72, 0x65, 0x72, 0x12, 0x39, 0x0a, 0x0b, 0x65, 0x6e, 0x76, 0x69,\n-\t0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e,\n-\t0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x76, 0x69, 0x72,\n-\t0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x52, 0x0b, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d,\n-\t0x65, 0x6e, 0x74, 0x12, 0x26, 0x0a, 0x05, 0x66, 0x69, 0x6c, 0x65, 0x73, 0x18, 0x10, 0x20, 0x03,\n-\t0x28, 0x0b, 0x32, 0x10, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e,\n-\t0x46, 0x69, 0x6c, 0x65, 0x52, 0x05, 0x66, 0x69, 0x6c, 0x65, 0x73, 0x12, 0x27, 0x0a, 0x05, 0x66,\n-\t0x6c, 0x61, 0x67, 0x73, 0x18, 0x11, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x61, 0x6e,\n-\t0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x46, 0x6c, 0x61, 0x67, 0x73, 0x52, 0x05, 0x66,\n-\t0x6c, 0x61, 0x67, 0x73, 0x22, 0xb4, 0x01, 0x0a, 0x0d, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65,\n-\t0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x3f, 0x0a, 0x0d, 0x6e, 0x65, 0x74, 0x62, 0x69, 0x72,\n-\t0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e,\n-\t0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4e, 0x65, 0x74, 0x62, 0x69,\n-\t0x72, 0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0d, 0x6e, 0x65, 0x74, 0x62, 0x69, 0x72,\n-\t0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x36, 0x0a, 0x0a, 0x70, 0x65, 0x65, 0x72, 0x43,\n-\t0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61,\n-\t0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e,\n-\t0x66, 0x69, 0x67, 0x52, 0x0a, 0x70, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12,\n-\t0x2a, 0x0a, 0x06, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32,\n-\t0x12, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x43, 0x68, 0x65,\n-\t0x63, 0x6b, 0x73, 0x52, 0x06, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x73, 0x22, 0x79, 0x0a, 0x11, 0x53,\n-\t0x65, 0x72, 0x76, 0x65, 0x72, 0x4b, 0x65, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,\n-\t0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b,\n-\t0x65, 0x79, 0x12, 0x38, 0x0a, 0x09, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x41, 0x74, 0x18,\n-\t0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,\n-\t0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,\n-\t0x70, 0x52, 0x09, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x41, 0x74, 0x12, 0x18, 0x0a, 0x07,\n-\t0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x07, 0x76,\n-\t0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0x07, 0x0a, 0x05, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22,\n-\t0xff, 0x01, 0x0a, 0x0d, 0x4e, 0x65, 0x74, 0x62, 0x69, 0x72, 0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69,\n-\t0x67, 0x12, 0x2c, 0x0a, 0x05, 0x73, 0x74, 0x75, 0x6e, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b,\n-\t0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x48, 0x6f,\n-\t0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x05, 0x73, 0x74, 0x75, 0x6e, 0x73, 0x12,\n-\t0x35, 0x0a, 0x05, 0x74, 0x75, 0x72, 0x6e, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1f,\n-\t0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x72, 0x6f, 0x74,\n-\t0x65, 0x63, 0x74, 0x65, 0x64, 0x48, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52,\n-\t0x05, 0x74, 0x75, 0x72, 0x6e, 0x73, 0x12, 0x2e, 0x0a, 0x06, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c,\n-\t0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d,\n-\t0x65, 0x6e, 0x74, 0x2e, 0x48, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x06,\n-\t0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x12, 0x2d, 0x0a, 0x05, 0x72, 0x65, 0x6c, 0x61, 0x79, 0x18,\n-\t0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65,\n-\t0x6e, 0x74, 0x2e, 0x52, 0x65, 0x6c, 0x61, 0x79, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x05,\n-\t0x72, 0x65, 0x6c, 0x61, 0x79, 0x12, 0x2a, 0x0a, 0x04, 0x66, 0x6c, 0x6f, 0x77, 0x18, 0x05, 0x20,\n-\t0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74,\n-\t0x2e, 0x46, 0x6c, 0x6f, 0x77, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x04, 0x66, 0x6c, 0x6f,\n-\t0x77, 0x22, 0x98, 0x01, 0x0a, 0x0a, 0x48, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,\n-\t0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x69, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x75,\n-\t0x72, 0x69, 0x12, 0x3b, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x02,\n-\t0x20, 0x01, 0x28, 0x0e, 0x32, 0x1f, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e,\n-\t0x74, 0x2e, 0x48, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x50, 0x72, 0x6f,\n-\t0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x52, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x22,\n-\t0x3b, 0x0a, 0x08, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x07, 0x0a, 0x03, 0x55,\n-\t0x44, 0x50, 0x10, 0x00, 0x12, 0x07, 0x0a, 0x03, 0x54, 0x43, 0x50, 0x10, 0x01, 0x12, 0x08, 0x0a,\n-\t0x04, 0x48, 0x54, 0x54, 0x50, 0x10, 0x02, 0x12, 0x09, 0x0a, 0x05, 0x48, 0x54, 0x54, 0x50, 0x53,\n-\t0x10, 0x03, 0x12, 0x08, 0x0a, 0x04, 0x44, 0x54, 0x4c, 0x53, 0x10, 0x04, 0x22, 0x6d, 0x0a, 0x0b,\n-\t0x52, 0x65, 0x6c, 0x61, 0x79, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x12, 0x0a, 0x04, 0x75,\n-\t0x72, 0x6c, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x04, 0x75, 0x72, 0x6c, 0x73, 0x12,\n-\t0x22, 0x0a, 0x0c, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x18,\n-\t0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x50, 0x61, 0x79, 0x6c,\n-\t0x6f, 0x61, 0x64, 0x12, 0x26, 0x0a, 0x0e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x53, 0x69, 0x67, 0x6e,\n-\t0x61, 0x74, 0x75, 0x72, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x74, 0x6f, 0x6b,\n-\t0x65, 0x6e, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x22, 0xad, 0x02, 0x0a, 0x0a,\n-\t0x46, 0x6c, 0x6f, 0x77, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72,\n-\t0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x75, 0x72, 0x6c, 0x12, 0x22, 0x0a, 0x0c,\n-\t0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x18, 0x02, 0x20, 0x01,\n-\t0x28, 0x09, 0x52, 0x0c, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64,\n-\t0x12, 0x26, 0x0a, 0x0e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75,\n-\t0x72, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x53,\n-\t0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x12, 0x35, 0x0a, 0x08, 0x69, 0x6e, 0x74, 0x65,\n-\t0x72, 0x76, 0x61, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f,\n-\t0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72,\n-\t0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x08, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x12,\n-\t0x18, 0x0a, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08,\n-\t0x52, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x6f, 0x75,\n-\t0x6e, 0x74, 0x65, 0x72, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x63, 0x6f, 0x75,\n-\t0x6e, 0x74, 0x65, 0x72, 0x73, 0x12, 0x2e, 0x0a, 0x12, 0x65, 0x78, 0x69, 0x74, 0x4e, 0x6f, 0x64,\n-\t0x65, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x07, 0x20, 0x01, 0x28,\n-\t0x08, 0x52, 0x12, 0x65, 0x78, 0x69, 0x74, 0x4e, 0x6f, 0x64, 0x65, 0x43, 0x6f, 0x6c, 0x6c, 0x65,\n-\t0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x24, 0x0a, 0x0d, 0x64, 0x6e, 0x73, 0x43, 0x6f, 0x6c, 0x6c,\n-\t0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x64, 0x6e,\n-\t0x73, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x7d, 0x0a, 0x13, 0x50,\n-\t0x72, 0x6f, 0x74, 0x65, 0x63, 0x74, 0x65, 0x64, 0x48, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66,\n-\t0x69, 0x67, 0x12, 0x36, 0x0a, 0x0a, 0x68, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,\n-\t0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d,\n-\t0x65, 0x6e, 0x74, 0x2e, 0x48, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0a,\n-\t0x68, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x73,\n-\t0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x12, 0x1a,\n-\t0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,\n-\t0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x22, 0x93, 0x02, 0x0a, 0x0a, 0x50,\n-\t0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x64, 0x64,\n-\t0x72, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72,\n-\t0x65, 0x73, 0x73, 0x12, 0x10, 0x0a, 0x03, 0x64, 0x6e, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,\n-\t0x52, 0x03, 0x64, 0x6e, 0x73, 0x12, 0x33, 0x0a, 0x09, 0x73, 0x73, 0x68, 0x43, 0x6f, 0x6e, 0x66,\n-\t0x69, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67,\n-\t0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x53, 0x48, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52,\n-\t0x09, 0x73, 0x73, 0x68, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x12, 0x0a, 0x04, 0x66, 0x71,\n-\t0x64, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x66, 0x71, 0x64, 0x6e, 0x12, 0x48,\n-\t0x0a, 0x1f, 0x52, 0x6f, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x50, 0x65, 0x65, 0x72, 0x44, 0x6e, 0x73,\n-\t0x52, 0x65, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65,\n-\t0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x1f, 0x52, 0x6f, 0x75, 0x74, 0x69, 0x6e, 0x67,\n-\t0x50, 0x65, 0x65, 0x72, 0x44, 0x6e, 0x73, 0x52, 0x65, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f,\n-\t0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x34, 0x0a, 0x15, 0x4c, 0x61, 0x7a, 0x79,\n-\t0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65,\n-\t0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x15, 0x4c, 0x61, 0x7a, 0x79, 0x43, 0x6f, 0x6e,\n-\t0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x10,\n-\t0x0a, 0x03, 0x6d, 0x74, 0x75, 0x18, 0x07, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x6d, 0x74, 0x75,\n-\t0x22, 0xb9, 0x05, 0x0a, 0x0a, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x4d, 0x61, 0x70, 0x12,\n-\t0x16, 0x0a, 0x06, 0x53, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52,\n-\t0x06, 0x53, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x12, 0x36, 0x0a, 0x0a, 0x70, 0x65, 0x65, 0x72, 0x43,\n-\t0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61,\n-\t0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e,\n-\t0x66, 0x69, 0x67, 0x52, 0x0a, 0x70, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12,\n-\t0x3e, 0x0a, 0x0b, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x73, 0x18, 0x03,\n+\t0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12,\n+\t0x24, 0x0a, 0x0d, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x53, 0x48, 0x52, 0x6f, 0x6f, 0x74,\n+\t0x18, 0x0b, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x53,\n+\t0x48, 0x52, 0x6f, 0x6f, 0x74, 0x12, 0x24, 0x0a, 0x0d, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x53,\n+\t0x53, 0x48, 0x53, 0x46, 0x54, 0x50, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x65, 0x6e,\n+\t0x61, 0x62, 0x6c, 0x65, 0x53, 0x53, 0x48, 0x53, 0x46, 0x54, 0x50, 0x12, 0x42, 0x0a, 0x1c, 0x65,\n+\t0x6e, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x53, 0x48, 0x4c, 0x6f, 0x63, 0x61, 0x6c, 0x50, 0x6f, 0x72,\n+\t0x74, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x18, 0x0d, 0x20, 0x01, 0x28,\n+\t0x08, 0x52, 0x1c, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x53, 0x48, 0x4c, 0x6f, 0x63, 0x61,\n+\t0x6c, 0x50, 0x6f, 0x72, 0x74, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x12,\n+\t0x44, 0x0a, 0x1d, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x53, 0x48, 0x52, 0x65, 0x6d, 0x6f,\n+\t0x74, 0x65, 0x50, 0x6f, 0x72, 0x74, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x69, 0x6e, 0x67,\n+\t0x18, 0x0e, 0x20, 0x01, 0x28, 0x08, 0x52, 0x1d, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x53,\n+\t0x48, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x6f, 0x72, 0x74, 0x46, 0x6f, 0x72, 0x77, 0x61,\n+\t0x72, 0x64, 0x69, 0x6e, 0x67, 0x12, 0x26, 0x0a, 0x0e, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65,\n+\t0x53, 0x53, 0x48, 0x41, 0x75, 0x74, 0x68, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0e, 0x64,\n+\t0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x53, 0x48, 0x41, 0x75, 0x74, 0x68, 0x22, 0xf2, 0x04,\n+\t0x0a, 0x0e, 0x50, 0x65, 0x65, 0x72, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x4d, 0x65, 0x74, 0x61,\n+\t0x12, 0x1a, 0x0a, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01,\n+\t0x28, 0x09, 0x52, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x12, 0x0a, 0x04,\n+\t0x67, 0x6f, 0x4f, 0x53, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x67, 0x6f, 0x4f, 0x53,\n+\t0x12, 0x16, 0x0a, 0x06, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,\n+\t0x52, 0x06, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x12, 0x12, 0x0a, 0x04, 0x63, 0x6f, 0x72, 0x65,\n+\t0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x63, 0x6f, 0x72, 0x65, 0x12, 0x1a, 0x0a, 0x08,\n+\t0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08,\n+\t0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x12, 0x0e, 0x0a, 0x02, 0x4f, 0x53, 0x18, 0x06,\n+\t0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x4f, 0x53, 0x12, 0x26, 0x0a, 0x0e, 0x6e, 0x65, 0x74, 0x62,\n+\t0x69, 0x72, 0x64, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09,\n+\t0x52, 0x0e, 0x6e, 0x65, 0x74, 0x62, 0x69, 0x72, 0x64, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,\n+\t0x12, 0x1c, 0x0a, 0x09, 0x75, 0x69, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x08, 0x20,\n+\t0x01, 0x28, 0x09, 0x52, 0x09, 0x75, 0x69, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x24,\n+\t0x0a, 0x0d, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18,\n+\t0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x56, 0x65, 0x72,\n+\t0x73, 0x69, 0x6f, 0x6e, 0x12, 0x1c, 0x0a, 0x09, 0x4f, 0x53, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f,\n+\t0x6e, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x4f, 0x53, 0x56, 0x65, 0x72, 0x73, 0x69,\n+\t0x6f, 0x6e, 0x12, 0x46, 0x0a, 0x10, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x41, 0x64, 0x64,\n+\t0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x18, 0x0b, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x6d,\n+\t0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72,\n+\t0x6b, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x10, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72,\n+\t0x6b, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x12, 0x28, 0x0a, 0x0f, 0x73, 0x79,\n+\t0x73, 0x53, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x0c, 0x20,\n+\t0x01, 0x28, 0x09, 0x52, 0x0f, 0x73, 0x79, 0x73, 0x53, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x4e, 0x75,\n+\t0x6d, 0x62, 0x65, 0x72, 0x12, 0x26, 0x0a, 0x0e, 0x73, 0x79, 0x73, 0x50, 0x72, 0x6f, 0x64, 0x75,\n+\t0x63, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x73, 0x79,\n+\t0x73, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x28, 0x0a, 0x0f,\n+\t0x73, 0x79, 0x73, 0x4d, 0x61, 0x6e, 0x75, 0x66, 0x61, 0x63, 0x74, 0x75, 0x72, 0x65, 0x72, 0x18,\n+\t0x0e, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x73, 0x79, 0x73, 0x4d, 0x61, 0x6e, 0x75, 0x66, 0x61,\n+\t0x63, 0x74, 0x75, 0x72, 0x65, 0x72, 0x12, 0x39, 0x0a, 0x0b, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f,\n+\t0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x6d, 0x61,\n+\t0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e,\n+\t0x6d, 0x65, 0x6e, 0x74, 0x52, 0x0b, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e,\n+\t0x74, 0x12, 0x26, 0x0a, 0x05, 0x66, 0x69, 0x6c, 0x65, 0x73, 0x18, 0x10, 0x20, 0x03, 0x28, 0x0b,\n+\t0x32, 0x10, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x46, 0x69,\n+\t0x6c, 0x65, 0x52, 0x05, 0x66, 0x69, 0x6c, 0x65, 0x73, 0x12, 0x27, 0x0a, 0x05, 0x66, 0x6c, 0x61,\n+\t0x67, 0x73, 0x18, 0x11, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67,\n+\t0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x46, 0x6c, 0x61, 0x67, 0x73, 0x52, 0x05, 0x66, 0x6c, 0x61,\n+\t0x67, 0x73, 0x22, 0xb4, 0x01, 0x0a, 0x0d, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x73, 0x70,\n+\t0x6f, 0x6e, 0x73, 0x65, 0x12, 0x3f, 0x0a, 0x0d, 0x6e, 0x65, 0x74, 0x62, 0x69, 0x72, 0x64, 0x43,\n+\t0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x6d, 0x61,\n+\t0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4e, 0x65, 0x74, 0x62, 0x69, 0x72, 0x64,\n+\t0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0d, 0x6e, 0x65, 0x74, 0x62, 0x69, 0x72, 0x64, 0x43,\n+\t0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x36, 0x0a, 0x0a, 0x70, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e,\n+\t0x66, 0x69, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61,\n+\t0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69,\n+\t0x67, 0x52, 0x0a, 0x70, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x2a, 0x0a,\n+\t0x06, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e,\n+\t0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x43, 0x68, 0x65, 0x63, 0x6b,\n+\t0x73, 0x52, 0x06, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x73, 0x22, 0x79, 0x0a, 0x11, 0x53, 0x65, 0x72,\n+\t0x76, 0x65, 0x72, 0x4b, 0x65, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x10,\n+\t0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79,\n+\t0x12, 0x38, 0x0a, 0x09, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x41, 0x74, 0x18, 0x02, 0x20,\n+\t0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,\n+\t0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52,\n+\t0x09, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x41, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x76, 0x65,\n+\t0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x07, 0x76, 0x65, 0x72,\n+\t0x73, 0x69, 0x6f, 0x6e, 0x22, 0x07, 0x0a, 0x05, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0xa8, 0x02,\n+\t0x0a, 0x0d, 0x4e, 0x65, 0x74, 0x62, 0x69, 0x72, 0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12,\n+\t0x2c, 0x0a, 0x05, 0x73, 0x74, 0x75, 0x6e, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16,\n+\t0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x48, 0x6f, 0x73, 0x74,\n+\t0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x05, 0x73, 0x74, 0x75, 0x6e, 0x73, 0x12, 0x35, 0x0a,\n+\t0x05, 0x74, 0x75, 0x72, 0x6e, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x6d,\n+\t0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x65, 0x63,\n+\t0x74, 0x65, 0x64, 0x48, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x05, 0x74,\n+\t0x75, 0x72, 0x6e, 0x73, 0x12, 0x2e, 0x0a, 0x06, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x18, 0x03,\n+\t0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e,\n+\t0x74, 0x2e, 0x48, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x06, 0x73, 0x69,\n+\t0x67, 0x6e, 0x61, 0x6c, 0x12, 0x2d, 0x0a, 0x05, 0x72, 0x65, 0x6c, 0x61, 0x79, 0x18, 0x04, 0x20,\n+\t0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74,\n+\t0x2e, 0x52, 0x65, 0x6c, 0x61, 0x79, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x05, 0x72, 0x65,\n+\t0x6c, 0x61, 0x79, 0x12, 0x2a, 0x0a, 0x04, 0x66, 0x6c, 0x6f, 0x77, 0x18, 0x05, 0x20, 0x01, 0x28,\n+\t0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x46,\n+\t0x6c, 0x6f, 0x77, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x04, 0x66, 0x6c, 0x6f, 0x77, 0x12,\n+\t0x27, 0x0a, 0x03, 0x6a, 0x77, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d,\n+\t0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4a, 0x57, 0x54, 0x43, 0x6f, 0x6e,\n+\t0x66, 0x69, 0x67, 0x52, 0x03, 0x6a, 0x77, 0x74, 0x22, 0x98, 0x01, 0x0a, 0x0a, 0x48, 0x6f, 0x73,\n+\t0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x69, 0x18, 0x01,\n+\t0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x75, 0x72, 0x69, 0x12, 0x3b, 0x0a, 0x08, 0x70, 0x72, 0x6f,\n+\t0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1f, 0x2e, 0x6d, 0x61,\n+\t0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x48, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e,\n+\t0x66, 0x69, 0x67, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x52, 0x08, 0x70, 0x72,\n+\t0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x22, 0x3b, 0x0a, 0x08, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63,\n+\t0x6f, 0x6c, 0x12, 0x07, 0x0a, 0x03, 0x55, 0x44, 0x50, 0x10, 0x00, 0x12, 0x07, 0x0a, 0x03, 0x54,\n+\t0x43, 0x50, 0x10, 0x01, 0x12, 0x08, 0x0a, 0x04, 0x48, 0x54, 0x54, 0x50, 0x10, 0x02, 0x12, 0x09,\n+\t0x0a, 0x05, 0x48, 0x54, 0x54, 0x50, 0x53, 0x10, 0x03, 0x12, 0x08, 0x0a, 0x04, 0x44, 0x54, 0x4c,\n+\t0x53, 0x10, 0x04, 0x22, 0x6d, 0x0a, 0x0b, 0x52, 0x65, 0x6c, 0x61, 0x79, 0x43, 0x6f, 0x6e, 0x66,\n+\t0x69, 0x67, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x72, 0x6c, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09,\n+\t0x52, 0x04, 0x75, 0x72, 0x6c, 0x73, 0x12, 0x22, 0x0a, 0x0c, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x50,\n+\t0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x74, 0x6f,\n+\t0x6b, 0x65, 0x6e, 0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x26, 0x0a, 0x0e, 0x74, 0x6f,\n+\t0x6b, 0x65, 0x6e, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x18, 0x03, 0x20, 0x01,\n+\t0x28, 0x09, 0x52, 0x0e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75,\n+\t0x72, 0x65, 0x22, 0xad, 0x02, 0x0a, 0x0a, 0x46, 0x6c, 0x6f, 0x77, 0x43, 0x6f, 0x6e, 0x66, 0x69,\n+\t0x67, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03,\n+\t0x75, 0x72, 0x6c, 0x12, 0x22, 0x0a, 0x0c, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x50, 0x61, 0x79, 0x6c,\n+\t0x6f, 0x61, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x74, 0x6f, 0x6b, 0x65, 0x6e,\n+\t0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x26, 0x0a, 0x0e, 0x74, 0x6f, 0x6b, 0x65, 0x6e,\n+\t0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52,\n+\t0x0e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x12,\n+\t0x35, 0x0a, 0x08, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28,\n+\t0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,\n+\t0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x08, 0x69, 0x6e,\n+\t0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x12, 0x18, 0x0a, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65,\n+\t0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64,\n+\t0x12, 0x1a, 0x0a, 0x08, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x73, 0x18, 0x06, 0x20, 0x01,\n+\t0x28, 0x08, 0x52, 0x08, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x73, 0x12, 0x2e, 0x0a, 0x12,\n+\t0x65, 0x78, 0x69, 0x74, 0x4e, 0x6f, 0x64, 0x65, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69,\n+\t0x6f, 0x6e, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x52, 0x12, 0x65, 0x78, 0x69, 0x74, 0x4e, 0x6f,\n+\t0x64, 0x65, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x24, 0x0a, 0x0d,\n+\t0x64, 0x6e, 0x73, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x08, 0x20,\n+\t0x01, 0x28, 0x08, 0x52, 0x0d, 0x64, 0x6e, 0x73, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69,\n+\t0x6f, 0x6e, 0x22, 0x85, 0x01, 0x0a, 0x09, 0x4a, 0x57, 0x54, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,\n+\t0x12, 0x16, 0x0a, 0x06, 0x69, 0x73, 0x73, 0x75, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,\n+\t0x52, 0x06, 0x69, 0x73, 0x73, 0x75, 0x65, 0x72, 0x12, 0x1a, 0x0a, 0x08, 0x61, 0x75, 0x64, 0x69,\n+\t0x65, 0x6e, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x61, 0x75, 0x64, 0x69,\n+\t0x65, 0x6e, 0x63, 0x65, 0x12, 0x22, 0x0a, 0x0c, 0x6b, 0x65, 0x79, 0x73, 0x4c, 0x6f, 0x63, 0x61,\n+\t0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x6b, 0x65, 0x79, 0x73,\n+\t0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x20, 0x0a, 0x0b, 0x6d, 0x61, 0x78, 0x54,\n+\t0x6f, 0x6b, 0x65, 0x6e, 0x41, 0x67, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0b, 0x6d,\n+\t0x61, 0x78, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x41, 0x67, 0x65, 0x22, 0x7d, 0x0a, 0x13, 0x50, 0x72,\n+\t0x6f, 0x74, 0x65, 0x63, 0x74, 0x65, 0x64, 0x48, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69,\n+\t0x67, 0x12, 0x36, 0x0a, 0x0a, 0x68, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18,\n+\t0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65,\n+\t0x6e, 0x74, 0x2e, 0x48, 0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0a, 0x68,\n+\t0x6f, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x73, 0x65,\n+\t0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x12, 0x1a, 0x0a,\n+\t0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52,\n+\t0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x22, 0x93, 0x02, 0x0a, 0x0a, 0x50, 0x65,\n+\t0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72,\n+\t0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65,\n+\t0x73, 0x73, 0x12, 0x10, 0x0a, 0x03, 0x64, 0x6e, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,\n+\t0x03, 0x64, 0x6e, 0x73, 0x12, 0x33, 0x0a, 0x09, 0x73, 0x73, 0x68, 0x43, 0x6f, 0x6e, 0x66, 0x69,\n+\t0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65,\n+\t0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x53, 0x48, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x09,\n+\t0x73, 0x73, 0x68, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x12, 0x0a, 0x04, 0x66, 0x71, 0x64,\n+\t0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x66, 0x71, 0x64, 0x6e, 0x12, 0x48, 0x0a,\n+\t0x1f, 0x52, 0x6f, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x50, 0x65, 0x65, 0x72, 0x44, 0x6e, 0x73, 0x52,\n+\t0x65, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64,\n+\t0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x1f, 0x52, 0x6f, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x50,\n+\t0x65, 0x65, 0x72, 0x44, 0x6e, 0x73, 0x52, 0x65, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e,\n+\t0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x34, 0x0a, 0x15, 0x4c, 0x61, 0x7a, 0x79, 0x43,\n+\t0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64,\n+\t0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x15, 0x4c, 0x61, 0x7a, 0x79, 0x43, 0x6f, 0x6e, 0x6e,\n+\t0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x10, 0x0a,\n+\t0x03, 0x6d, 0x74, 0x75, 0x18, 0x07, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x6d, 0x74, 0x75, 0x22,\n+\t0xb9, 0x05, 0x0a, 0x0a, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x4d, 0x61, 0x70, 0x12, 0x16,\n+\t0x0a, 0x06, 0x53, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06,\n+\t0x53, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x12, 0x36, 0x0a, 0x0a, 0x70, 0x65, 0x65, 0x72, 0x43, 0x6f,\n+\t0x6e, 0x66, 0x69, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e,\n+\t0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66,\n+\t0x69, 0x67, 0x52, 0x0a, 0x70, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x3e,\n+\t0x0a, 0x0b, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x73, 0x18, 0x03, 0x20,\n+\t0x03, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74,\n+\t0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69,\n+\t0x67, 0x52, 0x0b, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x73, 0x12, 0x2e,\n+\t0x0a, 0x12, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x73, 0x49, 0x73, 0x45,\n+\t0x6d, 0x70, 0x74, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x12, 0x72, 0x65, 0x6d, 0x6f,\n+\t0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x73, 0x49, 0x73, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x29,\n+\t0x0a, 0x06, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x11,\n+\t0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x6f, 0x75, 0x74,\n+\t0x65, 0x52, 0x06, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x12, 0x33, 0x0a, 0x09, 0x44, 0x4e, 0x53,\n+\t0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d,\n+\t0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x44, 0x4e, 0x53, 0x43, 0x6f, 0x6e,\n+\t0x66, 0x69, 0x67, 0x52, 0x09, 0x44, 0x4e, 0x53, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x40,\n+\t0x0a, 0x0c, 0x6f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65, 0x50, 0x65, 0x65, 0x72, 0x73, 0x18, 0x07,\n \t0x20, 0x03, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e,\n \t0x74, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66,\n-\t0x69, 0x67, 0x52, 0x0b, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x73, 0x12,\n-\t0x2e, 0x0a, 0x12, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x73, 0x49, 0x73,\n-\t0x45, 0x6d, 0x70, 0x74, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x12, 0x72, 0x65, 0x6d,\n-\t0x6f, 0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x73, 0x49, 0x73, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12,\n-\t0x29, 0x0a, 0x06, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32,\n-\t0x11, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x6f, 0x75,\n-\t0x74, 0x65, 0x52, 0x06, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x12, 0x33, 0x0a, 0x09, 0x44, 0x4e,\n-\t0x53, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e,\n-\t0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x44, 0x4e, 0x53, 0x43, 0x6f,\n-\t0x6e, 0x66, 0x69, 0x67, 0x52, 0x09, 0x44, 0x4e, 0x53, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12,\n-\t0x40, 0x0a, 0x0c, 0x6f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65, 0x50, 0x65, 0x65, 0x72, 0x73, 0x18,\n-\t0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65,\n-\t0x6e, 0x74, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e,\n-\t0x66, 0x69, 0x67, 0x52, 0x0c, 0x6f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65, 0x50, 0x65, 0x65, 0x72,\n-\t0x73, 0x12, 0x3e, 0x0a, 0x0d, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c,\n-\t0x65, 0x73, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67,\n-\t0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75,\n-\t0x6c, 0x65, 0x52, 0x0d, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65,\n-\t0x73, 0x12, 0x32, 0x0a, 0x14, 0x66, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c,\n-\t0x65, 0x73, 0x49, 0x73, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x52,\n-\t0x14, 0x66, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x49, 0x73,\n-\t0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x4f, 0x0a, 0x13, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x46,\n-\t0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x18, 0x0a, 0x20, 0x03,\n-\t0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e,\n-\t0x52, 0x6f, 0x75, 0x74, 0x65, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c,\n-\t0x65, 0x52, 0x13, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c,\n-\t0x6c, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x3e, 0x0a, 0x1a, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73,\n-\t0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x49, 0x73, 0x45,\n-\t0x6d, 0x70, 0x74, 0x79, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x08, 0x52, 0x1a, 0x72, 0x6f, 0x75, 0x74,\n-\t0x65, 0x73, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x49,\n-\t0x73, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x44, 0x0a, 0x0f, 0x66, 0x6f, 0x72, 0x77, 0x61, 0x72,\n-\t0x64, 0x69, 0x6e, 0x67, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x18, 0x0c, 0x20, 0x03, 0x28, 0x0b, 0x32,\n-\t0x1a, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x46, 0x6f, 0x72,\n-\t0x77, 0x61, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x75, 0x6c, 0x65, 0x52, 0x0f, 0x66, 0x6f, 0x72,\n-\t0x77, 0x61, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x22, 0xbb, 0x01, 0x0a,\n-\t0x10, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69,\n-\t0x67, 0x12, 0x1a, 0x0a, 0x08, 0x77, 0x67, 0x50, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x18, 0x01, 0x20,\n-\t0x01, 0x28, 0x09, 0x52, 0x08, 0x77, 0x67, 0x50, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x12, 0x1e, 0x0a,\n-\t0x0a, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x49, 0x70, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28,\n-\t0x09, 0x52, 0x0a, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x49, 0x70, 0x73, 0x12, 0x33, 0x0a,\n-\t0x09, 0x73, 0x73, 0x68, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b,\n-\t0x32, 0x15, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x53,\n-\t0x48, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x09, 0x73, 0x73, 0x68, 0x43, 0x6f, 0x6e, 0x66,\n-\t0x69, 0x67, 0x12, 0x12, 0x0a, 0x04, 0x66, 0x71, 0x64, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09,\n-\t0x52, 0x04, 0x66, 0x71, 0x64, 0x6e, 0x12, 0x22, 0x0a, 0x0c, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x56,\n-\t0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x61, 0x67,\n-\t0x65, 0x6e, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0x49, 0x0a, 0x09, 0x53, 0x53,\n-\t0x48, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x1e, 0x0a, 0x0a, 0x73, 0x73, 0x68, 0x45, 0x6e,\n-\t0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x73, 0x73, 0x68,\n-\t0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x1c, 0x0a, 0x09, 0x73, 0x73, 0x68, 0x50, 0x75,\n-\t0x62, 0x4b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x09, 0x73, 0x73, 0x68, 0x50,\n-\t0x75, 0x62, 0x4b, 0x65, 0x79, 0x22, 0x20, 0x0a, 0x1e, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x41,\n-\t0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x6f, 0x77,\n-\t0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0xbf, 0x01, 0x0a, 0x17, 0x44, 0x65, 0x76, 0x69,\n-\t0x63, 0x65, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46,\n-\t0x6c, 0x6f, 0x77, 0x12, 0x48, 0x0a, 0x08, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x18,\n-\t0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65,\n-\t0x6e, 0x74, 0x2e, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69,\n-\t0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x6f, 0x77, 0x2e, 0x70, 0x72, 0x6f, 0x76, 0x69,\n-\t0x64, 0x65, 0x72, 0x52, 0x08, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x12, 0x42, 0x0a,\n-\t0x0e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18,\n-\t0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65,\n-\t0x6e, 0x74, 0x2e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69,\n-\t0x67, 0x52, 0x0e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69,\n-\t0x67, 0x22, 0x16, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x12, 0x0a, 0x0a,\n-\t0x06, 0x48, 0x4f, 0x53, 0x54, 0x45, 0x44, 0x10, 0x00, 0x22, 0x1e, 0x0a, 0x1c, 0x50, 0x4b, 0x43,\n-\t0x45, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c,\n-\t0x6f, 0x77, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x5b, 0x0a, 0x15, 0x50, 0x4b, 0x43,\n-\t0x45, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c,\n-\t0x6f, 0x77, 0x12, 0x42, 0x0a, 0x0e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43, 0x6f,\n-\t0x6e, 0x66, 0x69, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x6d, 0x61, 0x6e,\n-\t0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72,\n-\t0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72,\n-\t0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x22, 0xb8, 0x03, 0x0a, 0x0e, 0x50, 0x72, 0x6f, 0x76, 0x69,\n-\t0x64, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x1a, 0x0a, 0x08, 0x43, 0x6c, 0x69,\n-\t0x65, 0x6e, 0x74, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x43, 0x6c, 0x69,\n-\t0x65, 0x6e, 0x74, 0x49, 0x44, 0x12, 0x22, 0x0a, 0x0c, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x53,\n-\t0x65, 0x63, 0x72, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x43, 0x6c, 0x69,\n-\t0x65, 0x6e, 0x74, 0x53, 0x65, 0x63, 0x72, 0x65, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x44, 0x6f, 0x6d,\n-\t0x61, 0x69, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x44, 0x6f, 0x6d, 0x61, 0x69,\n-\t0x6e, 0x12, 0x1a, 0x0a, 0x08, 0x41, 0x75, 0x64, 0x69, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x04, 0x20,\n-\t0x01, 0x28, 0x09, 0x52, 0x08, 0x41, 0x75, 0x64, 0x69, 0x65, 0x6e, 0x63, 0x65, 0x12, 0x2e, 0x0a,\n-\t0x12, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x41, 0x75, 0x74, 0x68, 0x45, 0x6e, 0x64, 0x70, 0x6f,\n-\t0x69, 0x6e, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x12, 0x44, 0x65, 0x76, 0x69, 0x63,\n-\t0x65, 0x41, 0x75, 0x74, 0x68, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x12, 0x24, 0x0a,\n-\t0x0d, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x06,\n-\t0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x45, 0x6e, 0x64, 0x70, 0x6f,\n-\t0x69, 0x6e, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x53, 0x63, 0x6f, 0x70, 0x65, 0x18, 0x07, 0x20, 0x01,\n-\t0x28, 0x09, 0x52, 0x05, 0x53, 0x63, 0x6f, 0x70, 0x65, 0x12, 0x1e, 0x0a, 0x0a, 0x55, 0x73, 0x65,\n-\t0x49, 0x44, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x55,\n-\t0x73, 0x65, 0x49, 0x44, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x34, 0x0a, 0x15, 0x41, 0x75, 0x74,\n-\t0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69,\n-\t0x6e, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x15, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72,\n-\t0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x12,\n-\t0x22, 0x0a, 0x0c, 0x52, 0x65, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x55, 0x52, 0x4c, 0x73, 0x18,\n-\t0x0a, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0c, 0x52, 0x65, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x55,\n-\t0x52, 0x4c, 0x73, 0x12, 0x2e, 0x0a, 0x12, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x72,\n-\t0x6f, 0x6d, 0x70, 0x74, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x08, 0x52,\n-\t0x12, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x6d, 0x70, 0x74, 0x4c, 0x6f,\n-\t0x67, 0x69, 0x6e, 0x12, 0x1c, 0x0a, 0x09, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x46, 0x6c, 0x61, 0x67,\n-\t0x18, 0x0c, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x46, 0x6c, 0x61,\n-\t0x67, 0x22, 0x93, 0x02, 0x0a, 0x05, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x49,\n-\t0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x49, 0x44, 0x12, 0x18, 0x0a, 0x07, 0x4e,\n-\t0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x4e, 0x65,\n-\t0x74, 0x77, 0x6f, 0x72, 0x6b, 0x12, 0x20, 0x0a, 0x0b, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b,\n-\t0x54, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0b, 0x4e, 0x65, 0x74, 0x77,\n-\t0x6f, 0x72, 0x6b, 0x54, 0x79, 0x70, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x50, 0x65, 0x65, 0x72, 0x18,\n-\t0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x50, 0x65, 0x65, 0x72, 0x12, 0x16, 0x0a, 0x06, 0x4d,\n-\t0x65, 0x74, 0x72, 0x69, 0x63, 0x18, 0x05, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x4d, 0x65, 0x74,\n-\t0x72, 0x69, 0x63, 0x12, 0x1e, 0x0a, 0x0a, 0x4d, 0x61, 0x73, 0x71, 0x75, 0x65, 0x72, 0x61, 0x64,\n-\t0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x4d, 0x61, 0x73, 0x71, 0x75, 0x65, 0x72,\n-\t0x61, 0x64, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x4e, 0x65, 0x74, 0x49, 0x44, 0x18, 0x07, 0x20, 0x01,\n-\t0x28, 0x09, 0x52, 0x05, 0x4e, 0x65, 0x74, 0x49, 0x44, 0x12, 0x18, 0x0a, 0x07, 0x44, 0x6f, 0x6d,\n-\t0x61, 0x69, 0x6e, 0x73, 0x18, 0x08, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x44, 0x6f, 0x6d, 0x61,\n-\t0x69, 0x6e, 0x73, 0x12, 0x1c, 0x0a, 0x09, 0x6b, 0x65, 0x65, 0x70, 0x52, 0x6f, 0x75, 0x74, 0x65,\n-\t0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x6b, 0x65, 0x65, 0x70, 0x52, 0x6f, 0x75, 0x74,\n-\t0x65, 0x12, 0x24, 0x0a, 0x0d, 0x73, 0x6b, 0x69, 0x70, 0x41, 0x75, 0x74, 0x6f, 0x41, 0x70, 0x70,\n-\t0x6c, 0x79, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x73, 0x6b, 0x69, 0x70, 0x41, 0x75,\n-\t0x74, 0x6f, 0x41, 0x70, 0x70, 0x6c, 0x79, 0x22, 0xda, 0x01, 0x0a, 0x09, 0x44, 0x4e, 0x53, 0x43,\n-\t0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x24, 0x0a, 0x0d, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,\n-\t0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x53, 0x65,\n-\t0x72, 0x76, 0x69, 0x63, 0x65, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x47, 0x0a, 0x10, 0x4e,\n-\t0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x73, 0x18,\n-\t0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65,\n-\t0x6e, 0x74, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x47, 0x72, 0x6f,\n-\t0x75, 0x70, 0x52, 0x10, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x47, 0x72,\n-\t0x6f, 0x75, 0x70, 0x73, 0x12, 0x38, 0x0a, 0x0b, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5a, 0x6f,\n-\t0x6e, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61,\n-\t0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5a, 0x6f, 0x6e,\n-\t0x65, 0x52, 0x0b, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5a, 0x6f, 0x6e, 0x65, 0x73, 0x12, 0x24,\n-\t0x0a, 0x0d, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x65, 0x72, 0x50, 0x6f, 0x72, 0x74, 0x18,\n-\t0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0d, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x65, 0x72,\n-\t0x50, 0x6f, 0x72, 0x74, 0x22, 0x58, 0x0a, 0x0a, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5a, 0x6f,\n-\t0x6e, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x18, 0x01, 0x20, 0x01,\n-\t0x28, 0x09, 0x52, 0x06, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x12, 0x32, 0x0a, 0x07, 0x52, 0x65,\n-\t0x63, 0x6f, 0x72, 0x64, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x6d, 0x61,\n-\t0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x52,\n-\t0x65, 0x63, 0x6f, 0x72, 0x64, 0x52, 0x07, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x22, 0x74,\n-\t0x0a, 0x0c, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x12, 0x12,\n-\t0x0a, 0x04, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x4e, 0x61,\n-\t0x6d, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x54, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03,\n-\t0x52, 0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x18,\n-\t0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x12, 0x10, 0x0a, 0x03,\n-\t0x54, 0x54, 0x4c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x03, 0x54, 0x54, 0x4c, 0x12, 0x14,\n-\t0x0a, 0x05, 0x52, 0x44, 0x61, 0x74, 0x61, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x52,\n-\t0x44, 0x61, 0x74, 0x61, 0x22, 0xb3, 0x01, 0x0a, 0x0f, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72,\n-\t0x76, 0x65, 0x72, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x12, 0x38, 0x0a, 0x0b, 0x4e, 0x61, 0x6d, 0x65,\n-\t0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e,\n-\t0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x53,\n-\t0x65, 0x72, 0x76, 0x65, 0x72, 0x52, 0x0b, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65,\n-\t0x72, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x50, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79, 0x18, 0x02, 0x20,\n-\t0x01, 0x28, 0x08, 0x52, 0x07, 0x50, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79, 0x12, 0x18, 0x0a, 0x07,\n-\t0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x44,\n-\t0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x12, 0x32, 0x0a, 0x14, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68,\n-\t0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x04,\n-\t0x20, 0x01, 0x28, 0x08, 0x52, 0x14, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x44, 0x6f, 0x6d, 0x61,\n-\t0x69, 0x6e, 0x73, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x22, 0x48, 0x0a, 0x0a, 0x4e, 0x61,\n-\t0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x12, 0x0e, 0x0a, 0x02, 0x49, 0x50, 0x18, 0x01,\n-\t0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x49, 0x50, 0x12, 0x16, 0x0a, 0x06, 0x4e, 0x53, 0x54, 0x79,\n-\t0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x4e, 0x53, 0x54, 0x79, 0x70, 0x65,\n-\t0x12, 0x12, 0x0a, 0x04, 0x50, 0x6f, 0x72, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x04,\n-\t0x50, 0x6f, 0x72, 0x74, 0x22, 0xa7, 0x02, 0x0a, 0x0c, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c,\n-\t0x6c, 0x52, 0x75, 0x6c, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x50, 0x65, 0x65, 0x72, 0x49, 0x50, 0x18,\n-\t0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x50, 0x65, 0x65, 0x72, 0x49, 0x50, 0x12, 0x37, 0x0a,\n-\t0x09, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e,\n-\t0x32, 0x19, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75,\n-\t0x6c, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x09, 0x44, 0x69, 0x72,\n-\t0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x2e, 0x0a, 0x06, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e,\n-\t0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d,\n-\t0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x06,\n-\t0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x34, 0x0a, 0x08, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63,\n-\t0x6f, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x18, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67,\n-\t0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63,\n-\t0x6f, 0x6c, 0x52, 0x08, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x12, 0x0a, 0x04,\n-\t0x50, 0x6f, 0x72, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x50, 0x6f, 0x72, 0x74,\n-\t0x12, 0x30, 0x0a, 0x08, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x18, 0x06, 0x20, 0x01,\n-\t0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e,\n-\t0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x08, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e,\n-\t0x66, 0x6f, 0x12, 0x1a, 0x0a, 0x08, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49, 0x44, 0x18, 0x07,\n-\t0x20, 0x01, 0x28, 0x0c, 0x52, 0x08, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49, 0x44, 0x22, 0x38,\n-\t0x0a, 0x0e, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,\n-\t0x12, 0x14, 0x0a, 0x05, 0x6e, 0x65, 0x74, 0x49, 0x50, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,\n-\t0x05, 0x6e, 0x65, 0x74, 0x49, 0x50, 0x12, 0x10, 0x0a, 0x03, 0x6d, 0x61, 0x63, 0x18, 0x02, 0x20,\n-\t0x01, 0x28, 0x09, 0x52, 0x03, 0x6d, 0x61, 0x63, 0x22, 0x1e, 0x0a, 0x06, 0x43, 0x68, 0x65, 0x63,\n-\t0x6b, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,\n-\t0x09, 0x52, 0x05, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x22, 0x96, 0x01, 0x0a, 0x08, 0x50, 0x6f, 0x72,\n-\t0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x14, 0x0a, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x01, 0x20,\n-\t0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x12, 0x32, 0x0a, 0x05, 0x72,\n-\t0x61, 0x6e, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x6d, 0x61, 0x6e,\n-\t0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f,\n-\t0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x48, 0x00, 0x52, 0x05, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x1a,\n-\t0x2f, 0x0a, 0x05, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x72,\n-\t0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x12, 0x10,\n-\t0x0a, 0x03, 0x65, 0x6e, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x03, 0x65, 0x6e, 0x64,\n-\t0x42, 0x0f, 0x0a, 0x0d, 0x70, 0x6f, 0x72, 0x74, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f,\n-\t0x6e, 0x22, 0x87, 0x03, 0x0a, 0x11, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x46, 0x69, 0x72, 0x65, 0x77,\n-\t0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x12, 0x22, 0x0a, 0x0c, 0x73, 0x6f, 0x75, 0x72, 0x63,\n-\t0x65, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0c, 0x73,\n-\t0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x12, 0x2e, 0x0a, 0x06, 0x61,\n-\t0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x16, 0x2e, 0x6d, 0x61,\n-\t0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x41, 0x63, 0x74,\n-\t0x69, 0x6f, 0x6e, 0x52, 0x06, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x20, 0x0a, 0x0b, 0x64,\n-\t0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,\n-\t0x52, 0x0b, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x34, 0x0a,\n-\t0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32,\n-\t0x18, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75, 0x6c,\n-\t0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x52, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f,\n-\t0x63, 0x6f, 0x6c, 0x12, 0x30, 0x0a, 0x08, 0x70, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x18,\n-\t0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65,\n-\t0x6e, 0x74, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x08, 0x70, 0x6f, 0x72,\n-\t0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x1c, 0x0a, 0x09, 0x69, 0x73, 0x44, 0x79, 0x6e, 0x61, 0x6d,\n-\t0x69, 0x63, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x69, 0x73, 0x44, 0x79, 0x6e, 0x61,\n-\t0x6d, 0x69, 0x63, 0x12, 0x18, 0x0a, 0x07, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x18, 0x07,\n-\t0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x12, 0x26, 0x0a,\n-\t0x0e, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18,\n-\t0x08, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0e, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x50, 0x72, 0x6f,\n-\t0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x1a, 0x0a, 0x08, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49,\n-\t0x44, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x08, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49,\n-\t0x44, 0x12, 0x18, 0x0a, 0x07, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x49, 0x44, 0x18, 0x0a, 0x20, 0x01,\n-\t0x28, 0x09, 0x52, 0x07, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x49, 0x44, 0x22, 0xf2, 0x01, 0x0a, 0x0e,\n-\t0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x75, 0x6c, 0x65, 0x12, 0x34,\n-\t0x0a, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e,\n-\t0x32, 0x18, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75,\n-\t0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x52, 0x08, 0x70, 0x72, 0x6f, 0x74,\n-\t0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x3e, 0x0a, 0x0f, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74,\n-\t0x69, 0x6f, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e,\n-\t0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x49,\n-\t0x6e, 0x66, 0x6f, 0x52, 0x0f, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e,\n-\t0x50, 0x6f, 0x72, 0x74, 0x12, 0x2c, 0x0a, 0x11, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74,\n-\t0x65, 0x64, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52,\n-\t0x11, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74, 0x65, 0x64, 0x41, 0x64, 0x64, 0x72, 0x65,\n-\t0x73, 0x73, 0x12, 0x3c, 0x0a, 0x0e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74, 0x65, 0x64,\n-\t0x50, 0x6f, 0x72, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x61, 0x6e,\n-\t0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f,\n-\t0x52, 0x0e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74, 0x65, 0x64, 0x50, 0x6f, 0x72, 0x74,\n-\t0x2a, 0x4c, 0x0a, 0x0c, 0x52, 0x75, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c,\n-\t0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x00, 0x12, 0x07, 0x0a,\n-\t0x03, 0x41, 0x4c, 0x4c, 0x10, 0x01, 0x12, 0x07, 0x0a, 0x03, 0x54, 0x43, 0x50, 0x10, 0x02, 0x12,\n-\t0x07, 0x0a, 0x03, 0x55, 0x44, 0x50, 0x10, 0x03, 0x12, 0x08, 0x0a, 0x04, 0x49, 0x43, 0x4d, 0x50,\n-\t0x10, 0x04, 0x12, 0x0a, 0x0a, 0x06, 0x43, 0x55, 0x53, 0x54, 0x4f, 0x4d, 0x10, 0x05, 0x2a, 0x20,\n-\t0x0a, 0x0d, 0x52, 0x75, 0x6c, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12,\n-\t0x06, 0x0a, 0x02, 0x49, 0x4e, 0x10, 0x00, 0x12, 0x07, 0x0a, 0x03, 0x4f, 0x55, 0x54, 0x10, 0x01,\n-\t0x2a, 0x22, 0x0a, 0x0a, 0x52, 0x75, 0x6c, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x0a,\n-\t0x0a, 0x06, 0x41, 0x43, 0x43, 0x45, 0x50, 0x54, 0x10, 0x00, 0x12, 0x08, 0x0a, 0x04, 0x44, 0x52,\n-\t0x4f, 0x50, 0x10, 0x01, 0x32, 0xcd, 0x04, 0x0a, 0x11, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d,\n-\t0x65, 0x6e, 0x74, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x45, 0x0a, 0x05, 0x4c, 0x6f,\n-\t0x67, 0x69, 0x6e, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74,\n-\t0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67,\n-\t0x65, 0x1a, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45,\n-\t0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22,\n-\t0x00, 0x12, 0x46, 0x0a, 0x04, 0x53, 0x79, 0x6e, 0x63, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61,\n-\t0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64,\n-\t0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65,\n+\t0x69, 0x67, 0x52, 0x0c, 0x6f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65, 0x50, 0x65, 0x65, 0x72, 0x73,\n+\t0x12, 0x3e, 0x0a, 0x0d, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65,\n+\t0x73, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65,\n+\t0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c,\n+\t0x65, 0x52, 0x0d, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x73,\n+\t0x12, 0x32, 0x0a, 0x14, 0x66, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65,\n+\t0x73, 0x49, 0x73, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x52, 0x14,\n+\t0x66, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x49, 0x73, 0x45,\n+\t0x6d, 0x70, 0x74, 0x79, 0x12, 0x4f, 0x0a, 0x13, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x46, 0x69,\n+\t0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x18, 0x0a, 0x20, 0x03, 0x28,\n+\t0x0b, 0x32, 0x1d, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52,\n+\t0x6f, 0x75, 0x74, 0x65, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65,\n+\t0x52, 0x13, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c,\n+\t0x52, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x3e, 0x0a, 0x1a, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x46,\n+\t0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x49, 0x73, 0x45, 0x6d,\n+\t0x70, 0x74, 0x79, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x08, 0x52, 0x1a, 0x72, 0x6f, 0x75, 0x74, 0x65,\n+\t0x73, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x49, 0x73,\n+\t0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x44, 0x0a, 0x0f, 0x66, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64,\n+\t0x69, 0x6e, 0x67, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x18, 0x0c, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a,\n+\t0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x46, 0x6f, 0x72, 0x77,\n+\t0x61, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x75, 0x6c, 0x65, 0x52, 0x0f, 0x66, 0x6f, 0x72, 0x77,\n+\t0x61, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x75, 0x6c, 0x65, 0x73, 0x22, 0xbb, 0x01, 0x0a, 0x10,\n+\t0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x65, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,\n+\t0x12, 0x1a, 0x0a, 0x08, 0x77, 0x67, 0x50, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01,\n+\t0x28, 0x09, 0x52, 0x08, 0x77, 0x67, 0x50, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x12, 0x1e, 0x0a, 0x0a,\n+\t0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x49, 0x70, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09,\n+\t0x52, 0x0a, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x49, 0x70, 0x73, 0x12, 0x33, 0x0a, 0x09,\n+\t0x73, 0x73, 0x68, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32,\n+\t0x15, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x53, 0x48,\n+\t0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x09, 0x73, 0x73, 0x68, 0x43, 0x6f, 0x6e, 0x66, 0x69,\n+\t0x67, 0x12, 0x12, 0x0a, 0x04, 0x66, 0x71, 0x64, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52,\n+\t0x04, 0x66, 0x71, 0x64, 0x6e, 0x12, 0x22, 0x0a, 0x0c, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x56, 0x65,\n+\t0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x61, 0x67, 0x65,\n+\t0x6e, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0x7e, 0x0a, 0x09, 0x53, 0x53, 0x48,\n+\t0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x1e, 0x0a, 0x0a, 0x73, 0x73, 0x68, 0x45, 0x6e, 0x61,\n+\t0x62, 0x6c, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x73, 0x73, 0x68, 0x45,\n+\t0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x1c, 0x0a, 0x09, 0x73, 0x73, 0x68, 0x50, 0x75, 0x62,\n+\t0x4b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x09, 0x73, 0x73, 0x68, 0x50, 0x75,\n+\t0x62, 0x4b, 0x65, 0x79, 0x12, 0x33, 0x0a, 0x09, 0x6a, 0x77, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69,\n+\t0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65,\n+\t0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4a, 0x57, 0x54, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x09,\n+\t0x6a, 0x77, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x22, 0x20, 0x0a, 0x1e, 0x44, 0x65, 0x76,\n+\t0x69, 0x63, 0x65, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e,\n+\t0x46, 0x6c, 0x6f, 0x77, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0xbf, 0x01, 0x0a, 0x17,\n+\t0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74,\n+\t0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x6f, 0x77, 0x12, 0x48, 0x0a, 0x08, 0x50, 0x72, 0x6f, 0x76, 0x69,\n+\t0x64, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2c, 0x2e, 0x6d, 0x61, 0x6e, 0x61,\n+\t0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x41, 0x75, 0x74,\n+\t0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x6f, 0x77, 0x2e, 0x70,\n+\t0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x52, 0x08, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65,\n+\t0x72, 0x12, 0x42, 0x0a, 0x0e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43, 0x6f, 0x6e,\n+\t0x66, 0x69, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x6d, 0x61, 0x6e, 0x61,\n+\t0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43,\n+\t0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43,\n+\t0x6f, 0x6e, 0x66, 0x69, 0x67, 0x22, 0x16, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65,\n+\t0x72, 0x12, 0x0a, 0x0a, 0x06, 0x48, 0x4f, 0x53, 0x54, 0x45, 0x44, 0x10, 0x00, 0x22, 0x1e, 0x0a,\n+\t0x1c, 0x50, 0x4b, 0x43, 0x45, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69,\n+\t0x6f, 0x6e, 0x46, 0x6c, 0x6f, 0x77, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x5b, 0x0a,\n+\t0x15, 0x50, 0x4b, 0x43, 0x45, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69,\n+\t0x6f, 0x6e, 0x46, 0x6c, 0x6f, 0x77, 0x12, 0x42, 0x0a, 0x0e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64,\n+\t0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a,\n+\t0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x72, 0x6f, 0x76,\n+\t0x69, 0x64, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0e, 0x50, 0x72, 0x6f, 0x76,\n+\t0x69, 0x64, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x22, 0xb8, 0x03, 0x0a, 0x0e, 0x50,\n+\t0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x1a, 0x0a,\n+\t0x08, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,\n+\t0x08, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x44, 0x12, 0x22, 0x0a, 0x0c, 0x43, 0x6c, 0x69,\n+\t0x65, 0x6e, 0x74, 0x53, 0x65, 0x63, 0x72, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,\n+\t0x0c, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x53, 0x65, 0x63, 0x72, 0x65, 0x74, 0x12, 0x16, 0x0a,\n+\t0x06, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x44,\n+\t0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x12, 0x1a, 0x0a, 0x08, 0x41, 0x75, 0x64, 0x69, 0x65, 0x6e, 0x63,\n+\t0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x41, 0x75, 0x64, 0x69, 0x65, 0x6e, 0x63,\n+\t0x65, 0x12, 0x2e, 0x0a, 0x12, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x41, 0x75, 0x74, 0x68, 0x45,\n+\t0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x12, 0x44,\n+\t0x65, 0x76, 0x69, 0x63, 0x65, 0x41, 0x75, 0x74, 0x68, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e,\n+\t0x74, 0x12, 0x24, 0x0a, 0x0d, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69,\n+\t0x6e, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x45,\n+\t0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x53, 0x63, 0x6f, 0x70, 0x65,\n+\t0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x53, 0x63, 0x6f, 0x70, 0x65, 0x12, 0x1e, 0x0a,\n+\t0x0a, 0x55, 0x73, 0x65, 0x49, 0x44, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x08, 0x20, 0x01, 0x28,\n+\t0x08, 0x52, 0x0a, 0x55, 0x73, 0x65, 0x49, 0x44, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x34, 0x0a,\n+\t0x15, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e,\n+\t0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x15, 0x41, 0x75,\n+\t0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x64, 0x70, 0x6f,\n+\t0x69, 0x6e, 0x74, 0x12, 0x22, 0x0a, 0x0c, 0x52, 0x65, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x55,\n+\t0x52, 0x4c, 0x73, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0c, 0x52, 0x65, 0x64, 0x69, 0x72,\n+\t0x65, 0x63, 0x74, 0x55, 0x52, 0x4c, 0x73, 0x12, 0x2e, 0x0a, 0x12, 0x44, 0x69, 0x73, 0x61, 0x62,\n+\t0x6c, 0x65, 0x50, 0x72, 0x6f, 0x6d, 0x70, 0x74, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x18, 0x0b, 0x20,\n+\t0x01, 0x28, 0x08, 0x52, 0x12, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x6d,\n+\t0x70, 0x74, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x12, 0x1c, 0x0a, 0x09, 0x4c, 0x6f, 0x67, 0x69, 0x6e,\n+\t0x46, 0x6c, 0x61, 0x67, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x4c, 0x6f, 0x67, 0x69,\n+\t0x6e, 0x46, 0x6c, 0x61, 0x67, 0x22, 0x93, 0x02, 0x0a, 0x05, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x12,\n+\t0x0e, 0x0a, 0x02, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x49, 0x44, 0x12,\n+\t0x18, 0x0a, 0x07, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,\n+\t0x52, 0x07, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x12, 0x20, 0x0a, 0x0b, 0x4e, 0x65, 0x74,\n+\t0x77, 0x6f, 0x72, 0x6b, 0x54, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0b,\n+\t0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x54, 0x79, 0x70, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x50,\n+\t0x65, 0x65, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x50, 0x65, 0x65, 0x72, 0x12,\n+\t0x16, 0x0a, 0x06, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x18, 0x05, 0x20, 0x01, 0x28, 0x03, 0x52,\n+\t0x06, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x12, 0x1e, 0x0a, 0x0a, 0x4d, 0x61, 0x73, 0x71, 0x75,\n+\t0x65, 0x72, 0x61, 0x64, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x4d, 0x61, 0x73,\n+\t0x71, 0x75, 0x65, 0x72, 0x61, 0x64, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x4e, 0x65, 0x74, 0x49, 0x44,\n+\t0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x4e, 0x65, 0x74, 0x49, 0x44, 0x12, 0x18, 0x0a,\n+\t0x07, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x18, 0x08, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07,\n+\t0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x12, 0x1c, 0x0a, 0x09, 0x6b, 0x65, 0x65, 0x70, 0x52,\n+\t0x6f, 0x75, 0x74, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x6b, 0x65, 0x65, 0x70,\n+\t0x52, 0x6f, 0x75, 0x74, 0x65, 0x12, 0x24, 0x0a, 0x0d, 0x73, 0x6b, 0x69, 0x70, 0x41, 0x75, 0x74,\n+\t0x6f, 0x41, 0x70, 0x70, 0x6c, 0x79, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x73, 0x6b,\n+\t0x69, 0x70, 0x41, 0x75, 0x74, 0x6f, 0x41, 0x70, 0x70, 0x6c, 0x79, 0x22, 0xda, 0x01, 0x0a, 0x09,\n+\t0x44, 0x4e, 0x53, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x24, 0x0a, 0x0d, 0x53, 0x65, 0x72,\n+\t0x76, 0x69, 0x63, 0x65, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08,\n+\t0x52, 0x0d, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x12,\n+\t0x47, 0x0a, 0x10, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x47, 0x72, 0x6f,\n+\t0x75, 0x70, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x6d, 0x61, 0x6e, 0x61,\n+\t0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65,\n+\t0x72, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x52, 0x10, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76,\n+\t0x65, 0x72, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x73, 0x12, 0x38, 0x0a, 0x0b, 0x43, 0x75, 0x73, 0x74,\n+\t0x6f, 0x6d, 0x5a, 0x6f, 0x6e, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e,\n+\t0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x43, 0x75, 0x73, 0x74, 0x6f,\n+\t0x6d, 0x5a, 0x6f, 0x6e, 0x65, 0x52, 0x0b, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5a, 0x6f, 0x6e,\n+\t0x65, 0x73, 0x12, 0x24, 0x0a, 0x0d, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x65, 0x72, 0x50,\n+\t0x6f, 0x72, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0d, 0x46, 0x6f, 0x72, 0x77, 0x61,\n+\t0x72, 0x64, 0x65, 0x72, 0x50, 0x6f, 0x72, 0x74, 0x22, 0x58, 0x0a, 0x0a, 0x43, 0x75, 0x73, 0x74,\n+\t0x6f, 0x6d, 0x5a, 0x6f, 0x6e, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e,\n+\t0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x12, 0x32,\n+\t0x0a, 0x07, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32,\n+\t0x18, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x69, 0x6d,\n+\t0x70, 0x6c, 0x65, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x52, 0x07, 0x52, 0x65, 0x63, 0x6f, 0x72,\n+\t0x64, 0x73, 0x22, 0x74, 0x0a, 0x0c, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x52, 0x65, 0x63, 0x6f,\n+\t0x72, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,\n+\t0x52, 0x04, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x54, 0x79, 0x70, 0x65, 0x18, 0x02,\n+\t0x20, 0x01, 0x28, 0x03, 0x52, 0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x43, 0x6c,\n+\t0x61, 0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x43, 0x6c, 0x61, 0x73, 0x73,\n+\t0x12, 0x10, 0x0a, 0x03, 0x54, 0x54, 0x4c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x03, 0x54,\n+\t0x54, 0x4c, 0x12, 0x14, 0x0a, 0x05, 0x52, 0x44, 0x61, 0x74, 0x61, 0x18, 0x05, 0x20, 0x01, 0x28,\n+\t0x09, 0x52, 0x05, 0x52, 0x44, 0x61, 0x74, 0x61, 0x22, 0xb3, 0x01, 0x0a, 0x0f, 0x4e, 0x61, 0x6d,\n+\t0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x12, 0x38, 0x0a, 0x0b,\n+\t0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,\n+\t0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4e,\n+\t0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x52, 0x0b, 0x4e, 0x61, 0x6d, 0x65, 0x53,\n+\t0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x50, 0x72, 0x69, 0x6d, 0x61, 0x72,\n+\t0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x50, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79,\n+\t0x12, 0x18, 0x0a, 0x07, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28,\n+\t0x09, 0x52, 0x07, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x12, 0x32, 0x0a, 0x14, 0x53, 0x65,\n+\t0x61, 0x72, 0x63, 0x68, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x45, 0x6e, 0x61, 0x62, 0x6c,\n+\t0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x14, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68,\n+\t0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x22, 0x48,\n+\t0x0a, 0x0a, 0x4e, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x12, 0x0e, 0x0a, 0x02,\n+\t0x49, 0x50, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x49, 0x50, 0x12, 0x16, 0x0a, 0x06,\n+\t0x4e, 0x53, 0x54, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x4e, 0x53,\n+\t0x54, 0x79, 0x70, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x50, 0x6f, 0x72, 0x74, 0x18, 0x03, 0x20, 0x01,\n+\t0x28, 0x03, 0x52, 0x04, 0x50, 0x6f, 0x72, 0x74, 0x22, 0xa7, 0x02, 0x0a, 0x0c, 0x46, 0x69, 0x72,\n+\t0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x50, 0x65, 0x65,\n+\t0x72, 0x49, 0x50, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x50, 0x65, 0x65, 0x72, 0x49,\n+\t0x50, 0x12, 0x37, 0x0a, 0x09, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02,\n+\t0x20, 0x01, 0x28, 0x0e, 0x32, 0x19, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e,\n+\t0x74, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52,\n+\t0x09, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x2e, 0x0a, 0x06, 0x41, 0x63,\n+\t0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x6e,\n+\t0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x41, 0x63, 0x74, 0x69,\n+\t0x6f, 0x6e, 0x52, 0x06, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x34, 0x0a, 0x08, 0x50, 0x72,\n+\t0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x18, 0x2e, 0x6d,\n+\t0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x50, 0x72,\n+\t0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x52, 0x08, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c,\n+\t0x12, 0x12, 0x0a, 0x04, 0x50, 0x6f, 0x72, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,\n+\t0x50, 0x6f, 0x72, 0x74, 0x12, 0x30, 0x0a, 0x08, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f,\n+\t0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d,\n+\t0x65, 0x6e, 0x74, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x08, 0x50, 0x6f,\n+\t0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x1a, 0x0a, 0x08, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79,\n+\t0x49, 0x44, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x08, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79,\n+\t0x49, 0x44, 0x22, 0x38, 0x0a, 0x0e, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x41, 0x64, 0x64,\n+\t0x72, 0x65, 0x73, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x6e, 0x65, 0x74, 0x49, 0x50, 0x18, 0x01, 0x20,\n+\t0x01, 0x28, 0x09, 0x52, 0x05, 0x6e, 0x65, 0x74, 0x49, 0x50, 0x12, 0x10, 0x0a, 0x03, 0x6d, 0x61,\n+\t0x63, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6d, 0x61, 0x63, 0x22, 0x1e, 0x0a, 0x06,\n+\t0x43, 0x68, 0x65, 0x63, 0x6b, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x18,\n+\t0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x05, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x22, 0x96, 0x01, 0x0a,\n+\t0x08, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x14, 0x0a, 0x04, 0x70, 0x6f, 0x72,\n+\t0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x12,\n+\t0x32, 0x0a, 0x05, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a,\n+\t0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x6f, 0x72, 0x74,\n+\t0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x48, 0x00, 0x52, 0x05, 0x72, 0x61,\n+\t0x6e, 0x67, 0x65, 0x1a, 0x2f, 0x0a, 0x05, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x14, 0x0a, 0x05,\n+\t0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x05, 0x73, 0x74, 0x61,\n+\t0x72, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x65, 0x6e, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52,\n+\t0x03, 0x65, 0x6e, 0x64, 0x42, 0x0f, 0x0a, 0x0d, 0x70, 0x6f, 0x72, 0x74, 0x53, 0x65, 0x6c, 0x65,\n+\t0x63, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x87, 0x03, 0x0a, 0x11, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x46,\n+\t0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x52, 0x75, 0x6c, 0x65, 0x12, 0x22, 0x0a, 0x0c, 0x73,\n+\t0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,\n+\t0x09, 0x52, 0x0c, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x12,\n+\t0x2e, 0x0a, 0x06, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32,\n+\t0x16, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x52, 0x75, 0x6c,\n+\t0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x06, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12,\n+\t0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03,\n+\t0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f,\n+\t0x6e, 0x12, 0x34, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x04, 0x20,\n+\t0x01, 0x28, 0x0e, 0x32, 0x18, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74,\n+\t0x2e, 0x52, 0x75, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x52, 0x08, 0x70,\n+\t0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x30, 0x0a, 0x08, 0x70, 0x6f, 0x72, 0x74, 0x49,\n+\t0x6e, 0x66, 0x6f, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x61, 0x6e, 0x61,\n+\t0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52,\n+\t0x08, 0x70, 0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x1c, 0x0a, 0x09, 0x69, 0x73, 0x44,\n+\t0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x69, 0x73,\n+\t0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x12, 0x18, 0x0a, 0x07, 0x64, 0x6f, 0x6d, 0x61, 0x69,\n+\t0x6e, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e,\n+\t0x73, 0x12, 0x26, 0x0a, 0x0e, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x50, 0x72, 0x6f, 0x74, 0x6f,\n+\t0x63, 0x6f, 0x6c, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0e, 0x63, 0x75, 0x73, 0x74, 0x6f,\n+\t0x6d, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x1a, 0x0a, 0x08, 0x50, 0x6f, 0x6c,\n+\t0x69, 0x63, 0x79, 0x49, 0x44, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x08, 0x50, 0x6f, 0x6c,\n+\t0x69, 0x63, 0x79, 0x49, 0x44, 0x12, 0x18, 0x0a, 0x07, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x49, 0x44,\n+\t0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x49, 0x44, 0x22,\n+\t0xf2, 0x01, 0x0a, 0x0e, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x75,\n+\t0x6c, 0x65, 0x12, 0x34, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x01,\n+\t0x20, 0x01, 0x28, 0x0e, 0x32, 0x18, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e,\n+\t0x74, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x52, 0x08,\n+\t0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x3e, 0x0a, 0x0f, 0x64, 0x65, 0x73, 0x74,\n+\t0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28,\n+\t0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50,\n+\t0x6f, 0x72, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x0f, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61,\n+\t0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x12, 0x2c, 0x0a, 0x11, 0x74, 0x72, 0x61, 0x6e,\n+\t0x73, 0x6c, 0x61, 0x74, 0x65, 0x64, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x03, 0x20,\n+\t0x01, 0x28, 0x0c, 0x52, 0x11, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74, 0x65, 0x64, 0x41,\n+\t0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x3c, 0x0a, 0x0e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6c,\n+\t0x61, 0x74, 0x65, 0x64, 0x50, 0x6f, 0x72, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14,\n+\t0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x50, 0x6f, 0x72, 0x74,\n+\t0x49, 0x6e, 0x66, 0x6f, 0x52, 0x0e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74, 0x65, 0x64,\n+\t0x50, 0x6f, 0x72, 0x74, 0x2a, 0x4c, 0x0a, 0x0c, 0x52, 0x75, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74,\n+\t0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10,\n+\t0x00, 0x12, 0x07, 0x0a, 0x03, 0x41, 0x4c, 0x4c, 0x10, 0x01, 0x12, 0x07, 0x0a, 0x03, 0x54, 0x43,\n+\t0x50, 0x10, 0x02, 0x12, 0x07, 0x0a, 0x03, 0x55, 0x44, 0x50, 0x10, 0x03, 0x12, 0x08, 0x0a, 0x04,\n+\t0x49, 0x43, 0x4d, 0x50, 0x10, 0x04, 0x12, 0x0a, 0x0a, 0x06, 0x43, 0x55, 0x53, 0x54, 0x4f, 0x4d,\n+\t0x10, 0x05, 0x2a, 0x20, 0x0a, 0x0d, 0x52, 0x75, 0x6c, 0x65, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74,\n+\t0x69, 0x6f, 0x6e, 0x12, 0x06, 0x0a, 0x02, 0x49, 0x4e, 0x10, 0x00, 0x12, 0x07, 0x0a, 0x03, 0x4f,\n+\t0x55, 0x54, 0x10, 0x01, 0x2a, 0x22, 0x0a, 0x0a, 0x52, 0x75, 0x6c, 0x65, 0x41, 0x63, 0x74, 0x69,\n+\t0x6f, 0x6e, 0x12, 0x0a, 0x0a, 0x06, 0x41, 0x43, 0x43, 0x45, 0x50, 0x54, 0x10, 0x00, 0x12, 0x08,\n+\t0x0a, 0x04, 0x44, 0x52, 0x4f, 0x50, 0x10, 0x01, 0x32, 0xcd, 0x04, 0x0a, 0x11, 0x4d, 0x61, 0x6e,\n+\t0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x45,\n+\t0x0a, 0x05, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65,\n \t0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65,\n-\t0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x00, 0x30, 0x01, 0x12, 0x42, 0x0a, 0x0c, 0x47, 0x65, 0x74,\n-\t0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x4b, 0x65, 0x79, 0x12, 0x11, 0x2e, 0x6d, 0x61, 0x6e, 0x61,\n-\t0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x1d, 0x2e, 0x6d,\n-\t0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72,\n-\t0x4b, 0x65, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x33, 0x0a,\n-\t0x09, 0x69, 0x73, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x79, 0x12, 0x11, 0x2e, 0x6d, 0x61, 0x6e,\n-\t0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x11, 0x2e,\n+\t0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65,\n+\t0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73,\n+\t0x61, 0x67, 0x65, 0x22, 0x00, 0x12, 0x46, 0x0a, 0x04, 0x53, 0x79, 0x6e, 0x63, 0x12, 0x1c, 0x2e,\n+\t0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79,\n+\t0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x1c, 0x2e, 0x6d, 0x61,\n+\t0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74,\n+\t0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x00, 0x30, 0x01, 0x12, 0x42, 0x0a,\n+\t0x0c, 0x47, 0x65, 0x74, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x4b, 0x65, 0x79, 0x12, 0x11, 0x2e,\n \t0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79,\n-\t0x22, 0x00, 0x12, 0x5a, 0x0a, 0x1a, 0x47, 0x65, 0x74, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x41,\n-\t0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x6f, 0x77,\n-\t0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e,\n-\t0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x1c,\n+\t0x1a, 0x1d, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x65,\n+\t0x72, 0x76, 0x65, 0x72, 0x4b, 0x65, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,\n+\t0x00, 0x12, 0x33, 0x0a, 0x09, 0x69, 0x73, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x79, 0x12, 0x11,\n+\t0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6d, 0x70, 0x74,\n+\t0x79, 0x1a, 0x11, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45,\n+\t0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x12, 0x5a, 0x0a, 0x1a, 0x47, 0x65, 0x74, 0x44, 0x65, 0x76,\n+\t0x69, 0x63, 0x65, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e,\n+\t0x46, 0x6c, 0x6f, 0x77, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e,\n+\t0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61,\n+\t0x67, 0x65, 0x1a, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e,\n+\t0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,\n+\t0x22, 0x00, 0x12, 0x58, 0x0a, 0x18, 0x47, 0x65, 0x74, 0x50, 0x4b, 0x43, 0x45, 0x41, 0x75, 0x74,\n+\t0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x6f, 0x77, 0x12, 0x1c,\n \t0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72,\n-\t0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x00, 0x12, 0x58,\n-\t0x0a, 0x18, 0x47, 0x65, 0x74, 0x50, 0x4b, 0x43, 0x45, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69,\n-\t0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x6f, 0x77, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e,\n-\t0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65,\n-\t0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67,\n+\t0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x1c, 0x2e, 0x6d,\n+\t0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70,\n+\t0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x00, 0x12, 0x3d, 0x0a, 0x08,\n+\t0x53, 0x79, 0x6e, 0x63, 0x4d, 0x65, 0x74, 0x61, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67,\n \t0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d,\n-\t0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x00, 0x12, 0x3d, 0x0a, 0x08, 0x53, 0x79, 0x6e, 0x63,\n-\t0x4d, 0x65, 0x74, 0x61, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e,\n-\t0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61,\n-\t0x67, 0x65, 0x1a, 0x11, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e,\n-\t0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x12, 0x3b, 0x0a, 0x06, 0x4c, 0x6f, 0x67, 0x6f, 0x75,\n-\t0x74, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45,\n-\t0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a,\n-\t0x11, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6d, 0x70,\n-\t0x74, 0x79, 0x22, 0x00, 0x42, 0x08, 0x5a, 0x06, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x06,\n-\t0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,\n+\t0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x11, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d,\n+\t0x65, 0x6e, 0x74, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x12, 0x3b, 0x0a, 0x06, 0x4c,\n+\t0x6f, 0x67, 0x6f, 0x75, 0x74, 0x12, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65,\n+\t0x6e, 0x74, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73,\n+\t0x61, 0x67, 0x65, 0x1a, 0x11, 0x2e, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74,\n+\t0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x42, 0x08, 0x5a, 0x06, 0x2f, 0x70, 0x72, 0x6f,\n+\t0x74, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,\n }\n \n var (\n@@ -3910,7 +4067,7 @@ func file_management_proto_rawDescGZIP() []byte {\n }\n \n var file_management_proto_enumTypes = make([]protoimpl.EnumInfo, 5)\n-var file_management_proto_msgTypes = make([]protoimpl.MessageInfo, 40)\n+var file_management_proto_msgTypes = make([]protoimpl.MessageInfo, 41)\n var file_management_proto_goTypes = []interface{}{\n \t(RuleProtocol)(0),                      // 0: management.RuleProtocol\n \t(RuleDirection)(0),                     // 1: management.RuleDirection\n@@ -3934,107 +4091,110 @@ var file_management_proto_goTypes = []interface{}{\n \t(*HostConfig)(nil),                     // 19: management.HostConfig\n \t(*RelayConfig)(nil),                    // 20: management.RelayConfig\n \t(*FlowConfig)(nil),                     // 21: management.FlowConfig\n-\t(*ProtectedHostConfig)(nil),            // 22: management.ProtectedHostConfig\n-\t(*PeerConfig)(nil),                     // 23: management.PeerConfig\n-\t(*NetworkMap)(nil),                     // 24: management.NetworkMap\n-\t(*RemotePeerConfig)(nil),               // 25: management.RemotePeerConfig\n-\t(*SSHConfig)(nil),                      // 26: management.SSHConfig\n-\t(*DeviceAuthorizationFlowRequest)(nil), // 27: management.DeviceAuthorizationFlowRequest\n-\t(*DeviceAuthorizationFlow)(nil),        // 28: management.DeviceAuthorizationFlow\n-\t(*PKCEAuthorizationFlowRequest)(nil),   // 29: management.PKCEAuthorizationFlowRequest\n-\t(*PKCEAuthorizationFlow)(nil),          // 30: management.PKCEAuthorizationFlow\n-\t(*ProviderConfig)(nil),                 // 31: management.ProviderConfig\n-\t(*Route)(nil),                          // 32: management.Route\n-\t(*DNSConfig)(nil),                      // 33: management.DNSConfig\n-\t(*CustomZone)(nil),                     // 34: management.CustomZone\n-\t(*SimpleRecord)(nil),                   // 35: management.SimpleRecord\n-\t(*NameServerGroup)(nil),                // 36: management.NameServerGroup\n-\t(*NameServer)(nil),                     // 37: management.NameServer\n-\t(*FirewallRule)(nil),                   // 38: management.FirewallRule\n-\t(*NetworkAddress)(nil),                 // 39: management.NetworkAddress\n-\t(*Checks)(nil),                         // 40: management.Checks\n-\t(*PortInfo)(nil),                       // 41: management.PortInfo\n-\t(*RouteFirewallRule)(nil),              // 42: management.RouteFirewallRule\n-\t(*ForwardingRule)(nil),                 // 43: management.ForwardingRule\n-\t(*PortInfo_Range)(nil),                 // 44: management.PortInfo.Range\n-\t(*timestamppb.Timestamp)(nil),          // 45: google.protobuf.Timestamp\n-\t(*durationpb.Duration)(nil),            // 46: google.protobuf.Duration\n+\t(*JWTConfig)(nil),                      // 22: management.JWTConfig\n+\t(*ProtectedHostConfig)(nil),            // 23: management.ProtectedHostConfig\n+\t(*PeerConfig)(nil),                     // 24: management.PeerConfig\n+\t(*NetworkMap)(nil),                     // 25: management.NetworkMap\n+\t(*RemotePeerConfig)(nil),               // 26: management.RemotePeerConfig\n+\t(*SSHConfig)(nil),                      // 27: management.SSHConfig\n+\t(*DeviceAuthorizationFlowRequest)(nil), // 28: management.DeviceAuthorizationFlowRequest\n+\t(*DeviceAuthorizationFlow)(nil),        // 29: management.DeviceAuthorizationFlow\n+\t(*PKCEAuthorizationFlowRequest)(nil),   // 30: management.PKCEAuthorizationFlowRequest\n+\t(*PKCEAuthorizationFlow)(nil),          // 31: management.PKCEAuthorizationFlow\n+\t(*ProviderConfig)(nil),                 // 32: management.ProviderConfig\n+\t(*Route)(nil),                          // 33: management.Route\n+\t(*DNSConfig)(nil),                      // 34: management.DNSConfig\n+\t(*CustomZone)(nil),                     // 35: management.CustomZone\n+\t(*SimpleRecord)(nil),                   // 36: management.SimpleRecord\n+\t(*NameServerGroup)(nil),                // 37: management.NameServerGroup\n+\t(*NameServer)(nil),                     // 38: management.NameServer\n+\t(*FirewallRule)(nil),                   // 39: management.FirewallRule\n+\t(*NetworkAddress)(nil),                 // 40: management.NetworkAddress\n+\t(*Checks)(nil),                         // 41: management.Checks\n+\t(*PortInfo)(nil),                       // 42: management.PortInfo\n+\t(*RouteFirewallRule)(nil),              // 43: management.RouteFirewallRule\n+\t(*ForwardingRule)(nil),                 // 44: management.ForwardingRule\n+\t(*PortInfo_Range)(nil),                 // 45: management.PortInfo.Range\n+\t(*timestamppb.Timestamp)(nil),          // 46: google.protobuf.Timestamp\n+\t(*durationpb.Duration)(nil),            // 47: google.protobuf.Duration\n }\n var file_management_proto_depIdxs = []int32{\n \t14, // 0: management.SyncRequest.meta:type_name -> management.PeerSystemMeta\n \t18, // 1: management.SyncResponse.netbirdConfig:type_name -> management.NetbirdConfig\n-\t23, // 2: management.SyncResponse.peerConfig:type_name -> management.PeerConfig\n-\t25, // 3: management.SyncResponse.remotePeers:type_name -> management.RemotePeerConfig\n-\t24, // 4: management.SyncResponse.NetworkMap:type_name -> management.NetworkMap\n-\t40, // 5: management.SyncResponse.Checks:type_name -> management.Checks\n+\t24, // 2: management.SyncResponse.peerConfig:type_name -> management.PeerConfig\n+\t26, // 3: management.SyncResponse.remotePeers:type_name -> management.RemotePeerConfig\n+\t25, // 4: management.SyncResponse.NetworkMap:type_name -> management.NetworkMap\n+\t41, // 5: management.SyncResponse.Checks:type_name -> management.Checks\n \t14, // 6: management.SyncMetaRequest.meta:type_name -> management.PeerSystemMeta\n \t14, // 7: management.LoginRequest.meta:type_name -> management.PeerSystemMeta\n \t10, // 8: management.LoginRequest.peerKeys:type_name -> management.PeerKeys\n-\t39, // 9: management.PeerSystemMeta.networkAddresses:type_name -> management.NetworkAddress\n+\t40, // 9: management.PeerSystemMeta.networkAddresses:type_name -> management.NetworkAddress\n \t11, // 10: management.PeerSystemMeta.environment:type_name -> management.Environment\n \t12, // 11: management.PeerSystemMeta.files:type_name -> management.File\n \t13, // 12: management.PeerSystemMeta.flags:type_name -> management.Flags\n \t18, // 13: management.LoginResponse.netbirdConfig:type_name -> management.NetbirdConfig\n-\t23, // 14: management.LoginResponse.peerConfig:type_name -> management.PeerConfig\n-\t40, // 15: management.LoginResponse.Checks:type_name -> management.Checks\n-\t45, // 16: management.ServerKeyResponse.expiresAt:type_name -> google.protobuf.Timestamp\n+\t24, // 14: management.LoginResponse.peerConfig:type_name -> management.PeerConfig\n+\t41, // 15: management.LoginResponse.Checks:type_name -> management.Checks\n+\t46, // 16: management.ServerKeyResponse.expiresAt:type_name -> google.protobuf.Timestamp\n \t19, // 17: management.NetbirdConfig.stuns:type_name -> management.HostConfig\n-\t22, // 18: management.NetbirdConfig.turns:type_name -> management.ProtectedHostConfig\n+\t23, // 18: management.NetbirdConfig.turns:type_name -> management.ProtectedHostConfig\n \t19, // 19: management.NetbirdConfig.signal:type_name -> management.HostConfig\n \t20, // 20: management.NetbirdConfig.relay:type_name -> management.RelayConfig\n \t21, // 21: management.NetbirdConfig.flow:type_name -> management.FlowConfig\n-\t3,  // 22: management.HostConfig.protocol:type_name -> management.HostConfig.Protocol\n-\t46, // 23: management.FlowConfig.interval:type_name -> google.protobuf.Duration\n-\t19, // 24: management.ProtectedHostConfig.hostConfig:type_name -> management.HostConfig\n-\t26, // 25: management.PeerConfig.sshConfig:type_name -> management.SSHConfig\n-\t23, // 26: management.NetworkMap.peerConfig:type_name -> management.PeerConfig\n-\t25, // 27: management.NetworkMap.remotePeers:type_name -> management.RemotePeerConfig\n-\t32, // 28: management.NetworkMap.Routes:type_name -> management.Route\n-\t33, // 29: management.NetworkMap.DNSConfig:type_name -> management.DNSConfig\n-\t25, // 30: management.NetworkMap.offlinePeers:type_name -> management.RemotePeerConfig\n-\t38, // 31: management.NetworkMap.FirewallRules:type_name -> management.FirewallRule\n-\t42, // 32: management.NetworkMap.routesFirewallRules:type_name -> management.RouteFirewallRule\n-\t43, // 33: management.NetworkMap.forwardingRules:type_name -> management.ForwardingRule\n-\t26, // 34: management.RemotePeerConfig.sshConfig:type_name -> management.SSHConfig\n-\t4,  // 35: management.DeviceAuthorizationFlow.Provider:type_name -> management.DeviceAuthorizationFlow.provider\n-\t31, // 36: management.DeviceAuthorizationFlow.ProviderConfig:type_name -> management.ProviderConfig\n-\t31, // 37: management.PKCEAuthorizationFlow.ProviderConfig:type_name -> management.ProviderConfig\n-\t36, // 38: management.DNSConfig.NameServerGroups:type_name -> management.NameServerGroup\n-\t34, // 39: management.DNSConfig.CustomZones:type_name -> management.CustomZone\n-\t35, // 40: management.CustomZone.Records:type_name -> management.SimpleRecord\n-\t37, // 41: management.NameServerGroup.NameServers:type_name -> management.NameServer\n-\t1,  // 42: management.FirewallRule.Direction:type_name -> management.RuleDirection\n-\t2,  // 43: management.FirewallRule.Action:type_name -> management.RuleAction\n-\t0,  // 44: management.FirewallRule.Protocol:type_name -> management.RuleProtocol\n-\t41, // 45: management.FirewallRule.PortInfo:type_name -> management.PortInfo\n-\t44, // 46: management.PortInfo.range:type_name -> management.PortInfo.Range\n-\t2,  // 47: management.RouteFirewallRule.action:type_name -> management.RuleAction\n-\t0,  // 48: management.RouteFirewallRule.protocol:type_name -> management.RuleProtocol\n-\t41, // 49: management.RouteFirewallRule.portInfo:type_name -> management.PortInfo\n-\t0,  // 50: management.ForwardingRule.protocol:type_name -> management.RuleProtocol\n-\t41, // 51: management.ForwardingRule.destinationPort:type_name -> management.PortInfo\n-\t41, // 52: management.ForwardingRule.translatedPort:type_name -> management.PortInfo\n-\t5,  // 53: management.ManagementService.Login:input_type -> management.EncryptedMessage\n-\t5,  // 54: management.ManagementService.Sync:input_type -> management.EncryptedMessage\n-\t17, // 55: management.ManagementService.GetServerKey:input_type -> management.Empty\n-\t17, // 56: management.ManagementService.isHealthy:input_type -> management.Empty\n-\t5,  // 57: management.ManagementService.GetDeviceAuthorizationFlow:input_type -> management.EncryptedMessage\n-\t5,  // 58: management.ManagementService.GetPKCEAuthorizationFlow:input_type -> management.EncryptedMessage\n-\t5,  // 59: management.ManagementService.SyncMeta:input_type -> management.EncryptedMessage\n-\t5,  // 60: management.ManagementService.Logout:input_type -> management.EncryptedMessage\n-\t5,  // 61: management.ManagementService.Login:output_type -> management.EncryptedMessage\n-\t5,  // 62: management.ManagementService.Sync:output_type -> management.EncryptedMessage\n-\t16, // 63: management.ManagementService.GetServerKey:output_type -> management.ServerKeyResponse\n-\t17, // 64: management.ManagementService.isHealthy:output_type -> management.Empty\n-\t5,  // 65: management.ManagementService.GetDeviceAuthorizationFlow:output_type -> management.EncryptedMessage\n-\t5,  // 66: management.ManagementService.GetPKCEAuthorizationFlow:output_type -> management.EncryptedMessage\n-\t17, // 67: management.ManagementService.SyncMeta:output_type -> management.Empty\n-\t17, // 68: management.ManagementService.Logout:output_type -> management.Empty\n-\t61, // [61:69] is the sub-list for method output_type\n-\t53, // [53:61] is the sub-list for method input_type\n-\t53, // [53:53] is the sub-list for extension type_name\n-\t53, // [53:53] is the sub-list for extension extendee\n-\t0,  // [0:53] is the sub-list for field type_name\n+\t22, // 22: management.NetbirdConfig.jwt:type_name -> management.JWTConfig\n+\t3,  // 23: management.HostConfig.protocol:type_name -> management.HostConfig.Protocol\n+\t47, // 24: management.FlowConfig.interval:type_name -> google.protobuf.Duration\n+\t19, // 25: management.ProtectedHostConfig.hostConfig:type_name -> management.HostConfig\n+\t27, // 26: management.PeerConfig.sshConfig:type_name -> management.SSHConfig\n+\t24, // 27: management.NetworkMap.peerConfig:type_name -> management.PeerConfig\n+\t26, // 28: management.NetworkMap.remotePeers:type_name -> management.RemotePeerConfig\n+\t33, // 29: management.NetworkMap.Routes:type_name -> management.Route\n+\t34, // 30: management.NetworkMap.DNSConfig:type_name -> management.DNSConfig\n+\t26, // 31: management.NetworkMap.offlinePeers:type_name -> management.RemotePeerConfig\n+\t39, // 32: management.NetworkMap.FirewallRules:type_name -> management.FirewallRule\n+\t43, // 33: management.NetworkMap.routesFirewallRules:type_name -> management.RouteFirewallRule\n+\t44, // 34: management.NetworkMap.forwardingRules:type_name -> management.ForwardingRule\n+\t27, // 35: management.RemotePeerConfig.sshConfig:type_name -> management.SSHConfig\n+\t22, // 36: management.SSHConfig.jwtConfig:type_name -> management.JWTConfig\n+\t4,  // 37: management.DeviceAuthorizationFlow.Provider:type_name -> management.DeviceAuthorizationFlow.provider\n+\t32, // 38: management.DeviceAuthorizationFlow.ProviderConfig:type_name -> management.ProviderConfig\n+\t32, // 39: management.PKCEAuthorizationFlow.ProviderConfig:type_name -> management.ProviderConfig\n+\t37, // 40: management.DNSConfig.NameServerGroups:type_name -> management.NameServerGroup\n+\t35, // 41: management.DNSConfig.CustomZones:type_name -> management.CustomZone\n+\t36, // 42: management.CustomZone.Records:type_name -> management.SimpleRecord\n+\t38, // 43: management.NameServerGroup.NameServers:type_name -> management.NameServer\n+\t1,  // 44: management.FirewallRule.Direction:type_name -> management.RuleDirection\n+\t2,  // 45: management.FirewallRule.Action:type_name -> management.RuleAction\n+\t0,  // 46: management.FirewallRule.Protocol:type_name -> management.RuleProtocol\n+\t42, // 47: management.FirewallRule.PortInfo:type_name -> management.PortInfo\n+\t45, // 48: management.PortInfo.range:type_name -> management.PortInfo.Range\n+\t2,  // 49: management.RouteFirewallRule.action:type_name -> management.RuleAction\n+\t0,  // 50: management.RouteFirewallRule.protocol:type_name -> management.RuleProtocol\n+\t42, // 51: management.RouteFirewallRule.portInfo:type_name -> management.PortInfo\n+\t0,  // 52: management.ForwardingRule.protocol:type_name -> management.RuleProtocol\n+\t42, // 53: management.ForwardingRule.destinationPort:type_name -> management.PortInfo\n+\t42, // 54: management.ForwardingRule.translatedPort:type_name -> management.PortInfo\n+\t5,  // 55: management.ManagementService.Login:input_type -> management.EncryptedMessage\n+\t5,  // 56: management.ManagementService.Sync:input_type -> management.EncryptedMessage\n+\t17, // 57: management.ManagementService.GetServerKey:input_type -> management.Empty\n+\t17, // 58: management.ManagementService.isHealthy:input_type -> management.Empty\n+\t5,  // 59: management.ManagementService.GetDeviceAuthorizationFlow:input_type -> management.EncryptedMessage\n+\t5,  // 60: management.ManagementService.GetPKCEAuthorizationFlow:input_type -> management.EncryptedMessage\n+\t5,  // 61: management.ManagementService.SyncMeta:input_type -> management.EncryptedMessage\n+\t5,  // 62: management.ManagementService.Logout:input_type -> management.EncryptedMessage\n+\t5,  // 63: management.ManagementService.Login:output_type -> management.EncryptedMessage\n+\t5,  // 64: management.ManagementService.Sync:output_type -> management.EncryptedMessage\n+\t16, // 65: management.ManagementService.GetServerKey:output_type -> management.ServerKeyResponse\n+\t17, // 66: management.ManagementService.isHealthy:output_type -> management.Empty\n+\t5,  // 67: management.ManagementService.GetDeviceAuthorizationFlow:output_type -> management.EncryptedMessage\n+\t5,  // 68: management.ManagementService.GetPKCEAuthorizationFlow:output_type -> management.EncryptedMessage\n+\t17, // 69: management.ManagementService.SyncMeta:output_type -> management.Empty\n+\t17, // 70: management.ManagementService.Logout:output_type -> management.Empty\n+\t63, // [63:71] is the sub-list for method output_type\n+\t55, // [55:63] is the sub-list for method input_type\n+\t55, // [55:55] is the sub-list for extension type_name\n+\t55, // [55:55] is the sub-list for extension extendee\n+\t0,  // [0:55] is the sub-list for field type_name\n }\n \n func init() { file_management_proto_init() }\n@@ -4248,7 +4408,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*ProtectedHostConfig); i {\n+\t\t\tswitch v := v.(*JWTConfig); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4260,7 +4420,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*PeerConfig); i {\n+\t\t\tswitch v := v.(*ProtectedHostConfig); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4272,7 +4432,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*NetworkMap); i {\n+\t\t\tswitch v := v.(*PeerConfig); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4284,7 +4444,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*RemotePeerConfig); i {\n+\t\t\tswitch v := v.(*NetworkMap); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4296,7 +4456,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*SSHConfig); i {\n+\t\t\tswitch v := v.(*RemotePeerConfig); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4308,7 +4468,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*DeviceAuthorizationFlowRequest); i {\n+\t\t\tswitch v := v.(*SSHConfig); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4320,7 +4480,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*DeviceAuthorizationFlow); i {\n+\t\t\tswitch v := v.(*DeviceAuthorizationFlowRequest); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4332,7 +4492,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*PKCEAuthorizationFlowRequest); i {\n+\t\t\tswitch v := v.(*DeviceAuthorizationFlow); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4344,7 +4504,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*PKCEAuthorizationFlow); i {\n+\t\t\tswitch v := v.(*PKCEAuthorizationFlowRequest); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4356,7 +4516,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[26].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*ProviderConfig); i {\n+\t\t\tswitch v := v.(*PKCEAuthorizationFlow); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4368,7 +4528,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[27].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*Route); i {\n+\t\t\tswitch v := v.(*ProviderConfig); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4380,7 +4540,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[28].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*DNSConfig); i {\n+\t\t\tswitch v := v.(*Route); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4392,7 +4552,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[29].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*CustomZone); i {\n+\t\t\tswitch v := v.(*DNSConfig); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4404,7 +4564,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[30].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*SimpleRecord); i {\n+\t\t\tswitch v := v.(*CustomZone); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4416,7 +4576,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[31].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*NameServerGroup); i {\n+\t\t\tswitch v := v.(*SimpleRecord); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4428,7 +4588,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[32].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*NameServer); i {\n+\t\t\tswitch v := v.(*NameServerGroup); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4440,7 +4600,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[33].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*FirewallRule); i {\n+\t\t\tswitch v := v.(*NameServer); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4452,7 +4612,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[34].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*NetworkAddress); i {\n+\t\t\tswitch v := v.(*FirewallRule); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4464,7 +4624,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[35].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*Checks); i {\n+\t\t\tswitch v := v.(*NetworkAddress); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4476,7 +4636,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[36].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*PortInfo); i {\n+\t\t\tswitch v := v.(*Checks); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4488,7 +4648,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[37].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*RouteFirewallRule); i {\n+\t\t\tswitch v := v.(*PortInfo); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4500,7 +4660,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[38].Exporter = func(v interface{}, i int) interface{} {\n-\t\t\tswitch v := v.(*ForwardingRule); i {\n+\t\t\tswitch v := v.(*RouteFirewallRule); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n \t\t\tcase 1:\n@@ -4512,6 +4672,18 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t\tfile_management_proto_msgTypes[39].Exporter = func(v interface{}, i int) interface{} {\n+\t\t\tswitch v := v.(*ForwardingRule); i {\n+\t\t\tcase 0:\n+\t\t\t\treturn &v.state\n+\t\t\tcase 1:\n+\t\t\t\treturn &v.sizeCache\n+\t\t\tcase 2:\n+\t\t\t\treturn &v.unknownFields\n+\t\t\tdefault:\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t}\n+\t\tfile_management_proto_msgTypes[40].Exporter = func(v interface{}, i int) interface{} {\n \t\t\tswitch v := v.(*PortInfo_Range); i {\n \t\t\tcase 0:\n \t\t\t\treturn &v.state\n@@ -4524,7 +4696,7 @@ func file_management_proto_init() {\n \t\t\t}\n \t\t}\n \t}\n-\tfile_management_proto_msgTypes[36].OneofWrappers = []interface{}{\n+\tfile_management_proto_msgTypes[37].OneofWrappers = []interface{}{\n \t\t(*PortInfo_Port)(nil),\n \t\t(*PortInfo_Range_)(nil),\n \t}\n@@ -4534,7 +4706,7 @@ func file_management_proto_init() {\n \t\t\tGoPackagePath: reflect.TypeOf(x{}).PkgPath(),\n \t\t\tRawDescriptor: file_management_proto_rawDesc,\n \t\t\tNumEnums:      5,\n-\t\t\tNumMessages:   40,\n+\t\t\tNumMessages:   41,\n \t\t\tNumExtensions: 0,\n \t\t\tNumServices:   1,\n \t\t},\ndiff --git a/shared/management/proto/management.proto b/shared/management/proto/management.proto\nindex 3982ea2af11..16737cf5898 100644\n--- a/shared/management/proto/management.proto\n+++ b/shared/management/proto/management.proto\n@@ -146,6 +146,12 @@ message Flags {\n   bool blockInbound = 9;\n \n   bool lazyConnectionEnabled = 10;\n+\n+  bool enableSSHRoot = 11;\n+  bool enableSSHSFTP = 12;\n+  bool enableSSHLocalPortForwarding = 13;\n+  bool enableSSHRemotePortForwarding = 14;\n+  bool disableSSHAuth = 15;\n }\n \n // PeerSystemMeta is machine meta data like OS and version.\n@@ -202,6 +208,8 @@ message NetbirdConfig {\n   RelayConfig relay = 4;\n \n   FlowConfig flow = 5;\n+\n+  JWTConfig jwt = 6;\n }\n \n // HostConfig describes connection properties of some server (e.g. STUN, Signal, Management)\n@@ -240,6 +248,14 @@ message FlowConfig {\n   bool dnsCollection = 8;\n }\n \n+// JWTConfig represents JWT authentication configuration\n+message JWTConfig {\n+  string issuer = 1;\n+  string audience = 2;\n+  string keysLocation = 3;\n+  int64 maxTokenAge = 4;\n+}\n+\n // ProtectedHostConfig is similar to HostConfig but has additional user and password\n // Mostly used for TURN servers\n message ProtectedHostConfig {\n@@ -335,6 +351,8 @@ message SSHConfig {\n   // sshPubKey is a SSH public key of a peer to be added to authorized_hosts.\n   // This property should be ignore if SSHConfig comes from PeerConfig.\n   bytes sshPubKey = 2;\n+\n+  JWTConfig jwtConfig = 3;\n }\n \n // DeviceAuthorizationFlowRequest empty struct for future expansion\ndiff --git a/shared/relay/client/dialer/quic/quic.go b/shared/relay/client/dialer/quic/quic.go\nindex 967e18d799a..c057ef08960 100644\n--- a/shared/relay/client/dialer/quic/quic.go\n+++ b/shared/relay/client/dialer/quic/quic.go\n@@ -11,8 +11,8 @@ import (\n \t\"github.com/quic-go/quic-go\"\n \tlog \"github.com/sirupsen/logrus\"\n \n-\tquictls \"github.com/netbirdio/netbird/shared/relay/tls\"\n \tnbnet \"github.com/netbirdio/netbird/client/net\"\n+\tquictls \"github.com/netbirdio/netbird/shared/relay/tls\"\n )\n \n type Dialer struct {\ndiff --git a/shared/relay/client/dialer/ws/ws.go b/shared/relay/client/dialer/ws/ws.go\nindex 66fff344773..37b189e05c5 100644\n--- a/shared/relay/client/dialer/ws/ws.go\n+++ b/shared/relay/client/dialer/ws/ws.go\n@@ -14,9 +14,9 @@ import (\n \t\"github.com/coder/websocket\"\n \tlog \"github.com/sirupsen/logrus\"\n \n+\tnbnet \"github.com/netbirdio/netbird/client/net\"\n \t\"github.com/netbirdio/netbird/shared/relay\"\n \t\"github.com/netbirdio/netbird/util/embeddedroots\"\n-\tnbnet \"github.com/netbirdio/netbird/client/net\"\n )\n \n type Dialer struct {\ndiff --git a/shared/relay/constants.go b/shared/relay/constants.go\nindex 3c7c3cd296e..0f2a276103c 100644\n--- a/shared/relay/constants.go\n+++ b/shared/relay/constants.go\n@@ -3,4 +3,4 @@ package relay\n const (\n \t// WebSocketURLPath is the path for the websocket relay connection\n \tWebSocketURLPath = \"/relay\"\n-)\n\\ No newline at end of file\n+)\ndiff --git a/version/url_windows.go b/version/url_windows.go\nindex 14fdb7ae638..a0fb6e5dd5f 100644\n--- a/version/url_windows.go\n+++ b/version/url_windows.go\n@@ -6,7 +6,7 @@ import (\n )\n \n const (\n-\turlWinExe = \"https://pkgs.netbird.io/windows/x64\"\n+\turlWinExe    = \"https://pkgs.netbird.io/windows/x64\"\n \turlWinExeArm = \"https://pkgs.netbird.io/windows/arm64\"\n )\n \n@@ -18,11 +18,11 @@ func DownloadUrl() string {\n \tif err != nil {\n \t\treturn downloadURL\n \t}\n-\t\n+\n \turl := urlWinExe\n \tif runtime.GOARCH == \"arm64\" {\n \t\turl = urlWinExeArm\n \t}\n-\t\n+\n \treturn url\n }\n", "test_patch": "diff --git a/client/cmd/ssh_test.go b/client/cmd/ssh_test.go\nnew file mode 100644\nindex 00000000000..43291fa87c1\n--- /dev/null\n+++ b/client/cmd/ssh_test.go\n@@ -0,0 +1,717 @@\n+package cmd\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+func TestSSHCommand_FlagParsing(t *testing.T) {\n+\ttests := []struct {\n+\t\tname         string\n+\t\targs         []string\n+\t\texpectedHost string\n+\t\texpectedUser string\n+\t\texpectedPort int\n+\t\texpectedCmd  string\n+\t\texpectError  bool\n+\t}{\n+\t\t{\n+\t\t\tname:         \"basic host\",\n+\t\t\targs:         []string{\"hostname\"},\n+\t\t\texpectedHost: \"hostname\",\n+\t\t\texpectedUser: \"\",\n+\t\t\texpectedPort: 22,\n+\t\t\texpectedCmd:  \"\",\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"user@host format\",\n+\t\t\targs:         []string{\"user@hostname\"},\n+\t\t\texpectedHost: \"hostname\",\n+\t\t\texpectedUser: \"user\",\n+\t\t\texpectedPort: 22,\n+\t\t\texpectedCmd:  \"\",\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"host with command\",\n+\t\t\targs:         []string{\"hostname\", \"echo\", \"hello\"},\n+\t\t\texpectedHost: \"hostname\",\n+\t\t\texpectedUser: \"\",\n+\t\t\texpectedPort: 22,\n+\t\t\texpectedCmd:  \"echo hello\",\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"command with flags should be preserved\",\n+\t\t\targs:         []string{\"hostname\", \"ls\", \"-la\", \"/tmp\"},\n+\t\t\texpectedHost: \"hostname\",\n+\t\t\texpectedUser: \"\",\n+\t\t\texpectedPort: 22,\n+\t\t\texpectedCmd:  \"ls -la /tmp\",\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"double dash separator\",\n+\t\t\targs:         []string{\"hostname\", \"--\", \"ls\", \"-la\"},\n+\t\t\texpectedHost: \"hostname\",\n+\t\t\texpectedUser: \"\",\n+\t\t\texpectedPort: 22,\n+\t\t\texpectedCmd:  \"-- ls -la\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Reset global variables\n+\t\t\thost = \"\"\n+\t\t\tusername = \"\"\n+\t\t\tport = 22\n+\t\t\tcommand = \"\"\n+\n+\t\t\t// Mock command for testing\n+\t\t\tcmd := sshCmd\n+\t\t\tcmd.SetArgs(tt.args)\n+\n+\t\t\terr := validateSSHArgsWithoutFlagParsing(cmd, tt.args)\n+\n+\t\t\tif tt.expectError {\n+\t\t\t\tassert.Error(t, err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\trequire.NoError(t, err, \"SSH args validation should succeed for valid input\")\n+\t\t\tassert.Equal(t, tt.expectedHost, host, \"host mismatch\")\n+\t\t\tif tt.expectedUser != \"\" {\n+\t\t\t\tassert.Equal(t, tt.expectedUser, username, \"username mismatch\")\n+\t\t\t}\n+\t\t\tassert.Equal(t, tt.expectedPort, port, \"port mismatch\")\n+\t\t\tassert.Equal(t, tt.expectedCmd, command, \"command mismatch\")\n+\t\t})\n+\t}\n+}\n+\n+func TestSSHCommand_FlagConflictPrevention(t *testing.T) {\n+\t// Test that SSH flags don't conflict with command flags\n+\ttests := []struct {\n+\t\tname        string\n+\t\targs        []string\n+\t\texpectedCmd string\n+\t\tdescription string\n+\t}{\n+\t\t{\n+\t\t\tname:        \"ls with -la flags\",\n+\t\t\targs:        []string{\"hostname\", \"ls\", \"-la\"},\n+\t\t\texpectedCmd: \"ls -la\",\n+\t\t\tdescription: \"ls flags should be passed to remote command\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"grep with -r flag\",\n+\t\t\targs:        []string{\"hostname\", \"grep\", \"-r\", \"pattern\", \"/path\"},\n+\t\t\texpectedCmd: \"grep -r pattern /path\",\n+\t\t\tdescription: \"grep flags should be passed to remote command\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"ps with aux flags\",\n+\t\t\targs:        []string{\"hostname\", \"ps\", \"aux\"},\n+\t\t\texpectedCmd: \"ps aux\",\n+\t\t\tdescription: \"ps flags should be passed to remote command\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"command with double dash\",\n+\t\t\targs:        []string{\"hostname\", \"--\", \"ls\", \"-la\"},\n+\t\t\texpectedCmd: \"-- ls -la\",\n+\t\t\tdescription: \"double dash should be preserved in command\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Reset global variables\n+\t\t\thost = \"\"\n+\t\t\tusername = \"\"\n+\t\t\tport = 22\n+\t\t\tcommand = \"\"\n+\n+\t\t\tcmd := sshCmd\n+\t\t\terr := validateSSHArgsWithoutFlagParsing(cmd, tt.args)\n+\t\t\trequire.NoError(t, err, \"SSH args validation should succeed for valid input\")\n+\n+\t\t\tassert.Equal(t, tt.expectedCmd, command, tt.description)\n+\t\t})\n+\t}\n+}\n+\n+func TestSSHCommand_NonInteractiveExecution(t *testing.T) {\n+\t// Test that commands with arguments should execute the command and exit,\n+\t// not drop to an interactive shell\n+\ttests := []struct {\n+\t\tname        string\n+\t\targs        []string\n+\t\texpectedCmd string\n+\t\tshouldExit  bool\n+\t\tdescription string\n+\t}{\n+\t\t{\n+\t\t\tname:        \"ls command should execute and exit\",\n+\t\t\targs:        []string{\"hostname\", \"ls\"},\n+\t\t\texpectedCmd: \"ls\",\n+\t\t\tshouldExit:  true,\n+\t\t\tdescription: \"ls command should execute and exit, not drop to shell\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"ls with flags should execute and exit\",\n+\t\t\targs:        []string{\"hostname\", \"ls\", \"-la\"},\n+\t\t\texpectedCmd: \"ls -la\",\n+\t\t\tshouldExit:  true,\n+\t\t\tdescription: \"ls with flags should execute and exit, not drop to shell\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"pwd command should execute and exit\",\n+\t\t\targs:        []string{\"hostname\", \"pwd\"},\n+\t\t\texpectedCmd: \"pwd\",\n+\t\t\tshouldExit:  true,\n+\t\t\tdescription: \"pwd command should execute and exit, not drop to shell\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"echo command should execute and exit\",\n+\t\t\targs:        []string{\"hostname\", \"echo\", \"hello\"},\n+\t\t\texpectedCmd: \"echo hello\",\n+\t\t\tshouldExit:  true,\n+\t\t\tdescription: \"echo command should execute and exit, not drop to shell\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"no command should open shell\",\n+\t\t\targs:        []string{\"hostname\"},\n+\t\t\texpectedCmd: \"\",\n+\t\t\tshouldExit:  false,\n+\t\t\tdescription: \"no command should open interactive shell\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Reset global variables\n+\t\t\thost = \"\"\n+\t\t\tusername = \"\"\n+\t\t\tport = 22\n+\t\t\tcommand = \"\"\n+\n+\t\t\tcmd := sshCmd\n+\t\t\terr := validateSSHArgsWithoutFlagParsing(cmd, tt.args)\n+\t\t\trequire.NoError(t, err, \"SSH args validation should succeed for valid input\")\n+\n+\t\t\tassert.Equal(t, tt.expectedCmd, command, tt.description)\n+\n+\t\t\t// When command is present, it should execute the command and exit\n+\t\t\t// When command is empty, it should open interactive shell\n+\t\t\thasCommand := command != \"\"\n+\t\t\tassert.Equal(t, tt.shouldExit, hasCommand, \"Command presence should match expected behavior\")\n+\t\t})\n+\t}\n+}\n+\n+func TestSSHCommand_FlagHandling(t *testing.T) {\n+\t// Test that flags after hostname are not parsed by netbird but passed to SSH command\n+\ttests := []struct {\n+\t\tname         string\n+\t\targs         []string\n+\t\texpectedHost string\n+\t\texpectedCmd  string\n+\t\texpectError  bool\n+\t\tdescription  string\n+\t}{\n+\t\t{\n+\t\t\tname:         \"ls with -la flag should not be parsed by netbird\",\n+\t\t\targs:         []string{\"debian2\", \"ls\", \"-la\"},\n+\t\t\texpectedHost: \"debian2\",\n+\t\t\texpectedCmd:  \"ls -la\",\n+\t\t\texpectError:  false,\n+\t\t\tdescription:  \"ls -la should be passed as SSH command, not parsed as netbird flags\",\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"command with netbird-like flags should be passed through\",\n+\t\t\targs:         []string{\"hostname\", \"echo\", \"--help\"},\n+\t\t\texpectedHost: \"hostname\",\n+\t\t\texpectedCmd:  \"echo --help\",\n+\t\t\texpectError:  false,\n+\t\t\tdescription:  \"--help should be passed to echo, not parsed by netbird\",\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"command with -p flag should not conflict with SSH port flag\",\n+\t\t\targs:         []string{\"hostname\", \"ps\", \"-p\", \"1234\"},\n+\t\t\texpectedHost: \"hostname\",\n+\t\t\texpectedCmd:  \"ps -p 1234\",\n+\t\t\texpectError:  false,\n+\t\t\tdescription:  \"ps -p should be passed to ps command, not parsed as port\",\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"tar with flags should be passed through\",\n+\t\t\targs:         []string{\"hostname\", \"tar\", \"-czf\", \"backup.tar.gz\", \"/home\"},\n+\t\t\texpectedHost: \"hostname\",\n+\t\t\texpectedCmd:  \"tar -czf backup.tar.gz /home\",\n+\t\t\texpectError:  false,\n+\t\t\tdescription:  \"tar flags should be passed to tar command\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Reset global variables\n+\t\t\thost = \"\"\n+\t\t\tusername = \"\"\n+\t\t\tport = 22\n+\t\t\tcommand = \"\"\n+\n+\t\t\tcmd := sshCmd\n+\t\t\terr := validateSSHArgsWithoutFlagParsing(cmd, tt.args)\n+\n+\t\t\tif tt.expectError {\n+\t\t\t\tassert.Error(t, err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\trequire.NoError(t, err, \"SSH args validation should succeed for valid input\")\n+\t\t\tassert.Equal(t, tt.expectedHost, host, \"host mismatch\")\n+\t\t\tassert.Equal(t, tt.expectedCmd, command, tt.description)\n+\t\t})\n+\t}\n+}\n+\n+func TestSSHCommand_RegressionFlagParsing(t *testing.T) {\n+\t// Regression test for the specific issue: \"sudo ./netbird ssh debian2 ls -la\"\n+\t// should not parse -la as netbird flags but pass them to the SSH command\n+\ttests := []struct {\n+\t\tname         string\n+\t\targs         []string\n+\t\texpectedHost string\n+\t\texpectedCmd  string\n+\t\texpectError  bool\n+\t\tdescription  string\n+\t}{\n+\t\t{\n+\t\t\tname:         \"original issue: ls -la should be preserved\",\n+\t\t\targs:         []string{\"debian2\", \"ls\", \"-la\"},\n+\t\t\texpectedHost: \"debian2\",\n+\t\t\texpectedCmd:  \"ls -la\",\n+\t\t\texpectError:  false,\n+\t\t\tdescription:  \"The original failing case should now work\",\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"ls -l should be preserved\",\n+\t\t\targs:         []string{\"hostname\", \"ls\", \"-l\"},\n+\t\t\texpectedHost: \"hostname\",\n+\t\t\texpectedCmd:  \"ls -l\",\n+\t\t\texpectError:  false,\n+\t\t\tdescription:  \"Single letter flags should be preserved\",\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"SSH port flag should work\",\n+\t\t\targs:         []string{\"-p\", \"2222\", \"hostname\", \"ls\", \"-la\"},\n+\t\t\texpectedHost: \"hostname\",\n+\t\t\texpectedCmd:  \"ls -la\",\n+\t\t\texpectError:  false,\n+\t\t\tdescription:  \"SSH -p flag should be parsed, command flags preserved\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Reset global variables\n+\t\t\thost = \"\"\n+\t\t\tusername = \"\"\n+\t\t\tport = 22\n+\t\t\tcommand = \"\"\n+\n+\t\t\tcmd := sshCmd\n+\t\t\terr := validateSSHArgsWithoutFlagParsing(cmd, tt.args)\n+\n+\t\t\tif tt.expectError {\n+\t\t\t\tassert.Error(t, err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\trequire.NoError(t, err, \"SSH args validation should succeed for valid input\")\n+\t\t\tassert.Equal(t, tt.expectedHost, host, \"host mismatch\")\n+\t\t\tassert.Equal(t, tt.expectedCmd, command, tt.description)\n+\n+\t\t\t// Check port for the test case with -p flag\n+\t\t\tif len(tt.args) > 0 && tt.args[0] == \"-p\" {\n+\t\t\t\tassert.Equal(t, 2222, port, \"port should be parsed from -p flag\")\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestSSHCommand_PortForwardingFlagParsing(t *testing.T) {\n+\ttests := []struct {\n+\t\tname           string\n+\t\targs           []string\n+\t\texpectedHost   string\n+\t\texpectedLocal  []string\n+\t\texpectedRemote []string\n+\t\texpectError    bool\n+\t\tdescription    string\n+\t}{\n+\t\t{\n+\t\t\tname:           \"local port forwarding -L\",\n+\t\t\targs:           []string{\"-L\", \"8080:localhost:80\", \"hostname\"},\n+\t\t\texpectedHost:   \"hostname\",\n+\t\t\texpectedLocal:  []string{\"8080:localhost:80\"},\n+\t\t\texpectedRemote: []string{},\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Single -L flag should be parsed correctly\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"remote port forwarding -R\",\n+\t\t\targs:           []string{\"-R\", \"8080:localhost:80\", \"hostname\"},\n+\t\t\texpectedHost:   \"hostname\",\n+\t\t\texpectedLocal:  []string{},\n+\t\t\texpectedRemote: []string{\"8080:localhost:80\"},\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Single -R flag should be parsed correctly\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"multiple local port forwards\",\n+\t\t\targs:           []string{\"-L\", \"8080:localhost:80\", \"-L\", \"9090:localhost:443\", \"hostname\"},\n+\t\t\texpectedHost:   \"hostname\",\n+\t\t\texpectedLocal:  []string{\"8080:localhost:80\", \"9090:localhost:443\"},\n+\t\t\texpectedRemote: []string{},\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Multiple -L flags should be parsed correctly\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"multiple remote port forwards\",\n+\t\t\targs:           []string{\"-R\", \"8080:localhost:80\", \"-R\", \"9090:localhost:443\", \"hostname\"},\n+\t\t\texpectedHost:   \"hostname\",\n+\t\t\texpectedLocal:  []string{},\n+\t\t\texpectedRemote: []string{\"8080:localhost:80\", \"9090:localhost:443\"},\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Multiple -R flags should be parsed correctly\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"mixed local and remote forwards\",\n+\t\t\targs:           []string{\"-L\", \"8080:localhost:80\", \"-R\", \"9090:localhost:443\", \"hostname\"},\n+\t\t\texpectedHost:   \"hostname\",\n+\t\t\texpectedLocal:  []string{\"8080:localhost:80\"},\n+\t\t\texpectedRemote: []string{\"9090:localhost:443\"},\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Mixed -L and -R flags should be parsed correctly\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"port forwarding with bind address\",\n+\t\t\targs:           []string{\"-L\", \"127.0.0.1:8080:localhost:80\", \"hostname\"},\n+\t\t\texpectedHost:   \"hostname\",\n+\t\t\texpectedLocal:  []string{\"127.0.0.1:8080:localhost:80\"},\n+\t\t\texpectedRemote: []string{},\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Port forwarding with bind address should work\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"port forwarding with command\",\n+\t\t\targs:           []string{\"-L\", \"8080:localhost:80\", \"hostname\", \"ls\", \"-la\"},\n+\t\t\texpectedHost:   \"hostname\",\n+\t\t\texpectedLocal:  []string{\"8080:localhost:80\"},\n+\t\t\texpectedRemote: []string{},\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Port forwarding with command should work\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Reset global variables\n+\t\t\thost = \"\"\n+\t\t\tusername = \"\"\n+\t\t\tport = 22\n+\t\t\tcommand = \"\"\n+\t\t\tlocalForwards = nil\n+\t\t\tremoteForwards = nil\n+\n+\t\t\tcmd := sshCmd\n+\t\t\terr := validateSSHArgsWithoutFlagParsing(cmd, tt.args)\n+\n+\t\t\tif tt.expectError {\n+\t\t\t\tassert.Error(t, err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\trequire.NoError(t, err, \"SSH args validation should succeed for valid input\")\n+\t\t\tassert.Equal(t, tt.expectedHost, host, \"host mismatch\")\n+\t\t\t// Handle nil vs empty slice comparison\n+\t\t\tif len(tt.expectedLocal) == 0 {\n+\t\t\t\tassert.True(t, len(localForwards) == 0, tt.description+\" - local forwards should be empty\")\n+\t\t\t} else {\n+\t\t\t\tassert.Equal(t, tt.expectedLocal, localForwards, tt.description+\" - local forwards\")\n+\t\t\t}\n+\t\t\tif len(tt.expectedRemote) == 0 {\n+\t\t\t\tassert.True(t, len(remoteForwards) == 0, tt.description+\" - remote forwards should be empty\")\n+\t\t\t} else {\n+\t\t\t\tassert.Equal(t, tt.expectedRemote, remoteForwards, tt.description+\" - remote forwards\")\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestParsePortForward(t *testing.T) {\n+\ttests := []struct {\n+\t\tname           string\n+\t\tspec           string\n+\t\texpectedLocal  string\n+\t\texpectedRemote string\n+\t\texpectError    bool\n+\t\tdescription    string\n+\t}{\n+\t\t{\n+\t\t\tname:           \"simple port forward\",\n+\t\t\tspec:           \"8080:localhost:80\",\n+\t\t\texpectedLocal:  \"localhost:8080\",\n+\t\t\texpectedRemote: \"localhost:80\",\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Simple port:host:port format should work\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"port forward with bind address\",\n+\t\t\tspec:           \"127.0.0.1:8080:localhost:80\",\n+\t\t\texpectedLocal:  \"127.0.0.1:8080\",\n+\t\t\texpectedRemote: \"localhost:80\",\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"bind_address:port:host:port format should work\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"port forward to different host\",\n+\t\t\tspec:           \"8080:example.com:443\",\n+\t\t\texpectedLocal:  \"localhost:8080\",\n+\t\t\texpectedRemote: \"example.com:443\",\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Forwarding to different host should work\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"port forward with IPv6 (needs bracket support)\",\n+\t\t\tspec:        \"::1:8080:localhost:80\",\n+\t\t\texpectError: true,\n+\t\t\tdescription: \"IPv6 without brackets fails as expected (feature to implement)\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"invalid format - too few parts\",\n+\t\t\tspec:        \"8080:localhost\",\n+\t\t\texpectError: true,\n+\t\t\tdescription: \"Invalid format with too few parts should fail\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"invalid format - too many parts\",\n+\t\t\tspec:        \"127.0.0.1:8080:localhost:80:extra\",\n+\t\t\texpectError: true,\n+\t\t\tdescription: \"Invalid format with too many parts should fail\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"empty spec\",\n+\t\t\tspec:        \"\",\n+\t\t\texpectError: true,\n+\t\t\tdescription: \"Empty spec should fail\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"unix socket local forward\",\n+\t\t\tspec:           \"8080:/tmp/socket\",\n+\t\t\texpectedLocal:  \"localhost:8080\",\n+\t\t\texpectedRemote: \"/tmp/socket\",\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Unix socket forwarding should work\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"unix socket with bind address\",\n+\t\t\tspec:           \"127.0.0.1:8080:/tmp/socket\",\n+\t\t\texpectedLocal:  \"127.0.0.1:8080\",\n+\t\t\texpectedRemote: \"/tmp/socket\",\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Unix socket with bind address should work\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"wildcard bind all interfaces\",\n+\t\t\tspec:           \"*:8080:localhost:80\",\n+\t\t\texpectedLocal:  \"0.0.0.0:8080\",\n+\t\t\texpectedRemote: \"localhost:80\",\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Wildcard * should bind to all interfaces (0.0.0.0)\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"wildcard for port only\",\n+\t\t\tspec:           \"8080:*:80\",\n+\t\t\texpectedLocal:  \"localhost:8080\",\n+\t\t\texpectedRemote: \"*:80\",\n+\t\t\texpectError:    false,\n+\t\t\tdescription:    \"Wildcard in remote host should be preserved\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tlocalAddr, remoteAddr, err := parsePortForwardSpec(tt.spec)\n+\n+\t\t\tif tt.expectError {\n+\t\t\t\tassert.Error(t, err, tt.description)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\trequire.NoError(t, err, tt.description)\n+\t\t\tassert.Equal(t, tt.expectedLocal, localAddr, tt.description+\" - local address\")\n+\t\t\tassert.Equal(t, tt.expectedRemote, remoteAddr, tt.description+\" - remote address\")\n+\t\t})\n+\t}\n+}\n+\n+func TestSSHCommand_IntegrationPortForwarding(t *testing.T) {\n+\t// Integration test for port forwarding with the actual SSH command implementation\n+\ttests := []struct {\n+\t\tname           string\n+\t\targs           []string\n+\t\texpectedHost   string\n+\t\texpectedLocal  []string\n+\t\texpectedRemote []string\n+\t\texpectedCmd    string\n+\t\tdescription    string\n+\t}{\n+\t\t{\n+\t\t\tname:           \"local forward with command\",\n+\t\t\targs:           []string{\"-L\", \"8080:localhost:80\", \"hostname\", \"echo\", \"test\"},\n+\t\t\texpectedHost:   \"hostname\",\n+\t\t\texpectedLocal:  []string{\"8080:localhost:80\"},\n+\t\t\texpectedRemote: []string{},\n+\t\t\texpectedCmd:    \"echo test\",\n+\t\t\tdescription:    \"Local forwarding should work with commands\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"remote forward with command\",\n+\t\t\targs:           []string{\"-R\", \"8080:localhost:80\", \"hostname\", \"ls\", \"-la\"},\n+\t\t\texpectedHost:   \"hostname\",\n+\t\t\texpectedLocal:  []string{},\n+\t\t\texpectedRemote: []string{\"8080:localhost:80\"},\n+\t\t\texpectedCmd:    \"ls -la\",\n+\t\t\tdescription:    \"Remote forwarding should work with commands\",\n+\t\t},\n+\t\t{\n+\t\t\tname:           \"multiple forwards with user and command\",\n+\t\t\targs:           []string{\"-L\", \"8080:localhost:80\", \"-R\", \"9090:localhost:443\", \"user@hostname\", \"ps\", \"aux\"},\n+\t\t\texpectedHost:   \"hostname\",\n+\t\t\texpectedLocal:  []string{\"8080:localhost:80\"},\n+\t\t\texpectedRemote: []string{\"9090:localhost:443\"},\n+\t\t\texpectedCmd:    \"ps aux\",\n+\t\t\tdescription:    \"Complex case with multiple forwards, user, and command\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Reset global variables\n+\t\t\thost = \"\"\n+\t\t\tusername = \"\"\n+\t\t\tport = 22\n+\t\t\tcommand = \"\"\n+\t\t\tlocalForwards = nil\n+\t\t\tremoteForwards = nil\n+\n+\t\t\tcmd := sshCmd\n+\t\t\terr := validateSSHArgsWithoutFlagParsing(cmd, tt.args)\n+\t\t\trequire.NoError(t, err, \"SSH args validation should succeed for valid input\")\n+\n+\t\t\tassert.Equal(t, tt.expectedHost, host, \"host mismatch\")\n+\t\t\t// Handle nil vs empty slice comparison\n+\t\t\tif len(tt.expectedLocal) == 0 {\n+\t\t\t\tassert.True(t, len(localForwards) == 0, tt.description+\" - local forwards should be empty\")\n+\t\t\t} else {\n+\t\t\t\tassert.Equal(t, tt.expectedLocal, localForwards, tt.description+\" - local forwards\")\n+\t\t\t}\n+\t\t\tif len(tt.expectedRemote) == 0 {\n+\t\t\t\tassert.True(t, len(remoteForwards) == 0, tt.description+\" - remote forwards should be empty\")\n+\t\t\t} else {\n+\t\t\t\tassert.Equal(t, tt.expectedRemote, remoteForwards, tt.description+\" - remote forwards\")\n+\t\t\t}\n+\t\t\tassert.Equal(t, tt.expectedCmd, command, tt.description+\" - command\")\n+\t\t})\n+\t}\n+}\n+\n+func TestSSHCommand_ParameterIsolation(t *testing.T) {\n+\ttests := []struct {\n+\t\tname        string\n+\t\targs        []string\n+\t\texpectedCmd string\n+\t}{\n+\t\t{\n+\t\t\tname:        \"cmd flag passed as command\",\n+\t\t\targs:        []string{\"hostname\", \"--cmd\", \"echo test\"},\n+\t\t\texpectedCmd: \"--cmd echo test\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"uid flag passed as command\",\n+\t\t\targs:        []string{\"hostname\", \"--uid\", \"1000\"},\n+\t\t\texpectedCmd: \"--uid 1000\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"shell flag passed as command\",\n+\t\t\targs:        []string{\"hostname\", \"--shell\", \"/bin/bash\"},\n+\t\t\texpectedCmd: \"--shell /bin/bash\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\thost = \"\"\n+\t\t\tusername = \"\"\n+\t\t\tport = 22\n+\t\t\tcommand = \"\"\n+\n+\t\t\terr := validateSSHArgsWithoutFlagParsing(sshCmd, tt.args)\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\tassert.Equal(t, \"hostname\", host)\n+\t\t\tassert.Equal(t, tt.expectedCmd, command)\n+\t\t})\n+\t}\n+}\n+\n+func TestSSHCommand_InvalidFlagRejection(t *testing.T) {\n+\t// Test that invalid flags are properly rejected and not misinterpreted as hostnames\n+\ttests := []struct {\n+\t\tname        string\n+\t\targs        []string\n+\t\tdescription string\n+\t}{\n+\t\t{\n+\t\t\tname:        \"invalid long flag before hostname\",\n+\t\t\targs:        []string{\"--invalid-flag\", \"hostname\"},\n+\t\t\tdescription: \"Invalid flag should return parse error, not treat flag as hostname\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"invalid short flag before hostname\",\n+\t\t\targs:        []string{\"-x\", \"hostname\"},\n+\t\t\tdescription: \"Invalid short flag should return parse error\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"invalid flag with value before hostname\",\n+\t\t\targs:        []string{\"--invalid-option=value\", \"hostname\"},\n+\t\t\tdescription: \"Invalid flag with value should return parse error\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"typo in known flag\",\n+\t\t\targs:        []string{\"--por\", \"2222\", \"hostname\"},\n+\t\t\tdescription: \"Typo in flag name should return parse error (not silently ignored)\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Reset global variables\n+\t\t\thost = \"\"\n+\t\t\tusername = \"\"\n+\t\t\tport = 22\n+\t\t\tcommand = \"\"\n+\n+\t\t\terr := validateSSHArgsWithoutFlagParsing(sshCmd, tt.args)\n+\n+\t\t\t// Should return an error for invalid flags\n+\t\t\tassert.Error(t, err, tt.description)\n+\n+\t\t\t// Should not have set host to the invalid flag\n+\t\t\tassert.NotEqual(t, tt.args[0], host, \"Invalid flag should not be interpreted as hostname\")\n+\t\t})\n+\t}\n+}\ndiff --git a/client/cmd/testutil_test.go b/client/cmd/testutil_test.go\nindex 78bb0476bfd..e7b0279e8a1 100644\n--- a/client/cmd/testutil_test.go\n+++ b/client/cmd/testutil_test.go\n@@ -12,6 +12,7 @@ import (\n \t\"google.golang.org/grpc\"\n \n \t\"github.com/netbirdio/management-integrations/integrations\"\n+\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map/controller\"\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map/update_channel\"\n \tnbgrpc \"github.com/netbirdio/netbird/management/internals/shared/grpc\"\n@@ -117,7 +118,7 @@ func startManagement(t *testing.T, config *config.Config, testFile string) (*grp\n \trequestBuffer := mgmt.NewAccountRequestBuffer(ctx, store)\n \tnetworkMapController := controller.NewController(ctx, store, metrics, updateManager, requestBuffer, mgmt.MockIntegratedValidator{}, settingsMockManager, \"netbird.cloud\", port_forwarding.NewControllerMock())\n \n-\taccountManager, err := mgmt.BuildManager(context.Background(), store, networkMapController, nil, \"\", eventStore, nil, false, iv, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManagerMock, false)\n+\taccountManager, err := mgmt.BuildManager(context.Background(), config, store, networkMapController, nil, \"\", eventStore, nil, false, iv, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManagerMock, false)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\ndiff --git a/client/firewall/uspfilter/filter_test.go b/client/firewall/uspfilter/filter_test.go\nindex c56a078fcf5..120a9f41887 100644\n--- a/client/firewall/uspfilter/filter_test.go\n+++ b/client/firewall/uspfilter/filter_test.go\n@@ -22,6 +22,7 @@ import (\n \t\"github.com/netbirdio/netbird/client/iface/device\"\n \t\"github.com/netbirdio/netbird/client/iface/wgaddr\"\n \t\"github.com/netbirdio/netbird/client/internal/netflow\"\n+\tnftypes \"github.com/netbirdio/netbird/client/internal/netflow/types\"\n \t\"github.com/netbirdio/netbird/shared/management/domain\"\n )\n \n@@ -1114,3 +1115,138 @@ func generateTCPPacketWithFlags(tb testing.TB, srcIP, dstIP net.IP, srcPort, dst\n \n \treturn buf.Bytes()\n }\n+\n+func TestShouldForward(t *testing.T) {\n+\t// Set up test addresses\n+\twgIP := netip.MustParseAddr(\"100.10.0.1\")\n+\totherIP := netip.MustParseAddr(\"100.10.0.2\")\n+\n+\t// Create test manager with mock interface\n+\tifaceMock := &IFaceMock{\n+\t\tSetFilterFunc: func(device.PacketFilter) error { return nil },\n+\t}\n+\t// Set the mock to return our test WG IP\n+\tifaceMock.AddressFunc = func() wgaddr.Address {\n+\t\treturn wgaddr.Address{IP: wgIP, Network: netip.PrefixFrom(wgIP, 24)}\n+\t}\n+\n+\tmanager, err := Create(ifaceMock, false, flowLogger, nbiface.DefaultMTU)\n+\trequire.NoError(t, err)\n+\tdefer func() {\n+\t\trequire.NoError(t, manager.Close(nil))\n+\t}()\n+\n+\t// Helper to create decoder with TCP packet\n+\tcreateTCPDecoder := func(dstPort uint16) *decoder {\n+\t\tipv4 := &layers.IPv4{\n+\t\t\tVersion:  4,\n+\t\t\tProtocol: layers.IPProtocolTCP,\n+\t\t\tSrcIP:    net.ParseIP(\"192.168.1.100\"),\n+\t\t\tDstIP:    wgIP.AsSlice(),\n+\t\t}\n+\t\ttcp := &layers.TCP{\n+\t\t\tSrcPort: 54321,\n+\t\t\tDstPort: layers.TCPPort(dstPort),\n+\t\t}\n+\n+\t\terr := tcp.SetNetworkLayerForChecksum(ipv4)\n+\t\trequire.NoError(t, err)\n+\n+\t\tbuf := gopacket.NewSerializeBuffer()\n+\t\topts := gopacket.SerializeOptions{ComputeChecksums: true, FixLengths: true}\n+\t\terr = gopacket.SerializeLayers(buf, opts, ipv4, tcp, gopacket.Payload(\"test\"))\n+\t\trequire.NoError(t, err)\n+\n+\t\td := &decoder{\n+\t\t\tdecoded: []gopacket.LayerType{},\n+\t\t}\n+\t\td.parser = gopacket.NewDecodingLayerParser(\n+\t\t\tlayers.LayerTypeIPv4,\n+\t\t\t&d.eth, &d.ip4, &d.ip6, &d.icmp4, &d.icmp6, &d.tcp, &d.udp,\n+\t\t)\n+\t\td.parser.IgnoreUnsupported = true\n+\n+\t\terr = d.parser.DecodeLayers(buf.Bytes(), &d.decoded)\n+\t\trequire.NoError(t, err)\n+\n+\t\treturn d\n+\t}\n+\n+\ttests := []struct {\n+\t\tname              string\n+\t\tlocalForwarding   bool\n+\t\tnetstack          bool\n+\t\tdstIP             netip.Addr\n+\t\tserviceRegistered bool\n+\t\tservicePort       uint16\n+\t\texpected          bool\n+\t\tdescription       string\n+\t}{\n+\t\t{\n+\t\t\tname:            \"no local forwarding\",\n+\t\t\tlocalForwarding: false,\n+\t\t\tnetstack:        true,\n+\t\t\tdstIP:           wgIP,\n+\t\t\texpected:        false,\n+\t\t\tdescription:     \"should never forward when local forwarding disabled\",\n+\t\t},\n+\t\t{\n+\t\t\tname:            \"traffic to other local interface\",\n+\t\t\tlocalForwarding: true,\n+\t\t\tnetstack:        false,\n+\t\t\tdstIP:           otherIP,\n+\t\t\texpected:        true,\n+\t\t\tdescription:     \"should forward traffic to our other local interfaces (not NetBird IP)\",\n+\t\t},\n+\t\t{\n+\t\t\tname:            \"traffic to NetBird IP, no netstack\",\n+\t\t\tlocalForwarding: true,\n+\t\t\tnetstack:        false,\n+\t\t\tdstIP:           wgIP,\n+\t\t\texpected:        false,\n+\t\t\tdescription:     \"should send to netstack listeners (final return false path)\",\n+\t\t},\n+\t\t{\n+\t\t\tname:            \"traffic to our IP, netstack mode, no service\",\n+\t\t\tlocalForwarding: true,\n+\t\t\tnetstack:        true,\n+\t\t\tdstIP:           wgIP,\n+\t\t\texpected:        true,\n+\t\t\tdescription:     \"should forward when in netstack mode with no matching service\",\n+\t\t},\n+\t\t{\n+\t\t\tname:              \"traffic to our IP, netstack mode, with service\",\n+\t\t\tlocalForwarding:   true,\n+\t\t\tnetstack:          true,\n+\t\t\tdstIP:             wgIP,\n+\t\t\tserviceRegistered: true,\n+\t\t\tservicePort:       22,\n+\t\t\texpected:          false,\n+\t\t\tdescription:       \"should send to netstack listeners when service is registered\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Configure manager\n+\t\t\tmanager.localForwarding = tt.localForwarding\n+\t\t\tmanager.netstack = tt.netstack\n+\n+\t\t\t// Register service if needed\n+\t\t\tif tt.serviceRegistered {\n+\t\t\t\tmanager.RegisterNetstackService(nftypes.TCP, tt.servicePort)\n+\t\t\t\tdefer manager.UnregisterNetstackService(nftypes.TCP, tt.servicePort)\n+\t\t\t}\n+\n+\t\t\t// Create decoder for the test\n+\t\t\tdecoder := createTCPDecoder(tt.servicePort)\n+\t\t\tif !tt.serviceRegistered {\n+\t\t\t\tdecoder = createTCPDecoder(8080) // Use non-registered port\n+\t\t\t}\n+\n+\t\t\t// Test the method\n+\t\t\tresult := manager.shouldForward(decoder, tt.dstIP)\n+\t\t\trequire.Equal(t, tt.expected, result, tt.description)\n+\t\t})\n+\t}\n+}\ndiff --git a/client/firewall/uspfilter/nat_stateful_test.go b/client/firewall/uspfilter/nat_stateful_test.go\nnew file mode 100644\nindex 00000000000..21c6da06e32\n--- /dev/null\n+++ b/client/firewall/uspfilter/nat_stateful_test.go\n@@ -0,0 +1,85 @@\n+package uspfilter\n+\n+import (\n+\t\"net/netip\"\n+\t\"testing\"\n+\n+\t\"github.com/google/gopacket/layers\"\n+\t\"github.com/stretchr/testify/require\"\n+\n+\t\"github.com/netbirdio/netbird/client/iface\"\n+\t\"github.com/netbirdio/netbird/client/iface/device\"\n+)\n+\n+// TestPortDNATBasic tests basic port DNAT functionality\n+func TestPortDNATBasic(t *testing.T) {\n+\tmanager, err := Create(&IFaceMock{\n+\t\tSetFilterFunc: func(device.PacketFilter) error { return nil },\n+\t}, false, flowLogger, iface.DefaultMTU)\n+\trequire.NoError(t, err)\n+\tdefer func() {\n+\t\trequire.NoError(t, manager.Close(nil))\n+\t}()\n+\n+\t// Define peer IPs\n+\tpeerA := netip.MustParseAddr(\"100.10.0.50\")\n+\tpeerB := netip.MustParseAddr(\"100.10.0.51\")\n+\n+\t// Add SSH port redirection rule for peer B (the target)\n+\terr = manager.addPortRedirection(peerB, layers.LayerTypeTCP, 22, 22022)\n+\trequire.NoError(t, err)\n+\n+\t// Scenario: Peer A connects to Peer B on port 22 (should get NAT)\n+\tpacketAtoB := generateDNATTestPacket(t, peerA, peerB, layers.IPProtocolTCP, 54321, 22)\n+\td := parsePacket(t, packetAtoB)\n+\ttranslatedAtoB := manager.translateInboundPortDNAT(packetAtoB, d, peerA, peerB)\n+\trequire.True(t, translatedAtoB, \"Peer A to Peer B should be translated (NAT applied)\")\n+\n+\t// Verify port was translated to 22022\n+\td = parsePacket(t, packetAtoB)\n+\trequire.Equal(t, uint16(22022), uint16(d.tcp.DstPort), \"Port should be rewritten to 22022\")\n+\n+\t// Scenario: Return traffic from Peer B to Peer A should NOT be translated\n+\t// (prevents double NAT - original port stored in conntrack)\n+\treturnPacket := generateDNATTestPacket(t, peerB, peerA, layers.IPProtocolTCP, 22022, 54321)\n+\td2 := parsePacket(t, returnPacket)\n+\ttranslatedReturn := manager.translateInboundPortDNAT(returnPacket, d2, peerB, peerA)\n+\trequire.False(t, translatedReturn, \"Return traffic from same IP should not be translated\")\n+}\n+\n+// TestPortDNATMultipleRules tests multiple port DNAT rules\n+func TestPortDNATMultipleRules(t *testing.T) {\n+\tmanager, err := Create(&IFaceMock{\n+\t\tSetFilterFunc: func(device.PacketFilter) error { return nil },\n+\t}, false, flowLogger, iface.DefaultMTU)\n+\trequire.NoError(t, err)\n+\tdefer func() {\n+\t\trequire.NoError(t, manager.Close(nil))\n+\t}()\n+\n+\t// Define peer IPs\n+\tpeerA := netip.MustParseAddr(\"100.10.0.50\")\n+\tpeerB := netip.MustParseAddr(\"100.10.0.51\")\n+\n+\t// Add SSH port redirection rules for both peers\n+\terr = manager.addPortRedirection(peerA, layers.LayerTypeTCP, 22, 22022)\n+\trequire.NoError(t, err)\n+\terr = manager.addPortRedirection(peerB, layers.LayerTypeTCP, 22, 22022)\n+\trequire.NoError(t, err)\n+\n+\t// Test traffic to peer B gets translated\n+\tpacketToB := generateDNATTestPacket(t, peerA, peerB, layers.IPProtocolTCP, 54321, 22)\n+\td1 := parsePacket(t, packetToB)\n+\ttranslatedToB := manager.translateInboundPortDNAT(packetToB, d1, peerA, peerB)\n+\trequire.True(t, translatedToB, \"Traffic to peer B should be translated\")\n+\td1 = parsePacket(t, packetToB)\n+\trequire.Equal(t, uint16(22022), uint16(d1.tcp.DstPort), \"Port should be 22022\")\n+\n+\t// Test traffic to peer A gets translated\n+\tpacketToA := generateDNATTestPacket(t, peerB, peerA, layers.IPProtocolTCP, 54322, 22)\n+\td2 := parsePacket(t, packetToA)\n+\ttranslatedToA := manager.translateInboundPortDNAT(packetToA, d2, peerB, peerA)\n+\trequire.True(t, translatedToA, \"Traffic to peer A should be translated\")\n+\td2 = parsePacket(t, packetToA)\n+\trequire.Equal(t, uint16(22022), uint16(d2.tcp.DstPort), \"Port should be 22022\")\n+}\ndiff --git a/client/internal/acl/manager_test.go b/client/internal/acl/manager_test.go\nindex 638245bf72b..4bc0fd800e3 100644\n--- a/client/internal/acl/manager_test.go\n+++ b/client/internal/acl/manager_test.go\n@@ -272,70 +272,3 @@ func TestPortInfoEmpty(t *testing.T) {\n \t\t})\n \t}\n }\n-\n-func TestDefaultManagerEnableSSHRules(t *testing.T) {\n-\tnetworkMap := &mgmProto.NetworkMap{\n-\t\tPeerConfig: &mgmProto.PeerConfig{\n-\t\t\tSshConfig: &mgmProto.SSHConfig{\n-\t\t\t\tSshEnabled: true,\n-\t\t\t},\n-\t\t},\n-\t\tRemotePeers: []*mgmProto.RemotePeerConfig{\n-\t\t\t{AllowedIps: []string{\"10.93.0.1\"}},\n-\t\t\t{AllowedIps: []string{\"10.93.0.2\"}},\n-\t\t\t{AllowedIps: []string{\"10.93.0.3\"}},\n-\t\t},\n-\t\tFirewallRules: []*mgmProto.FirewallRule{\n-\t\t\t{\n-\t\t\t\tPeerIP:    \"10.93.0.1\",\n-\t\t\t\tDirection: mgmProto.RuleDirection_IN,\n-\t\t\t\tAction:    mgmProto.RuleAction_ACCEPT,\n-\t\t\t\tProtocol:  mgmProto.RuleProtocol_TCP,\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tPeerIP:    \"10.93.0.2\",\n-\t\t\t\tDirection: mgmProto.RuleDirection_IN,\n-\t\t\t\tAction:    mgmProto.RuleAction_ACCEPT,\n-\t\t\t\tProtocol:  mgmProto.RuleProtocol_TCP,\n-\t\t\t},\n-\t\t\t{\n-\t\t\t\tPeerIP:    \"10.93.0.3\",\n-\t\t\t\tDirection: mgmProto.RuleDirection_OUT,\n-\t\t\t\tAction:    mgmProto.RuleAction_ACCEPT,\n-\t\t\t\tProtocol:  mgmProto.RuleProtocol_UDP,\n-\t\t\t},\n-\t\t},\n-\t}\n-\n-\tctrl := gomock.NewController(t)\n-\tdefer ctrl.Finish()\n-\n-\tifaceMock := mocks.NewMockIFaceMapper(ctrl)\n-\tifaceMock.EXPECT().IsUserspaceBind().Return(true).AnyTimes()\n-\tifaceMock.EXPECT().SetFilter(gomock.Any())\n-\tnetwork := netip.MustParsePrefix(\"172.0.0.1/32\")\n-\n-\tifaceMock.EXPECT().Name().Return(\"lo\").AnyTimes()\n-\tifaceMock.EXPECT().Address().Return(wgaddr.Address{\n-\t\tIP:      network.Addr(),\n-\t\tNetwork: network,\n-\t}).AnyTimes()\n-\tifaceMock.EXPECT().GetWGDevice().Return(nil).AnyTimes()\n-\n-\tfw, err := firewall.NewFirewall(ifaceMock, nil, flowLogger, false, iface.DefaultMTU)\n-\trequire.NoError(t, err)\n-\tdefer func() {\n-\t\terr = fw.Close(nil)\n-\t\trequire.NoError(t, err)\n-\t}()\n-\n-\tacl := NewDefaultManager(fw)\n-\n-\tacl.ApplyFiltering(networkMap, false)\n-\n-\texpectedRules := 3\n-\tif fw.IsStateful() {\n-\t\texpectedRules = 3 // 2 inbound rules + SSH rule\n-\t}\n-\tassert.Equal(t, expectedRules, len(acl.peerRulesPairs))\n-}\ndiff --git a/client/internal/engine_test.go b/client/internal/engine_test.go\nindex d15a07f9d27..3b7ff0eba5d 100644\n--- a/client/internal/engine_test.go\n+++ b/client/internal/engine_test.go\n@@ -14,7 +14,6 @@ import (\n \n \t\"github.com/golang/mock/gomock\"\n \t\"github.com/google/uuid\"\n-\t\"github.com/netbirdio/netbird/client/internal/stdnet\"\n \tlog \"github.com/sirupsen/logrus\"\n \t\"github.com/stretchr/testify/assert\"\n \t\"github.com/stretchr/testify/require\"\n@@ -25,7 +24,10 @@ import (\n \t\"google.golang.org/grpc\"\n \t\"google.golang.org/grpc/keepalive\"\n \n+\t\"github.com/netbirdio/netbird/client/internal/stdnet\"\n+\n \t\"github.com/netbirdio/management-integrations/integrations\"\n+\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map/controller\"\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map/update_channel\"\n \tnbgrpc \"github.com/netbirdio/netbird/management/internals/shared/grpc\"\n@@ -46,7 +48,7 @@ import (\n \ticemaker \"github.com/netbirdio/netbird/client/internal/peer/ice\"\n \t\"github.com/netbirdio/netbird/client/internal/profilemanager\"\n \t\"github.com/netbirdio/netbird/client/internal/routemanager\"\n-\t\"github.com/netbirdio/netbird/client/ssh\"\n+\tnbssh \"github.com/netbirdio/netbird/client/ssh\"\n \t\"github.com/netbirdio/netbird/client/system\"\n \tnbdns \"github.com/netbirdio/netbird/dns\"\n \t\"github.com/netbirdio/netbird/management/server\"\n@@ -214,11 +216,13 @@ func TestMain(m *testing.M) {\n }\n \n func TestEngine_SSH(t *testing.T) {\n-\tif runtime.GOOS == \"windows\" {\n-\t\tt.Skip(\"skipping TestEngine_SSH\")\n+\tkey, err := wgtypes.GeneratePrivateKey()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t\treturn\n \t}\n \n-\tkey, err := wgtypes.GeneratePrivateKey()\n+\tsshKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t\treturn\n@@ -240,6 +244,7 @@ func TestEngine_SSH(t *testing.T) {\n \t\t\tWgPort:           33100,\n \t\t\tServerSSHAllowed: true,\n \t\t\tMTU:              iface.DefaultMTU,\n+\t\t\tSSHKey:           sshKey,\n \t\t},\n \t\tMobileDependency{},\n \t\tpeer.NewRecorder(\"https://mgm\"),\n@@ -250,35 +255,8 @@ func TestEngine_SSH(t *testing.T) {\n \t\tUpdateDNSServerFunc: func(serial uint64, update nbdns.Config) error { return nil },\n \t}\n \n-\tvar sshKeysAdded []string\n-\tvar sshPeersRemoved []string\n-\n-\tsshCtx, cancel := context.WithCancel(context.Background())\n-\n-\tengine.sshServerFunc = func(hostKeyPEM []byte, addr string) (ssh.Server, error) {\n-\t\treturn &ssh.MockServer{\n-\t\t\tCtx: sshCtx,\n-\t\t\tStopFunc: func() error {\n-\t\t\t\tcancel()\n-\t\t\t\treturn nil\n-\t\t\t},\n-\t\t\tStartFunc: func() error {\n-\t\t\t\t<-ctx.Done()\n-\t\t\t\treturn ctx.Err()\n-\t\t\t},\n-\t\t\tAddAuthorizedKeyFunc: func(peer, newKey string) error {\n-\t\t\t\tsshKeysAdded = append(sshKeysAdded, newKey)\n-\t\t\t\treturn nil\n-\t\t\t},\n-\t\t\tRemoveAuthorizedKeyFunc: func(peer string) {\n-\t\t\t\tsshPeersRemoved = append(sshPeersRemoved, peer)\n-\t\t\t},\n-\t\t}, nil\n-\t}\n \terr = engine.Start(nil, nil)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n+\trequire.NoError(t, err)\n \n \tdefer func() {\n \t\terr := engine.Stop()\n@@ -304,9 +282,7 @@ func TestEngine_SSH(t *testing.T) {\n \t}\n \n \terr = engine.updateNetworkMap(networkMap)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n+\trequire.NoError(t, err)\n \n \tassert.Nil(t, engine.sshServer)\n \n@@ -314,19 +290,24 @@ func TestEngine_SSH(t *testing.T) {\n \tnetworkMap = &mgmtProto.NetworkMap{\n \t\tSerial: 7,\n \t\tPeerConfig: &mgmtProto.PeerConfig{Address: \"100.64.0.1/24\",\n-\t\t\tSshConfig: &mgmtProto.SSHConfig{SshEnabled: true}},\n+\t\t\tSshConfig: &mgmtProto.SSHConfig{\n+\t\t\t\tSshEnabled: true,\n+\t\t\t\tJwtConfig: &mgmtProto.JWTConfig{\n+\t\t\t\t\tIssuer:       \"test-issuer\",\n+\t\t\t\t\tAudience:     \"test-audience\",\n+\t\t\t\t\tKeysLocation: \"test-keys\",\n+\t\t\t\t\tMaxTokenAge:  3600,\n+\t\t\t\t},\n+\t\t\t}},\n \t\tRemotePeers:        []*mgmtProto.RemotePeerConfig{peerWithSSH},\n \t\tRemotePeersIsEmpty: false,\n \t}\n \n \terr = engine.updateNetworkMap(networkMap)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n+\trequire.NoError(t, err)\n \n \ttime.Sleep(250 * time.Millisecond)\n \tassert.NotNil(t, engine.sshServer)\n-\tassert.Contains(t, sshKeysAdded, \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFATYCqaQw/9id1Qkq3n16JYhDhXraI6Pc1fgB8ynEfQ\")\n \n \t// now remove peer\n \tnetworkMap = &mgmtProto.NetworkMap{\n@@ -336,13 +317,10 @@ func TestEngine_SSH(t *testing.T) {\n \t}\n \n \terr = engine.updateNetworkMap(networkMap)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n+\trequire.NoError(t, err)\n \n \t// time.Sleep(250 * time.Millisecond)\n \tassert.NotNil(t, engine.sshServer)\n-\tassert.Contains(t, sshPeersRemoved, \"MNHf3Ma6z6mdLbriAJbqhX7+nM/B71lgw2+91q3LfhU=\")\n \n \t// now disable SSH server\n \tnetworkMap = &mgmtProto.NetworkMap{\n@@ -354,12 +332,70 @@ func TestEngine_SSH(t *testing.T) {\n \t}\n \n \terr = engine.updateNetworkMap(networkMap)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n+\trequire.NoError(t, err)\n+\n+\tassert.Nil(t, engine.sshServer)\n+}\n+\n+func TestEngine_SSHUpdateLogic(t *testing.T) {\n+\t// Test that SSH server start/stop logic works based on config\n+\tengine := &Engine{\n+\t\tconfig: &EngineConfig{\n+\t\t\tServerSSHAllowed: false, // Start with SSH disabled\n+\t\t},\n+\t\tsyncMsgMux: &sync.Mutex{},\n \t}\n \n+\t// Test SSH disabled config\n+\tsshConfig := &mgmtProto.SSHConfig{SshEnabled: false}\n+\terr := engine.updateSSH(sshConfig)\n+\tassert.NoError(t, err)\n \tassert.Nil(t, engine.sshServer)\n \n+\t// Test inbound blocked\n+\tengine.config.BlockInbound = true\n+\terr = engine.updateSSH(&mgmtProto.SSHConfig{SshEnabled: true})\n+\tassert.NoError(t, err)\n+\tassert.Nil(t, engine.sshServer)\n+\tengine.config.BlockInbound = false\n+\n+\t// Test with server SSH not allowed\n+\terr = engine.updateSSH(&mgmtProto.SSHConfig{SshEnabled: true})\n+\tassert.NoError(t, err)\n+\tassert.Nil(t, engine.sshServer)\n+}\n+\n+func TestEngine_SSHServerConsistency(t *testing.T) {\n+\n+\tt.Run(\"server set only on successful creation\", func(t *testing.T) {\n+\t\tengine := &Engine{\n+\t\t\tconfig: &EngineConfig{\n+\t\t\t\tServerSSHAllowed: true,\n+\t\t\t\tSSHKey:           []byte(\"test-key\"),\n+\t\t\t},\n+\t\t\tsyncMsgMux: &sync.Mutex{},\n+\t\t}\n+\n+\t\tengine.wgInterface = nil\n+\n+\t\terr := engine.updateSSH(&mgmtProto.SSHConfig{SshEnabled: true})\n+\n+\t\tassert.Error(t, err)\n+\t\tassert.Nil(t, engine.sshServer)\n+\t})\n+\n+\tt.Run(\"cleanup handles nil gracefully\", func(t *testing.T) {\n+\t\tengine := &Engine{\n+\t\t\tconfig: &EngineConfig{\n+\t\t\t\tServerSSHAllowed: false,\n+\t\t\t},\n+\t\t\tsyncMsgMux: &sync.Mutex{},\n+\t\t}\n+\n+\t\terr := engine.stopSSHServer()\n+\t\tassert.NoError(t, err)\n+\t\tassert.Nil(t, engine.sshServer)\n+\t})\n }\n \n func TestEngine_UpdateNetworkMap(t *testing.T) {\n@@ -1589,7 +1625,7 @@ func startManagement(t *testing.T, dataDir, testFile string) (*grpc.Server, stri\n \tupdateManager := update_channel.NewPeersUpdateManager(metrics)\n \trequestBuffer := server.NewAccountRequestBuffer(context.Background(), store)\n \tnetworkMapController := controller.NewController(context.Background(), store, metrics, updateManager, requestBuffer, server.MockIntegratedValidator{}, settingsMockManager, \"netbird.selfhosted\", port_forwarding.NewControllerMock())\n-\taccountManager, err := server.BuildManager(context.Background(), store, networkMapController, nil, \"\", eventStore, nil, false, ia, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n+\taccountManager, err := server.BuildManager(context.Background(), config, store, networkMapController, nil, \"\", eventStore, nil, false, ia, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n \tif err != nil {\n \t\treturn nil, \"\", err\n \t}\ndiff --git a/client/internal/profilemanager/config_test.go b/client/internal/profilemanager/config_test.go\nindex 90bde7707f9..ab13cf3895f 100644\n--- a/client/internal/profilemanager/config_test.go\n+++ b/client/internal/profilemanager/config_test.go\n@@ -193,10 +193,10 @@ func TestWireguardPortZeroExplicit(t *testing.T) {\n \n func TestWireguardPortDefaultVsExplicit(t *testing.T) {\n \ttests := []struct {\n-\t\tname           string\n-\t\twireguardPort  *int\n-\t\texpectedPort   int\n-\t\tdescription    string\n+\t\tname          string\n+\t\twireguardPort *int\n+\t\texpectedPort  int\n+\t\tdescription   string\n \t}{\n \t\t{\n \t\t\tname:          \"no port specified uses default\",\ndiff --git a/client/server/server_test.go b/client/server/server_test.go\nindex ae5f759ee04..96d4c0af0d6 100644\n--- a/client/server/server_test.go\n+++ b/client/server/server_test.go\n@@ -14,6 +14,7 @@ import (\n \t\"go.opentelemetry.io/otel\"\n \n \t\"github.com/netbirdio/management-integrations/integrations\"\n+\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map/controller\"\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map/update_channel\"\n \tnbgrpc \"github.com/netbirdio/netbird/management/internals/shared/grpc\"\n@@ -316,7 +317,7 @@ func startManagement(t *testing.T, signalAddr string, counter *int) (*grpc.Serve\n \trequestBuffer := server.NewAccountRequestBuffer(context.Background(), store)\n \tpeersUpdateManager := update_channel.NewPeersUpdateManager(metrics)\n \tnetworkMapController := controller.NewController(context.Background(), store, metrics, peersUpdateManager, requestBuffer, server.MockIntegratedValidator{}, settingsMockManager, \"netbird.selfhosted\", port_forwarding.NewControllerMock())\n-\taccountManager, err := server.BuildManager(context.Background(), store, networkMapController, nil, \"\", eventStore, nil, false, ia, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManagerMock, false)\n+\taccountManager, err := server.BuildManager(context.Background(), config, store, networkMapController, nil, \"\", eventStore, nil, false, ia, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManagerMock, false)\n \tif err != nil {\n \t\treturn nil, \"\", err\n \t}\ndiff --git a/client/server/setconfig_test.go b/client/server/setconfig_test.go\nindex 1260bcc7835..8e360175d45 100644\n--- a/client/server/setconfig_test.go\n+++ b/client/server/setconfig_test.go\n@@ -72,6 +72,7 @@ func TestSetConfig_AllFieldsSaved(t *testing.T) {\n \tlazyConnectionEnabled := true\n \tblockInbound := true\n \tmtu := int64(1280)\n+\tsshJWTCacheTTL := int32(300)\n \n \treq := &proto.SetConfigRequest{\n \t\tProfileName:           profName,\n@@ -102,6 +103,7 @@ func TestSetConfig_AllFieldsSaved(t *testing.T) {\n \t\tCleanDNSLabels:        false,\n \t\tDnsRouteInterval:      durationpb.New(2 * time.Minute),\n \t\tMtu:                   &mtu,\n+\t\tSshJWTCacheTTL:        &sshJWTCacheTTL,\n \t}\n \n \t_, err = s.SetConfig(ctx, req)\n@@ -146,6 +148,8 @@ func TestSetConfig_AllFieldsSaved(t *testing.T) {\n \trequire.Equal(t, []string{\"label1\", \"label2\"}, cfg.DNSLabels.ToPunycodeList())\n \trequire.Equal(t, 2*time.Minute, cfg.DNSRouteInterval)\n \trequire.Equal(t, uint16(mtu), cfg.MTU)\n+\trequire.NotNil(t, cfg.SSHJWTCacheTTL)\n+\trequire.Equal(t, int(sshJWTCacheTTL), *cfg.SSHJWTCacheTTL)\n \n \tverifyAllFieldsCovered(t, req)\n }\n@@ -167,30 +171,36 @@ func verifyAllFieldsCovered(t *testing.T, req *proto.SetConfigRequest) {\n \t}\n \n \texpectedFields := map[string]bool{\n-\t\t\"ManagementUrl\":         true,\n-\t\t\"AdminURL\":              true,\n-\t\t\"RosenpassEnabled\":      true,\n-\t\t\"RosenpassPermissive\":   true,\n-\t\t\"ServerSSHAllowed\":      true,\n-\t\t\"InterfaceName\":         true,\n-\t\t\"WireguardPort\":         true,\n-\t\t\"OptionalPreSharedKey\":  true,\n-\t\t\"DisableAutoConnect\":    true,\n-\t\t\"NetworkMonitor\":        true,\n-\t\t\"DisableClientRoutes\":   true,\n-\t\t\"DisableServerRoutes\":   true,\n-\t\t\"DisableDns\":            true,\n-\t\t\"DisableFirewall\":       true,\n-\t\t\"BlockLanAccess\":        true,\n-\t\t\"DisableNotifications\":  true,\n-\t\t\"LazyConnectionEnabled\": true,\n-\t\t\"BlockInbound\":          true,\n-\t\t\"NatExternalIPs\":        true,\n-\t\t\"CustomDNSAddress\":      true,\n-\t\t\"ExtraIFaceBlacklist\":   true,\n-\t\t\"DnsLabels\":             true,\n-\t\t\"DnsRouteInterval\":      true,\n-\t\t\"Mtu\":                   true,\n+\t\t\"ManagementUrl\":                 true,\n+\t\t\"AdminURL\":                      true,\n+\t\t\"RosenpassEnabled\":              true,\n+\t\t\"RosenpassPermissive\":           true,\n+\t\t\"ServerSSHAllowed\":              true,\n+\t\t\"InterfaceName\":                 true,\n+\t\t\"WireguardPort\":                 true,\n+\t\t\"OptionalPreSharedKey\":          true,\n+\t\t\"DisableAutoConnect\":            true,\n+\t\t\"NetworkMonitor\":                true,\n+\t\t\"DisableClientRoutes\":           true,\n+\t\t\"DisableServerRoutes\":           true,\n+\t\t\"DisableDns\":                    true,\n+\t\t\"DisableFirewall\":               true,\n+\t\t\"BlockLanAccess\":                true,\n+\t\t\"DisableNotifications\":          true,\n+\t\t\"LazyConnectionEnabled\":         true,\n+\t\t\"BlockInbound\":                  true,\n+\t\t\"NatExternalIPs\":                true,\n+\t\t\"CustomDNSAddress\":              true,\n+\t\t\"ExtraIFaceBlacklist\":           true,\n+\t\t\"DnsLabels\":                     true,\n+\t\t\"DnsRouteInterval\":              true,\n+\t\t\"Mtu\":                           true,\n+\t\t\"EnableSSHRoot\":                 true,\n+\t\t\"EnableSSHSFTP\":                 true,\n+\t\t\"EnableSSHLocalPortForwarding\":  true,\n+\t\t\"EnableSSHRemotePortForwarding\": true,\n+\t\t\"DisableSSHAuth\":                true,\n+\t\t\"SshJWTCacheTTL\":                true,\n \t}\n \n \tval := reflect.ValueOf(req).Elem()\n@@ -221,29 +231,35 @@ func TestCLIFlags_MappedToSetConfig(t *testing.T) {\n \t// Map of CLI flag names to their corresponding SetConfigRequest field names.\n \t// This map must be updated when adding new config-related CLI flags.\n \tflagToField := map[string]string{\n-\t\t\"management-url\":         \"ManagementUrl\",\n-\t\t\"admin-url\":              \"AdminURL\",\n-\t\t\"enable-rosenpass\":       \"RosenpassEnabled\",\n-\t\t\"rosenpass-permissive\":   \"RosenpassPermissive\",\n-\t\t\"allow-server-ssh\":       \"ServerSSHAllowed\",\n-\t\t\"interface-name\":         \"InterfaceName\",\n-\t\t\"wireguard-port\":         \"WireguardPort\",\n-\t\t\"preshared-key\":          \"OptionalPreSharedKey\",\n-\t\t\"disable-auto-connect\":   \"DisableAutoConnect\",\n-\t\t\"network-monitor\":        \"NetworkMonitor\",\n-\t\t\"disable-client-routes\":  \"DisableClientRoutes\",\n-\t\t\"disable-server-routes\":  \"DisableServerRoutes\",\n-\t\t\"disable-dns\":            \"DisableDns\",\n-\t\t\"disable-firewall\":       \"DisableFirewall\",\n-\t\t\"block-lan-access\":       \"BlockLanAccess\",\n-\t\t\"block-inbound\":          \"BlockInbound\",\n-\t\t\"enable-lazy-connection\": \"LazyConnectionEnabled\",\n-\t\t\"external-ip-map\":        \"NatExternalIPs\",\n-\t\t\"dns-resolver-address\":   \"CustomDNSAddress\",\n-\t\t\"extra-iface-blacklist\":  \"ExtraIFaceBlacklist\",\n-\t\t\"extra-dns-labels\":       \"DnsLabels\",\n-\t\t\"dns-router-interval\":    \"DnsRouteInterval\",\n-\t\t\"mtu\":                    \"Mtu\",\n+\t\t\"management-url\":                    \"ManagementUrl\",\n+\t\t\"admin-url\":                         \"AdminURL\",\n+\t\t\"enable-rosenpass\":                  \"RosenpassEnabled\",\n+\t\t\"rosenpass-permissive\":              \"RosenpassPermissive\",\n+\t\t\"allow-server-ssh\":                  \"ServerSSHAllowed\",\n+\t\t\"interface-name\":                    \"InterfaceName\",\n+\t\t\"wireguard-port\":                    \"WireguardPort\",\n+\t\t\"preshared-key\":                     \"OptionalPreSharedKey\",\n+\t\t\"disable-auto-connect\":              \"DisableAutoConnect\",\n+\t\t\"network-monitor\":                   \"NetworkMonitor\",\n+\t\t\"disable-client-routes\":             \"DisableClientRoutes\",\n+\t\t\"disable-server-routes\":             \"DisableServerRoutes\",\n+\t\t\"disable-dns\":                       \"DisableDns\",\n+\t\t\"disable-firewall\":                  \"DisableFirewall\",\n+\t\t\"block-lan-access\":                  \"BlockLanAccess\",\n+\t\t\"block-inbound\":                     \"BlockInbound\",\n+\t\t\"enable-lazy-connection\":            \"LazyConnectionEnabled\",\n+\t\t\"external-ip-map\":                   \"NatExternalIPs\",\n+\t\t\"dns-resolver-address\":              \"CustomDNSAddress\",\n+\t\t\"extra-iface-blacklist\":             \"ExtraIFaceBlacklist\",\n+\t\t\"extra-dns-labels\":                  \"DnsLabels\",\n+\t\t\"dns-router-interval\":               \"DnsRouteInterval\",\n+\t\t\"mtu\":                               \"Mtu\",\n+\t\t\"enable-ssh-root\":                   \"EnableSSHRoot\",\n+\t\t\"enable-ssh-sftp\":                   \"EnableSSHSFTP\",\n+\t\t\"enable-ssh-local-port-forwarding\":  \"EnableSSHLocalPortForwarding\",\n+\t\t\"enable-ssh-remote-port-forwarding\": \"EnableSSHRemotePortForwarding\",\n+\t\t\"disable-ssh-auth\":                  \"DisableSSHAuth\",\n+\t\t\"ssh-jwt-cache-ttl\":                 \"SshJWTCacheTTL\",\n \t}\n \n \t// SetConfigRequest fields that don't have CLI flags (settable only via UI or other means).\ndiff --git a/client/ssh/client/client_test.go b/client/ssh/client/client_test.go\nnew file mode 100644\nindex 00000000000..e38e02a866b\n--- /dev/null\n+++ b/client/ssh/client/client_test.go\n@@ -0,0 +1,512 @@\n+package client\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net\"\n+\t\"os\"\n+\t\"os/user\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\tcryptossh \"golang.org/x/crypto/ssh\"\n+\n+\t\"github.com/netbirdio/netbird/client/ssh\"\n+\tsshserver \"github.com/netbirdio/netbird/client/ssh/server\"\n+\t\"github.com/netbirdio/netbird/client/ssh/testutil\"\n+)\n+\n+// TestMain handles package-level setup and cleanup\n+func TestMain(m *testing.M) {\n+\t// Guard against infinite recursion when test binary is called as \"netbird ssh exec\"\n+\t// This happens when running tests as non-privileged user with fallback\n+\tif len(os.Args) > 2 && os.Args[1] == \"ssh\" && os.Args[2] == \"exec\" {\n+\t\t// Just exit with error to break the recursion\n+\t\tfmt.Fprintf(os.Stderr, \"Test binary called as 'ssh exec' - preventing infinite recursion\\n\")\n+\t\tos.Exit(1)\n+\t}\n+\n+\t// Run tests\n+\tcode := m.Run()\n+\n+\t// Cleanup any created test users\n+\ttestutil.CleanupTestUsers()\n+\n+\tos.Exit(code)\n+}\n+\n+func TestSSHClient_DialWithKey(t *testing.T) {\n+\t// Generate host key for server\n+\thostKey, err := ssh.GeneratePrivateKey(ssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\t// Create and start server\n+\tserverConfig := &sshserver.Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := sshserver.New(serverConfig)\n+\tserver.SetAllowRootLogin(true) // Allow root/admin login for tests\n+\n+\tserverAddr := sshserver.StartTestServer(t, server)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\t// Test Dial\n+\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n+\tdefer cancel()\n+\n+\tcurrentUser := testutil.GetTestUsername(t)\n+\tclient, err := Dial(ctx, serverAddr, currentUser, DialOptions{\n+\t\tInsecureSkipVerify: true,\n+\t})\n+\trequire.NoError(t, err)\n+\tdefer func() {\n+\t\terr := client.Close()\n+\t\tassert.NoError(t, err)\n+\t}()\n+\n+\t// Verify client is connected\n+\tassert.NotNil(t, client.client)\n+}\n+\n+func TestSSHClient_CommandExecution(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" && testutil.IsCI() {\n+\t\tt.Skip(\"Skipping Windows command execution tests in CI due to S4U authentication issues\")\n+\t}\n+\n+\tserver, _, client := setupTestSSHServerAndClient(t)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\tdefer func() {\n+\t\terr := client.Close()\n+\t\tassert.NoError(t, err)\n+\t}()\n+\n+\tctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)\n+\tdefer cancel()\n+\n+\tt.Run(\"ExecuteCommand captures output\", func(t *testing.T) {\n+\t\toutput, err := client.ExecuteCommand(ctx, \"echo hello\")\n+\t\tassert.NoError(t, err)\n+\t\tassert.Contains(t, string(output), \"hello\")\n+\t})\n+\n+\tt.Run(\"ExecuteCommandWithIO streams output\", func(t *testing.T) {\n+\t\terr := client.ExecuteCommandWithIO(ctx, \"echo world\")\n+\t\tassert.NoError(t, err)\n+\t})\n+\n+\tt.Run(\"commands with flags work\", func(t *testing.T) {\n+\t\toutput, err := client.ExecuteCommand(ctx, \"echo -n test_flag\")\n+\t\tassert.NoError(t, err)\n+\t\tassert.Equal(t, \"test_flag\", strings.TrimSpace(string(output)))\n+\t})\n+\n+\tt.Run(\"non-zero exit codes don't return errors\", func(t *testing.T) {\n+\t\tvar testCmd string\n+\t\tif runtime.GOOS == \"windows\" {\n+\t\t\ttestCmd = \"echo hello | Select-String notfound\"\n+\t\t} else {\n+\t\t\ttestCmd = \"echo 'hello' | grep 'notfound'\"\n+\t\t}\n+\t\t_, err := client.ExecuteCommand(ctx, testCmd)\n+\t\tassert.NoError(t, err)\n+\t})\n+}\n+\n+func TestSSHClient_ConnectionHandling(t *testing.T) {\n+\tserver, serverAddr, _ := setupTestSSHServerAndClient(t)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\t// Generate client key for multiple connections\n+\n+\tconst numClients = 3\n+\tclients := make([]*Client, numClients)\n+\n+\tcurrentUser := testutil.GetTestUsername(t)\n+\tfor i := 0; i < numClients; i++ {\n+\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n+\t\tclient, err := Dial(ctx, serverAddr, currentUser, DialOptions{\n+\t\t\tInsecureSkipVerify: true,\n+\t\t})\n+\t\tcancel()\n+\t\trequire.NoError(t, err, \"Client %d should connect successfully\", i)\n+\t\tclients[i] = client\n+\t}\n+\n+\tfor i, client := range clients {\n+\t\terr := client.Close()\n+\t\tassert.NoError(t, err, \"Client %d should close without error\", i)\n+\t}\n+}\n+\n+func TestSSHClient_ContextCancellation(t *testing.T) {\n+\tserver, serverAddr, _ := setupTestSSHServerAndClient(t)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\tt.Run(\"connection with short timeout\", func(t *testing.T) {\n+\t\tctx, cancel := context.WithTimeout(context.Background(), 1*time.Millisecond)\n+\t\tdefer cancel()\n+\n+\t\tcurrentUser := testutil.GetTestUsername(t)\n+\t\t_, err := Dial(ctx, serverAddr, currentUser, DialOptions{\n+\t\t\tInsecureSkipVerify: true,\n+\t\t})\n+\t\tif err != nil {\n+\t\t\t// Check for actual timeout-related errors rather than string matching\n+\t\t\tassert.True(t,\n+\t\t\t\terrors.Is(err, context.DeadlineExceeded) ||\n+\t\t\t\t\terrors.Is(err, context.Canceled) ||\n+\t\t\t\t\tstrings.Contains(err.Error(), \"timeout\"),\n+\t\t\t\t\"Expected timeout-related error, got: %v\", err)\n+\t\t}\n+\t})\n+\n+\tt.Run(\"command execution cancellation\", func(t *testing.T) {\n+\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n+\t\tdefer cancel()\n+\t\tcurrentUser := testutil.GetTestUsername(t)\n+\t\tclient, err := Dial(ctx, serverAddr, currentUser, DialOptions{\n+\t\t\tInsecureSkipVerify: true,\n+\t\t})\n+\t\trequire.NoError(t, err)\n+\t\tdefer func() {\n+\t\t\tif err := client.Close(); err != nil {\n+\t\t\t\tt.Logf(\"client close error: %v\", err)\n+\t\t\t}\n+\t\t}()\n+\n+\t\tcmdCtx, cmdCancel := context.WithTimeout(context.Background(), 100*time.Millisecond)\n+\t\tdefer cmdCancel()\n+\n+\t\terr = client.ExecuteCommandWithPTY(cmdCtx, \"sleep 10\")\n+\t\tif err != nil {\n+\t\t\tvar exitMissingErr *cryptossh.ExitMissingError\n+\t\t\tisValidCancellation := errors.Is(err, context.DeadlineExceeded) ||\n+\t\t\t\terrors.Is(err, context.Canceled) ||\n+\t\t\t\terrors.As(err, &exitMissingErr)\n+\t\t\tassert.True(t, isValidCancellation, \"Should handle command cancellation properly\")\n+\t\t}\n+\t})\n+}\n+\n+func TestSSHClient_NoAuthMode(t *testing.T) {\n+\thostKey, err := ssh.GeneratePrivateKey(ssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tserverConfig := &sshserver.Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := sshserver.New(serverConfig)\n+\tserver.SetAllowRootLogin(true) // Allow root/admin login for tests\n+\n+\tserverAddr := sshserver.StartTestServer(t, server)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n+\tdefer cancel()\n+\n+\tcurrentUser := testutil.GetTestUsername(t)\n+\n+\tt.Run(\"any key succeeds in no-auth mode\", func(t *testing.T) {\n+\t\tclient, err := Dial(ctx, serverAddr, currentUser, DialOptions{\n+\t\t\tInsecureSkipVerify: true,\n+\t\t})\n+\t\tassert.NoError(t, err)\n+\t\tif client != nil {\n+\t\t\trequire.NoError(t, client.Close(), \"Client should close without error\")\n+\t\t}\n+\t})\n+}\n+\n+func TestSSHClient_TerminalState(t *testing.T) {\n+\tserver, _, client := setupTestSSHServerAndClient(t)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\tdefer func() {\n+\t\terr := client.Close()\n+\t\tassert.NoError(t, err)\n+\t}()\n+\n+\tassert.Nil(t, client.terminalState)\n+\tassert.Equal(t, 0, client.terminalFd)\n+\n+\tclient.restoreTerminal()\n+\tassert.Nil(t, client.terminalState)\n+\n+\tctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)\n+\tdefer cancel()\n+\n+\terr := client.OpenTerminal(ctx)\n+\t// In test environment without a real terminal, this may complete quickly or timeout\n+\t// Both behaviors are acceptable for testing terminal state management\n+\tif err != nil {\n+\t\tif runtime.GOOS == \"windows\" {\n+\t\t\tassert.True(t,\n+\t\t\t\tstrings.Contains(err.Error(), \"context deadline exceeded\") ||\n+\t\t\t\t\tstrings.Contains(err.Error(), \"console\"),\n+\t\t\t\t\"Should timeout or have console error on Windows\")\n+\t\t} else {\n+\t\t\t// On Unix systems in test environment, we may get various errors\n+\t\t\t// including timeouts or terminal-related errors\n+\t\t\tassert.True(t,\n+\t\t\t\tstrings.Contains(err.Error(), \"context deadline exceeded\") ||\n+\t\t\t\t\tstrings.Contains(err.Error(), \"terminal\") ||\n+\t\t\t\t\tstrings.Contains(err.Error(), \"pty\"),\n+\t\t\t\t\"Expected timeout or terminal-related error, got: %v\", err)\n+\t\t}\n+\t}\n+}\n+\n+func setupTestSSHServerAndClient(t *testing.T) (*sshserver.Server, string, *Client) {\n+\thostKey, err := ssh.GeneratePrivateKey(ssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tserverConfig := &sshserver.Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := sshserver.New(serverConfig)\n+\tserver.SetAllowRootLogin(true) // Allow root/admin login for tests\n+\n+\tserverAddr := sshserver.StartTestServer(t, server)\n+\n+\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n+\tdefer cancel()\n+\n+\tcurrentUser := testutil.GetTestUsername(t)\n+\tclient, err := Dial(ctx, serverAddr, currentUser, DialOptions{\n+\t\tInsecureSkipVerify: true,\n+\t})\n+\trequire.NoError(t, err)\n+\n+\treturn server, serverAddr, client\n+}\n+\n+func TestSSHClient_PortForwarding(t *testing.T) {\n+\tserver, _, client := setupTestSSHServerAndClient(t)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\tdefer func() {\n+\t\terr := client.Close()\n+\t\tassert.NoError(t, err)\n+\t}()\n+\n+\tt.Run(\"local forwarding times out gracefully\", func(t *testing.T) {\n+\t\tctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)\n+\t\tdefer cancel()\n+\n+\t\terr := client.LocalPortForward(ctx, \"127.0.0.1:0\", \"127.0.0.1:8080\")\n+\t\tassert.Error(t, err)\n+\t\tassert.True(t,\n+\t\t\terrors.Is(err, context.DeadlineExceeded) ||\n+\t\t\t\terrors.Is(err, context.Canceled) ||\n+\t\t\t\tstrings.Contains(err.Error(), \"connection\"),\n+\t\t\t\"Expected context or connection error\")\n+\t})\n+\n+\tt.Run(\"remote forwarding denied\", func(t *testing.T) {\n+\t\tctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)\n+\t\tdefer cancel()\n+\n+\t\terr := client.RemotePortForward(ctx, \"127.0.0.1:0\", \"127.0.0.1:8080\")\n+\t\tassert.Error(t, err)\n+\t\tassert.True(t,\n+\t\t\tstrings.Contains(err.Error(), \"denied\") ||\n+\t\t\t\tstrings.Contains(err.Error(), \"disabled\"),\n+\t\t\t\"Should be denied by default\")\n+\t})\n+\n+\tt.Run(\"invalid addresses fail\", func(t *testing.T) {\n+\t\tctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)\n+\t\tdefer cancel()\n+\n+\t\terr := client.LocalPortForward(ctx, \"invalid:address\", \"127.0.0.1:8080\")\n+\t\tassert.Error(t, err)\n+\n+\t\terr = client.LocalPortForward(ctx, \"127.0.0.1:0\", \"invalid:address\")\n+\t\tassert.Error(t, err)\n+\t})\n+}\n+\n+func TestSSHClient_PortForwardingDataTransfer(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping data transfer test in short mode\")\n+\t}\n+\n+\thostKey, err := ssh.GeneratePrivateKey(ssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tserverConfig := &sshserver.Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := sshserver.New(serverConfig)\n+\tserver.SetAllowLocalPortForwarding(true)\n+\tserver.SetAllowRootLogin(true) // Allow root/admin login for tests\n+\n+\tserverAddr := sshserver.StartTestServer(t, server)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n+\tdefer cancel()\n+\n+\t// Port forwarding requires the actual current user, not test user\n+\trealUser, err := getRealCurrentUser()\n+\trequire.NoError(t, err)\n+\n+\t// Skip if running as system account that can't do port forwarding\n+\tif testutil.IsSystemAccount(realUser) {\n+\t\tt.Skipf(\"Skipping port forwarding test - running as system account: %s\", realUser)\n+\t}\n+\n+\tclient, err := Dial(ctx, serverAddr, realUser, DialOptions{\n+\t\tInsecureSkipVerify: true, // Skip host key verification for test\n+\t})\n+\trequire.NoError(t, err)\n+\tdefer func() {\n+\t\tif err := client.Close(); err != nil {\n+\t\t\tt.Logf(\"client close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\ttestServer, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n+\trequire.NoError(t, err)\n+\tdefer func() {\n+\t\tif err := testServer.Close(); err != nil {\n+\t\t\tt.Logf(\"test server close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\ttestServerAddr := testServer.Addr().String()\n+\texpectedResponse := \"Hello, World!\"\n+\n+\tgo func() {\n+\t\tfor {\n+\t\t\tconn, err := testServer.Accept()\n+\t\t\tif err != nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tgo func(c net.Conn) {\n+\t\t\t\tdefer func() {\n+\t\t\t\t\tif err := c.Close(); err != nil {\n+\t\t\t\t\t\tt.Logf(\"connection close error: %v\", err)\n+\t\t\t\t\t}\n+\t\t\t\t}()\n+\t\t\t\tbuf := make([]byte, 1024)\n+\t\t\t\tif _, err := c.Read(buf); err != nil {\n+\t\t\t\t\tt.Logf(\"connection read error: %v\", err)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tif _, err := c.Write([]byte(expectedResponse)); err != nil {\n+\t\t\t\t\tt.Logf(\"connection write error: %v\", err)\n+\t\t\t\t}\n+\t\t\t}(conn)\n+\t\t}\n+\t}()\n+\n+\tlocalListener, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n+\trequire.NoError(t, err)\n+\tlocalAddr := localListener.Addr().String()\n+\tif err := localListener.Close(); err != nil {\n+\t\tt.Logf(\"local listener close error: %v\", err)\n+\t}\n+\n+\tctx, cancel = context.WithTimeout(context.Background(), 5*time.Second)\n+\tdefer cancel()\n+\n+\tgo func() {\n+\t\terr := client.LocalPortForward(ctx, localAddr, testServerAddr)\n+\t\tif err != nil && !errors.Is(err, context.Canceled) {\n+\t\t\tif isWindowsPrivilegeError(err) {\n+\t\t\t\tt.Logf(\"Port forward failed due to Windows privilege restrictions: %v\", err)\n+\t\t\t} else {\n+\t\t\t\tt.Logf(\"Port forward error: %v\", err)\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n+\ttime.Sleep(100 * time.Millisecond)\n+\n+\tconn, err := net.DialTimeout(\"tcp\", localAddr, 2*time.Second)\n+\trequire.NoError(t, err)\n+\tdefer func() {\n+\t\tif err := conn.Close(); err != nil {\n+\t\t\tt.Logf(\"connection close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\t_, err = conn.Write([]byte(\"test\"))\n+\trequire.NoError(t, err)\n+\n+\tif err := conn.SetReadDeadline(time.Now().Add(2 * time.Second)); err != nil {\n+\t\tt.Logf(\"set read deadline error: %v\", err)\n+\t}\n+\tresponse := make([]byte, len(expectedResponse))\n+\tn, err := io.ReadFull(conn, response)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, len(expectedResponse), n)\n+\tassert.Equal(t, expectedResponse, string(response))\n+}\n+\n+// getRealCurrentUser returns the actual current user (not test user) for features like port forwarding\n+func getRealCurrentUser() (string, error) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\tif currentUser, err := user.Current(); err == nil {\n+\t\t\treturn currentUser.Username, nil\n+\t\t}\n+\t}\n+\n+\tif username := os.Getenv(\"USER\"); username != \"\" {\n+\t\treturn username, nil\n+\t}\n+\n+\tif currentUser, err := user.Current(); err == nil {\n+\t\treturn currentUser.Username, nil\n+\t}\n+\n+\treturn \"\", fmt.Errorf(\"unable to determine current user\")\n+}\n+\n+// isWindowsPrivilegeError checks if an error is related to Windows privilege restrictions\n+func isWindowsPrivilegeError(err error) bool {\n+\tif err == nil {\n+\t\treturn false\n+\t}\n+\n+\terrStr := strings.ToLower(err.Error())\n+\treturn strings.Contains(errStr, \"ntstatus=0xc0000062\") || // STATUS_PRIVILEGE_NOT_HELD\n+\t\tstrings.Contains(errStr, \"0xc0000041\") || // STATUS_PRIVILEGE_NOT_HELD (LsaRegisterLogonProcess)\n+\t\tstrings.Contains(errStr, \"0xc0000062\") || // STATUS_PRIVILEGE_NOT_HELD (LsaLogonUser)\n+\t\tstrings.Contains(errStr, \"privilege\") ||\n+\t\tstrings.Contains(errStr, \"access denied\") ||\n+\t\tstrings.Contains(errStr, \"user authentication failed\")\n+}\ndiff --git a/client/ssh/config/manager_test.go b/client/ssh/config/manager_test.go\nnew file mode 100644\nindex 00000000000..dc3ad95b35f\n--- /dev/null\n+++ b/client/ssh/config/manager_test.go\n@@ -0,0 +1,159 @@\n+package config\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+func TestManager_SetupSSHClientConfig(t *testing.T) {\n+\t// Create temporary directory for test\n+\ttempDir, err := os.MkdirTemp(\"\", \"netbird-ssh-config-test\")\n+\trequire.NoError(t, err)\n+\tdefer func() { assert.NoError(t, os.RemoveAll(tempDir)) }()\n+\n+\t// Override manager paths to use temp directory\n+\tmanager := &Manager{\n+\t\tsshConfigDir:  filepath.Join(tempDir, \"ssh_config.d\"),\n+\t\tsshConfigFile: \"99-netbird.conf\",\n+\t}\n+\n+\t// Test SSH config generation with peers\n+\tpeers := []PeerSSHInfo{\n+\t\t{\n+\t\t\tHostname: \"peer1\",\n+\t\t\tIP:       \"100.125.1.1\",\n+\t\t\tFQDN:     \"peer1.nb.internal\",\n+\t\t},\n+\t\t{\n+\t\t\tHostname: \"peer2\",\n+\t\t\tIP:       \"100.125.1.2\",\n+\t\t\tFQDN:     \"peer2.nb.internal\",\n+\t\t},\n+\t}\n+\n+\terr = manager.SetupSSHClientConfig(peers)\n+\trequire.NoError(t, err)\n+\n+\t// Read generated config\n+\tconfigPath := filepath.Join(manager.sshConfigDir, manager.sshConfigFile)\n+\tcontent, err := os.ReadFile(configPath)\n+\trequire.NoError(t, err)\n+\n+\tconfigStr := string(content)\n+\n+\t// Verify the basic SSH config structure exists\n+\tassert.Contains(t, configStr, \"# NetBird SSH client configuration\")\n+\tassert.Contains(t, configStr, \"Generated automatically - do not edit manually\")\n+\n+\t// Check that peer hostnames are included\n+\tassert.Contains(t, configStr, \"100.125.1.1\")\n+\tassert.Contains(t, configStr, \"100.125.1.2\")\n+\tassert.Contains(t, configStr, \"peer1.nb.internal\")\n+\tassert.Contains(t, configStr, \"peer2.nb.internal\")\n+\n+\t// Check platform-specific UserKnownHostsFile\n+\tif runtime.GOOS == \"windows\" {\n+\t\tassert.Contains(t, configStr, \"UserKnownHostsFile NUL\")\n+\t} else {\n+\t\tassert.Contains(t, configStr, \"UserKnownHostsFile /dev/null\")\n+\t}\n+}\n+\n+func TestGetSystemSSHConfigDir(t *testing.T) {\n+\tconfigDir := getSystemSSHConfigDir()\n+\n+\t// Path should not be empty\n+\tassert.NotEmpty(t, configDir)\n+\n+\t// Should be an absolute path\n+\tassert.True(t, filepath.IsAbs(configDir))\n+\n+\t// On Unix systems, should start with /etc\n+\t// On Windows, should contain ProgramData\n+\tif runtime.GOOS == \"windows\" {\n+\t\tassert.Contains(t, strings.ToLower(configDir), \"programdata\")\n+\t} else {\n+\t\tassert.Contains(t, configDir, \"/etc/ssh\")\n+\t}\n+}\n+\n+func TestManager_PeerLimit(t *testing.T) {\n+\t// Create temporary directory for test\n+\ttempDir, err := os.MkdirTemp(\"\", \"netbird-ssh-config-test\")\n+\trequire.NoError(t, err)\n+\tdefer func() { assert.NoError(t, os.RemoveAll(tempDir)) }()\n+\n+\t// Override manager paths to use temp directory\n+\tmanager := &Manager{\n+\t\tsshConfigDir:  filepath.Join(tempDir, \"ssh_config.d\"),\n+\t\tsshConfigFile: \"99-netbird.conf\",\n+\t}\n+\n+\t// Generate many peers (more than limit)\n+\tvar peers []PeerSSHInfo\n+\tfor i := 0; i < MaxPeersForSSHConfig+10; i++ {\n+\t\tpeers = append(peers, PeerSSHInfo{\n+\t\t\tHostname: fmt.Sprintf(\"peer%d\", i),\n+\t\t\tIP:       fmt.Sprintf(\"100.125.1.%d\", i%254+1),\n+\t\t\tFQDN:     fmt.Sprintf(\"peer%d.nb.internal\", i),\n+\t\t})\n+\t}\n+\n+\t// Test that SSH config generation is skipped when too many peers\n+\terr = manager.SetupSSHClientConfig(peers)\n+\trequire.NoError(t, err)\n+\n+\t// Config should not be created due to peer limit\n+\tconfigPath := filepath.Join(manager.sshConfigDir, manager.sshConfigFile)\n+\t_, err = os.Stat(configPath)\n+\tassert.True(t, os.IsNotExist(err), \"SSH config should not be created with too many peers\")\n+}\n+\n+func TestManager_ForcedSSHConfig(t *testing.T) {\n+\t// Set force environment variable\n+\tt.Setenv(EnvForceSSHConfig, \"true\")\n+\n+\t// Create temporary directory for test\n+\ttempDir, err := os.MkdirTemp(\"\", \"netbird-ssh-config-test\")\n+\trequire.NoError(t, err)\n+\tdefer func() { assert.NoError(t, os.RemoveAll(tempDir)) }()\n+\n+\t// Override manager paths to use temp directory\n+\tmanager := &Manager{\n+\t\tsshConfigDir:  filepath.Join(tempDir, \"ssh_config.d\"),\n+\t\tsshConfigFile: \"99-netbird.conf\",\n+\t}\n+\n+\t// Generate many peers (more than limit)\n+\tvar peers []PeerSSHInfo\n+\tfor i := 0; i < MaxPeersForSSHConfig+10; i++ {\n+\t\tpeers = append(peers, PeerSSHInfo{\n+\t\t\tHostname: fmt.Sprintf(\"peer%d\", i),\n+\t\t\tIP:       fmt.Sprintf(\"100.125.1.%d\", i%254+1),\n+\t\t\tFQDN:     fmt.Sprintf(\"peer%d.nb.internal\", i),\n+\t\t})\n+\t}\n+\n+\t// Test that SSH config generation is forced despite many peers\n+\terr = manager.SetupSSHClientConfig(peers)\n+\trequire.NoError(t, err)\n+\n+\t// Config should be created despite peer limit due to force flag\n+\tconfigPath := filepath.Join(manager.sshConfigDir, manager.sshConfigFile)\n+\t_, err = os.Stat(configPath)\n+\trequire.NoError(t, err, \"SSH config should be created when forced\")\n+\n+\t// Verify config contains peer hostnames\n+\tcontent, err := os.ReadFile(configPath)\n+\trequire.NoError(t, err)\n+\tconfigStr := string(content)\n+\tassert.Contains(t, configStr, \"peer0.nb.internal\")\n+\tassert.Contains(t, configStr, \"peer1.nb.internal\")\n+}\ndiff --git a/client/ssh/proxy/proxy_test.go b/client/ssh/proxy/proxy_test.go\nnew file mode 100644\nindex 00000000000..c5036da37af\n--- /dev/null\n+++ b/client/ssh/proxy/proxy_test.go\n@@ -0,0 +1,367 @@\n+package proxy\n+\n+import (\n+\t\"context\"\n+\t\"crypto/rand\"\n+\t\"crypto/rsa\"\n+\t\"encoding/base64\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"math/big\"\n+\t\"net\"\n+\t\"net/http\"\n+\t\"net/http/httptest\"\n+\t\"os\"\n+\t\"runtime\"\n+\t\"strconv\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/golang-jwt/jwt/v5\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\tcryptossh \"golang.org/x/crypto/ssh\"\n+\t\"google.golang.org/grpc\"\n+\t\"google.golang.org/grpc/credentials/insecure\"\n+\n+\t\"github.com/netbirdio/netbird/client/proto\"\n+\tnbssh \"github.com/netbirdio/netbird/client/ssh\"\n+\t\"github.com/netbirdio/netbird/client/ssh/server\"\n+\t\"github.com/netbirdio/netbird/client/ssh/testutil\"\n+\tnbjwt \"github.com/netbirdio/netbird/shared/auth/jwt\"\n+)\n+\n+func TestMain(m *testing.M) {\n+\tif len(os.Args) > 2 && os.Args[1] == \"ssh\" {\n+\t\tif os.Args[2] == \"exec\" {\n+\t\t\tif len(os.Args) > 3 {\n+\t\t\t\tcmd := os.Args[3]\n+\t\t\t\tif cmd == \"echo\" && len(os.Args) > 4 {\n+\t\t\t\t\tfmt.Fprintln(os.Stdout, os.Args[4])\n+\t\t\t\t\tos.Exit(0)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfmt.Fprintf(os.Stderr, \"Test binary called as 'ssh exec' with args: %v - preventing infinite recursion\\n\", os.Args)\n+\t\t\tos.Exit(1)\n+\t\t}\n+\t}\n+\n+\tcode := m.Run()\n+\n+\ttestutil.CleanupTestUsers()\n+\n+\tos.Exit(code)\n+}\n+\n+func TestSSHProxy_verifyHostKey(t *testing.T) {\n+\tt.Run(\"calls daemon to verify host key\", func(t *testing.T) {\n+\t\tmockDaemon := startMockDaemon(t)\n+\t\tdefer mockDaemon.stop()\n+\n+\t\tgrpcConn, err := grpc.NewClient(mockDaemon.addr, grpc.WithTransportCredentials(insecure.NewCredentials()))\n+\t\trequire.NoError(t, err)\n+\t\tdefer func() { _ = grpcConn.Close() }()\n+\n+\t\tproxy := &SSHProxy{\n+\t\t\tdaemonAddr:   mockDaemon.addr,\n+\t\t\tdaemonClient: proto.NewDaemonServiceClient(grpcConn),\n+\t\t}\n+\n+\t\ttestKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\t\trequire.NoError(t, err)\n+\t\ttestPubKey, err := nbssh.GeneratePublicKey(testKey)\n+\t\trequire.NoError(t, err)\n+\n+\t\tmockDaemon.setHostKey(\"test-host\", testPubKey)\n+\n+\t\terr = proxy.verifyHostKey(\"test-host\", &net.TCPAddr{IP: net.ParseIP(\"127.0.0.1\"), Port: 22}, mustParsePublicKey(t, testPubKey))\n+\t\tassert.NoError(t, err)\n+\t})\n+\n+\tt.Run(\"rejects unknown host key\", func(t *testing.T) {\n+\t\tmockDaemon := startMockDaemon(t)\n+\t\tdefer mockDaemon.stop()\n+\n+\t\tgrpcConn, err := grpc.NewClient(mockDaemon.addr, grpc.WithTransportCredentials(insecure.NewCredentials()))\n+\t\trequire.NoError(t, err)\n+\t\tdefer func() { _ = grpcConn.Close() }()\n+\n+\t\tproxy := &SSHProxy{\n+\t\t\tdaemonAddr:   mockDaemon.addr,\n+\t\t\tdaemonClient: proto.NewDaemonServiceClient(grpcConn),\n+\t\t}\n+\n+\t\tunknownKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\t\trequire.NoError(t, err)\n+\t\tunknownPubKey, err := nbssh.GeneratePublicKey(unknownKey)\n+\t\trequire.NoError(t, err)\n+\n+\t\terr = proxy.verifyHostKey(\"unknown-host\", &net.TCPAddr{IP: net.ParseIP(\"127.0.0.1\"), Port: 22}, mustParsePublicKey(t, unknownPubKey))\n+\t\tassert.Error(t, err)\n+\t\tassert.Contains(t, err.Error(), \"peer unknown-host not found in network\")\n+\t})\n+}\n+\n+func TestSSHProxy_Connect(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping integration test in short mode\")\n+\t}\n+\n+\t// TODO: Windows test times out - user switching and command execution tested on Linux\n+\tif runtime.GOOS == \"windows\" {\n+\t\tt.Skip(\"Skipping on Windows - covered by Linux tests\")\n+\t}\n+\n+\tconst (\n+\t\tissuer   = \"https://test-issuer.example.com\"\n+\t\taudience = \"test-audience\"\n+\t)\n+\n+\tjwksServer, privateKey, jwksURL := setupJWKSServer(t)\n+\tdefer jwksServer.Close()\n+\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\thostPubKey, err := nbssh.GeneratePublicKey(hostKey)\n+\trequire.NoError(t, err)\n+\n+\tserverConfig := &server.Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT: &server.JWTConfig{\n+\t\t\tIssuer:       issuer,\n+\t\t\tAudience:     audience,\n+\t\t\tKeysLocation: jwksURL,\n+\t\t},\n+\t}\n+\tsshServer := server.New(serverConfig)\n+\tsshServer.SetAllowRootLogin(true)\n+\n+\tsshServerAddr := server.StartTestServer(t, sshServer)\n+\tdefer func() { _ = sshServer.Stop() }()\n+\n+\tmockDaemon := startMockDaemon(t)\n+\tdefer mockDaemon.stop()\n+\n+\thost, portStr, err := net.SplitHostPort(sshServerAddr)\n+\trequire.NoError(t, err)\n+\tport, err := strconv.Atoi(portStr)\n+\trequire.NoError(t, err)\n+\n+\tmockDaemon.setHostKey(host, hostPubKey)\n+\n+\tvalidToken := generateValidJWT(t, privateKey, issuer, audience)\n+\tmockDaemon.setJWTToken(validToken)\n+\n+\tproxyInstance, err := New(mockDaemon.addr, host, port, nil)\n+\trequire.NoError(t, err)\n+\n+\tclientConn, proxyConn := net.Pipe()\n+\tdefer func() { _ = clientConn.Close() }()\n+\n+\torigStdin := os.Stdin\n+\torigStdout := os.Stdout\n+\tdefer func() {\n+\t\tos.Stdin = origStdin\n+\t\tos.Stdout = origStdout\n+\t}()\n+\n+\tstdinReader, stdinWriter, err := os.Pipe()\n+\trequire.NoError(t, err)\n+\tstdoutReader, stdoutWriter, err := os.Pipe()\n+\trequire.NoError(t, err)\n+\n+\tos.Stdin = stdinReader\n+\tos.Stdout = stdoutWriter\n+\n+\tgo func() {\n+\t\t_, _ = io.Copy(stdinWriter, proxyConn)\n+\t}()\n+\tgo func() {\n+\t\t_, _ = io.Copy(proxyConn, stdoutReader)\n+\t}()\n+\n+\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n+\tdefer cancel()\n+\n+\tconnectErrCh := make(chan error, 1)\n+\tgo func() {\n+\t\tconnectErrCh <- proxyInstance.Connect(ctx)\n+\t}()\n+\n+\tsshConfig := &cryptossh.ClientConfig{\n+\t\tUser:            testutil.GetTestUsername(t),\n+\t\tAuth:            []cryptossh.AuthMethod{},\n+\t\tHostKeyCallback: cryptossh.InsecureIgnoreHostKey(),\n+\t\tTimeout:         3 * time.Second,\n+\t}\n+\n+\tsshClientConn, chans, reqs, err := cryptossh.NewClientConn(clientConn, \"test\", sshConfig)\n+\trequire.NoError(t, err, \"Should connect to proxy server\")\n+\tdefer func() { _ = sshClientConn.Close() }()\n+\n+\tsshClient := cryptossh.NewClient(sshClientConn, chans, reqs)\n+\n+\tsession, err := sshClient.NewSession()\n+\trequire.NoError(t, err, \"Should create session through full proxy to backend\")\n+\n+\toutputCh := make(chan []byte, 1)\n+\terrCh := make(chan error, 1)\n+\tgo func() {\n+\t\toutput, err := session.Output(\"echo hello-from-proxy\")\n+\t\toutputCh <- output\n+\t\terrCh <- err\n+\t}()\n+\n+\tselect {\n+\tcase output := <-outputCh:\n+\t\terr := <-errCh\n+\t\trequire.NoError(t, err, \"Command should execute successfully through proxy\")\n+\t\tassert.Contains(t, string(output), \"hello-from-proxy\", \"Should receive command output through proxy\")\n+\tcase <-time.After(3 * time.Second):\n+\t\tt.Fatal(\"Command execution timed out\")\n+\t}\n+\n+\t_ = session.Close()\n+\t_ = sshClient.Close()\n+\t_ = clientConn.Close()\n+\tcancel()\n+}\n+\n+type mockDaemonServer struct {\n+\tproto.UnimplementedDaemonServiceServer\n+\thostKeys map[string][]byte\n+\tjwtToken string\n+}\n+\n+func (m *mockDaemonServer) GetPeerSSHHostKey(ctx context.Context, req *proto.GetPeerSSHHostKeyRequest) (*proto.GetPeerSSHHostKeyResponse, error) {\n+\tkey, found := m.hostKeys[req.PeerAddress]\n+\treturn &proto.GetPeerSSHHostKeyResponse{\n+\t\tFound:      found,\n+\t\tSshHostKey: key,\n+\t}, nil\n+}\n+\n+func (m *mockDaemonServer) RequestJWTAuth(ctx context.Context, req *proto.RequestJWTAuthRequest) (*proto.RequestJWTAuthResponse, error) {\n+\treturn &proto.RequestJWTAuthResponse{\n+\t\tCachedToken: m.jwtToken,\n+\t}, nil\n+}\n+\n+func (m *mockDaemonServer) WaitJWTToken(ctx context.Context, req *proto.WaitJWTTokenRequest) (*proto.WaitJWTTokenResponse, error) {\n+\treturn &proto.WaitJWTTokenResponse{\n+\t\tToken: m.jwtToken,\n+\t}, nil\n+}\n+\n+type mockDaemon struct {\n+\taddr   string\n+\tserver *grpc.Server\n+\timpl   *mockDaemonServer\n+}\n+\n+func startMockDaemon(t *testing.T) *mockDaemon {\n+\tt.Helper()\n+\n+\tlistener, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n+\trequire.NoError(t, err)\n+\n+\timpl := &mockDaemonServer{\n+\t\thostKeys: make(map[string][]byte),\n+\t\tjwtToken: \"test-jwt-token\",\n+\t}\n+\n+\tgrpcServer := grpc.NewServer()\n+\tproto.RegisterDaemonServiceServer(grpcServer, impl)\n+\n+\tgo func() {\n+\t\t_ = grpcServer.Serve(listener)\n+\t}()\n+\n+\treturn &mockDaemon{\n+\t\taddr:   listener.Addr().String(),\n+\t\tserver: grpcServer,\n+\t\timpl:   impl,\n+\t}\n+}\n+\n+func (m *mockDaemon) setHostKey(addr string, pubKey []byte) {\n+\tm.impl.hostKeys[addr] = pubKey\n+}\n+\n+func (m *mockDaemon) setJWTToken(token string) {\n+\tm.impl.jwtToken = token\n+}\n+\n+func (m *mockDaemon) stop() {\n+\tif m.server != nil {\n+\t\tm.server.Stop()\n+\t}\n+}\n+\n+func mustParsePublicKey(t *testing.T, pubKeyBytes []byte) cryptossh.PublicKey {\n+\tt.Helper()\n+\tpubKey, _, _, _, err := cryptossh.ParseAuthorizedKey(pubKeyBytes)\n+\trequire.NoError(t, err)\n+\treturn pubKey\n+}\n+\n+func setupJWKSServer(t *testing.T) (*httptest.Server, *rsa.PrivateKey, string) {\n+\tt.Helper()\n+\tprivateKey, jwksJSON := generateTestJWKS(t)\n+\n+\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n+\t\tif _, err := w.Write(jwksJSON); err != nil {\n+\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n+\t\t}\n+\t}))\n+\n+\treturn server, privateKey, server.URL\n+}\n+\n+func generateTestJWKS(t *testing.T) (*rsa.PrivateKey, []byte) {\n+\tt.Helper()\n+\tprivateKey, err := rsa.GenerateKey(rand.Reader, 2048)\n+\trequire.NoError(t, err)\n+\n+\tpublicKey := &privateKey.PublicKey\n+\tn := publicKey.N.Bytes()\n+\te := publicKey.E\n+\n+\tjwk := nbjwt.JSONWebKey{\n+\t\tKty: \"RSA\",\n+\t\tKid: \"test-key-id\",\n+\t\tUse: \"sig\",\n+\t\tN:   base64.RawURLEncoding.EncodeToString(n),\n+\t\tE:   base64.RawURLEncoding.EncodeToString(big.NewInt(int64(e)).Bytes()),\n+\t}\n+\n+\tjwks := nbjwt.Jwks{\n+\t\tKeys: []nbjwt.JSONWebKey{jwk},\n+\t}\n+\n+\tjwksJSON, err := json.Marshal(jwks)\n+\trequire.NoError(t, err)\n+\n+\treturn privateKey, jwksJSON\n+}\n+\n+func generateValidJWT(t *testing.T, privateKey *rsa.PrivateKey, issuer, audience string) string {\n+\tt.Helper()\n+\tclaims := jwt.MapClaims{\n+\t\t\"iss\": issuer,\n+\t\t\"aud\": audience,\n+\t\t\"sub\": \"test-user\",\n+\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n+\t\t\"iat\": time.Now().Unix(),\n+\t}\n+\n+\ttoken := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)\n+\ttoken.Header[\"kid\"] = \"test-key-id\"\n+\n+\ttokenString, err := token.SignedString(privateKey)\n+\trequire.NoError(t, err)\n+\n+\treturn tokenString\n+}\ndiff --git a/client/ssh/server/compatibility_test.go b/client/ssh/server/compatibility_test.go\nnew file mode 100644\nindex 00000000000..34ffccfd22a\n--- /dev/null\n+++ b/client/ssh/server/compatibility_test.go\n@@ -0,0 +1,722 @@\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"crypto/ed25519\"\n+\t\"crypto/rand\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\t\"golang.org/x/crypto/ssh\"\n+\n+\tnbssh \"github.com/netbirdio/netbird/client/ssh\"\n+\t\"github.com/netbirdio/netbird/client/ssh/testutil\"\n+)\n+\n+// TestMain handles package-level setup and cleanup\n+func TestMain(m *testing.M) {\n+\t// Guard against infinite recursion when test binary is called as \"netbird ssh exec\"\n+\t// This happens when running tests as non-privileged user with fallback\n+\tif len(os.Args) > 2 && os.Args[1] == \"ssh\" && os.Args[2] == \"exec\" {\n+\t\t// Just exit with error to break the recursion\n+\t\tfmt.Fprintf(os.Stderr, \"Test binary called as 'ssh exec' - preventing infinite recursion\\n\")\n+\t\tos.Exit(1)\n+\t}\n+\n+\t// Run tests\n+\tcode := m.Run()\n+\n+\t// Cleanup any created test users\n+\ttestutil.CleanupTestUsers()\n+\n+\tos.Exit(code)\n+}\n+\n+// TestSSHServerCompatibility tests that our SSH server is compatible with the system SSH client\n+func TestSSHServerCompatibility(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping SSH compatibility tests in short mode\")\n+\t}\n+\n+\t// Check if ssh binary is available\n+\tif !isSSHClientAvailable() {\n+\t\tt.Skip(\"SSH client not available on this system\")\n+\t}\n+\n+\t// Set up SSH server - use our existing key generation for server\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\t// Generate OpenSSH-compatible keys for client\n+\tclientPrivKeyOpenSSH, _, err := generateOpenSSHKey(t)\n+\trequire.NoError(t, err)\n+\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := New(serverConfig)\n+\tserver.SetAllowRootLogin(true)\n+\n+\tserverAddr := StartTestServer(t, server)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\t// Create temporary key files for SSH client\n+\tclientKeyFile, cleanupKey := createTempKeyFileFromBytes(t, clientPrivKeyOpenSSH)\n+\tdefer cleanupKey()\n+\n+\t// Extract host and port from server address\n+\thost, portStr, err := net.SplitHostPort(serverAddr)\n+\trequire.NoError(t, err)\n+\n+\t// Get appropriate user for SSH connection (handle system accounts)\n+\tusername := testutil.GetTestUsername(t)\n+\n+\tt.Run(\"basic command execution\", func(t *testing.T) {\n+\t\ttestSSHCommandExecutionWithUser(t, host, portStr, clientKeyFile, username)\n+\t})\n+\n+\tt.Run(\"interactive command\", func(t *testing.T) {\n+\t\ttestSSHInteractiveCommand(t, host, portStr, clientKeyFile)\n+\t})\n+\n+\tt.Run(\"port forwarding\", func(t *testing.T) {\n+\t\ttestSSHPortForwarding(t, host, portStr, clientKeyFile)\n+\t})\n+}\n+\n+// testSSHCommandExecutionWithUser tests basic command execution with system SSH client using specified user.\n+func testSSHCommandExecutionWithUser(t *testing.T, host, port, keyFile, username string) {\n+\tcmd := exec.Command(\"ssh\",\n+\t\t\"-i\", keyFile,\n+\t\t\"-p\", port,\n+\t\t\"-o\", \"StrictHostKeyChecking=no\",\n+\t\t\"-o\", \"UserKnownHostsFile=/dev/null\",\n+\t\t\"-o\", \"ConnectTimeout=5\",\n+\t\tfmt.Sprintf(\"%s@%s\", username, host),\n+\t\t\"echo\", \"hello_world\")\n+\n+\toutput, err := cmd.CombinedOutput()\n+\n+\tif err != nil {\n+\t\tt.Logf(\"SSH command failed: %v\", err)\n+\t\tt.Logf(\"Output: %s\", string(output))\n+\t\treturn\n+\t}\n+\n+\tassert.Contains(t, string(output), \"hello_world\", \"SSH command should execute successfully\")\n+}\n+\n+// testSSHInteractiveCommand tests interactive shell session.\n+func testSSHInteractiveCommand(t *testing.T, host, port, keyFile string) {\n+\t// Get appropriate user for SSH connection\n+\tusername := testutil.GetTestUsername(t)\n+\n+\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n+\tdefer cancel()\n+\n+\tcmd := exec.CommandContext(ctx, \"ssh\",\n+\t\t\"-i\", keyFile,\n+\t\t\"-p\", port,\n+\t\t\"-o\", \"StrictHostKeyChecking=no\",\n+\t\t\"-o\", \"UserKnownHostsFile=/dev/null\",\n+\t\t\"-o\", \"ConnectTimeout=5\",\n+\t\tfmt.Sprintf(\"%s@%s\", username, host))\n+\n+\tstdin, err := cmd.StdinPipe()\n+\tif err != nil {\n+\t\tt.Skipf(\"Cannot create stdin pipe: %v\", err)\n+\t\treturn\n+\t}\n+\n+\tstdout, err := cmd.StdoutPipe()\n+\tif err != nil {\n+\t\tt.Skipf(\"Cannot create stdout pipe: %v\", err)\n+\t\treturn\n+\t}\n+\n+\terr = cmd.Start()\n+\tif err != nil {\n+\t\tt.Logf(\"Cannot start SSH session: %v\", err)\n+\t\treturn\n+\t}\n+\n+\tgo func() {\n+\t\tdefer func() {\n+\t\t\tif err := stdin.Close(); err != nil {\n+\t\t\t\tt.Logf(\"stdin close error: %v\", err)\n+\t\t\t}\n+\t\t}()\n+\t\ttime.Sleep(100 * time.Millisecond)\n+\t\tif _, err := stdin.Write([]byte(\"echo interactive_test\\n\")); err != nil {\n+\t\t\tt.Logf(\"stdin write error: %v\", err)\n+\t\t}\n+\t\ttime.Sleep(100 * time.Millisecond)\n+\t\tif _, err := stdin.Write([]byte(\"exit\\n\")); err != nil {\n+\t\t\tt.Logf(\"stdin write error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\toutput, err := io.ReadAll(stdout)\n+\tif err != nil {\n+\t\tt.Logf(\"Cannot read SSH output: %v\", err)\n+\t}\n+\n+\terr = cmd.Wait()\n+\tif err != nil {\n+\t\tt.Logf(\"SSH interactive session error: %v\", err)\n+\t\tt.Logf(\"Output: %s\", string(output))\n+\t\treturn\n+\t}\n+\n+\tassert.Contains(t, string(output), \"interactive_test\", \"Interactive SSH session should work\")\n+}\n+\n+// testSSHPortForwarding tests port forwarding compatibility.\n+func testSSHPortForwarding(t *testing.T, host, port, keyFile string) {\n+\t// Get appropriate user for SSH connection\n+\tusername := testutil.GetTestUsername(t)\n+\n+\ttestServer, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n+\trequire.NoError(t, err)\n+\tdefer testServer.Close()\n+\n+\ttestServerAddr := testServer.Addr().String()\n+\texpectedResponse := \"HTTP/1.1 200 OK\\r\\nContent-Length: 21\\r\\n\\r\\nCompatibility Test OK\"\n+\n+\tgo func() {\n+\t\tfor {\n+\t\t\tconn, err := testServer.Accept()\n+\t\t\tif err != nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tgo func(c net.Conn) {\n+\t\t\t\tdefer func() {\n+\t\t\t\t\tif err := c.Close(); err != nil {\n+\t\t\t\t\t\tt.Logf(\"test server connection close error: %v\", err)\n+\t\t\t\t\t}\n+\t\t\t\t}()\n+\t\t\t\tbuf := make([]byte, 1024)\n+\t\t\t\tif _, err := c.Read(buf); err != nil {\n+\t\t\t\t\tt.Logf(\"Test server read error: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif _, err := c.Write([]byte(expectedResponse)); err != nil {\n+\t\t\t\t\tt.Logf(\"Test server write error: %v\", err)\n+\t\t\t\t}\n+\t\t\t}(conn)\n+\t\t}\n+\t}()\n+\n+\tlocalListener, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n+\trequire.NoError(t, err)\n+\tlocalAddr := localListener.Addr().String()\n+\tlocalListener.Close()\n+\n+\t_, localPort, err := net.SplitHostPort(localAddr)\n+\trequire.NoError(t, err)\n+\n+\tctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)\n+\tdefer cancel()\n+\n+\tforwardSpec := fmt.Sprintf(\"%s:%s\", localPort, testServerAddr)\n+\tcmd := exec.CommandContext(ctx, \"ssh\",\n+\t\t\"-i\", keyFile,\n+\t\t\"-p\", port,\n+\t\t\"-L\", forwardSpec,\n+\t\t\"-o\", \"StrictHostKeyChecking=no\",\n+\t\t\"-o\", \"UserKnownHostsFile=/dev/null\",\n+\t\t\"-o\", \"ConnectTimeout=5\",\n+\t\t\"-N\",\n+\t\tfmt.Sprintf(\"%s@%s\", username, host))\n+\n+\terr = cmd.Start()\n+\tif err != nil {\n+\t\tt.Logf(\"Cannot start SSH port forwarding: %v\", err)\n+\t\treturn\n+\t}\n+\n+\tdefer func() {\n+\t\tif cmd.Process != nil {\n+\t\t\tif err := cmd.Process.Kill(); err != nil {\n+\t\t\t\tt.Logf(\"process kill error: %v\", err)\n+\t\t\t}\n+\t\t}\n+\t\tif err := cmd.Wait(); err != nil {\n+\t\t\tt.Logf(\"process wait after kill: %v\", err)\n+\t\t}\n+\t}()\n+\n+\ttime.Sleep(500 * time.Millisecond)\n+\n+\tconn, err := net.DialTimeout(\"tcp\", localAddr, 3*time.Second)\n+\tif err != nil {\n+\t\tt.Logf(\"Cannot connect to forwarded port: %v\", err)\n+\t\treturn\n+\t}\n+\tdefer func() {\n+\t\tif err := conn.Close(); err != nil {\n+\t\t\tt.Logf(\"forwarded connection close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\trequest := \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n\"\n+\t_, err = conn.Write([]byte(request))\n+\trequire.NoError(t, err)\n+\n+\tif err := conn.SetReadDeadline(time.Now().Add(3 * time.Second)); err != nil {\n+\t\tlog.Debugf(\"failed to set read deadline: %v\", err)\n+\t}\n+\tresponse := make([]byte, len(expectedResponse))\n+\tn, err := io.ReadFull(conn, response)\n+\tif err != nil {\n+\t\tt.Logf(\"Cannot read forwarded response: %v\", err)\n+\t\treturn\n+\t}\n+\n+\tassert.Equal(t, len(expectedResponse), n, \"Should read expected number of bytes\")\n+\tassert.Equal(t, expectedResponse, string(response), \"Should get correct HTTP response through SSH port forwarding\")\n+}\n+\n+// isSSHClientAvailable checks if the ssh binary is available\n+func isSSHClientAvailable() bool {\n+\t_, err := exec.LookPath(\"ssh\")\n+\treturn err == nil\n+}\n+\n+// generateOpenSSHKey generates an ED25519 key in OpenSSH format that the system SSH client can use.\n+func generateOpenSSHKey(t *testing.T) ([]byte, []byte, error) {\n+\t// Check if ssh-keygen is available\n+\tif _, err := exec.LookPath(\"ssh-keygen\"); err != nil {\n+\t\t// Fall back to our existing key generation and try to convert\n+\t\treturn generateOpenSSHKeyFallback()\n+\t}\n+\n+\t// Create temporary file for ssh-keygen\n+\ttempFile, err := os.CreateTemp(\"\", \"ssh_keygen_*\")\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"create temp file: %w\", err)\n+\t}\n+\tkeyPath := tempFile.Name()\n+\ttempFile.Close()\n+\n+\t// Remove the temp file so ssh-keygen can create it\n+\tif err := os.Remove(keyPath); err != nil {\n+\t\tt.Logf(\"failed to remove key file: %v\", err)\n+\t}\n+\n+\t// Clean up temp files\n+\tdefer func() {\n+\t\tif err := os.Remove(keyPath); err != nil {\n+\t\t\tt.Logf(\"failed to cleanup key file: %v\", err)\n+\t\t}\n+\t\tif err := os.Remove(keyPath + \".pub\"); err != nil {\n+\t\t\tt.Logf(\"failed to cleanup public key file: %v\", err)\n+\t\t}\n+\t}()\n+\n+\t// Generate key using ssh-keygen\n+\tcmd := exec.Command(\"ssh-keygen\", \"-t\", \"ed25519\", \"-f\", keyPath, \"-N\", \"\", \"-q\")\n+\toutput, err := cmd.CombinedOutput()\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"ssh-keygen failed: %w, output: %s\", err, string(output))\n+\t}\n+\n+\t// Read private key\n+\tprivKeyBytes, err := os.ReadFile(keyPath)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"read private key: %w\", err)\n+\t}\n+\n+\t// Read public key\n+\tpubKeyBytes, err := os.ReadFile(keyPath + \".pub\")\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"read public key: %w\", err)\n+\t}\n+\n+\treturn privKeyBytes, pubKeyBytes, nil\n+}\n+\n+// generateOpenSSHKeyFallback falls back to generating keys using our existing method\n+func generateOpenSSHKeyFallback() ([]byte, []byte, error) {\n+\t// Generate shared.ED25519 key pair using our existing method\n+\t_, privKey, err := ed25519.GenerateKey(rand.Reader)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"generate key: %w\", err)\n+\t}\n+\n+\t// Convert to SSH format\n+\tsshPrivKey, err := ssh.NewSignerFromKey(privKey)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"create signer: %w\", err)\n+\t}\n+\n+\t// For the fallback, just use our PKCS#8 format and hope it works\n+\t// This won't be in OpenSSH format but might still work with some SSH clients\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\tif err != nil {\n+\t\treturn nil, nil, fmt.Errorf(\"generate fallback key: %w\", err)\n+\t}\n+\n+\t// Get public key in SSH format\n+\tsshPubKey := ssh.MarshalAuthorizedKey(sshPrivKey.PublicKey())\n+\n+\treturn hostKey, sshPubKey, nil\n+}\n+\n+// createTempKeyFileFromBytes creates a temporary SSH private key file from raw bytes\n+func createTempKeyFileFromBytes(t *testing.T, keyBytes []byte) (string, func()) {\n+\tt.Helper()\n+\n+\ttempFile, err := os.CreateTemp(\"\", \"ssh_test_key_*\")\n+\trequire.NoError(t, err)\n+\n+\t_, err = tempFile.Write(keyBytes)\n+\trequire.NoError(t, err)\n+\n+\terr = tempFile.Close()\n+\trequire.NoError(t, err)\n+\n+\t// Set proper permissions for SSH key (readable by owner only)\n+\terr = os.Chmod(tempFile.Name(), 0600)\n+\trequire.NoError(t, err)\n+\n+\tcleanup := func() {\n+\t\t_ = os.Remove(tempFile.Name())\n+\t}\n+\n+\treturn tempFile.Name(), cleanup\n+}\n+\n+// createTempKeyFile creates a temporary SSH private key file (for backward compatibility)\n+func createTempKeyFile(t *testing.T, privateKey []byte) (string, func()) {\n+\treturn createTempKeyFileFromBytes(t, privateKey)\n+}\n+\n+// TestSSHServerFeatureCompatibility tests specific SSH features for compatibility\n+func TestSSHServerFeatureCompatibility(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping SSH feature compatibility tests in short mode\")\n+\t}\n+\n+\tif runtime.GOOS == \"windows\" && testutil.IsCI() {\n+\t\tt.Skip(\"Skipping Windows SSH compatibility tests in CI due to S4U authentication issues\")\n+\t}\n+\n+\tif !isSSHClientAvailable() {\n+\t\tt.Skip(\"SSH client not available on this system\")\n+\t}\n+\n+\t// Test various SSH features\n+\ttestCases := []struct {\n+\t\tname        string\n+\t\ttestFunc    func(t *testing.T, host, port, keyFile string)\n+\t\tdescription string\n+\t}{\n+\t\t{\n+\t\t\tname:        \"command_with_flags\",\n+\t\t\ttestFunc:    testCommandWithFlags,\n+\t\t\tdescription: \"Commands with flags should work like standard SSH\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"environment_variables\",\n+\t\t\ttestFunc:    testEnvironmentVariables,\n+\t\t\tdescription: \"Environment variables should be available\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"exit_codes\",\n+\t\t\ttestFunc:    testExitCodes,\n+\t\t\tdescription: \"Exit codes should be properly handled\",\n+\t\t},\n+\t}\n+\n+\t// Set up SSH server\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tclientPrivKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := New(serverConfig)\n+\tserver.SetAllowRootLogin(true)\n+\n+\tserverAddr := StartTestServer(t, server)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\tclientKeyFile, cleanupKey := createTempKeyFile(t, clientPrivKey)\n+\tdefer cleanupKey()\n+\n+\thost, portStr, err := net.SplitHostPort(serverAddr)\n+\trequire.NoError(t, err)\n+\n+\tfor _, tc := range testCases {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\ttc.testFunc(t, host, portStr, clientKeyFile)\n+\t\t})\n+\t}\n+}\n+\n+// testCommandWithFlags tests that commands with flags work properly\n+func testCommandWithFlags(t *testing.T, host, port, keyFile string) {\n+\t// Get appropriate user for SSH connection\n+\tusername := testutil.GetTestUsername(t)\n+\n+\t// Test ls with flags\n+\tcmd := exec.Command(\"ssh\",\n+\t\t\"-i\", keyFile,\n+\t\t\"-p\", port,\n+\t\t\"-o\", \"StrictHostKeyChecking=no\",\n+\t\t\"-o\", \"UserKnownHostsFile=/dev/null\",\n+\t\t\"-o\", \"ConnectTimeout=5\",\n+\t\tfmt.Sprintf(\"%s@%s\", username, host),\n+\t\t\"ls\", \"-la\", \"/tmp\")\n+\n+\toutput, err := cmd.CombinedOutput()\n+\tif err != nil {\n+\t\tt.Logf(\"Command with flags failed: %v\", err)\n+\t\tt.Logf(\"Output: %s\", string(output))\n+\t\treturn\n+\t}\n+\n+\t// Should not be empty and should not contain error messages\n+\tassert.NotEmpty(t, string(output), \"ls -la should produce output\")\n+\tassert.NotContains(t, strings.ToLower(string(output)), \"command not found\", \"Command should be executed\")\n+}\n+\n+// testEnvironmentVariables tests that environment is properly set up\n+func testEnvironmentVariables(t *testing.T, host, port, keyFile string) {\n+\t// Get appropriate user for SSH connection\n+\tusername := testutil.GetTestUsername(t)\n+\n+\tcmd := exec.Command(\"ssh\",\n+\t\t\"-i\", keyFile,\n+\t\t\"-p\", port,\n+\t\t\"-o\", \"StrictHostKeyChecking=no\",\n+\t\t\"-o\", \"UserKnownHostsFile=/dev/null\",\n+\t\t\"-o\", \"ConnectTimeout=5\",\n+\t\tfmt.Sprintf(\"%s@%s\", username, host),\n+\t\t\"echo\", \"$HOME\")\n+\n+\toutput, err := cmd.CombinedOutput()\n+\tif err != nil {\n+\t\tt.Logf(\"Environment test failed: %v\", err)\n+\t\tt.Logf(\"Output: %s\", string(output))\n+\t\treturn\n+\t}\n+\n+\t// HOME environment variable should be available\n+\thomeOutput := strings.TrimSpace(string(output))\n+\tassert.NotEmpty(t, homeOutput, \"HOME environment variable should be set\")\n+\tassert.NotEqual(t, \"$HOME\", homeOutput, \"Environment variable should be expanded\")\n+}\n+\n+// testExitCodes tests that exit codes are properly handled\n+func testExitCodes(t *testing.T, host, port, keyFile string) {\n+\t// Get appropriate user for SSH connection\n+\tusername := testutil.GetTestUsername(t)\n+\n+\t// Test successful command (exit code 0)\n+\tcmd := exec.Command(\"ssh\",\n+\t\t\"-i\", keyFile,\n+\t\t\"-p\", port,\n+\t\t\"-o\", \"StrictHostKeyChecking=no\",\n+\t\t\"-o\", \"UserKnownHostsFile=/dev/null\",\n+\t\t\"-o\", \"ConnectTimeout=5\",\n+\t\tfmt.Sprintf(\"%s@%s\", username, host),\n+\t\t\"true\") // always succeeds\n+\n+\terr := cmd.Run()\n+\tassert.NoError(t, err, \"Command with exit code 0 should succeed\")\n+\n+\t// Test failing command (exit code 1)\n+\tcmd = exec.Command(\"ssh\",\n+\t\t\"-i\", keyFile,\n+\t\t\"-p\", port,\n+\t\t\"-o\", \"StrictHostKeyChecking=no\",\n+\t\t\"-o\", \"UserKnownHostsFile=/dev/null\",\n+\t\t\"-o\", \"ConnectTimeout=5\",\n+\t\tfmt.Sprintf(\"%s@%s\", username, host),\n+\t\t\"false\") // always fails\n+\n+\terr = cmd.Run()\n+\tassert.Error(t, err, \"Command with exit code 1 should fail\")\n+\n+\t// Check if it's the right kind of error\n+\tif exitError, ok := err.(*exec.ExitError); ok {\n+\t\tassert.Equal(t, 1, exitError.ExitCode(), \"Exit code should be preserved\")\n+\t}\n+}\n+\n+// TestSSHServerSecurityFeatures tests security-related SSH features\n+func TestSSHServerSecurityFeatures(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping SSH security tests in short mode\")\n+\t}\n+\n+\tif !isSSHClientAvailable() {\n+\t\tt.Skip(\"SSH client not available on this system\")\n+\t}\n+\n+\t// Get appropriate user for SSH connection\n+\tusername := testutil.GetTestUsername(t)\n+\n+\t// Set up SSH server with specific security settings\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tclientPrivKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := New(serverConfig)\n+\tserver.SetAllowRootLogin(true)\n+\n+\tserverAddr := StartTestServer(t, server)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\tclientKeyFile, cleanupKey := createTempKeyFile(t, clientPrivKey)\n+\tdefer cleanupKey()\n+\n+\thost, portStr, err := net.SplitHostPort(serverAddr)\n+\trequire.NoError(t, err)\n+\n+\tt.Run(\"key_authentication\", func(t *testing.T) {\n+\t\t// Test that key authentication works\n+\t\tcmd := exec.Command(\"ssh\",\n+\t\t\t\"-i\", clientKeyFile,\n+\t\t\t\"-p\", portStr,\n+\t\t\t\"-o\", \"StrictHostKeyChecking=no\",\n+\t\t\t\"-o\", \"UserKnownHostsFile=/dev/null\",\n+\t\t\t\"-o\", \"ConnectTimeout=5\",\n+\t\t\t\"-o\", \"PasswordAuthentication=no\",\n+\t\t\tfmt.Sprintf(\"%s@%s\", username, host),\n+\t\t\t\"echo\", \"auth_success\")\n+\n+\t\toutput, err := cmd.CombinedOutput()\n+\t\tif err != nil {\n+\t\t\tt.Logf(\"Key authentication failed: %v\", err)\n+\t\t\tt.Logf(\"Output: %s\", string(output))\n+\t\t\treturn\n+\t\t}\n+\n+\t\tassert.Contains(t, string(output), \"auth_success\", \"Key authentication should work\")\n+\t})\n+\n+\tt.Run(\"any_key_accepted_in_no_auth_mode\", func(t *testing.T) {\n+\t\t// Create a different key that shouldn't be accepted\n+\t\twrongKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\t\trequire.NoError(t, err)\n+\n+\t\twrongKeyFile, cleanupWrongKey := createTempKeyFile(t, wrongKey)\n+\t\tdefer cleanupWrongKey()\n+\n+\t\t// Test that wrong key is rejected\n+\t\tcmd := exec.Command(\"ssh\",\n+\t\t\t\"-i\", wrongKeyFile,\n+\t\t\t\"-p\", portStr,\n+\t\t\t\"-o\", \"StrictHostKeyChecking=no\",\n+\t\t\t\"-o\", \"UserKnownHostsFile=/dev/null\",\n+\t\t\t\"-o\", \"ConnectTimeout=5\",\n+\t\t\t\"-o\", \"PasswordAuthentication=no\",\n+\t\t\tfmt.Sprintf(\"%s@%s\", username, host),\n+\t\t\t\"echo\", \"should_not_work\")\n+\n+\t\terr = cmd.Run()\n+\t\tassert.NoError(t, err, \"Any key should work in no-auth mode\")\n+\t})\n+}\n+\n+// TestCrossPlatformCompatibility tests cross-platform behavior\n+func TestCrossPlatformCompatibility(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping cross-platform compatibility tests in short mode\")\n+\t}\n+\n+\tif !isSSHClientAvailable() {\n+\t\tt.Skip(\"SSH client not available on this system\")\n+\t}\n+\n+\t// Get appropriate user for SSH connection\n+\tusername := testutil.GetTestUsername(t)\n+\n+\t// Set up SSH server\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tclientPrivKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := New(serverConfig)\n+\tserver.SetAllowRootLogin(true)\n+\n+\tserverAddr := StartTestServer(t, server)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\tclientKeyFile, cleanupKey := createTempKeyFile(t, clientPrivKey)\n+\tdefer cleanupKey()\n+\n+\thost, portStr, err := net.SplitHostPort(serverAddr)\n+\trequire.NoError(t, err)\n+\n+\t// Test platform-specific commands\n+\tvar testCommand string\n+\n+\tswitch runtime.GOOS {\n+\tcase \"windows\":\n+\t\ttestCommand = \"echo %OS%\"\n+\tdefault:\n+\t\ttestCommand = \"uname\"\n+\t}\n+\n+\tcmd := exec.Command(\"ssh\",\n+\t\t\"-i\", clientKeyFile,\n+\t\t\"-p\", portStr,\n+\t\t\"-o\", \"StrictHostKeyChecking=no\",\n+\t\t\"-o\", \"UserKnownHostsFile=/dev/null\",\n+\t\t\"-o\", \"ConnectTimeout=5\",\n+\t\tfmt.Sprintf(\"%s@%s\", username, host),\n+\t\ttestCommand)\n+\n+\toutput, err := cmd.CombinedOutput()\n+\tif err != nil {\n+\t\tt.Logf(\"Platform-specific command failed: %v\", err)\n+\t\tt.Logf(\"Output: %s\", string(output))\n+\t\treturn\n+\t}\n+\n+\toutputStr := strings.TrimSpace(string(output))\n+\tt.Logf(\"Platform command output: %s\", outputStr)\n+\tassert.NotEmpty(t, outputStr, \"Platform-specific command should produce output\")\n+}\ndiff --git a/client/ssh/server/executor_unix_test.go b/client/ssh/server/executor_unix_test.go\nnew file mode 100644\nindex 00000000000..0c5108f57fa\n--- /dev/null\n+++ b/client/ssh/server/executor_unix_test.go\n@@ -0,0 +1,262 @@\n+//go:build unix\n+\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"os/user\"\n+\t\"strconv\"\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+func TestPrivilegeDropper_ValidatePrivileges(t *testing.T) {\n+\tpd := NewPrivilegeDropper()\n+\n+\tcurrentUID := uint32(os.Geteuid())\n+\tcurrentGID := uint32(os.Getegid())\n+\n+\ttests := []struct {\n+\t\tname    string\n+\t\tuid     uint32\n+\t\tgid     uint32\n+\t\twantErr bool\n+\t}{\n+\t\t{\n+\t\t\tname:    \"same user - no privilege drop needed\",\n+\t\t\tuid:     currentUID,\n+\t\t\tgid:     currentGID,\n+\t\t\twantErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"non-root to different user should fail\",\n+\t\t\tuid:     currentUID + 1,  // Use a different UID to ensure it's actually different\n+\t\t\tgid:     currentGID + 1,  // Use a different GID to ensure it's actually different\n+\t\t\twantErr: currentUID != 0, // Only fail if current user is not root\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"root can drop to any user\",\n+\t\t\tuid:     1000,\n+\t\t\tgid:     1000,\n+\t\t\twantErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"root can stay as root\",\n+\t\t\tuid:     0,\n+\t\t\tgid:     0,\n+\t\t\twantErr: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Skip non-root tests when running as root, and root tests when not root\n+\t\t\tif tt.name == \"non-root to different user should fail\" && currentUID == 0 {\n+\t\t\t\tt.Skip(\"Skipping non-root test when running as root\")\n+\t\t\t}\n+\t\t\tif (tt.name == \"root can drop to any user\" || tt.name == \"root can stay as root\") && currentUID != 0 {\n+\t\t\t\tt.Skip(\"Skipping root test when not running as root\")\n+\t\t\t}\n+\n+\t\t\terr := pd.validatePrivileges(tt.uid, tt.gid)\n+\t\t\tif tt.wantErr {\n+\t\t\t\tassert.Error(t, err)\n+\t\t\t} else {\n+\t\t\t\tassert.NoError(t, err)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestPrivilegeDropper_CreateExecutorCommand(t *testing.T) {\n+\tpd := NewPrivilegeDropper()\n+\n+\tconfig := ExecutorConfig{\n+\t\tUID:        1000,\n+\t\tGID:        1000,\n+\t\tGroups:     []uint32{1000, 1001},\n+\t\tWorkingDir: \"/home/testuser\",\n+\t\tShell:      \"/bin/bash\",\n+\t\tCommand:    \"ls -la\",\n+\t}\n+\n+\tcmd, err := pd.CreateExecutorCommand(context.Background(), config)\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, cmd)\n+\n+\t// Verify the command is calling netbird ssh exec\n+\tassert.Contains(t, cmd.Args, \"ssh\")\n+\tassert.Contains(t, cmd.Args, \"exec\")\n+\tassert.Contains(t, cmd.Args, \"--uid\")\n+\tassert.Contains(t, cmd.Args, \"1000\")\n+\tassert.Contains(t, cmd.Args, \"--gid\")\n+\tassert.Contains(t, cmd.Args, \"1000\")\n+\tassert.Contains(t, cmd.Args, \"--groups\")\n+\tassert.Contains(t, cmd.Args, \"1000\")\n+\tassert.Contains(t, cmd.Args, \"1001\")\n+\tassert.Contains(t, cmd.Args, \"--working-dir\")\n+\tassert.Contains(t, cmd.Args, \"/home/testuser\")\n+\tassert.Contains(t, cmd.Args, \"--shell\")\n+\tassert.Contains(t, cmd.Args, \"/bin/bash\")\n+\tassert.Contains(t, cmd.Args, \"--cmd\")\n+\tassert.Contains(t, cmd.Args, \"ls -la\")\n+}\n+\n+func TestPrivilegeDropper_CreateExecutorCommandInteractive(t *testing.T) {\n+\tpd := NewPrivilegeDropper()\n+\n+\tconfig := ExecutorConfig{\n+\t\tUID:        1000,\n+\t\tGID:        1000,\n+\t\tGroups:     []uint32{1000},\n+\t\tWorkingDir: \"/home/testuser\",\n+\t\tShell:      \"/bin/bash\",\n+\t\tCommand:    \"\",\n+\t}\n+\n+\tcmd, err := pd.CreateExecutorCommand(context.Background(), config)\n+\trequire.NoError(t, err)\n+\trequire.NotNil(t, cmd)\n+\n+\t// Verify no command mode (command is empty so no --cmd flag)\n+\tassert.NotContains(t, cmd.Args, \"--cmd\")\n+\tassert.NotContains(t, cmd.Args, \"--interactive\")\n+}\n+\n+// TestPrivilegeDropper_ActualPrivilegeDrop tests actual privilege dropping\n+// This test requires root privileges and will be skipped if not running as root\n+func TestPrivilegeDropper_ActualPrivilegeDrop(t *testing.T) {\n+\tif os.Geteuid() != 0 {\n+\t\tt.Skip(\"This test requires root privileges\")\n+\t}\n+\n+\t// Find a non-root user to test with\n+\ttestUser, err := findNonRootUser()\n+\tif err != nil {\n+\t\tt.Skip(\"No suitable non-root user found for testing\")\n+\t}\n+\n+\t// Verify the user actually exists by looking it up again\n+\t_, err = user.LookupId(testUser.Uid)\n+\tif err != nil {\n+\t\tt.Skipf(\"Test user %s (UID %s) does not exist on this system: %v\", testUser.Username, testUser.Uid, err)\n+\t}\n+\n+\tuid64, err := strconv.ParseUint(testUser.Uid, 10, 32)\n+\trequire.NoError(t, err)\n+\ttargetUID := uint32(uid64)\n+\n+\tgid64, err := strconv.ParseUint(testUser.Gid, 10, 32)\n+\trequire.NoError(t, err)\n+\ttargetGID := uint32(gid64)\n+\n+\t// Test in a child process to avoid affecting the test runner\n+\tif os.Getenv(\"TEST_PRIVILEGE_DROP\") == \"1\" {\n+\t\tpd := NewPrivilegeDropper()\n+\n+\t\t// This should succeed\n+\t\terr := pd.DropPrivileges(targetUID, targetGID, []uint32{targetGID})\n+\t\trequire.NoError(t, err)\n+\n+\t\t// Verify we are now running as the target user\n+\t\tcurrentUID := uint32(os.Geteuid())\n+\t\tcurrentGID := uint32(os.Getegid())\n+\n+\t\tassert.Equal(t, targetUID, currentUID, \"UID should match target\")\n+\t\tassert.Equal(t, targetGID, currentGID, \"GID should match target\")\n+\t\tassert.NotEqual(t, uint32(0), currentUID, \"Should not be running as root\")\n+\t\tassert.NotEqual(t, uint32(0), currentGID, \"Should not be running as root group\")\n+\n+\t\treturn\n+\t}\n+\n+\t// Fork a child process to test privilege dropping\n+\tcmd := os.Args[0]\n+\targs := []string{\"-test.run=TestPrivilegeDropper_ActualPrivilegeDrop\"}\n+\n+\tenv := append(os.Environ(), \"TEST_PRIVILEGE_DROP=1\")\n+\n+\texecCmd := exec.Command(cmd, args...)\n+\texecCmd.Env = env\n+\n+\terr = execCmd.Run()\n+\trequire.NoError(t, err, \"Child process should succeed\")\n+}\n+\n+// findNonRootUser finds any non-root user on the system for testing\n+func findNonRootUser() (*user.User, error) {\n+\t// Try common non-root users, but avoid \"nobody\" on macOS due to negative UID issues\n+\tcommonUsers := []string{\"daemon\", \"bin\", \"sys\", \"sync\", \"games\", \"man\", \"lp\", \"mail\", \"news\", \"uucp\", \"proxy\", \"www-data\", \"backup\", \"list\", \"irc\"}\n+\n+\tfor _, username := range commonUsers {\n+\t\tif u, err := user.Lookup(username); err == nil {\n+\t\t\t// Parse as signed integer first to handle negative UIDs\n+\t\t\tuid64, err := strconv.ParseInt(u.Uid, 10, 32)\n+\t\t\tif err != nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\t// Skip negative UIDs (like nobody=-2 on macOS) and root\n+\t\t\tif uid64 > 0 && uid64 != 0 {\n+\t\t\t\treturn u, nil\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// If no common users found, try to find any regular user with UID > 100\n+\t// This helps on macOS where regular users start at UID 501\n+\tallUsers := []string{\"vma\", \"user\", \"test\", \"admin\"}\n+\tfor _, username := range allUsers {\n+\t\tif u, err := user.Lookup(username); err == nil {\n+\t\t\tuid64, err := strconv.ParseInt(u.Uid, 10, 32)\n+\t\t\tif err != nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif uid64 > 100 { // Regular user\n+\t\t\t\treturn u, nil\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// If no common users found, return an error\n+\treturn nil, fmt.Errorf(\"no suitable non-root user found on this system\")\n+}\n+\n+func TestPrivilegeDropper_ExecuteWithPrivilegeDrop_Validation(t *testing.T) {\n+\tpd := NewPrivilegeDropper()\n+\tcurrentUID := uint32(os.Geteuid())\n+\n+\tif currentUID == 0 {\n+\t\t// When running as root, test that root can create commands for any user\n+\t\tconfig := ExecutorConfig{\n+\t\t\tUID:        1000, // Target non-root user\n+\t\t\tGID:        1000,\n+\t\t\tGroups:     []uint32{1000},\n+\t\t\tWorkingDir: \"/tmp\",\n+\t\t\tShell:      \"/bin/sh\",\n+\t\t\tCommand:    \"echo test\",\n+\t\t}\n+\n+\t\tcmd, err := pd.CreateExecutorCommand(context.Background(), config)\n+\t\tassert.NoError(t, err, \"Root should be able to create commands for any user\")\n+\t\tassert.NotNil(t, cmd)\n+\t} else {\n+\t\t// When running as non-root, test that we can't drop to a different user\n+\t\tconfig := ExecutorConfig{\n+\t\t\tUID:        0, // Try to target root\n+\t\t\tGID:        0,\n+\t\t\tGroups:     []uint32{0},\n+\t\t\tWorkingDir: \"/tmp\",\n+\t\t\tShell:      \"/bin/sh\",\n+\t\t\tCommand:    \"echo test\",\n+\t\t}\n+\n+\t\t_, err := pd.CreateExecutorCommand(context.Background(), config)\n+\t\tassert.Error(t, err)\n+\t\tassert.Contains(t, err.Error(), \"cannot drop privileges\")\n+\t}\n+}\ndiff --git a/client/ssh/server/jwt_test.go b/client/ssh/server/jwt_test.go\nnew file mode 100644\nindex 00000000000..e22bdfb06c4\n--- /dev/null\n+++ b/client/ssh/server/jwt_test.go\n@@ -0,0 +1,629 @@\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"crypto/rand\"\n+\t\"crypto/rsa\"\n+\t\"encoding/base64\"\n+\t\"encoding/json\"\n+\t\"io\"\n+\t\"math/big\"\n+\t\"net\"\n+\t\"net/http\"\n+\t\"net/http/httptest\"\n+\t\"runtime\"\n+\t\"strconv\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/golang-jwt/jwt/v5\"\n+\tcryptossh \"golang.org/x/crypto/ssh\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\n+\tnbssh \"github.com/netbirdio/netbird/client/ssh\"\n+\t\"github.com/netbirdio/netbird/client/ssh/client\"\n+\t\"github.com/netbirdio/netbird/client/ssh/detection\"\n+\t\"github.com/netbirdio/netbird/client/ssh/testutil\"\n+\tnbjwt \"github.com/netbirdio/netbird/shared/auth/jwt\"\n+)\n+\n+func TestJWTEnforcement(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping JWT enforcement tests in short mode\")\n+\t}\n+\n+\t// Set up SSH server\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tt.Run(\"blocks_without_jwt\", func(t *testing.T) {\n+\t\tjwtConfig := &JWTConfig{\n+\t\t\tIssuer:       \"test-issuer\",\n+\t\t\tAudience:     \"test-audience\",\n+\t\t\tKeysLocation: \"test-keys\",\n+\t\t}\n+\t\tserverConfig := &Config{\n+\t\t\tHostKeyPEM: hostKey,\n+\t\t\tJWT:        jwtConfig,\n+\t\t}\n+\t\tserver := New(serverConfig)\n+\t\tserver.SetAllowRootLogin(true)\n+\n+\t\tserverAddr := StartTestServer(t, server)\n+\t\tdefer require.NoError(t, server.Stop())\n+\n+\t\thost, portStr, err := net.SplitHostPort(serverAddr)\n+\t\trequire.NoError(t, err)\n+\t\tport, err := strconv.Atoi(portStr)\n+\t\trequire.NoError(t, err)\n+\t\tdialer := &net.Dialer{Timeout: detection.Timeout}\n+\t\tserverType, err := detection.DetectSSHServerType(context.Background(), dialer, host, port)\n+\t\tif err != nil {\n+\t\t\tt.Logf(\"Detection failed: %v\", err)\n+\t\t}\n+\t\tt.Logf(\"Detected server type: %s\", serverType)\n+\n+\t\tconfig := &cryptossh.ClientConfig{\n+\t\t\tUser:            testutil.GetTestUsername(t),\n+\t\t\tAuth:            []cryptossh.AuthMethod{},\n+\t\t\tHostKeyCallback: cryptossh.InsecureIgnoreHostKey(),\n+\t\t\tTimeout:         2 * time.Second,\n+\t\t}\n+\n+\t\t_, err = cryptossh.Dial(\"tcp\", net.JoinHostPort(host, portStr), config)\n+\t\tassert.Error(t, err, \"SSH connection should fail when JWT is required but not provided\")\n+\t})\n+\n+\tt.Run(\"allows_when_disabled\", func(t *testing.T) {\n+\t\tserverConfigNoJWT := &Config{\n+\t\t\tHostKeyPEM: hostKey,\n+\t\t\tJWT:        nil,\n+\t\t}\n+\t\tserverNoJWT := New(serverConfigNoJWT)\n+\t\trequire.False(t, serverNoJWT.jwtEnabled, \"JWT should be disabled without config\")\n+\t\tserverNoJWT.SetAllowRootLogin(true)\n+\n+\t\tserverAddrNoJWT := StartTestServer(t, serverNoJWT)\n+\t\tdefer require.NoError(t, serverNoJWT.Stop())\n+\n+\t\thostNoJWT, portStrNoJWT, err := net.SplitHostPort(serverAddrNoJWT)\n+\t\trequire.NoError(t, err)\n+\t\tportNoJWT, err := strconv.Atoi(portStrNoJWT)\n+\t\trequire.NoError(t, err)\n+\n+\t\tdialer := &net.Dialer{Timeout: detection.Timeout}\n+\t\tserverType, err := detection.DetectSSHServerType(context.Background(), dialer, hostNoJWT, portNoJWT)\n+\t\trequire.NoError(t, err)\n+\t\tassert.Equal(t, detection.ServerTypeNetBirdNoJWT, serverType)\n+\t\tassert.False(t, serverType.RequiresJWT())\n+\n+\t\tclient, err := connectWithNetBirdClient(t, hostNoJWT, portNoJWT)\n+\t\trequire.NoError(t, err)\n+\t\tdefer client.Close()\n+\t})\n+\n+}\n+\n+// setupJWKSServer creates a test HTTP server serving JWKS and returns the server, private key, and URL\n+func setupJWKSServer(t *testing.T) (*httptest.Server, *rsa.PrivateKey, string) {\n+\tprivateKey, jwksJSON := generateTestJWKS(t)\n+\n+\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n+\t\tif _, err := w.Write(jwksJSON); err != nil {\n+\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n+\t\t}\n+\t}))\n+\n+\treturn server, privateKey, server.URL\n+}\n+\n+// generateTestJWKS creates a test RSA key pair and returns private key and JWKS JSON\n+func generateTestJWKS(t *testing.T) (*rsa.PrivateKey, []byte) {\n+\tprivateKey, err := rsa.GenerateKey(rand.Reader, 2048)\n+\trequire.NoError(t, err)\n+\n+\tpublicKey := &privateKey.PublicKey\n+\tn := publicKey.N.Bytes()\n+\te := publicKey.E\n+\n+\tjwk := nbjwt.JSONWebKey{\n+\t\tKty: \"RSA\",\n+\t\tKid: \"test-key-id\",\n+\t\tUse: \"sig\",\n+\t\tN:   base64RawURLEncode(n),\n+\t\tE:   base64RawURLEncode(big.NewInt(int64(e)).Bytes()),\n+\t}\n+\n+\tjwks := nbjwt.Jwks{\n+\t\tKeys: []nbjwt.JSONWebKey{jwk},\n+\t}\n+\n+\tjwksJSON, err := json.Marshal(jwks)\n+\trequire.NoError(t, err)\n+\n+\treturn privateKey, jwksJSON\n+}\n+\n+func base64RawURLEncode(data []byte) string {\n+\treturn base64.RawURLEncoding.EncodeToString(data)\n+}\n+\n+// generateValidJWT creates a valid JWT token for testing\n+func generateValidJWT(t *testing.T, privateKey *rsa.PrivateKey, issuer, audience string) string {\n+\tclaims := jwt.MapClaims{\n+\t\t\"iss\": issuer,\n+\t\t\"aud\": audience,\n+\t\t\"sub\": \"test-user\",\n+\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n+\t\t\"iat\": time.Now().Unix(),\n+\t}\n+\n+\ttoken := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)\n+\ttoken.Header[\"kid\"] = \"test-key-id\"\n+\n+\ttokenString, err := token.SignedString(privateKey)\n+\trequire.NoError(t, err)\n+\n+\treturn tokenString\n+}\n+\n+// connectWithNetBirdClient connects to SSH server using NetBird's SSH client\n+func connectWithNetBirdClient(t *testing.T, host string, port int) (*client.Client, error) {\n+\tt.Helper()\n+\taddr := net.JoinHostPort(host, strconv.Itoa(port))\n+\n+\tctx := context.Background()\n+\treturn client.Dial(ctx, addr, testutil.GetTestUsername(t), client.DialOptions{\n+\t\tInsecureSkipVerify: true,\n+\t})\n+}\n+\n+// TestJWTDetection tests that server detection correctly identifies JWT-enabled servers\n+func TestJWTDetection(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping JWT detection test in short mode\")\n+\t}\n+\n+\tjwksServer, _, jwksURL := setupJWKSServer(t)\n+\tdefer jwksServer.Close()\n+\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tconst (\n+\t\tissuer   = \"https://test-issuer.example.com\"\n+\t\taudience = \"test-audience\"\n+\t)\n+\n+\tjwtConfig := &JWTConfig{\n+\t\tIssuer:       issuer,\n+\t\tAudience:     audience,\n+\t\tKeysLocation: jwksURL,\n+\t}\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        jwtConfig,\n+\t}\n+\tserver := New(serverConfig)\n+\tserver.SetAllowRootLogin(true)\n+\n+\tserverAddr := StartTestServer(t, server)\n+\tdefer require.NoError(t, server.Stop())\n+\n+\thost, portStr, err := net.SplitHostPort(serverAddr)\n+\trequire.NoError(t, err)\n+\tport, err := strconv.Atoi(portStr)\n+\trequire.NoError(t, err)\n+\n+\tdialer := &net.Dialer{Timeout: detection.Timeout}\n+\tserverType, err := detection.DetectSSHServerType(context.Background(), dialer, host, port)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, detection.ServerTypeNetBirdJWT, serverType)\n+\tassert.True(t, serverType.RequiresJWT())\n+}\n+\n+func TestJWTFailClose(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping JWT fail-close tests in short mode\")\n+\t}\n+\n+\tjwksServer, privateKey, jwksURL := setupJWKSServer(t)\n+\tdefer jwksServer.Close()\n+\n+\tconst (\n+\t\tissuer   = \"https://test-issuer.example.com\"\n+\t\taudience = \"test-audience\"\n+\t)\n+\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\ttestCases := []struct {\n+\t\tname        string\n+\t\ttokenClaims jwt.MapClaims\n+\t}{\n+\t\t{\n+\t\t\tname: \"blocks_token_missing_iat\",\n+\t\t\ttokenClaims: jwt.MapClaims{\n+\t\t\t\t\"iss\": issuer,\n+\t\t\t\t\"aud\": audience,\n+\t\t\t\t\"sub\": \"test-user\",\n+\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"blocks_token_missing_sub\",\n+\t\t\ttokenClaims: jwt.MapClaims{\n+\t\t\t\t\"iss\": issuer,\n+\t\t\t\t\"aud\": audience,\n+\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n+\t\t\t\t\"iat\": time.Now().Unix(),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"blocks_token_missing_iss\",\n+\t\t\ttokenClaims: jwt.MapClaims{\n+\t\t\t\t\"aud\": audience,\n+\t\t\t\t\"sub\": \"test-user\",\n+\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n+\t\t\t\t\"iat\": time.Now().Unix(),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"blocks_token_missing_aud\",\n+\t\t\ttokenClaims: jwt.MapClaims{\n+\t\t\t\t\"iss\": issuer,\n+\t\t\t\t\"sub\": \"test-user\",\n+\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n+\t\t\t\t\"iat\": time.Now().Unix(),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"blocks_token_wrong_issuer\",\n+\t\t\ttokenClaims: jwt.MapClaims{\n+\t\t\t\t\"iss\": \"wrong-issuer\",\n+\t\t\t\t\"aud\": audience,\n+\t\t\t\t\"sub\": \"test-user\",\n+\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n+\t\t\t\t\"iat\": time.Now().Unix(),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"blocks_token_wrong_audience\",\n+\t\t\ttokenClaims: jwt.MapClaims{\n+\t\t\t\t\"iss\": issuer,\n+\t\t\t\t\"aud\": \"wrong-audience\",\n+\t\t\t\t\"sub\": \"test-user\",\n+\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n+\t\t\t\t\"iat\": time.Now().Unix(),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"blocks_expired_token\",\n+\t\t\ttokenClaims: jwt.MapClaims{\n+\t\t\t\t\"iss\": issuer,\n+\t\t\t\t\"aud\": audience,\n+\t\t\t\t\"sub\": \"test-user\",\n+\t\t\t\t\"exp\": time.Now().Add(-time.Hour).Unix(),\n+\t\t\t\t\"iat\": time.Now().Add(-2 * time.Hour).Unix(),\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"blocks_token_exceeding_max_age\",\n+\t\t\ttokenClaims: jwt.MapClaims{\n+\t\t\t\t\"iss\": issuer,\n+\t\t\t\t\"aud\": audience,\n+\t\t\t\t\"sub\": \"test-user\",\n+\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n+\t\t\t\t\"iat\": time.Now().Add(-2 * time.Hour).Unix(),\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tjwtConfig := &JWTConfig{\n+\t\t\t\tIssuer:       issuer,\n+\t\t\t\tAudience:     audience,\n+\t\t\t\tKeysLocation: jwksURL,\n+\t\t\t\tMaxTokenAge:  3600,\n+\t\t\t}\n+\t\t\tserverConfig := &Config{\n+\t\t\t\tHostKeyPEM: hostKey,\n+\t\t\t\tJWT:        jwtConfig,\n+\t\t\t}\n+\t\t\tserver := New(serverConfig)\n+\t\t\tserver.SetAllowRootLogin(true)\n+\n+\t\t\tserverAddr := StartTestServer(t, server)\n+\t\t\tdefer require.NoError(t, server.Stop())\n+\n+\t\t\thost, portStr, err := net.SplitHostPort(serverAddr)\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\ttoken := jwt.NewWithClaims(jwt.SigningMethodRS256, tc.tokenClaims)\n+\t\t\ttoken.Header[\"kid\"] = \"test-key-id\"\n+\t\t\ttokenString, err := token.SignedString(privateKey)\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\tconfig := &cryptossh.ClientConfig{\n+\t\t\t\tUser: testutil.GetTestUsername(t),\n+\t\t\t\tAuth: []cryptossh.AuthMethod{\n+\t\t\t\t\tcryptossh.Password(tokenString),\n+\t\t\t\t},\n+\t\t\t\tHostKeyCallback: cryptossh.InsecureIgnoreHostKey(),\n+\t\t\t\tTimeout:         2 * time.Second,\n+\t\t\t}\n+\n+\t\t\tconn, err := cryptossh.Dial(\"tcp\", net.JoinHostPort(host, portStr), config)\n+\t\t\tif conn != nil {\n+\t\t\t\tdefer func() {\n+\t\t\t\t\tif err := conn.Close(); err != nil {\n+\t\t\t\t\t\tt.Logf(\"close connection: %v\", err)\n+\t\t\t\t\t}\n+\t\t\t\t}()\n+\t\t\t}\n+\n+\t\t\tassert.Error(t, err, \"Authentication should fail (fail-close)\")\n+\t\t})\n+\t}\n+}\n+\n+// TestJWTAuthentication tests JWT authentication with valid/invalid tokens and enforcement for various connection types\n+func TestJWTAuthentication(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping JWT authentication tests in short mode\")\n+\t}\n+\n+\tjwksServer, privateKey, jwksURL := setupJWKSServer(t)\n+\tdefer jwksServer.Close()\n+\n+\tconst (\n+\t\tissuer   = \"https://test-issuer.example.com\"\n+\t\taudience = \"test-audience\"\n+\t)\n+\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\ttestCases := []struct {\n+\t\tname          string\n+\t\ttoken         string\n+\t\twantAuthOK    bool\n+\t\tsetupServer   func(*Server)\n+\t\ttestOperation func(*testing.T, *cryptossh.Client, string) error\n+\t\twantOpSuccess bool\n+\t}{\n+\t\t{\n+\t\t\tname:       \"allows_shell_with_jwt\",\n+\t\t\ttoken:      \"valid\",\n+\t\t\twantAuthOK: true,\n+\t\t\tsetupServer: func(s *Server) {\n+\t\t\t\ts.SetAllowRootLogin(true)\n+\t\t\t},\n+\t\t\ttestOperation: func(t *testing.T, conn *cryptossh.Client, _ string) error {\n+\t\t\t\tsession, err := conn.NewSession()\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\tdefer session.Close()\n+\t\t\t\treturn session.Shell()\n+\t\t\t},\n+\t\t\twantOpSuccess: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:       \"rejects_invalid_token\",\n+\t\t\ttoken:      \"invalid\",\n+\t\t\twantAuthOK: false,\n+\t\t\tsetupServer: func(s *Server) {\n+\t\t\t\ts.SetAllowRootLogin(true)\n+\t\t\t},\n+\t\t\ttestOperation: func(t *testing.T, conn *cryptossh.Client, _ string) error {\n+\t\t\t\tsession, err := conn.NewSession()\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\tdefer session.Close()\n+\n+\t\t\t\toutput, err := session.CombinedOutput(\"echo test\")\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Logf(\"Command output: %s\", string(output))\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\t\t\t\treturn nil\n+\t\t\t},\n+\t\t\twantOpSuccess: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:       \"blocks_shell_without_jwt\",\n+\t\t\ttoken:      \"\",\n+\t\t\twantAuthOK: false,\n+\t\t\tsetupServer: func(s *Server) {\n+\t\t\t\ts.SetAllowRootLogin(true)\n+\t\t\t},\n+\t\t\ttestOperation: func(t *testing.T, conn *cryptossh.Client, _ string) error {\n+\t\t\t\tsession, err := conn.NewSession()\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\tdefer session.Close()\n+\n+\t\t\t\toutput, err := session.CombinedOutput(\"echo test\")\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Logf(\"Command output: %s\", string(output))\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\t\t\t\treturn nil\n+\t\t\t},\n+\t\t\twantOpSuccess: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:       \"blocks_command_without_jwt\",\n+\t\t\ttoken:      \"\",\n+\t\t\twantAuthOK: false,\n+\t\t\tsetupServer: func(s *Server) {\n+\t\t\t\ts.SetAllowRootLogin(true)\n+\t\t\t},\n+\t\t\ttestOperation: func(t *testing.T, conn *cryptossh.Client, _ string) error {\n+\t\t\t\tsession, err := conn.NewSession()\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\tdefer session.Close()\n+\n+\t\t\t\toutput, err := session.CombinedOutput(\"ls\")\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Logf(\"Command output: %s\", string(output))\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\t\t\t\treturn nil\n+\t\t\t},\n+\t\t\twantOpSuccess: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:       \"allows_sftp_with_jwt\",\n+\t\t\ttoken:      \"valid\",\n+\t\t\twantAuthOK: true,\n+\t\t\tsetupServer: func(s *Server) {\n+\t\t\t\ts.SetAllowRootLogin(true)\n+\t\t\t\ts.SetAllowSFTP(true)\n+\t\t\t},\n+\t\t\ttestOperation: func(t *testing.T, conn *cryptossh.Client, _ string) error {\n+\t\t\t\tsession, err := conn.NewSession()\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\tdefer session.Close()\n+\n+\t\t\t\tsession.Stdout = io.Discard\n+\t\t\t\tsession.Stderr = io.Discard\n+\t\t\t\treturn session.RequestSubsystem(\"sftp\")\n+\t\t\t},\n+\t\t\twantOpSuccess: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:       \"blocks_sftp_without_jwt\",\n+\t\t\ttoken:      \"\",\n+\t\t\twantAuthOK: false,\n+\t\t\tsetupServer: func(s *Server) {\n+\t\t\t\ts.SetAllowRootLogin(true)\n+\t\t\t\ts.SetAllowSFTP(true)\n+\t\t\t},\n+\t\t\ttestOperation: func(t *testing.T, conn *cryptossh.Client, _ string) error {\n+\t\t\t\tsession, err := conn.NewSession()\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t\tdefer session.Close()\n+\n+\t\t\t\tsession.Stdout = io.Discard\n+\t\t\t\tsession.Stderr = io.Discard\n+\t\t\t\terr = session.RequestSubsystem(\"sftp\")\n+\t\t\t\tif err == nil {\n+\t\t\t\t\terr = session.Wait()\n+\t\t\t\t}\n+\t\t\t\treturn err\n+\t\t\t},\n+\t\t\twantOpSuccess: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:       \"allows_port_forward_with_jwt\",\n+\t\t\ttoken:      \"valid\",\n+\t\t\twantAuthOK: true,\n+\t\t\tsetupServer: func(s *Server) {\n+\t\t\t\ts.SetAllowRootLogin(true)\n+\t\t\t\ts.SetAllowRemotePortForwarding(true)\n+\t\t\t},\n+\t\t\ttestOperation: func(t *testing.T, conn *cryptossh.Client, _ string) error {\n+\t\t\t\tln, err := conn.Listen(\"tcp\", \"127.0.0.1:0\")\n+\t\t\t\tif ln != nil {\n+\t\t\t\t\tdefer ln.Close()\n+\t\t\t\t}\n+\t\t\t\treturn err\n+\t\t\t},\n+\t\t\twantOpSuccess: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:       \"blocks_port_forward_without_jwt\",\n+\t\t\ttoken:      \"\",\n+\t\t\twantAuthOK: false,\n+\t\t\tsetupServer: func(s *Server) {\n+\t\t\t\ts.SetAllowRootLogin(true)\n+\t\t\t\ts.SetAllowLocalPortForwarding(true)\n+\t\t\t},\n+\t\t\ttestOperation: func(t *testing.T, conn *cryptossh.Client, _ string) error {\n+\t\t\t\tln, err := conn.Listen(\"tcp\", \"127.0.0.1:0\")\n+\t\t\t\tif ln != nil {\n+\t\t\t\t\tdefer ln.Close()\n+\t\t\t\t}\n+\t\t\t\treturn err\n+\t\t\t},\n+\t\t\twantOpSuccess: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\t// TODO: Skip port forwarding tests on Windows - user switching not supported\n+\t\t\t// These features are tested on Linux/Unix platforms\n+\t\t\tif runtime.GOOS == \"windows\" &&\n+\t\t\t\t(tc.name == \"allows_port_forward_with_jwt\" ||\n+\t\t\t\t\ttc.name == \"blocks_port_forward_without_jwt\") {\n+\t\t\t\tt.Skip(\"Skipping port forwarding test on Windows - covered by Linux tests\")\n+\t\t\t}\n+\n+\t\t\tjwtConfig := &JWTConfig{\n+\t\t\t\tIssuer:       issuer,\n+\t\t\t\tAudience:     audience,\n+\t\t\t\tKeysLocation: jwksURL,\n+\t\t\t}\n+\t\t\tserverConfig := &Config{\n+\t\t\t\tHostKeyPEM: hostKey,\n+\t\t\t\tJWT:        jwtConfig,\n+\t\t\t}\n+\t\t\tserver := New(serverConfig)\n+\t\t\tif tc.setupServer != nil {\n+\t\t\t\ttc.setupServer(server)\n+\t\t\t}\n+\n+\t\t\tserverAddr := StartTestServer(t, server)\n+\t\t\tdefer require.NoError(t, server.Stop())\n+\n+\t\t\thost, portStr, err := net.SplitHostPort(serverAddr)\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\tvar authMethods []cryptossh.AuthMethod\n+\t\t\tif tc.token == \"valid\" {\n+\t\t\t\ttoken := generateValidJWT(t, privateKey, issuer, audience)\n+\t\t\t\tauthMethods = []cryptossh.AuthMethod{\n+\t\t\t\t\tcryptossh.Password(token),\n+\t\t\t\t}\n+\t\t\t} else if tc.token == \"invalid\" {\n+\t\t\t\tinvalidToken := \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.invalid\"\n+\t\t\t\tauthMethods = []cryptossh.AuthMethod{\n+\t\t\t\t\tcryptossh.Password(invalidToken),\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tconfig := &cryptossh.ClientConfig{\n+\t\t\t\tUser:            testutil.GetTestUsername(t),\n+\t\t\t\tAuth:            authMethods,\n+\t\t\t\tHostKeyCallback: cryptossh.InsecureIgnoreHostKey(),\n+\t\t\t\tTimeout:         2 * time.Second,\n+\t\t\t}\n+\n+\t\t\tconn, err := cryptossh.Dial(\"tcp\", net.JoinHostPort(host, portStr), config)\n+\t\t\tif tc.wantAuthOK {\n+\t\t\t\trequire.NoError(t, err, \"JWT authentication should succeed\")\n+\t\t\t} else if err != nil {\n+\t\t\t\tt.Logf(\"Connection failed as expected: %v\", err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif conn != nil {\n+\t\t\t\tdefer func() {\n+\t\t\t\t\tif err := conn.Close(); err != nil {\n+\t\t\t\t\t\tt.Logf(\"close connection: %v\", err)\n+\t\t\t\t\t}\n+\t\t\t\t}()\n+\t\t\t}\n+\n+\t\t\terr = tc.testOperation(t, conn, serverAddr)\n+\t\t\tif tc.wantOpSuccess {\n+\t\t\t\trequire.NoError(t, err, \"Operation should succeed\")\n+\t\t\t} else {\n+\t\t\t\tassert.Error(t, err, \"Operation should fail\")\n+\t\t\t}\n+\t\t})\n+\t}\n+}\ndiff --git a/client/ssh/server/server_config_test.go b/client/ssh/server/server_config_test.go\nnew file mode 100644\nindex 00000000000..24e455025be\n--- /dev/null\n+++ b/client/ssh/server/server_config_test.go\n@@ -0,0 +1,394 @@\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"net\"\n+\t\"os/user\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\n+\t\"github.com/netbirdio/netbird/client/ssh\"\n+\tsshclient \"github.com/netbirdio/netbird/client/ssh/client\"\n+)\n+\n+func TestServer_RootLoginRestriction(t *testing.T) {\n+\t// Generate host key for server\n+\thostKey, err := ssh.GeneratePrivateKey(ssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\ttests := []struct {\n+\t\tname        string\n+\t\tallowRoot   bool\n+\t\tusername    string\n+\t\texpectError bool\n+\t\tdescription string\n+\t}{\n+\t\t{\n+\t\t\tname:        \"root login allowed\",\n+\t\t\tallowRoot:   true,\n+\t\t\tusername:    \"root\",\n+\t\t\texpectError: false,\n+\t\t\tdescription: \"Root login should succeed when allowed\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"root login denied\",\n+\t\t\tallowRoot:   false,\n+\t\t\tusername:    \"root\",\n+\t\t\texpectError: true,\n+\t\t\tdescription: \"Root login should fail when disabled\",\n+\t\t},\n+\t\t{\n+\t\t\tname:        \"regular user login always allowed\",\n+\t\t\tallowRoot:   false,\n+\t\t\tusername:    \"testuser\",\n+\t\t\texpectError: false,\n+\t\t\tdescription: \"Regular user login should work regardless of root setting\",\n+\t\t},\n+\t}\n+\n+\t// Add Windows Administrator tests if on Windows\n+\tif runtime.GOOS == \"windows\" {\n+\t\ttests = append(tests, []struct {\n+\t\t\tname        string\n+\t\t\tallowRoot   bool\n+\t\t\tusername    string\n+\t\t\texpectError bool\n+\t\t\tdescription string\n+\t\t}{\n+\t\t\t{\n+\t\t\t\tname:        \"Administrator login allowed\",\n+\t\t\t\tallowRoot:   true,\n+\t\t\t\tusername:    \"Administrator\",\n+\t\t\t\texpectError: false,\n+\t\t\t\tdescription: \"Administrator login should succeed when allowed\",\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tname:        \"Administrator login denied\",\n+\t\t\t\tallowRoot:   false,\n+\t\t\t\tusername:    \"Administrator\",\n+\t\t\t\texpectError: true,\n+\t\t\t\tdescription: \"Administrator login should fail when disabled\",\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tname:        \"administrator login denied (lowercase)\",\n+\t\t\t\tallowRoot:   false,\n+\t\t\t\tusername:    \"administrator\",\n+\t\t\t\texpectError: true,\n+\t\t\t\tdescription: \"administrator login should fail when disabled (case insensitive)\",\n+\t\t\t},\n+\t\t}...)\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Mock privileged environment to test root access controls\n+\t\t\t// Set up mock users based on platform\n+\t\t\tmockUsers := map[string]*user.User{\n+\t\t\t\t\"root\":     createTestUser(\"root\", \"0\", \"0\", \"/root\"),\n+\t\t\t\t\"testuser\": createTestUser(\"testuser\", \"1000\", \"1000\", \"/home/testuser\"),\n+\t\t\t}\n+\n+\t\t\t// Add Windows-specific users for Administrator tests\n+\t\t\tif runtime.GOOS == \"windows\" {\n+\t\t\t\tmockUsers[\"Administrator\"] = createTestUser(\"Administrator\", \"500\", \"544\", \"C:\\\\Users\\\\Administrator\")\n+\t\t\t\tmockUsers[\"administrator\"] = createTestUser(\"administrator\", \"500\", \"544\", \"C:\\\\Users\\\\administrator\")\n+\t\t\t}\n+\n+\t\t\tcleanup := setupTestDependencies(\n+\t\t\t\tcreateTestUser(\"root\", \"0\", \"0\", \"/root\"), // Running as root\n+\t\t\t\tnil,\n+\t\t\t\truntime.GOOS,\n+\t\t\t\t0, // euid 0 (root)\n+\t\t\t\tmockUsers,\n+\t\t\t\tnil,\n+\t\t\t)\n+\t\t\tdefer cleanup()\n+\n+\t\t\t// Create server with specific configuration\n+\t\t\tserverConfig := &Config{\n+\t\t\t\tHostKeyPEM: hostKey,\n+\t\t\t\tJWT:        nil,\n+\t\t\t}\n+\t\t\tserver := New(serverConfig)\n+\t\t\tserver.SetAllowRootLogin(tt.allowRoot)\n+\n+\t\t\t// Test the userNameLookup method directly\n+\t\t\tuser, err := server.userNameLookup(tt.username)\n+\n+\t\t\tif tt.expectError {\n+\t\t\t\tassert.Error(t, err, tt.description)\n+\t\t\t\tif tt.username == \"root\" || strings.ToLower(tt.username) == \"administrator\" {\n+\t\t\t\t\t// Check for appropriate error message based on platform capabilities\n+\t\t\t\t\terrorMsg := err.Error()\n+\t\t\t\t\t// Either privileged user restriction OR user switching limitation\n+\t\t\t\t\thasPrivilegedError := strings.Contains(errorMsg, \"privileged user\")\n+\t\t\t\t\thasSwitchingError := strings.Contains(errorMsg, \"cannot switch\") || strings.Contains(errorMsg, \"user switching not supported\")\n+\t\t\t\t\tassert.True(t, hasPrivilegedError || hasSwitchingError,\n+\t\t\t\t\t\t\"Expected privileged user or user switching error, got: %s\", errorMsg)\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif tt.username == \"root\" || strings.ToLower(tt.username) == \"administrator\" {\n+\t\t\t\t\t// For privileged users, we expect either success or a different error\n+\t\t\t\t\t// (like user not found), but not the \"login disabled\" error\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\tassert.NotContains(t, err.Error(), \"privileged user login is disabled\")\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\t// For regular users, lookup should generally succeed or fall back gracefully\n+\t\t\t\t\t// Note: may return current user as fallback\n+\t\t\t\t\tassert.NotNil(t, user)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestServer_PortForwardingRestriction(t *testing.T) {\n+\t// Test that the port forwarding callbacks properly respect configuration flags\n+\t// This is a unit test of the callback logic, not a full integration test\n+\n+\t// Generate host key for server\n+\thostKey, err := ssh.GeneratePrivateKey(ssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\ttests := []struct {\n+\t\tname                  string\n+\t\tallowLocalForwarding  bool\n+\t\tallowRemoteForwarding bool\n+\t\tdescription           string\n+\t}{\n+\t\t{\n+\t\t\tname:                  \"all forwarding allowed\",\n+\t\t\tallowLocalForwarding:  true,\n+\t\t\tallowRemoteForwarding: true,\n+\t\t\tdescription:           \"Both local and remote forwarding should be allowed\",\n+\t\t},\n+\t\t{\n+\t\t\tname:                  \"local forwarding disabled\",\n+\t\t\tallowLocalForwarding:  false,\n+\t\t\tallowRemoteForwarding: true,\n+\t\t\tdescription:           \"Local forwarding should be denied when disabled\",\n+\t\t},\n+\t\t{\n+\t\t\tname:                  \"remote forwarding disabled\",\n+\t\t\tallowLocalForwarding:  true,\n+\t\t\tallowRemoteForwarding: false,\n+\t\t\tdescription:           \"Remote forwarding should be denied when disabled\",\n+\t\t},\n+\t\t{\n+\t\t\tname:                  \"all forwarding disabled\",\n+\t\t\tallowLocalForwarding:  false,\n+\t\t\tallowRemoteForwarding: false,\n+\t\t\tdescription:           \"Both forwarding types should be denied when disabled\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Create server with specific configuration\n+\t\t\tserverConfig := &Config{\n+\t\t\t\tHostKeyPEM: hostKey,\n+\t\t\t\tJWT:        nil,\n+\t\t\t}\n+\t\t\tserver := New(serverConfig)\n+\t\t\tserver.SetAllowLocalPortForwarding(tt.allowLocalForwarding)\n+\t\t\tserver.SetAllowRemotePortForwarding(tt.allowRemoteForwarding)\n+\n+\t\t\t// We need to access the internal configuration to simulate the callback tests\n+\t\t\t// Since the callbacks are created inside the Start method, we'll test the logic directly\n+\n+\t\t\t// Test the configuration values are set correctly\n+\t\t\tserver.mu.RLock()\n+\t\t\tallowLocal := server.allowLocalPortForwarding\n+\t\t\tallowRemote := server.allowRemotePortForwarding\n+\t\t\tserver.mu.RUnlock()\n+\n+\t\t\tassert.Equal(t, tt.allowLocalForwarding, allowLocal, \"Local forwarding configuration should be set correctly\")\n+\t\t\tassert.Equal(t, tt.allowRemoteForwarding, allowRemote, \"Remote forwarding configuration should be set correctly\")\n+\n+\t\t\t// Simulate the callback logic\n+\t\t\tlocalResult := allowLocal   // This would be the callback return value\n+\t\t\tremoteResult := allowRemote // This would be the callback return value\n+\n+\t\t\tassert.Equal(t, tt.allowLocalForwarding, localResult,\n+\t\t\t\t\"Local port forwarding callback should return correct value\")\n+\t\t\tassert.Equal(t, tt.allowRemoteForwarding, remoteResult,\n+\t\t\t\t\"Remote port forwarding callback should return correct value\")\n+\t\t})\n+\t}\n+}\n+\n+func TestServer_PortConflictHandling(t *testing.T) {\n+\t// Test that multiple sessions requesting the same local port are handled naturally by the OS\n+\t// Get current user for SSH connection\n+\tcurrentUser, err := user.Current()\n+\trequire.NoError(t, err, \"Should be able to get current user\")\n+\n+\t// Generate host key for server\n+\thostKey, err := ssh.GeneratePrivateKey(ssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\t// Create server\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := New(serverConfig)\n+\tserver.SetAllowRootLogin(true)\n+\n+\tserverAddr := StartTestServer(t, server)\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\t// Get a free port for testing\n+\tln, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n+\trequire.NoError(t, err)\n+\ttestPort := ln.Addr().(*net.TCPAddr).Port\n+\terr = ln.Close()\n+\trequire.NoError(t, err)\n+\n+\t// Connect first client\n+\tctx1, cancel1 := context.WithTimeout(context.Background(), 5*time.Second)\n+\tdefer cancel1()\n+\n+\tclient1, err := sshclient.Dial(ctx1, serverAddr, currentUser.Username, sshclient.DialOptions{\n+\t\tInsecureSkipVerify: true,\n+\t})\n+\trequire.NoError(t, err)\n+\tdefer func() {\n+\t\terr := client1.Close()\n+\t\tassert.NoError(t, err)\n+\t}()\n+\n+\t// Connect second client\n+\tctx2, cancel2 := context.WithTimeout(context.Background(), 5*time.Second)\n+\tdefer cancel2()\n+\n+\tclient2, err := sshclient.Dial(ctx2, serverAddr, currentUser.Username, sshclient.DialOptions{\n+\t\tInsecureSkipVerify: true,\n+\t})\n+\trequire.NoError(t, err)\n+\tdefer func() {\n+\t\terr := client2.Close()\n+\t\tassert.NoError(t, err)\n+\t}()\n+\n+\t// First client binds to the test port\n+\tlocalAddr1 := fmt.Sprintf(\"127.0.0.1:%d\", testPort)\n+\tremoteAddr := \"127.0.0.1:80\"\n+\n+\t// Start first client's port forwarding\n+\tdone1 := make(chan error, 1)\n+\tgo func() {\n+\t\t// This should succeed and hold the port\n+\t\terr := client1.LocalPortForward(ctx1, localAddr1, remoteAddr)\n+\t\tdone1 <- err\n+\t}()\n+\n+\t// Give first client time to bind\n+\ttime.Sleep(200 * time.Millisecond)\n+\n+\t// Second client tries to bind to same port\n+\tlocalAddr2 := fmt.Sprintf(\"127.0.0.1:%d\", testPort)\n+\n+\tshortCtx, shortCancel := context.WithTimeout(context.Background(), 1*time.Second)\n+\tdefer shortCancel()\n+\n+\terr = client2.LocalPortForward(shortCtx, localAddr2, remoteAddr)\n+\t// Second client should fail due to \"address already in use\"\n+\tassert.Error(t, err, \"Second client should fail to bind to same port\")\n+\tif err != nil {\n+\t\t// The error should indicate the address is already in use\n+\t\terrMsg := strings.ToLower(err.Error())\n+\t\tif runtime.GOOS == \"windows\" {\n+\t\t\tassert.Contains(t, errMsg, \"only one usage of each socket address\",\n+\t\t\t\t\"Error should indicate port conflict\")\n+\t\t} else {\n+\t\t\tassert.Contains(t, errMsg, \"address already in use\",\n+\t\t\t\t\"Error should indicate port conflict\")\n+\t\t}\n+\t}\n+\n+\t// Cancel first client's context and wait for it to finish\n+\tcancel1()\n+\tselect {\n+\tcase err1 := <-done1:\n+\t\t// Should get context cancelled or deadline exceeded\n+\t\tassert.Error(t, err1, \"First client should exit when context cancelled\")\n+\tcase <-time.After(2 * time.Second):\n+\t\tt.Error(\"First client did not exit within timeout\")\n+\t}\n+}\n+\n+func TestServer_IsPrivilegedUser(t *testing.T) {\n+\n+\ttests := []struct {\n+\t\tusername    string\n+\t\texpected    bool\n+\t\tdescription string\n+\t}{\n+\t\t{\n+\t\t\tusername:    \"root\",\n+\t\t\texpected:    true,\n+\t\t\tdescription: \"root should be considered privileged\",\n+\t\t},\n+\t\t{\n+\t\t\tusername:    \"regular\",\n+\t\t\texpected:    false,\n+\t\t\tdescription: \"regular user should not be privileged\",\n+\t\t},\n+\t\t{\n+\t\t\tusername:    \"\",\n+\t\t\texpected:    false,\n+\t\t\tdescription: \"empty username should not be privileged\",\n+\t\t},\n+\t}\n+\n+\t// Add Windows-specific tests\n+\tif runtime.GOOS == \"windows\" {\n+\t\ttests = append(tests, []struct {\n+\t\t\tusername    string\n+\t\t\texpected    bool\n+\t\t\tdescription string\n+\t\t}{\n+\t\t\t{\n+\t\t\t\tusername:    \"Administrator\",\n+\t\t\t\texpected:    true,\n+\t\t\t\tdescription: \"Administrator should be considered privileged on Windows\",\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tusername:    \"administrator\",\n+\t\t\t\texpected:    true,\n+\t\t\t\tdescription: \"administrator should be considered privileged on Windows (case insensitive)\",\n+\t\t\t},\n+\t\t}...)\n+\t} else {\n+\t\t// On non-Windows systems, Administrator should not be privileged\n+\t\ttests = append(tests, []struct {\n+\t\t\tusername    string\n+\t\t\texpected    bool\n+\t\t\tdescription string\n+\t\t}{\n+\t\t\t{\n+\t\t\t\tusername:    \"Administrator\",\n+\t\t\t\texpected:    false,\n+\t\t\t\tdescription: \"Administrator should not be privileged on non-Windows systems\",\n+\t\t\t},\n+\t\t}...)\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.description, func(t *testing.T) {\n+\t\t\tresult := isPrivilegedUsername(tt.username)\n+\t\t\tassert.Equal(t, tt.expected, result, tt.description)\n+\t\t})\n+\t}\n+}\ndiff --git a/client/ssh/server/server_test.go b/client/ssh/server/server_test.go\nnew file mode 100644\nindex 00000000000..6610685393d\n--- /dev/null\n+++ b/client/ssh/server/server_test.go\n@@ -0,0 +1,441 @@\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"net\"\n+\t\"net/netip\"\n+\t\"os/user\"\n+\t\"runtime\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\tcryptossh \"golang.org/x/crypto/ssh\"\n+\n+\tnbssh \"github.com/netbirdio/netbird/client/ssh\"\n+)\n+\n+func TestServer_StartStop(t *testing.T) {\n+\tkey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: key,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := New(serverConfig)\n+\n+\terr = server.Stop()\n+\tassert.NoError(t, err)\n+}\n+\n+func TestSSHServerIntegration(t *testing.T) {\n+\t// Generate host key for server\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\t// Generate client key pair\n+\tclientPrivKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\t// Create server with random port\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := New(serverConfig)\n+\n+\t// Start server in background\n+\tserverAddr := \"127.0.0.1:0\"\n+\tstarted := make(chan string, 1)\n+\terrChan := make(chan error, 1)\n+\n+\tgo func() {\n+\t\t// Get a free port\n+\t\tln, err := net.Listen(\"tcp\", serverAddr)\n+\t\tif err != nil {\n+\t\t\terrChan <- err\n+\t\t\treturn\n+\t\t}\n+\t\tactualAddr := ln.Addr().String()\n+\t\tif err := ln.Close(); err != nil {\n+\t\t\terrChan <- fmt.Errorf(\"close temp listener: %w\", err)\n+\t\t\treturn\n+\t\t}\n+\n+\t\taddrPort, _ := netip.ParseAddrPort(actualAddr)\n+\t\tif err := server.Start(context.Background(), addrPort); err != nil {\n+\t\t\terrChan <- err\n+\t\t\treturn\n+\t\t}\n+\t\tstarted <- actualAddr\n+\t}()\n+\n+\tselect {\n+\tcase actualAddr := <-started:\n+\t\tserverAddr = actualAddr\n+\tcase err := <-errChan:\n+\t\tt.Fatalf(\"Server failed to start: %v\", err)\n+\tcase <-time.After(5 * time.Second):\n+\t\tt.Fatal(\"Server start timeout\")\n+\t}\n+\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\t// Parse client private key\n+\tsigner, err := cryptossh.ParsePrivateKey(clientPrivKey)\n+\trequire.NoError(t, err)\n+\n+\t// Parse server host key for verification\n+\thostPrivParsed, err := cryptossh.ParsePrivateKey(hostKey)\n+\trequire.NoError(t, err)\n+\thostPubKey := hostPrivParsed.PublicKey()\n+\n+\t// Get current user for SSH connection\n+\tcurrentUser, err := user.Current()\n+\trequire.NoError(t, err, \"Should be able to get current user for test\")\n+\n+\t// Create SSH client config\n+\tconfig := &cryptossh.ClientConfig{\n+\t\tUser: currentUser.Username,\n+\t\tAuth: []cryptossh.AuthMethod{\n+\t\t\tcryptossh.PublicKeys(signer),\n+\t\t},\n+\t\tHostKeyCallback: cryptossh.FixedHostKey(hostPubKey),\n+\t\tTimeout:         3 * time.Second,\n+\t}\n+\n+\t// Connect to SSH server\n+\tclient, err := cryptossh.Dial(\"tcp\", serverAddr, config)\n+\trequire.NoError(t, err)\n+\tdefer func() {\n+\t\tif err := client.Close(); err != nil {\n+\t\t\tt.Logf(\"close client: %v\", err)\n+\t\t}\n+\t}()\n+\n+\t// Test creating a session\n+\tsession, err := client.NewSession()\n+\trequire.NoError(t, err)\n+\tdefer func() {\n+\t\tif err := session.Close(); err != nil {\n+\t\t\tt.Logf(\"close session: %v\", err)\n+\t\t}\n+\t}()\n+\n+\t// Note: Since we don't have a real shell environment in tests,\n+\t// we can't test actual command execution, but we can verify\n+\t// the connection and authentication work\n+\tt.Log(\"SSH connection and authentication successful\")\n+}\n+\n+func TestSSHServerMultipleConnections(t *testing.T) {\n+\t// Generate host key for server\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\t// Generate client key pair\n+\tclientPrivKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\t// Create server\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := New(serverConfig)\n+\n+\t// Start server\n+\tserverAddr := \"127.0.0.1:0\"\n+\tstarted := make(chan string, 1)\n+\terrChan := make(chan error, 1)\n+\n+\tgo func() {\n+\t\tln, err := net.Listen(\"tcp\", serverAddr)\n+\t\tif err != nil {\n+\t\t\terrChan <- err\n+\t\t\treturn\n+\t\t}\n+\t\tactualAddr := ln.Addr().String()\n+\t\tif err := ln.Close(); err != nil {\n+\t\t\terrChan <- fmt.Errorf(\"close temp listener: %w\", err)\n+\t\t\treturn\n+\t\t}\n+\n+\t\taddrPort, _ := netip.ParseAddrPort(actualAddr)\n+\t\tif err := server.Start(context.Background(), addrPort); err != nil {\n+\t\t\terrChan <- err\n+\t\t\treturn\n+\t\t}\n+\t\tstarted <- actualAddr\n+\t}()\n+\n+\tselect {\n+\tcase actualAddr := <-started:\n+\t\tserverAddr = actualAddr\n+\tcase err := <-errChan:\n+\t\tt.Fatalf(\"Server failed to start: %v\", err)\n+\tcase <-time.After(5 * time.Second):\n+\t\tt.Fatal(\"Server start timeout\")\n+\t}\n+\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\t// Parse client private key\n+\tsigner, err := cryptossh.ParsePrivateKey(clientPrivKey)\n+\trequire.NoError(t, err)\n+\n+\t// Parse server host key\n+\thostPrivParsed, err := cryptossh.ParsePrivateKey(hostKey)\n+\trequire.NoError(t, err)\n+\thostPubKey := hostPrivParsed.PublicKey()\n+\n+\t// Get current user for SSH connection\n+\tcurrentUser, err := user.Current()\n+\trequire.NoError(t, err, \"Should be able to get current user for test\")\n+\n+\tconfig := &cryptossh.ClientConfig{\n+\t\tUser: currentUser.Username,\n+\t\tAuth: []cryptossh.AuthMethod{\n+\t\t\tcryptossh.PublicKeys(signer),\n+\t\t},\n+\t\tHostKeyCallback: cryptossh.FixedHostKey(hostPubKey),\n+\t\tTimeout:         3 * time.Second,\n+\t}\n+\n+\t// Test multiple concurrent connections\n+\tconst numConnections = 5\n+\tresults := make(chan error, numConnections)\n+\n+\tfor i := 0; i < numConnections; i++ {\n+\t\tgo func(id int) {\n+\t\t\tclient, err := cryptossh.Dial(\"tcp\", serverAddr, config)\n+\t\t\tif err != nil {\n+\t\t\t\tresults <- fmt.Errorf(\"connection %d failed: %w\", id, err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tdefer func() {\n+\t\t\t\t_ = client.Close() // Ignore error in test goroutine\n+\t\t\t}()\n+\n+\t\t\tsession, err := client.NewSession()\n+\t\t\tif err != nil {\n+\t\t\t\tresults <- fmt.Errorf(\"session %d failed: %w\", id, err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tdefer func() {\n+\t\t\t\t_ = session.Close() // Ignore error in test goroutine\n+\t\t\t}()\n+\n+\t\t\tresults <- nil\n+\t\t}(i)\n+\t}\n+\n+\t// Wait for all connections to complete\n+\tfor i := 0; i < numConnections; i++ {\n+\t\tselect {\n+\t\tcase err := <-results:\n+\t\t\tassert.NoError(t, err)\n+\t\tcase <-time.After(10 * time.Second):\n+\t\t\tt.Fatalf(\"Connection %d timed out\", i)\n+\t\t}\n+\t}\n+}\n+\n+func TestSSHServerNoAuthMode(t *testing.T) {\n+\t// Generate host key for server\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\t// Create server\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := New(serverConfig)\n+\n+\t// Start server\n+\tserverAddr := \"127.0.0.1:0\"\n+\tstarted := make(chan string, 1)\n+\terrChan := make(chan error, 1)\n+\n+\tgo func() {\n+\t\tln, err := net.Listen(\"tcp\", serverAddr)\n+\t\tif err != nil {\n+\t\t\terrChan <- err\n+\t\t\treturn\n+\t\t}\n+\t\tactualAddr := ln.Addr().String()\n+\t\tif err := ln.Close(); err != nil {\n+\t\t\terrChan <- fmt.Errorf(\"close temp listener: %w\", err)\n+\t\t\treturn\n+\t\t}\n+\n+\t\taddrPort, _ := netip.ParseAddrPort(actualAddr)\n+\t\tif err := server.Start(context.Background(), addrPort); err != nil {\n+\t\t\terrChan <- err\n+\t\t\treturn\n+\t\t}\n+\t\tstarted <- actualAddr\n+\t}()\n+\n+\tselect {\n+\tcase actualAddr := <-started:\n+\t\tserverAddr = actualAddr\n+\tcase err := <-errChan:\n+\t\tt.Fatalf(\"Server failed to start: %v\", err)\n+\tcase <-time.After(5 * time.Second):\n+\t\tt.Fatal(\"Server start timeout\")\n+\t}\n+\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\t// Generate a client private key for SSH protocol (server doesn't check it)\n+\tclientPrivKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\tclientSigner, err := cryptossh.ParsePrivateKey(clientPrivKey)\n+\trequire.NoError(t, err)\n+\n+\t// Parse server host key\n+\thostPrivParsed, err := cryptossh.ParsePrivateKey(hostKey)\n+\trequire.NoError(t, err)\n+\thostPubKey := hostPrivParsed.PublicKey()\n+\n+\t// Get current user for SSH connection\n+\tcurrentUser, err := user.Current()\n+\trequire.NoError(t, err, \"Should be able to get current user for test\")\n+\n+\t// Try to connect with client key\n+\tconfig := &cryptossh.ClientConfig{\n+\t\tUser: currentUser.Username,\n+\t\tAuth: []cryptossh.AuthMethod{\n+\t\t\tcryptossh.PublicKeys(clientSigner),\n+\t\t},\n+\t\tHostKeyCallback: cryptossh.FixedHostKey(hostPubKey),\n+\t\tTimeout:         3 * time.Second,\n+\t}\n+\n+\t// This should succeed in no-auth mode (server doesn't verify keys)\n+\tconn, err := cryptossh.Dial(\"tcp\", serverAddr, config)\n+\tassert.NoError(t, err, \"Connection should succeed in no-auth mode\")\n+\tif conn != nil {\n+\t\tassert.NoError(t, conn.Close())\n+\t}\n+}\n+\n+func TestSSHServerStartStopCycle(t *testing.T) {\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := New(serverConfig)\n+\tserverAddr := \"127.0.0.1:0\"\n+\n+\t// Test multiple start/stop cycles\n+\tfor i := 0; i < 3; i++ {\n+\t\tt.Logf(\"Start/stop cycle %d\", i+1)\n+\n+\t\tstarted := make(chan string, 1)\n+\t\terrChan := make(chan error, 1)\n+\n+\t\tgo func() {\n+\t\t\tln, err := net.Listen(\"tcp\", serverAddr)\n+\t\t\tif err != nil {\n+\t\t\t\terrChan <- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tactualAddr := ln.Addr().String()\n+\t\t\tif err := ln.Close(); err != nil {\n+\t\t\t\terrChan <- fmt.Errorf(\"close temp listener: %w\", err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\taddrPort, _ := netip.ParseAddrPort(actualAddr)\n+\t\t\tif err := server.Start(context.Background(), addrPort); err != nil {\n+\t\t\t\terrChan <- err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tstarted <- actualAddr\n+\t\t}()\n+\n+\t\tselect {\n+\t\tcase <-started:\n+\t\tcase err := <-errChan:\n+\t\t\tt.Fatalf(\"Cycle %d: Server failed to start: %v\", i+1, err)\n+\t\tcase <-time.After(5 * time.Second):\n+\t\t\tt.Fatalf(\"Cycle %d: Server start timeout\", i+1)\n+\t\t}\n+\n+\t\terr = server.Stop()\n+\t\trequire.NoError(t, err, \"Cycle %d: Stop should succeed\", i+1)\n+\t}\n+}\n+\n+func TestSSHServer_WindowsShellHandling(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping Windows shell test in short mode\")\n+\t}\n+\n+\tserver := &Server{}\n+\n+\tif runtime.GOOS == \"windows\" {\n+\t\t// Test Windows cmd.exe shell behavior\n+\t\targs := server.getShellCommandArgs(\"cmd.exe\", \"echo test\")\n+\t\tassert.Equal(t, \"cmd.exe\", args[0])\n+\t\tassert.Equal(t, \"-Command\", args[1])\n+\t\tassert.Equal(t, \"echo test\", args[2])\n+\n+\t\t// Test PowerShell behavior\n+\t\targs = server.getShellCommandArgs(\"powershell.exe\", \"echo test\")\n+\t\tassert.Equal(t, \"powershell.exe\", args[0])\n+\t\tassert.Equal(t, \"-Command\", args[1])\n+\t\tassert.Equal(t, \"echo test\", args[2])\n+\t} else {\n+\t\t// Test Unix shell behavior\n+\t\targs := server.getShellCommandArgs(\"/bin/sh\", \"echo test\")\n+\t\tassert.Equal(t, \"/bin/sh\", args[0])\n+\t\tassert.Equal(t, \"-l\", args[1])\n+\t\tassert.Equal(t, \"-c\", args[2])\n+\t\tassert.Equal(t, \"echo test\", args[3])\n+\t}\n+}\n+\n+func TestSSHServer_PortForwardingConfiguration(t *testing.T) {\n+\thostKey, err := nbssh.GeneratePrivateKey(nbssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\tserverConfig1 := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver1 := New(serverConfig1)\n+\n+\tserverConfig2 := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver2 := New(serverConfig2)\n+\n+\tassert.False(t, server1.allowLocalPortForwarding, \"Local port forwarding should be disabled by default for security\")\n+\tassert.False(t, server1.allowRemotePortForwarding, \"Remote port forwarding should be disabled by default for security\")\n+\n+\tserver2.SetAllowLocalPortForwarding(true)\n+\tserver2.SetAllowRemotePortForwarding(true)\n+\n+\tassert.True(t, server2.allowLocalPortForwarding, \"Local port forwarding should be enabled when explicitly set\")\n+\tassert.True(t, server2.allowRemotePortForwarding, \"Remote port forwarding should be enabled when explicitly set\")\n+}\ndiff --git a/client/ssh/server/sftp_test.go b/client/ssh/server/sftp_test.go\nnew file mode 100644\nindex 00000000000..32a3643e487\n--- /dev/null\n+++ b/client/ssh/server/sftp_test.go\n@@ -0,0 +1,228 @@\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"net\"\n+\t\"net/netip\"\n+\t\"os\"\n+\t\"os/user\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/pkg/sftp\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\tcryptossh \"golang.org/x/crypto/ssh\"\n+\n+\t\"github.com/netbirdio/netbird/client/ssh\"\n+)\n+\n+func TestSSHServer_SFTPSubsystem(t *testing.T) {\n+\t// Skip SFTP test when running as root due to protocol issues in some environments\n+\tif os.Geteuid() == 0 {\n+\t\tt.Skip(\"Skipping SFTP test when running as root - may have protocol compatibility issues\")\n+\t}\n+\n+\t// Get current user for SSH connection\n+\tcurrentUser, err := user.Current()\n+\trequire.NoError(t, err, \"Should be able to get current user\")\n+\n+\t// Generate host key for server\n+\thostKey, err := ssh.GeneratePrivateKey(ssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\t// Generate client key pair\n+\tclientPrivKey, err := ssh.GeneratePrivateKey(ssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\t// Create server with SFTP enabled\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := New(serverConfig)\n+\tserver.SetAllowSFTP(true)\n+\tserver.SetAllowRootLogin(true)\n+\n+\t// Start server\n+\tserverAddr := \"127.0.0.1:0\"\n+\tstarted := make(chan string, 1)\n+\terrChan := make(chan error, 1)\n+\n+\tgo func() {\n+\t\tln, err := net.Listen(\"tcp\", serverAddr)\n+\t\tif err != nil {\n+\t\t\terrChan <- err\n+\t\t\treturn\n+\t\t}\n+\t\tactualAddr := ln.Addr().String()\n+\t\tif err := ln.Close(); err != nil {\n+\t\t\terrChan <- fmt.Errorf(\"close temp listener: %w\", err)\n+\t\t\treturn\n+\t\t}\n+\n+\t\taddrPort, _ := netip.ParseAddrPort(actualAddr)\n+\t\tif err := server.Start(context.Background(), addrPort); err != nil {\n+\t\t\terrChan <- err\n+\t\t\treturn\n+\t\t}\n+\t\tstarted <- actualAddr\n+\t}()\n+\n+\tselect {\n+\tcase actualAddr := <-started:\n+\t\tserverAddr = actualAddr\n+\tcase err := <-errChan:\n+\t\tt.Fatalf(\"Server failed to start: %v\", err)\n+\tcase <-time.After(5 * time.Second):\n+\t\tt.Fatal(\"Server start timeout\")\n+\t}\n+\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\t// Parse client private key\n+\tsigner, err := cryptossh.ParsePrivateKey(clientPrivKey)\n+\trequire.NoError(t, err)\n+\n+\t// Parse server host key\n+\thostPrivParsed, err := cryptossh.ParsePrivateKey(hostKey)\n+\trequire.NoError(t, err)\n+\thostPubKey := hostPrivParsed.PublicKey()\n+\n+\t// (currentUser already obtained at function start)\n+\n+\t// Create SSH client connection\n+\tclientConfig := &cryptossh.ClientConfig{\n+\t\tUser: currentUser.Username,\n+\t\tAuth: []cryptossh.AuthMethod{\n+\t\t\tcryptossh.PublicKeys(signer),\n+\t\t},\n+\t\tHostKeyCallback: cryptossh.FixedHostKey(hostPubKey),\n+\t\tTimeout:         5 * time.Second,\n+\t}\n+\n+\tconn, err := cryptossh.Dial(\"tcp\", serverAddr, clientConfig)\n+\trequire.NoError(t, err, \"SSH connection should succeed\")\n+\tdefer func() {\n+\t\tif err := conn.Close(); err != nil {\n+\t\t\tt.Logf(\"connection close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\t// Create SFTP client\n+\tsftpClient, err := sftp.NewClient(conn)\n+\trequire.NoError(t, err, \"SFTP client creation should succeed\")\n+\tdefer func() {\n+\t\tif err := sftpClient.Close(); err != nil {\n+\t\t\tt.Logf(\"SFTP client close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\t// Test basic SFTP operations\n+\tworkingDir, err := sftpClient.Getwd()\n+\tassert.NoError(t, err, \"Should be able to get working directory\")\n+\tassert.NotEmpty(t, workingDir, \"Working directory should not be empty\")\n+\n+\t// Test directory listing\n+\tfiles, err := sftpClient.ReadDir(\".\")\n+\tassert.NoError(t, err, \"Should be able to list current directory\")\n+\tassert.NotNil(t, files, \"File list should not be nil\")\n+}\n+\n+func TestSSHServer_SFTPDisabled(t *testing.T) {\n+\t// Get current user for SSH connection\n+\tcurrentUser, err := user.Current()\n+\trequire.NoError(t, err, \"Should be able to get current user\")\n+\n+\t// Generate host key for server\n+\thostKey, err := ssh.GeneratePrivateKey(ssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\t// Generate client key pair\n+\tclientPrivKey, err := ssh.GeneratePrivateKey(ssh.ED25519)\n+\trequire.NoError(t, err)\n+\n+\t// Create server with SFTP disabled\n+\tserverConfig := &Config{\n+\t\tHostKeyPEM: hostKey,\n+\t\tJWT:        nil,\n+\t}\n+\tserver := New(serverConfig)\n+\tserver.SetAllowSFTP(false)\n+\n+\t// Start server\n+\tserverAddr := \"127.0.0.1:0\"\n+\tstarted := make(chan string, 1)\n+\terrChan := make(chan error, 1)\n+\n+\tgo func() {\n+\t\tln, err := net.Listen(\"tcp\", serverAddr)\n+\t\tif err != nil {\n+\t\t\terrChan <- err\n+\t\t\treturn\n+\t\t}\n+\t\tactualAddr := ln.Addr().String()\n+\t\tif err := ln.Close(); err != nil {\n+\t\t\terrChan <- fmt.Errorf(\"close temp listener: %w\", err)\n+\t\t\treturn\n+\t\t}\n+\n+\t\taddrPort, _ := netip.ParseAddrPort(actualAddr)\n+\t\tif err := server.Start(context.Background(), addrPort); err != nil {\n+\t\t\terrChan <- err\n+\t\t\treturn\n+\t\t}\n+\t\tstarted <- actualAddr\n+\t}()\n+\n+\tselect {\n+\tcase actualAddr := <-started:\n+\t\tserverAddr = actualAddr\n+\tcase err := <-errChan:\n+\t\tt.Fatalf(\"Server failed to start: %v\", err)\n+\tcase <-time.After(5 * time.Second):\n+\t\tt.Fatal(\"Server start timeout\")\n+\t}\n+\n+\tdefer func() {\n+\t\terr := server.Stop()\n+\t\trequire.NoError(t, err)\n+\t}()\n+\n+\t// Parse client private key\n+\tsigner, err := cryptossh.ParsePrivateKey(clientPrivKey)\n+\trequire.NoError(t, err)\n+\n+\t// Parse server host key\n+\thostPrivParsed, err := cryptossh.ParsePrivateKey(hostKey)\n+\trequire.NoError(t, err)\n+\thostPubKey := hostPrivParsed.PublicKey()\n+\n+\t// (currentUser already obtained at function start)\n+\n+\t// Create SSH client connection\n+\tclientConfig := &cryptossh.ClientConfig{\n+\t\tUser: currentUser.Username,\n+\t\tAuth: []cryptossh.AuthMethod{\n+\t\t\tcryptossh.PublicKeys(signer),\n+\t\t},\n+\t\tHostKeyCallback: cryptossh.FixedHostKey(hostPubKey),\n+\t\tTimeout:         5 * time.Second,\n+\t}\n+\n+\tconn, err := cryptossh.Dial(\"tcp\", serverAddr, clientConfig)\n+\trequire.NoError(t, err, \"SSH connection should succeed\")\n+\tdefer func() {\n+\t\tif err := conn.Close(); err != nil {\n+\t\t\tt.Logf(\"connection close error: %v\", err)\n+\t\t}\n+\t}()\n+\n+\t// Try to create SFTP client - should fail when SFTP is disabled\n+\t_, err = sftp.NewClient(conn)\n+\tassert.Error(t, err, \"SFTP client creation should fail when SFTP is disabled\")\n+}\ndiff --git a/client/ssh/server/test.go b/client/ssh/server/test.go\nnew file mode 100644\nindex 00000000000..20930c72199\n--- /dev/null\n+++ b/client/ssh/server/test.go\n@@ -0,0 +1,45 @@\n+package server\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"net\"\n+\t\"net/netip\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func StartTestServer(t *testing.T, server *Server) string {\n+\tstarted := make(chan string, 1)\n+\terrChan := make(chan error, 1)\n+\n+\tgo func() {\n+\t\tln, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n+\t\tif err != nil {\n+\t\t\terrChan <- err\n+\t\t\treturn\n+\t\t}\n+\t\tactualAddr := ln.Addr().String()\n+\t\tif err := ln.Close(); err != nil {\n+\t\t\terrChan <- fmt.Errorf(\"close temp listener: %w\", err)\n+\t\t\treturn\n+\t\t}\n+\n+\t\taddrPort := netip.MustParseAddrPort(actualAddr)\n+\t\tif err := server.Start(context.Background(), addrPort); err != nil {\n+\t\t\terrChan <- err\n+\t\t\treturn\n+\t\t}\n+\t\tstarted <- actualAddr\n+\t}()\n+\n+\tselect {\n+\tcase actualAddr := <-started:\n+\t\treturn actualAddr\n+\tcase err := <-errChan:\n+\t\tt.Fatalf(\"Server failed to start: %v\", err)\n+\tcase <-time.After(5 * time.Second):\n+\t\tt.Fatal(\"Server start timeout\")\n+\t}\n+\treturn \"\"\n+}\ndiff --git a/client/ssh/server/user_utils_test.go b/client/ssh/server/user_utils_test.go\nnew file mode 100644\nindex 00000000000..637dc10d0a6\n--- /dev/null\n+++ b/client/ssh/server/user_utils_test.go\n@@ -0,0 +1,908 @@\n+package server\n+\n+import (\n+\t\"errors\"\n+\t\"os/user\"\n+\t\"runtime\"\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+// Test helper functions\n+func createTestUser(username, uid, gid, homeDir string) *user.User {\n+\treturn &user.User{\n+\t\tUid:      uid,\n+\t\tGid:      gid,\n+\t\tUsername: username,\n+\t\tName:     username,\n+\t\tHomeDir:  homeDir,\n+\t}\n+}\n+\n+// Test dependency injection setup - injects platform dependencies to test real logic\n+func setupTestDependencies(currentUser *user.User, currentUserErr error, os string, euid int, lookupUsers map[string]*user.User, lookupErrors map[string]error) func() {\n+\t// Store originals\n+\toriginalGetCurrentUser := getCurrentUser\n+\toriginalLookupUser := lookupUser\n+\toriginalGetCurrentOS := getCurrentOS\n+\toriginalGetEuid := getEuid\n+\n+\t// Reset caches to ensure clean test state\n+\n+\t// Set test values - inject platform dependencies\n+\tgetCurrentUser = func() (*user.User, error) {\n+\t\treturn currentUser, currentUserErr\n+\t}\n+\n+\tlookupUser = func(username string) (*user.User, error) {\n+\t\tif err, exists := lookupErrors[username]; exists {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif userObj, exists := lookupUsers[username]; exists {\n+\t\t\treturn userObj, nil\n+\t\t}\n+\t\treturn nil, errors.New(\"user: unknown user \" + username)\n+\t}\n+\n+\tgetCurrentOS = func() string {\n+\t\treturn os\n+\t}\n+\n+\tgetEuid = func() int {\n+\t\treturn euid\n+\t}\n+\n+\t// Mock privilege detection based on the test user\n+\tgetIsProcessPrivileged = func() bool {\n+\t\tif currentUser == nil {\n+\t\t\treturn false\n+\t\t}\n+\t\t// Check both username and SID for Windows systems\n+\t\tif os == \"windows\" && isWindowsPrivilegedSID(currentUser.Uid) {\n+\t\t\treturn true\n+\t\t}\n+\t\treturn isPrivilegedUsername(currentUser.Username)\n+\t}\n+\n+\t// Return cleanup function\n+\treturn func() {\n+\t\tgetCurrentUser = originalGetCurrentUser\n+\t\tlookupUser = originalLookupUser\n+\t\tgetCurrentOS = originalGetCurrentOS\n+\t\tgetEuid = originalGetEuid\n+\n+\t\tgetIsProcessPrivileged = isCurrentProcessPrivileged\n+\n+\t\t// Reset caches after test\n+\t}\n+}\n+\n+func TestCheckPrivileges_ComprehensiveMatrix(t *testing.T) {\n+\ttests := []struct {\n+\t\tname                      string\n+\t\tos                        string\n+\t\teuid                      int\n+\t\tcurrentUser               *user.User\n+\t\trequestedUsername         string\n+\t\tfeatureSupportsUserSwitch bool\n+\t\tallowRoot                 bool\n+\t\tlookupUsers               map[string]*user.User\n+\t\texpectedAllowed           bool\n+\t\texpectedRequiresSwitch    bool\n+\t}{\n+\t\t{\n+\t\t\tname:                      \"linux_root_can_switch_to_alice\",\n+\t\t\tos:                        \"linux\",\n+\t\t\teuid:                      0, // Root process\n+\t\t\tcurrentUser:               createTestUser(\"root\", \"0\", \"0\", \"/root\"),\n+\t\t\trequestedUsername:         \"alice\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 true,\n+\t\t\tlookupUsers: map[string]*user.User{\n+\t\t\t\t\"alice\": createTestUser(\"alice\", \"1000\", \"1000\", \"/home/alice\"),\n+\t\t\t},\n+\t\t\texpectedAllowed:        true,\n+\t\t\texpectedRequiresSwitch: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:                      \"linux_non_root_fallback_to_current_user\",\n+\t\t\tos:                        \"linux\",\n+\t\t\teuid:                      1000, // Non-root process\n+\t\t\tcurrentUser:               createTestUser(\"alice\", \"1000\", \"1000\", \"/home/alice\"),\n+\t\t\trequestedUsername:         \"bob\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 true,\n+\t\t\texpectedAllowed:           true,  // Should fallback to current user (alice)\n+\t\t\texpectedRequiresSwitch:    false, // Fallback means no actual switching\n+\t\t},\n+\t\t{\n+\t\t\tname:                      \"windows_admin_can_switch_to_alice\",\n+\t\t\tos:                        \"windows\",\n+\t\t\teuid:                      1000, // Irrelevant on Windows\n+\t\t\tcurrentUser:               createTestUser(\"Administrator\", \"S-1-5-21-123456789-123456789-123456789-500\", \"S-1-5-32-544\", \"C:\\\\Users\\\\Administrator\"),\n+\t\t\trequestedUsername:         \"alice\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 true,\n+\t\t\tlookupUsers: map[string]*user.User{\n+\t\t\t\t\"alice\": createTestUser(\"alice\", \"S-1-5-21-123456789-123456789-123456789-1001\", \"S-1-5-21-123456789-123456789-123456789-513\", \"C:\\\\Users\\\\alice\"),\n+\t\t\t},\n+\t\t\texpectedAllowed:        true,\n+\t\t\texpectedRequiresSwitch: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:                      \"windows_non_admin_no_fallback_hard_failure\",\n+\t\t\tos:                        \"windows\",\n+\t\t\teuid:                      1000, // Irrelevant on Windows\n+\t\t\tcurrentUser:               createTestUser(\"alice\", \"1001\", \"1001\", \"C:\\\\Users\\\\alice\"),\n+\t\t\trequestedUsername:         \"bob\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 true,\n+\t\t\tlookupUsers: map[string]*user.User{\n+\t\t\t\t\"bob\": createTestUser(\"bob\", \"S-1-5-21-123456789-123456789-123456789-1002\", \"S-1-5-21-123456789-123456789-123456789-513\", \"C:\\\\Users\\\\bob\"),\n+\t\t\t},\n+\t\t\texpectedAllowed:        true, // Let OS decide - deferred security check\n+\t\t\texpectedRequiresSwitch: true, // Different user was requested\n+\t\t},\n+\t\t// Comprehensive test matrix: non-root linux with different allowRoot settings\n+\t\t{\n+\t\t\tname:                      \"linux_non_root_request_root_allowRoot_false\",\n+\t\t\tos:                        \"linux\",\n+\t\t\teuid:                      1000,\n+\t\t\tcurrentUser:               createTestUser(\"alice\", \"1000\", \"1000\", \"/home/alice\"),\n+\t\t\trequestedUsername:         \"root\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 false,\n+\t\t\texpectedAllowed:           true,  // Fallback allows access regardless of root setting\n+\t\t\texpectedRequiresSwitch:    false, // Fallback case, no switching\n+\t\t},\n+\t\t{\n+\t\t\tname:                      \"linux_non_root_request_root_allowRoot_true\",\n+\t\t\tos:                        \"linux\",\n+\t\t\teuid:                      1000,\n+\t\t\tcurrentUser:               createTestUser(\"alice\", \"1000\", \"1000\", \"/home/alice\"),\n+\t\t\trequestedUsername:         \"root\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 true,\n+\t\t\texpectedAllowed:           true,  // Should fallback to alice (non-privileged process)\n+\t\t\texpectedRequiresSwitch:    false, // Fallback means no actual switching\n+\t\t},\n+\t\t// Windows admin test matrix\n+\t\t{\n+\t\t\tname:                      \"windows_admin_request_root_allowRoot_false\",\n+\t\t\tos:                        \"windows\",\n+\t\t\teuid:                      1000,\n+\t\t\tcurrentUser:               createTestUser(\"Administrator\", \"S-1-5-21-123456789-123456789-123456789-500\", \"S-1-5-32-544\", \"C:\\\\Users\\\\Administrator\"),\n+\t\t\trequestedUsername:         \"root\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 false,\n+\t\t\texpectedAllowed:           false, // Root not allowed\n+\t\t\texpectedRequiresSwitch:    true,\n+\t\t},\n+\t\t{\n+\t\t\tname:                      \"windows_admin_request_root_allowRoot_true\",\n+\t\t\tos:                        \"windows\",\n+\t\t\teuid:                      1000,\n+\t\t\tcurrentUser:               createTestUser(\"Administrator\", \"S-1-5-21-123456789-123456789-123456789-500\", \"S-1-5-32-544\", \"C:\\\\Users\\\\Administrator\"),\n+\t\t\trequestedUsername:         \"root\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 true,\n+\t\t\tlookupUsers: map[string]*user.User{\n+\t\t\t\t\"root\": createTestUser(\"root\", \"0\", \"0\", \"/root\"),\n+\t\t\t},\n+\t\t\texpectedAllowed:        true, // Windows user switching should work like Unix\n+\t\t\texpectedRequiresSwitch: true,\n+\t\t},\n+\t\t// Windows non-admin test matrix\n+\t\t{\n+\t\t\tname:                      \"windows_non_admin_request_root_allowRoot_false\",\n+\t\t\tos:                        \"windows\",\n+\t\t\teuid:                      1000,\n+\t\t\tcurrentUser:               createTestUser(\"alice\", \"S-1-5-21-123456789-123456789-123456789-1001\", \"S-1-5-21-123456789-123456789-123456789-513\", \"C:\\\\Users\\\\alice\"),\n+\t\t\trequestedUsername:         \"root\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 false,\n+\t\t\texpectedAllowed:           false, // Root not allowed (allowRoot=false takes precedence)\n+\t\t\texpectedRequiresSwitch:    true,\n+\t\t},\n+\t\t{\n+\t\t\tname:                      \"windows_system_account_allowRoot_false\",\n+\t\t\tos:                        \"windows\",\n+\t\t\teuid:                      1000,\n+\t\t\tcurrentUser:               createTestUser(\"NETBIRD\\\\WIN2K19-C2$\", \"S-1-5-18\", \"S-1-5-18\", \"C:\\\\Windows\\\\System32\"),\n+\t\t\trequestedUsername:         \"root\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 false,\n+\t\t\texpectedAllowed:           false, // Root not allowed\n+\t\t\texpectedRequiresSwitch:    true,\n+\t\t},\n+\t\t{\n+\t\t\tname:                      \"windows_system_account_allowRoot_true\",\n+\t\t\tos:                        \"windows\",\n+\t\t\teuid:                      1000,\n+\t\t\tcurrentUser:               createTestUser(\"NETBIRD\\\\WIN2K19-C2$\", \"S-1-5-18\", \"S-1-5-18\", \"C:\\\\Windows\\\\System32\"),\n+\t\t\trequestedUsername:         \"root\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 true,\n+\t\t\tlookupUsers: map[string]*user.User{\n+\t\t\t\t\"root\": createTestUser(\"root\", \"0\", \"0\", \"/root\"),\n+\t\t\t},\n+\t\t\texpectedAllowed:        true, // SYSTEM can switch to root\n+\t\t\texpectedRequiresSwitch: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:                      \"windows_non_admin_request_root_allowRoot_true\",\n+\t\t\tos:                        \"windows\",\n+\t\t\teuid:                      1000,\n+\t\t\tcurrentUser:               createTestUser(\"alice\", \"S-1-5-21-123456789-123456789-123456789-1001\", \"S-1-5-21-123456789-123456789-123456789-513\", \"C:\\\\Users\\\\alice\"),\n+\t\t\trequestedUsername:         \"root\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 true,\n+\t\t\tlookupUsers: map[string]*user.User{\n+\t\t\t\t\"root\": createTestUser(\"root\", \"0\", \"0\", \"/root\"),\n+\t\t\t},\n+\t\t\texpectedAllowed:        true, // Let OS decide - deferred security check\n+\t\t\texpectedRequiresSwitch: true,\n+\t\t},\n+\n+\t\t// Feature doesn't support user switching scenarios\n+\t\t{\n+\t\t\tname:                      \"linux_root_feature_no_user_switching_same_user\",\n+\t\t\tos:                        \"linux\",\n+\t\t\teuid:                      0,\n+\t\t\tcurrentUser:               createTestUser(\"root\", \"0\", \"0\", \"/root\"),\n+\t\t\trequestedUsername:         \"root\", // Same user\n+\t\t\tfeatureSupportsUserSwitch: false,\n+\t\t\tallowRoot:                 true,\n+\t\t\tlookupUsers: map[string]*user.User{\n+\t\t\t\t\"root\": createTestUser(\"root\", \"0\", \"0\", \"/root\"),\n+\t\t\t},\n+\t\t\texpectedAllowed:        true, // Same user should work regardless of feature support\n+\t\t\texpectedRequiresSwitch: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:                      \"linux_root_feature_no_user_switching_different_user\",\n+\t\t\tos:                        \"linux\",\n+\t\t\teuid:                      0,\n+\t\t\tcurrentUser:               createTestUser(\"root\", \"0\", \"0\", \"/root\"),\n+\t\t\trequestedUsername:         \"alice\",\n+\t\t\tfeatureSupportsUserSwitch: false, // Feature doesn't support switching\n+\t\t\tallowRoot:                 true,\n+\t\t\tlookupUsers: map[string]*user.User{\n+\t\t\t\t\"alice\": createTestUser(\"alice\", \"1000\", \"1000\", \"/home/alice\"),\n+\t\t\t},\n+\t\t\texpectedAllowed:        false, // Should deny because feature doesn't support switching\n+\t\t\texpectedRequiresSwitch: true,\n+\t\t},\n+\n+\t\t// Empty username (current user) scenarios\n+\t\t{\n+\t\t\tname:                      \"linux_non_root_current_user_empty_username\",\n+\t\t\tos:                        \"linux\",\n+\t\t\teuid:                      1000,\n+\t\t\tcurrentUser:               createTestUser(\"alice\", \"1000\", \"1000\", \"/home/alice\"),\n+\t\t\trequestedUsername:         \"\", // Empty = current user\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 false,\n+\t\t\texpectedAllowed:           true, // Current user should always work\n+\t\t\texpectedRequiresSwitch:    false,\n+\t\t},\n+\t\t{\n+\t\t\tname:                      \"linux_root_current_user_empty_username_root_not_allowed\",\n+\t\t\tos:                        \"linux\",\n+\t\t\teuid:                      0,\n+\t\t\tcurrentUser:               createTestUser(\"root\", \"0\", \"0\", \"/root\"),\n+\t\t\trequestedUsername:         \"\", // Empty = current user (root)\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 false, // Root not allowed\n+\t\t\texpectedAllowed:           false, // Should deny root even when it's current user\n+\t\t\texpectedRequiresSwitch:    false,\n+\t\t},\n+\n+\t\t// User not found scenarios\n+\t\t{\n+\t\t\tname:                      \"linux_root_user_not_found\",\n+\t\t\tos:                        \"linux\",\n+\t\t\teuid:                      0,\n+\t\t\tcurrentUser:               createTestUser(\"root\", \"0\", \"0\", \"/root\"),\n+\t\t\trequestedUsername:         \"nonexistent\",\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 true,\n+\t\t\tlookupUsers:               map[string]*user.User{}, // No users defined = user not found\n+\t\t\texpectedAllowed:           false,                   // Should fail due to user not found\n+\t\t\texpectedRequiresSwitch:    true,\n+\t\t},\n+\n+\t\t// Windows feature doesn't support user switching\n+\t\t{\n+\t\t\tname:                      \"windows_admin_feature_no_user_switching_different_user\",\n+\t\t\tos:                        \"windows\",\n+\t\t\teuid:                      1000,\n+\t\t\tcurrentUser:               createTestUser(\"Administrator\", \"S-1-5-21-123456789-123456789-123456789-500\", \"S-1-5-32-544\", \"C:\\\\Users\\\\Administrator\"),\n+\t\t\trequestedUsername:         \"alice\",\n+\t\t\tfeatureSupportsUserSwitch: false, // Feature doesn't support switching\n+\t\t\tallowRoot:                 true,\n+\t\t\tlookupUsers: map[string]*user.User{\n+\t\t\t\t\"alice\": createTestUser(\"alice\", \"S-1-5-21-123456789-123456789-123456789-1001\", \"S-1-5-21-123456789-123456789-123456789-513\", \"C:\\\\Users\\\\alice\"),\n+\t\t\t},\n+\t\t\texpectedAllowed:        false, // Should deny because feature doesn't support switching\n+\t\t\texpectedRequiresSwitch: true,\n+\t\t},\n+\n+\t\t// Windows regular user scenarios (non-admin)\n+\t\t{\n+\t\t\tname:                      \"windows_regular_user_same_user\",\n+\t\t\tos:                        \"windows\",\n+\t\t\teuid:                      1000,\n+\t\t\tcurrentUser:               createTestUser(\"alice\", \"S-1-5-21-123456789-123456789-123456789-1001\", \"S-1-5-21-123456789-123456789-123456789-513\", \"C:\\\\Users\\\\alice\"),\n+\t\t\trequestedUsername:         \"alice\", // Same user\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 false,\n+\t\t\tlookupUsers: map[string]*user.User{\n+\t\t\t\t\"alice\": createTestUser(\"alice\", \"S-1-5-21-123456789-123456789-123456789-1001\", \"S-1-5-21-123456789-123456789-123456789-513\", \"C:\\\\Users\\\\alice\"),\n+\t\t\t},\n+\t\t\texpectedAllowed:        true,  // Regular user accessing themselves should work\n+\t\t\texpectedRequiresSwitch: false, // No switching for same user\n+\t\t},\n+\t\t{\n+\t\t\tname:                      \"windows_regular_user_empty_username\",\n+\t\t\tos:                        \"windows\",\n+\t\t\teuid:                      1000,\n+\t\t\tcurrentUser:               createTestUser(\"alice\", \"S-1-5-21-123456789-123456789-123456789-1001\", \"S-1-5-21-123456789-123456789-123456789-513\", \"C:\\\\Users\\\\alice\"),\n+\t\t\trequestedUsername:         \"\", // Empty = current user\n+\t\t\tfeatureSupportsUserSwitch: true,\n+\t\t\tallowRoot:                 false,\n+\t\t\texpectedAllowed:           true,  // Current user should always work\n+\t\t\texpectedRequiresSwitch:    false, // No switching for current user\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Inject platform dependencies to test real logic\n+\t\t\tcleanup := setupTestDependencies(tt.currentUser, nil, tt.os, tt.euid, tt.lookupUsers, nil)\n+\t\t\tdefer cleanup()\n+\n+\t\t\tserver := &Server{allowRootLogin: tt.allowRoot}\n+\n+\t\t\tresult := server.CheckPrivileges(PrivilegeCheckRequest{\n+\t\t\t\tRequestedUsername:         tt.requestedUsername,\n+\t\t\t\tFeatureSupportsUserSwitch: tt.featureSupportsUserSwitch,\n+\t\t\t\tFeatureName:               \"SSH login\",\n+\t\t\t})\n+\n+\t\t\tassert.Equal(t, tt.expectedAllowed, result.Allowed)\n+\t\t\tassert.Equal(t, tt.expectedRequiresSwitch, result.RequiresUserSwitching)\n+\t\t})\n+\t}\n+}\n+\n+func TestUsedFallback_MeansNoPrivilegeDropping(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\tt.Skip(\"Fallback mechanism is Unix-specific\")\n+\t}\n+\n+\t// Create test scenario where fallback should occur\n+\tserver := &Server{allowRootLogin: true}\n+\n+\t// Mock dependencies to simulate non-privileged user\n+\toriginalGetCurrentUser := getCurrentUser\n+\toriginalGetIsProcessPrivileged := getIsProcessPrivileged\n+\n+\tdefer func() {\n+\t\tgetCurrentUser = originalGetCurrentUser\n+\t\tgetIsProcessPrivileged = originalGetIsProcessPrivileged\n+\n+\t}()\n+\n+\t// Set up mocks for fallback scenario\n+\tgetCurrentUser = func() (*user.User, error) {\n+\t\treturn createTestUser(\"netbird\", \"1000\", \"1000\", \"/var/lib/netbird\"), nil\n+\t}\n+\tgetIsProcessPrivileged = func() bool { return false } // Non-privileged\n+\n+\t// Request different user - should fallback\n+\tresult := server.CheckPrivileges(PrivilegeCheckRequest{\n+\t\tRequestedUsername:         \"alice\",\n+\t\tFeatureSupportsUserSwitch: true,\n+\t\tFeatureName:               \"SSH login\",\n+\t})\n+\n+\t// Verify fallback occurred\n+\tassert.True(t, result.Allowed, \"Should allow with fallback\")\n+\tassert.True(t, result.UsedFallback, \"Should indicate fallback was used\")\n+\tassert.Equal(t, \"netbird\", result.User.Username, \"Should return current user\")\n+\tassert.False(t, result.RequiresUserSwitching, \"Should not require switching when fallback is used\")\n+\n+\t// Key assertion: When UsedFallback is true, no privilege dropping should be needed\n+\t// because all privilege checks have already been performed and we're using current user\n+\tt.Logf(\"UsedFallback=true means: current user (%s) is the target, no privilege dropping needed\",\n+\t\tresult.User.Username)\n+}\n+\n+func TestPrivilegedUsernameDetection(t *testing.T) {\n+\ttests := []struct {\n+\t\tname       string\n+\t\tusername   string\n+\t\tplatform   string\n+\t\tprivileged bool\n+\t}{\n+\t\t// Unix/Linux tests\n+\t\t{\"unix_root\", \"root\", \"linux\", true},\n+\t\t{\"unix_regular_user\", \"alice\", \"linux\", false},\n+\t\t{\"unix_root_capital\", \"Root\", \"linux\", false}, // Case-sensitive\n+\n+\t\t// Windows tests\n+\t\t{\"windows_administrator\", \"Administrator\", \"windows\", true},\n+\t\t{\"windows_system\", \"SYSTEM\", \"windows\", true},\n+\t\t{\"windows_admin\", \"admin\", \"windows\", true},\n+\t\t{\"windows_admin_lowercase\", \"administrator\", \"windows\", true}, // Case-insensitive\n+\t\t{\"windows_domain_admin\", \"DOMAIN\\\\Administrator\", \"windows\", true},\n+\t\t{\"windows_email_admin\", \"admin@domain.com\", \"windows\", true},\n+\t\t{\"windows_regular_user\", \"alice\", \"windows\", false},\n+\t\t{\"windows_domain_user\", \"DOMAIN\\\\alice\", \"windows\", false},\n+\t\t{\"windows_localsystem\", \"localsystem\", \"windows\", true},\n+\t\t{\"windows_networkservice\", \"networkservice\", \"windows\", true},\n+\t\t{\"windows_localservice\", \"localservice\", \"windows\", true},\n+\n+\t\t// Computer accounts (these depend on current user context in real implementation)\n+\t\t{\"windows_computer_account\", \"WIN2K19-C2$\", \"windows\", false},      // Computer account by itself not privileged\n+\t\t{\"windows_domain_computer\", \"DOMAIN\\\\COMPUTER$\", \"windows\", false}, // Domain computer account\n+\n+\t\t// Cross-platform\n+\t\t{\"root_on_windows\", \"root\", \"windows\", true}, // Root should be privileged everywhere\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Mock the platform for this test\n+\t\t\tcleanup := setupTestDependencies(nil, nil, tt.platform, 1000, nil, nil)\n+\t\t\tdefer cleanup()\n+\n+\t\t\tresult := isPrivilegedUsername(tt.username)\n+\t\t\tassert.Equal(t, tt.privileged, result)\n+\t\t})\n+\t}\n+}\n+\n+func TestWindowsPrivilegedSIDDetection(t *testing.T) {\n+\ttests := []struct {\n+\t\tname        string\n+\t\tsid         string\n+\t\tprivileged  bool\n+\t\tdescription string\n+\t}{\n+\t\t// Well-known system accounts\n+\t\t{\"system_account\", \"S-1-5-18\", true, \"Local System (SYSTEM)\"},\n+\t\t{\"local_service\", \"S-1-5-19\", true, \"Local Service\"},\n+\t\t{\"network_service\", \"S-1-5-20\", true, \"Network Service\"},\n+\t\t{\"administrators_group\", \"S-1-5-32-544\", true, \"Administrators group\"},\n+\t\t{\"builtin_administrator\", \"S-1-5-500\", true, \"Built-in Administrator\"},\n+\n+\t\t// Domain accounts\n+\t\t{\"domain_administrator\", \"S-1-5-21-1234567890-1234567890-1234567890-500\", true, \"Domain Administrator (RID 500)\"},\n+\t\t{\"domain_admins_group\", \"S-1-5-21-1234567890-1234567890-1234567890-512\", true, \"Domain Admins group\"},\n+\t\t{\"domain_controllers_group\", \"S-1-5-21-1234567890-1234567890-1234567890-516\", true, \"Domain Controllers group\"},\n+\t\t{\"enterprise_admins_group\", \"S-1-5-21-1234567890-1234567890-1234567890-519\", true, \"Enterprise Admins group\"},\n+\n+\t\t// Regular users\n+\t\t{\"regular_user\", \"S-1-5-21-1234567890-1234567890-1234567890-1001\", false, \"Regular domain user\"},\n+\t\t{\"another_regular_user\", \"S-1-5-21-1234567890-1234567890-1234567890-1234\", false, \"Another regular user\"},\n+\t\t{\"local_user\", \"S-1-5-21-1234567890-1234567890-1234567890-1000\", false, \"Local regular user\"},\n+\n+\t\t// Groups that are not privileged\n+\t\t{\"domain_users\", \"S-1-5-21-1234567890-1234567890-1234567890-513\", false, \"Domain Users group\"},\n+\t\t{\"power_users\", \"S-1-5-32-547\", false, \"Power Users group\"},\n+\n+\t\t// Invalid SIDs\n+\t\t{\"malformed_sid\", \"S-1-5-invalid\", false, \"Malformed SID\"},\n+\t\t{\"empty_sid\", \"\", false, \"Empty SID\"},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tresult := isWindowsPrivilegedSID(tt.sid)\n+\t\t\tassert.Equal(t, tt.privileged, result, \"Failed for %s: %s\", tt.description, tt.sid)\n+\t\t})\n+\t}\n+}\n+\n+func TestIsSameUser(t *testing.T) {\n+\ttests := []struct {\n+\t\tname     string\n+\t\tuser1    string\n+\t\tuser2    string\n+\t\tos       string\n+\t\texpected bool\n+\t}{\n+\t\t// Basic cases\n+\t\t{\"same_username\", \"alice\", \"alice\", \"linux\", true},\n+\t\t{\"different_username\", \"alice\", \"bob\", \"linux\", false},\n+\n+\t\t// Linux (no domain processing)\n+\t\t{\"linux_domain_vs_bare\", \"DOMAIN\\\\alice\", \"alice\", \"linux\", false},\n+\t\t{\"linux_email_vs_bare\", \"alice@domain.com\", \"alice\", \"linux\", false},\n+\t\t{\"linux_same_literal\", \"DOMAIN\\\\alice\", \"DOMAIN\\\\alice\", \"linux\", true},\n+\n+\t\t// Windows (with domain processing) - Note: parameter order is (requested, current, os, expected)\n+\t\t{\"windows_domain_vs_bare\", \"alice\", \"DOMAIN\\\\alice\", \"windows\", true},                         // bare username matches domain current user\n+\t\t{\"windows_email_vs_bare\", \"alice\", \"alice@domain.com\", \"windows\", true},                       // bare username matches email current user\n+\t\t{\"windows_different_domains_same_user\", \"DOMAIN1\\\\alice\", \"DOMAIN2\\\\alice\", \"windows\", false}, // SECURITY: different domains = different users\n+\t\t{\"windows_case_insensitive\", \"Alice\", \"alice\", \"windows\", true},\n+\t\t{\"windows_different_users\", \"DOMAIN\\\\alice\", \"DOMAIN\\\\bob\", \"windows\", false},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Set up OS mock\n+\t\t\tcleanup := setupTestDependencies(nil, nil, tt.os, 1000, nil, nil)\n+\t\t\tdefer cleanup()\n+\n+\t\t\tresult := isSameUser(tt.user1, tt.user2)\n+\t\t\tassert.Equal(t, tt.expected, result)\n+\t\t})\n+\t}\n+}\n+\n+func TestUsernameValidation_Unix(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\tt.Skip(\"Unix-specific username validation tests\")\n+\t}\n+\n+\ttests := []struct {\n+\t\tname     string\n+\t\tusername string\n+\t\twantErr  bool\n+\t\terrMsg   string\n+\t}{\n+\t\t// Valid usernames (Unix/POSIX)\n+\t\t{\"valid_alphanumeric\", \"user123\", false, \"\"},\n+\t\t{\"valid_with_dots\", \"user.name\", false, \"\"},\n+\t\t{\"valid_with_hyphens\", \"user-name\", false, \"\"},\n+\t\t{\"valid_with_underscores\", \"user_name\", false, \"\"},\n+\t\t{\"valid_uppercase\", \"UserName\", false, \"\"},\n+\t\t{\"valid_starting_with_digit\", \"123user\", false, \"\"},\n+\t\t{\"valid_starting_with_dot\", \".hidden\", false, \"\"},\n+\n+\t\t// Invalid usernames (Unix/POSIX)\n+\t\t{\"empty_username\", \"\", true, \"username cannot be empty\"},\n+\t\t{\"username_too_long\", \"thisusernameiswaytoolongandexceedsthe32characterlimit\", true, \"username too long\"},\n+\t\t{\"username_starting_with_hyphen\", \"-user\", true, \"invalid characters\"}, // POSIX restriction\n+\t\t{\"username_with_spaces\", \"user name\", true, \"invalid characters\"},\n+\t\t{\"username_with_shell_metacharacters\", \"user;rm\", true, \"invalid characters\"},\n+\t\t{\"username_with_command_injection\", \"user`rm -rf /`\", true, \"invalid characters\"},\n+\t\t{\"username_with_pipe\", \"user|rm\", true, \"invalid characters\"},\n+\t\t{\"username_with_ampersand\", \"user&rm\", true, \"invalid characters\"},\n+\t\t{\"username_with_quotes\", \"user\\\"name\", true, \"invalid characters\"},\n+\t\t{\"username_with_newline\", \"user\\nname\", true, \"invalid characters\"},\n+\t\t{\"reserved_dot\", \".\", true, \"cannot be '.' or '..'\"},\n+\t\t{\"reserved_dotdot\", \"..\", true, \"cannot be '.' or '..'\"},\n+\t\t{\"username_with_at_symbol\", \"user@domain\", true, \"invalid characters\"}, // Not allowed in bare Unix usernames\n+\t\t{\"username_with_backslash\", \"user\\\\name\", true, \"invalid characters\"},  // Not allowed in Unix usernames\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\terr := validateUsername(tt.username)\n+\t\t\tif tt.wantErr {\n+\t\t\t\tassert.Error(t, err, \"Should reject invalid username\")\n+\t\t\t\tif tt.errMsg != \"\" {\n+\t\t\t\t\tassert.Contains(t, err.Error(), tt.errMsg, \"Error message should contain expected text\")\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tassert.NoError(t, err, \"Should accept valid username\")\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestUsernameValidation_Windows(t *testing.T) {\n+\tif runtime.GOOS != \"windows\" {\n+\t\tt.Skip(\"Windows-specific username validation tests\")\n+\t}\n+\n+\ttests := []struct {\n+\t\tname     string\n+\t\tusername string\n+\t\twantErr  bool\n+\t\terrMsg   string\n+\t}{\n+\t\t// Valid usernames (Windows)\n+\t\t{\"valid_alphanumeric\", \"user123\", false, \"\"},\n+\t\t{\"valid_with_dots\", \"user.name\", false, \"\"},\n+\t\t{\"valid_with_hyphens\", \"user-name\", false, \"\"},\n+\t\t{\"valid_with_underscores\", \"user_name\", false, \"\"},\n+\t\t{\"valid_uppercase\", \"UserName\", false, \"\"},\n+\t\t{\"valid_starting_with_digit\", \"123user\", false, \"\"},\n+\t\t{\"valid_starting_with_dot\", \".hidden\", false, \"\"},\n+\t\t{\"valid_starting_with_hyphen\", \"-user\", false, \"\"},     // Windows allows this\n+\t\t{\"valid_domain_username\", \"DOMAIN\\\\user\", false, \"\"},   // Windows domain format\n+\t\t{\"valid_email_username\", \"user@domain.com\", false, \"\"}, // Windows email format\n+\t\t{\"valid_machine_username\", \"MACHINE\\\\user\", false, \"\"}, // Windows machine format\n+\n+\t\t// Invalid usernames (Windows)\n+\t\t{\"empty_username\", \"\", true, \"username cannot be empty\"},\n+\t\t{\"username_too_long\", \"thisusernameiswaytoolongandexceedsthe32characterlimit\", true, \"username too long\"},\n+\t\t{\"username_with_spaces\", \"user name\", true, \"invalid characters\"},\n+\t\t{\"username_with_shell_metacharacters\", \"user;rm\", true, \"invalid characters\"},\n+\t\t{\"username_with_command_injection\", \"user`rm -rf /`\", true, \"invalid characters\"},\n+\t\t{\"username_with_pipe\", \"user|rm\", true, \"invalid characters\"},\n+\t\t{\"username_with_ampersand\", \"user&rm\", true, \"invalid characters\"},\n+\t\t{\"username_with_quotes\", \"user\\\"name\", true, \"invalid characters\"},\n+\t\t{\"username_with_newline\", \"user\\nname\", true, \"invalid characters\"},\n+\t\t{\"username_with_brackets\", \"user[name]\", true, \"invalid characters\"},\n+\t\t{\"username_with_colon\", \"user:name\", true, \"invalid characters\"},\n+\t\t{\"username_with_semicolon\", \"user;name\", true, \"invalid characters\"},\n+\t\t{\"username_with_equals\", \"user=name\", true, \"invalid characters\"},\n+\t\t{\"username_with_comma\", \"user,name\", true, \"invalid characters\"},\n+\t\t{\"username_with_plus\", \"user+name\", true, \"invalid characters\"},\n+\t\t{\"username_with_asterisk\", \"user*name\", true, \"invalid characters\"},\n+\t\t{\"username_with_question\", \"user?name\", true, \"invalid characters\"},\n+\t\t{\"username_with_angles\", \"user<name>\", true, \"invalid characters\"},\n+\t\t{\"reserved_dot\", \".\", true, \"cannot be '.' or '..'\"},\n+\t\t{\"reserved_dotdot\", \"..\", true, \"cannot be '.' or '..'\"},\n+\t\t{\"username_ending_with_period\", \"user.\", true, \"cannot end with a period\"},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\terr := validateUsername(tt.username)\n+\t\t\tif tt.wantErr {\n+\t\t\t\tassert.Error(t, err, \"Should reject invalid username\")\n+\t\t\t\tif tt.errMsg != \"\" {\n+\t\t\t\t\tassert.Contains(t, err.Error(), tt.errMsg, \"Error message should contain expected text\")\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tassert.NoError(t, err, \"Should accept valid username\")\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+// Test real-world integration scenarios with actual platform capabilities\n+func TestCheckPrivileges_RealWorldScenarios(t *testing.T) {\n+\ttests := []struct {\n+\t\tname                      string\n+\t\tfeature                   string\n+\t\tfeatureSupportsUserSwitch bool\n+\t\trequestedUsername         string\n+\t\tallowRoot                 bool\n+\t\texpectedBehaviorPattern   string\n+\t}{\n+\t\t{\"SSH_login_current_user\", \"SSH login\", true, \"\", true, \"should_allow_current_user\"},\n+\t\t{\"SFTP_current_user\", \"SFTP\", true, \"\", true, \"should_allow_current_user\"},\n+\t\t{\"port_forwarding_current_user\", \"port forwarding\", false, \"\", true, \"should_allow_current_user\"},\n+\t\t{\"SSH_login_root_not_allowed\", \"SSH login\", true, \"root\", false, \"should_deny_root\"},\n+\t\t{\"port_forwarding_different_user\", \"port forwarding\", false, \"differentuser\", true, \"should_deny_switching\"},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Mock privileged environment to ensure consistent test behavior across environments\n+\t\t\tcleanup := setupTestDependencies(\n+\t\t\t\tcreateTestUser(\"root\", \"0\", \"0\", \"/root\"), // Running as root\n+\t\t\t\tnil,\n+\t\t\t\truntime.GOOS,\n+\t\t\t\t0, // euid 0 (root)\n+\t\t\t\tmap[string]*user.User{\n+\t\t\t\t\t\"root\":          createTestUser(\"root\", \"0\", \"0\", \"/root\"),\n+\t\t\t\t\t\"differentuser\": createTestUser(\"differentuser\", \"1000\", \"1000\", \"/home/differentuser\"),\n+\t\t\t\t},\n+\t\t\t\tnil,\n+\t\t\t)\n+\t\t\tdefer cleanup()\n+\n+\t\t\tserver := &Server{allowRootLogin: tt.allowRoot}\n+\n+\t\t\tresult := server.CheckPrivileges(PrivilegeCheckRequest{\n+\t\t\t\tRequestedUsername:         tt.requestedUsername,\n+\t\t\t\tFeatureSupportsUserSwitch: tt.featureSupportsUserSwitch,\n+\t\t\t\tFeatureName:               tt.feature,\n+\t\t\t})\n+\n+\t\t\tswitch tt.expectedBehaviorPattern {\n+\t\t\tcase \"should_allow_current_user\":\n+\t\t\t\tassert.True(t, result.Allowed, \"Should allow current user access\")\n+\t\t\t\tassert.False(t, result.RequiresUserSwitching, \"Current user should not require switching\")\n+\t\t\tcase \"should_deny_root\":\n+\t\t\t\tassert.False(t, result.Allowed, \"Should deny root when not allowed\")\n+\t\t\t\tassert.Contains(t, result.Error.Error(), \"root\", \"Should mention root in error\")\n+\t\t\tcase \"should_deny_switching\":\n+\t\t\t\tassert.False(t, result.Allowed, \"Should deny when feature doesn't support switching\")\n+\t\t\t\tassert.Contains(t, result.Error.Error(), \"user switching not supported\", \"Should mention switching in error\")\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+// Test with actual platform capabilities - no mocking\n+func TestCheckPrivileges_ActualPlatform(t *testing.T) {\n+\t// This test uses the REAL platform capabilities\n+\tserver := &Server{allowRootLogin: true}\n+\n+\t// Test current user access - should always work\n+\tresult := server.CheckPrivileges(PrivilegeCheckRequest{\n+\t\tRequestedUsername:         \"\", // Current user\n+\t\tFeatureSupportsUserSwitch: true,\n+\t\tFeatureName:               \"SSH login\",\n+\t})\n+\n+\tassert.True(t, result.Allowed, \"Current user should always be allowed\")\n+\tassert.False(t, result.RequiresUserSwitching, \"Current user should not require switching\")\n+\tassert.NotNil(t, result.User, \"Should return current user\")\n+\n+\t// Test user switching capability based on actual platform\n+\tactualIsPrivileged := isCurrentProcessPrivileged() // REAL check\n+\tactualOS := runtime.GOOS                           // REAL check\n+\n+\tt.Logf(\"Platform capabilities: OS=%s, isPrivileged=%v, supportsUserSwitching=%v\",\n+\t\tactualOS, actualIsPrivileged, actualIsPrivileged)\n+\n+\t// Test requesting different user\n+\tresult = server.CheckPrivileges(PrivilegeCheckRequest{\n+\t\tRequestedUsername:         \"nonexistentuser\",\n+\t\tFeatureSupportsUserSwitch: true,\n+\t\tFeatureName:               \"SSH login\",\n+\t})\n+\n+\tswitch {\n+\tcase actualOS == \"windows\":\n+\t\t// Windows supports user switching but should fail on nonexistent user\n+\t\tassert.False(t, result.Allowed, \"Windows should deny nonexistent user\")\n+\t\tassert.True(t, result.RequiresUserSwitching, \"Should indicate switching is needed\")\n+\t\tassert.Contains(t, result.Error.Error(), \"not found\",\n+\t\t\t\"Should indicate user not found\")\n+\tcase !actualIsPrivileged:\n+\t\t// Non-privileged Unix processes should fallback to current user\n+\t\tassert.True(t, result.Allowed, \"Non-privileged Unix process should fallback to current user\")\n+\t\tassert.False(t, result.RequiresUserSwitching, \"Fallback means no switching actually happens\")\n+\t\tassert.True(t, result.UsedFallback, \"Should indicate fallback was used\")\n+\t\tassert.NotNil(t, result.User, \"Should return current user\")\n+\tdefault:\n+\t\t// Privileged Unix processes should attempt user lookup\n+\t\tassert.False(t, result.Allowed, \"Should fail due to nonexistent user\")\n+\t\tassert.True(t, result.RequiresUserSwitching, \"Should indicate switching is needed\")\n+\t\tassert.Contains(t, result.Error.Error(), \"nonexistentuser\",\n+\t\t\t\"Should indicate user not found\")\n+\t}\n+}\n+\n+// Test platform detection logic with dependency injection\n+func TestPlatformLogic_DependencyInjection(t *testing.T) {\n+\ttests := []struct {\n+\t\tname                          string\n+\t\tos                            string\n+\t\teuid                          int\n+\t\tcurrentUser                   *user.User\n+\t\texpectedIsProcessPrivileged   bool\n+\t\texpectedSupportsUserSwitching bool\n+\t}{\n+\t\t{\n+\t\t\tname:                          \"linux_root_process\",\n+\t\t\tos:                            \"linux\",\n+\t\t\teuid:                          0,\n+\t\t\tcurrentUser:                   createTestUser(\"root\", \"0\", \"0\", \"/root\"),\n+\t\t\texpectedIsProcessPrivileged:   true,\n+\t\t\texpectedSupportsUserSwitching: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:                          \"linux_non_root_process\",\n+\t\t\tos:                            \"linux\",\n+\t\t\teuid:                          1000,\n+\t\t\tcurrentUser:                   createTestUser(\"alice\", \"1000\", \"1000\", \"/home/alice\"),\n+\t\t\texpectedIsProcessPrivileged:   false,\n+\t\t\texpectedSupportsUserSwitching: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:                          \"windows_admin_process\",\n+\t\t\tos:                            \"windows\",\n+\t\t\teuid:                          1000, // euid ignored on Windows\n+\t\t\tcurrentUser:                   createTestUser(\"Administrator\", \"S-1-5-21-123456789-123456789-123456789-500\", \"S-1-5-32-544\", \"C:\\\\Users\\\\Administrator\"),\n+\t\t\texpectedIsProcessPrivileged:   true,\n+\t\t\texpectedSupportsUserSwitching: true, // Windows supports user switching when privileged\n+\t\t},\n+\t\t{\n+\t\t\tname:                          \"windows_regular_process\",\n+\t\t\tos:                            \"windows\",\n+\t\t\teuid:                          1000, // euid ignored on Windows\n+\t\t\tcurrentUser:                   createTestUser(\"alice\", \"1001\", \"1001\", \"C:\\\\Users\\\\alice\"),\n+\t\t\texpectedIsProcessPrivileged:   false,\n+\t\t\texpectedSupportsUserSwitching: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Inject platform dependencies and test REAL logic\n+\t\t\tcleanup := setupTestDependencies(tt.currentUser, nil, tt.os, tt.euid, nil, nil)\n+\t\t\tdefer cleanup()\n+\n+\t\t\t// Test the actual functions with injected dependencies\n+\t\t\tactualIsPrivileged := isCurrentProcessPrivileged()\n+\t\t\tactualSupportsUserSwitching := actualIsPrivileged\n+\n+\t\t\tassert.Equal(t, tt.expectedIsProcessPrivileged, actualIsPrivileged,\n+\t\t\t\t\"isCurrentProcessPrivileged() result mismatch\")\n+\t\t\tassert.Equal(t, tt.expectedSupportsUserSwitching, actualSupportsUserSwitching,\n+\t\t\t\t\"supportsUserSwitching() result mismatch\")\n+\n+\t\t\tt.Logf(\"Platform: %s, EUID: %d, User: %s\", tt.os, tt.euid, tt.currentUser.Username)\n+\t\t\tt.Logf(\"Results: isPrivileged=%v, supportsUserSwitching=%v\",\n+\t\t\t\tactualIsPrivileged, actualSupportsUserSwitching)\n+\t\t})\n+\t}\n+}\n+\n+func TestCheckPrivileges_WindowsElevatedUserSwitching(t *testing.T) {\n+\t// Test Windows elevated user switching scenarios with simplified privilege logic\n+\ttests := []struct {\n+\t\tname                  string\n+\t\tcurrentUser           *user.User\n+\t\trequestedUsername     string\n+\t\tallowRoot             bool\n+\t\texpectedAllowed       bool\n+\t\texpectedErrorContains string\n+\t}{\n+\t\t{\n+\t\t\tname:              \"windows_admin_can_switch_to_alice\",\n+\t\t\tcurrentUser:       createTestUser(\"administrator\", \"S-1-5-21-123456789-123456789-123456789-500\", \"S-1-5-32-544\", \"C:\\\\\\\\Users\\\\\\\\Administrator\"),\n+\t\t\trequestedUsername: \"alice\",\n+\t\t\tallowRoot:         true,\n+\t\t\texpectedAllowed:   true,\n+\t\t},\n+\t\t{\n+\t\t\tname:              \"windows_non_admin_can_try_switch\",\n+\t\t\tcurrentUser:       createTestUser(\"alice\", \"S-1-5-21-123456789-123456789-123456789-1001\", \"S-1-5-21-123456789-123456789-123456789-513\", \"C:\\\\\\\\Users\\\\\\\\alice\"),\n+\t\t\trequestedUsername: \"bob\",\n+\t\t\tallowRoot:         true,\n+\t\t\texpectedAllowed:   true, // Privilege check allows it, OS will reject during execution\n+\t\t},\n+\t\t{\n+\t\t\tname:              \"windows_system_can_switch_to_alice\",\n+\t\t\tcurrentUser:       createTestUser(\"SYSTEM\", \"S-1-5-18\", \"S-1-5-18\", \"C:\\\\\\\\Windows\\\\\\\\system32\\\\\\\\config\\\\\\\\systemprofile\"),\n+\t\t\trequestedUsername: \"alice\",\n+\t\t\tallowRoot:         true,\n+\t\t\texpectedAllowed:   true,\n+\t\t},\n+\t\t{\n+\t\t\tname:                  \"windows_admin_root_not_allowed\",\n+\t\t\tcurrentUser:           createTestUser(\"administrator\", \"S-1-5-21-123456789-123456789-123456789-500\", \"S-1-5-32-544\", \"C:\\\\\\\\Users\\\\\\\\Administrator\"),\n+\t\t\trequestedUsername:     \"root\",\n+\t\t\tallowRoot:             false,\n+\t\t\texpectedAllowed:       false,\n+\t\t\texpectedErrorContains: \"privileged user login is disabled\",\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\t// Setup test dependencies with Windows OS and specified privileges\n+\t\t\tlookupUsers := map[string]*user.User{\n+\t\t\t\ttt.requestedUsername: createTestUser(tt.requestedUsername, \"1002\", \"1002\", \"C:\\\\\\\\Users\\\\\\\\\"+tt.requestedUsername),\n+\t\t\t}\n+\t\t\tcleanup := setupTestDependencies(tt.currentUser, nil, \"windows\", 1000, lookupUsers, nil)\n+\t\t\tdefer cleanup()\n+\n+\t\t\tserver := &Server{allowRootLogin: tt.allowRoot}\n+\n+\t\t\tresult := server.CheckPrivileges(PrivilegeCheckRequest{\n+\t\t\t\tRequestedUsername:         tt.requestedUsername,\n+\t\t\t\tFeatureSupportsUserSwitch: true,\n+\t\t\t\tFeatureName:               \"SSH login\",\n+\t\t\t})\n+\n+\t\t\tassert.Equal(t, tt.expectedAllowed, result.Allowed,\n+\t\t\t\t\"Privilege check result should match expected for %s\", tt.name)\n+\n+\t\t\tif !tt.expectedAllowed && tt.expectedErrorContains != \"\" {\n+\t\t\t\tassert.NotNil(t, result.Error, \"Should have error when not allowed\")\n+\t\t\t\tassert.Contains(t, result.Error.Error(), tt.expectedErrorContains,\n+\t\t\t\t\t\"Error should contain expected message\")\n+\t\t\t}\n+\n+\t\t\tif tt.expectedAllowed && tt.requestedUsername != \"\" && tt.currentUser.Username != tt.requestedUsername {\n+\t\t\t\tassert.True(t, result.RequiresUserSwitching, \"Should require user switching for different user\")\n+\t\t\t}\n+\t\t})\n+\t}\n+}\ndiff --git a/client/ssh/server/winpty/conpty_test.go b/client/ssh/server/winpty/conpty_test.go\nnew file mode 100644\nindex 00000000000..4f04e1fad97\n--- /dev/null\n+++ b/client/ssh/server/winpty/conpty_test.go\n@@ -0,0 +1,290 @@\n+//go:build windows\n+\n+package winpty\n+\n+import (\n+\t\"testing\"\n+\n+\tlog \"github.com/sirupsen/logrus\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\t\"golang.org/x/sys/windows\"\n+)\n+\n+func TestBuildShellArgs(t *testing.T) {\n+\ttests := []struct {\n+\t\tname     string\n+\t\tshell    string\n+\t\tcommand  string\n+\t\texpected []string\n+\t}{\n+\t\t{\n+\t\t\tname:     \"Shell with command\",\n+\t\t\tshell:    \"powershell.exe\",\n+\t\t\tcommand:  \"Get-Process\",\n+\t\t\texpected: []string{\"powershell.exe\", \"-Command\", \"Get-Process\"},\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"CMD with command\",\n+\t\t\tshell:    \"cmd.exe\",\n+\t\t\tcommand:  \"dir\",\n+\t\t\texpected: []string{\"cmd.exe\", \"-Command\", \"dir\"},\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"Shell interactive\",\n+\t\t\tshell:    \"powershell.exe\",\n+\t\t\tcommand:  \"\",\n+\t\t\texpected: []string{\"powershell.exe\"},\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"CMD interactive\",\n+\t\t\tshell:    \"cmd.exe\",\n+\t\t\tcommand:  \"\",\n+\t\t\texpected: []string{\"cmd.exe\"},\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tresult := buildShellArgs(tt.shell, tt.command)\n+\t\t\tassert.Equal(t, tt.expected, result)\n+\t\t})\n+\t}\n+}\n+\n+func TestBuildCommandLine(t *testing.T) {\n+\ttests := []struct {\n+\t\tname     string\n+\t\targs     []string\n+\t\texpected string\n+\t}{\n+\t\t{\n+\t\t\tname:     \"Simple args\",\n+\t\t\targs:     []string{\"cmd.exe\", \"/c\", \"echo\"},\n+\t\t\texpected: \"cmd.exe /c echo\",\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"Args with spaces\",\n+\t\t\targs:     []string{\"Program Files\\\\app.exe\", \"arg with spaces\"},\n+\t\t\texpected: `\"Program Files\\app.exe\" \"arg with spaces\"`,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"Args with quotes\",\n+\t\t\targs:     []string{\"cmd.exe\", \"/c\", `echo \"hello world\"`},\n+\t\t\texpected: `cmd.exe /c \"echo \\\"hello world\\\"\"`,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"PowerShell calling PowerShell\",\n+\t\t\targs:     []string{\"powershell.exe\", \"-Command\", `powershell.exe -Command \"Get-Process | Where-Object {$_.Name -eq 'notepad'}\"`},\n+\t\t\texpected: `powershell.exe -Command \"powershell.exe -Command \\\"Get-Process | Where-Object {$_.Name -eq 'notepad'}\\\"\"`,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"Complex nested quotes\",\n+\t\t\targs:     []string{\"cmd.exe\", \"/c\", `echo \"He said \\\"Hello\\\" to me\"`},\n+\t\t\texpected: `cmd.exe /c \"echo \\\"He said \\\\\\\"Hello\\\\\\\" to me\\\"\"`,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"Path with spaces and args\",\n+\t\t\targs:     []string{`C:\\Program Files\\MyApp\\app.exe`, \"--config\", `C:\\My Config\\settings.json`},\n+\t\t\texpected: `\"C:\\Program Files\\MyApp\\app.exe\" --config \"C:\\My Config\\settings.json\"`,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"Empty argument\",\n+\t\t\targs:     []string{\"cmd.exe\", \"/c\", \"echo\", \"\"},\n+\t\t\texpected: `cmd.exe /c echo \"\"`,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"Argument with backslashes\",\n+\t\t\targs:     []string{\"robocopy\", `C:\\Source\\`, `C:\\Dest\\`, \"/E\"},\n+\t\t\texpected: `robocopy C:\\Source\\ C:\\Dest\\ /E`,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"Empty args\",\n+\t\t\targs:     []string{},\n+\t\t\texpected: \"\",\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"Single arg with space\",\n+\t\t\targs:     []string{\"path with spaces\"},\n+\t\t\texpected: `\"path with spaces\"`,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tresult := buildCommandLine(tt.args)\n+\t\t\tassert.Equal(t, tt.expected, result)\n+\t\t})\n+\t}\n+}\n+\n+func TestCreateConPtyPipes(t *testing.T) {\n+\tinputRead, inputWrite, outputRead, outputWrite, err := createConPtyPipes()\n+\trequire.NoError(t, err, \"Should create ConPty pipes successfully\")\n+\n+\t// Verify all handles are valid\n+\tassert.NotEqual(t, windows.InvalidHandle, inputRead, \"Input read handle should be valid\")\n+\tassert.NotEqual(t, windows.InvalidHandle, inputWrite, \"Input write handle should be valid\")\n+\tassert.NotEqual(t, windows.InvalidHandle, outputRead, \"Output read handle should be valid\")\n+\tassert.NotEqual(t, windows.InvalidHandle, outputWrite, \"Output write handle should be valid\")\n+\n+\t// Clean up handles\n+\tcloseHandles(inputRead, inputWrite, outputRead, outputWrite)\n+}\n+\n+func TestCreateConPty(t *testing.T) {\n+\tinputRead, inputWrite, outputRead, outputWrite, err := createConPtyPipes()\n+\trequire.NoError(t, err, \"Should create ConPty pipes successfully\")\n+\tdefer closeHandles(inputRead, inputWrite, outputRead, outputWrite)\n+\n+\thPty, err := createConPty(80, 24, inputRead, outputWrite)\n+\trequire.NoError(t, err, \"Should create ConPty successfully\")\n+\tassert.NotEqual(t, windows.InvalidHandle, hPty, \"ConPty handle should be valid\")\n+\n+\t// Clean up ConPty\n+\tret, _, _ := procClosePseudoConsole.Call(uintptr(hPty))\n+\tassert.NotEqual(t, uintptr(0), ret, \"Should close ConPty successfully\")\n+}\n+\n+func TestConvertEnvironmentToUTF16(t *testing.T) {\n+\ttests := []struct {\n+\t\tname     string\n+\t\tuserEnv  []string\n+\t\thasError bool\n+\t}{\n+\t\t{\n+\t\t\tname:     \"Valid environment variables\",\n+\t\t\tuserEnv:  []string{\"PATH=C:\\\\Windows\", \"USER=testuser\", \"HOME=C:\\\\Users\\\\testuser\"},\n+\t\t\thasError: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"Empty environment\",\n+\t\t\tuserEnv:  []string{},\n+\t\t\thasError: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"Environment with empty strings\",\n+\t\t\tuserEnv:  []string{\"PATH=C:\\\\Windows\", \"\", \"USER=testuser\"},\n+\t\t\thasError: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tresult, err := convertEnvironmentToUTF16(tt.userEnv)\n+\t\t\tif tt.hasError {\n+\t\t\t\tassert.Error(t, err)\n+\t\t\t} else {\n+\t\t\t\tassert.NoError(t, err)\n+\t\t\t\tif len(tt.userEnv) == 0 {\n+\t\t\t\t\tassert.Nil(t, result, \"Empty environment should return nil\")\n+\t\t\t\t} else {\n+\t\t\t\t\tassert.NotNil(t, result, \"Non-empty environment should return valid pointer\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestDuplicateToPrimaryToken(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"Skipping token tests in short mode\")\n+\t}\n+\n+\t// Get current process token for testing\n+\tvar token windows.Token\n+\terr := windows.OpenProcessToken(windows.CurrentProcess(), windows.TOKEN_ALL_ACCESS, &token)\n+\trequire.NoError(t, err, \"Should open current process token\")\n+\tdefer func() {\n+\t\tif err := windows.CloseHandle(windows.Handle(token)); err != nil {\n+\t\t\tt.Logf(\"Failed to close token: %v\", err)\n+\t\t}\n+\t}()\n+\n+\tprimaryToken, err := duplicateToPrimaryToken(windows.Handle(token))\n+\trequire.NoError(t, err, \"Should duplicate token to primary\")\n+\tassert.NotEqual(t, windows.InvalidHandle, primaryToken, \"Primary token should be valid\")\n+\n+\t// Clean up\n+\terr = windows.CloseHandle(primaryToken)\n+\tassert.NoError(t, err, \"Should close primary token\")\n+}\n+\n+func TestWindowsHandleReader(t *testing.T) {\n+\t// Create a pipe for testing\n+\tvar readHandle, writeHandle windows.Handle\n+\terr := windows.CreatePipe(&readHandle, &writeHandle, nil, 0)\n+\trequire.NoError(t, err, \"Should create pipe for testing\")\n+\tdefer closeHandles(readHandle, writeHandle)\n+\n+\t// Write test data\n+\ttestData := []byte(\"Hello, Windows Handle Reader!\")\n+\tvar bytesWritten uint32\n+\terr = windows.WriteFile(writeHandle, testData, &bytesWritten, nil)\n+\trequire.NoError(t, err, \"Should write test data\")\n+\trequire.Equal(t, uint32(len(testData)), bytesWritten, \"Should write all test data\")\n+\n+\t// Close write handle to signal EOF\n+\tif err := windows.CloseHandle(writeHandle); err != nil {\n+\t\tt.Fatalf(\"Should close write handle: %v\", err)\n+\t}\n+\twriteHandle = windows.InvalidHandle\n+\n+\t// Test reading\n+\treader := &windowsHandleReader{handle: readHandle}\n+\tbuffer := make([]byte, len(testData))\n+\tn, err := reader.Read(buffer)\n+\trequire.NoError(t, err, \"Should read from handle\")\n+\tassert.Equal(t, len(testData), n, \"Should read expected number of bytes\")\n+\tassert.Equal(t, testData, buffer, \"Should read expected data\")\n+}\n+\n+func TestWindowsHandleWriter(t *testing.T) {\n+\t// Create a pipe for testing\n+\tvar readHandle, writeHandle windows.Handle\n+\terr := windows.CreatePipe(&readHandle, &writeHandle, nil, 0)\n+\trequire.NoError(t, err, \"Should create pipe for testing\")\n+\tdefer closeHandles(readHandle, writeHandle)\n+\n+\t// Test writing\n+\ttestData := []byte(\"Hello, Windows Handle Writer!\")\n+\twriter := &windowsHandleWriter{handle: writeHandle}\n+\tn, err := writer.Write(testData)\n+\trequire.NoError(t, err, \"Should write to handle\")\n+\tassert.Equal(t, len(testData), n, \"Should write expected number of bytes\")\n+\n+\t// Close write handle\n+\tif err := windows.CloseHandle(writeHandle); err != nil {\n+\t\tt.Fatalf(\"Should close write handle: %v\", err)\n+\t}\n+\n+\t// Verify data was written by reading it back\n+\tbuffer := make([]byte, len(testData))\n+\tvar bytesRead uint32\n+\terr = windows.ReadFile(readHandle, buffer, &bytesRead, nil)\n+\trequire.NoError(t, err, \"Should read back written data\")\n+\tassert.Equal(t, uint32(len(testData)), bytesRead, \"Should read back expected number of bytes\")\n+\tassert.Equal(t, testData, buffer, \"Should read back expected data\")\n+}\n+\n+// BenchmarkConPtyCreation benchmarks ConPty creation performance\n+func BenchmarkConPtyCreation(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tinputRead, inputWrite, outputRead, outputWrite, err := createConPtyPipes()\n+\t\tif err != nil {\n+\t\t\tb.Fatal(err)\n+\t\t}\n+\n+\t\thPty, err := createConPty(80, 24, inputRead, outputWrite)\n+\t\tif err != nil {\n+\t\t\tcloseHandles(inputRead, inputWrite, outputRead, outputWrite)\n+\t\t\tb.Fatal(err)\n+\t\t}\n+\n+\t\t// Clean up\n+\t\tif ret, _, err := procClosePseudoConsole.Call(uintptr(hPty)); ret == 0 {\n+\t\t\tlog.Debugf(\"ClosePseudoConsole failed: %v\", err)\n+\t\t}\n+\t\tcloseHandles(inputRead, inputWrite, outputRead, outputWrite)\n+\t}\n+}\ndiff --git a/client/ssh/server_test.go b/client/ssh/server_test.go\ndeleted file mode 100644\nindex 1f310c2bb6e..00000000000\n--- a/client/ssh/server_test.go\n+++ /dev/null\n@@ -1,123 +0,0 @@\n-//go:build !js\n-\n-package ssh\n-\n-import (\n-\t\"fmt\"\n-\t\"github.com/stretchr/testify/assert\"\n-\t\"golang.org/x/crypto/ssh\"\n-\t\"strings\"\n-\t\"testing\"\n-)\n-\n-func TestServer_AddAuthorizedKey(t *testing.T) {\n-\tkey, err := GeneratePrivateKey(ED25519)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tserver, err := newDefaultServer(key, \"localhost:\")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\n-\t// add multiple keys\n-\tkeys := map[string][]byte{}\n-\tfor i := 0; i < 10; i++ {\n-\t\tpeer := fmt.Sprintf(\"%s-%d\", \"remotePeer\", i)\n-\t\tremotePrivKey, err := GeneratePrivateKey(ED25519)\n-\t\tif err != nil {\n-\t\t\tt.Fatal(err)\n-\t\t}\n-\t\tremotePubKey, err := GeneratePublicKey(remotePrivKey)\n-\t\tif err != nil {\n-\t\t\tt.Fatal(err)\n-\t\t}\n-\n-\t\terr = server.AddAuthorizedKey(peer, string(remotePubKey))\n-\t\tif err != nil {\n-\t\t\tt.Error(err)\n-\t\t}\n-\t\tkeys[peer] = remotePubKey\n-\t}\n-\n-\t// make sure that all keys have been added\n-\tfor peer, remotePubKey := range keys {\n-\t\tk, ok := server.authorizedKeys[peer]\n-\t\tassert.True(t, ok, \"expecting remotePeer key to be found in authorizedKeys\")\n-\n-\t\tassert.Equal(t, string(remotePubKey), strings.TrimSpace(string(ssh.MarshalAuthorizedKey(k))))\n-\t}\n-\n-}\n-\n-func TestServer_RemoveAuthorizedKey(t *testing.T) {\n-\tkey, err := GeneratePrivateKey(ED25519)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tserver, err := newDefaultServer(key, \"localhost:\")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\n-\tremotePrivKey, err := GeneratePrivateKey(ED25519)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tremotePubKey, err := GeneratePublicKey(remotePrivKey)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\n-\terr = server.AddAuthorizedKey(\"remotePeer\", string(remotePubKey))\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t}\n-\n-\tserver.RemoveAuthorizedKey(\"remotePeer\")\n-\n-\t_, ok := server.authorizedKeys[\"remotePeer\"]\n-\tassert.False(t, ok, \"expecting remotePeer's SSH key to be removed\")\n-}\n-\n-func TestServer_PubKeyHandler(t *testing.T) {\n-\tkey, err := GeneratePrivateKey(ED25519)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tserver, err := newDefaultServer(key, \"localhost:\")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\n-\tvar keys []ssh.PublicKey\n-\tfor i := 0; i < 10; i++ {\n-\t\tpeer := fmt.Sprintf(\"%s-%d\", \"remotePeer\", i)\n-\t\tremotePrivKey, err := GeneratePrivateKey(ED25519)\n-\t\tif err != nil {\n-\t\t\tt.Fatal(err)\n-\t\t}\n-\t\tremotePubKey, err := GeneratePublicKey(remotePrivKey)\n-\t\tif err != nil {\n-\t\t\tt.Fatal(err)\n-\t\t}\n-\n-\t\tremoteParsedPubKey, _, _, _, err := ssh.ParseAuthorizedKey(remotePubKey)\n-\t\tif err != nil {\n-\t\t\tt.Fatal(err)\n-\t\t}\n-\n-\t\terr = server.AddAuthorizedKey(peer, string(remotePubKey))\n-\t\tif err != nil {\n-\t\t\tt.Error(err)\n-\t\t}\n-\t\tkeys = append(keys, remoteParsedPubKey)\n-\t}\n-\n-\tfor _, key := range keys {\n-\t\taccepted := server.publicKeyHandler(nil, key)\n-\n-\t\tassert.Truef(t, accepted, \"expecting SSH connection to be accepted for a given SSH key %s\", string(ssh.MarshalAuthorizedKey(key)))\n-\t}\n-\n-}\ndiff --git a/client/ssh/testutil/user_helpers.go b/client/ssh/testutil/user_helpers.go\nnew file mode 100644\nindex 00000000000..0c122207884\n--- /dev/null\n+++ b/client/ssh/testutil/user_helpers.go\n@@ -0,0 +1,172 @@\n+package testutil\n+\n+import (\n+\t\"fmt\"\n+\t\"log\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"os/user\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+var testCreatedUsers = make(map[string]bool)\n+var testUsersToCleanup []string\n+\n+// GetTestUsername returns an appropriate username for testing\n+func GetTestUsername(t *testing.T) string {\n+\tif runtime.GOOS == \"windows\" {\n+\t\tcurrentUser, err := user.Current()\n+\t\trequire.NoError(t, err, \"Should be able to get current user\")\n+\n+\t\tif IsSystemAccount(currentUser.Username) {\n+\t\t\tif IsCI() {\n+\t\t\t\tif testUser := GetOrCreateTestUser(t); testUser != \"\" {\n+\t\t\t\t\treturn testUser\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif _, err := user.Lookup(\"Administrator\"); err == nil {\n+\t\t\t\t\treturn \"Administrator\"\n+\t\t\t\t}\n+\t\t\t\tif testUser := GetOrCreateTestUser(t); testUser != \"\" {\n+\t\t\t\t\treturn testUser\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn currentUser.Username\n+\t}\n+\n+\tcurrentUser, err := user.Current()\n+\trequire.NoError(t, err, \"Should be able to get current user\")\n+\treturn currentUser.Username\n+}\n+\n+// IsCI checks if we're running in a CI environment\n+func IsCI() bool {\n+\tif os.Getenv(\"GITHUB_ACTIONS\") == \"true\" || os.Getenv(\"CI\") == \"true\" {\n+\t\treturn true\n+\t}\n+\n+\thostname, err := os.Hostname()\n+\tif err == nil && strings.HasPrefix(hostname, \"runner\") {\n+\t\treturn true\n+\t}\n+\n+\treturn false\n+}\n+\n+// IsSystemAccount checks if the user is a system account that can't authenticate\n+func IsSystemAccount(username string) bool {\n+\tsystemAccounts := []string{\n+\t\t\"system\",\n+\t\t\"NT AUTHORITY\\\\SYSTEM\",\n+\t\t\"NT AUTHORITY\\\\LOCAL SERVICE\",\n+\t\t\"NT AUTHORITY\\\\NETWORK SERVICE\",\n+\t}\n+\n+\tfor _, sysAccount := range systemAccounts {\n+\t\tif strings.EqualFold(username, sysAccount) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+// RegisterTestUserCleanup registers a test user for cleanup\n+func RegisterTestUserCleanup(username string) {\n+\tif !testCreatedUsers[username] {\n+\t\ttestCreatedUsers[username] = true\n+\t\ttestUsersToCleanup = append(testUsersToCleanup, username)\n+\t}\n+}\n+\n+// CleanupTestUsers removes all created test users\n+func CleanupTestUsers() {\n+\tfor _, username := range testUsersToCleanup {\n+\t\tRemoveWindowsTestUser(username)\n+\t}\n+\ttestUsersToCleanup = nil\n+\ttestCreatedUsers = make(map[string]bool)\n+}\n+\n+// GetOrCreateTestUser creates a test user on Windows if needed\n+func GetOrCreateTestUser(t *testing.T) string {\n+\ttestUsername := \"netbird-test-user\"\n+\n+\tif _, err := user.Lookup(testUsername); err == nil {\n+\t\treturn testUsername\n+\t}\n+\n+\tif CreateWindowsTestUser(t, testUsername) {\n+\t\tRegisterTestUserCleanup(testUsername)\n+\t\treturn testUsername\n+\t}\n+\n+\treturn \"\"\n+}\n+\n+// RemoveWindowsTestUser removes a local user on Windows using PowerShell\n+func RemoveWindowsTestUser(username string) {\n+\tif runtime.GOOS != \"windows\" {\n+\t\treturn\n+\t}\n+\n+\tpsCmd := fmt.Sprintf(`\n+\t\ttry {\n+\t\t\tRemove-LocalUser -Name \"%s\" -ErrorAction Stop\n+\t\t\tWrite-Output \"User removed successfully\"\n+\t\t} catch {\n+\t\t\tif ($_.Exception.Message -like \"*cannot be found*\") {\n+\t\t\t\tWrite-Output \"User not found (already removed)\"\n+\t\t\t} else {\n+\t\t\t\tWrite-Error $_.Exception.Message\n+\t\t\t}\n+\t\t}\n+\t`, username)\n+\n+\tcmd := exec.Command(\"powershell\", \"-Command\", psCmd)\n+\toutput, err := cmd.CombinedOutput()\n+\n+\tif err != nil {\n+\t\tlog.Printf(\"Failed to remove test user %s: %v, output: %s\", username, err, string(output))\n+\t} else {\n+\t\tlog.Printf(\"Test user %s cleanup result: %s\", username, string(output))\n+\t}\n+}\n+\n+// CreateWindowsTestUser creates a local user on Windows using PowerShell\n+func CreateWindowsTestUser(t *testing.T, username string) bool {\n+\tif runtime.GOOS != \"windows\" {\n+\t\treturn false\n+\t}\n+\n+\tpsCmd := fmt.Sprintf(`\n+\t\ttry {\n+\t\t\t$password = ConvertTo-SecureString \"TestPassword123!\" -AsPlainText -Force\n+\t\t\tNew-LocalUser -Name \"%s\" -Password $password -Description \"NetBird test user\" -UserMayNotChangePassword -PasswordNeverExpires\n+\t\t\tAdd-LocalGroupMember -Group \"Users\" -Member \"%s\"\n+\t\t\tWrite-Output \"User created successfully\"\n+\t\t} catch {\n+\t\t\tif ($_.Exception.Message -like \"*already exists*\") {\n+\t\t\t\tWrite-Output \"User already exists\"\n+\t\t\t} else {\n+\t\t\t\tWrite-Error $_.Exception.Message\n+\t\t\t\texit 1\n+\t\t\t}\n+\t\t}\n+\t`, username, username)\n+\n+\tcmd := exec.Command(\"powershell\", \"-Command\", psCmd)\n+\toutput, err := cmd.CombinedOutput()\n+\n+\tif err != nil {\n+\t\tt.Logf(\"Failed to create test user: %v, output: %s\", err, string(output))\n+\t\treturn false\n+\t}\n+\n+\tt.Logf(\"Test user creation result: %s\", string(output))\n+\treturn true\n+}\ndiff --git a/client/status/status_test.go b/client/status/status_test.go\nindex 660efd9ef04..1dca1e5b16d 100644\n--- a/client/status/status_test.go\n+++ b/client/status/status_test.go\n@@ -231,6 +231,10 @@ var overview = OutputOverview{\n \tNetworks: []string{\n \t\t\"10.10.0.0/24\",\n \t},\n+\tSSHServerState: SSHServerStateOutput{\n+\t\tEnabled:  false,\n+\t\tSessions: []SSHSessionOutput{},\n+\t},\n }\n \n func TestConversionFromFullStatusToOutputOverview(t *testing.T) {\n@@ -385,7 +389,11 @@ func TestParsingToJSON(t *testing.T) {\n           ],\n           \"events\": [],\n           \"lazyConnectionEnabled\": false,\n-\t\t  \"profileName\":\"\"\n+\t\t  \"profileName\":\"\",\n+\t\t  \"sshServer\":{\n+\t\t    \"enabled\":false,\n+\t\t\t\"sessions\":[]\n+\t\t  }\n         }`\n \t// @formatter:on\n \n@@ -488,6 +496,9 @@ dnsServers:\n events: []\n lazyConnectionEnabled: false\n profileName: \"\"\n+sshServer:\n+    enabled: false\n+    sessions: []\n `\n \n \tassert.Equal(t, expectedYAML, yaml)\n@@ -554,6 +565,7 @@ NetBird IP: 192.168.178.100/16\n Interface type: Kernel\n Quantum resistance: false\n Lazy connection: false\n+SSH Server: Disabled\n Networks: 10.10.0.0/24\n Forwarding rules: 0\n Peers count: 2/2 Connected\n@@ -563,7 +575,7 @@ Peers count: 2/2 Connected\n }\n \n func TestParsingToShortVersion(t *testing.T) {\n-\tshortVersion := ParseGeneralSummary(overview, false, false, false)\n+\tshortVersion := ParseGeneralSummary(overview, false, false, false, false)\n \n \texpectedString := fmt.Sprintf(\"OS: %s/%s\", runtime.GOOS, runtime.GOARCH) + `\n Daemon version: 0.14.1\n@@ -578,6 +590,7 @@ NetBird IP: 192.168.178.100/16\n Interface type: Kernel\n Quantum resistance: false\n Lazy connection: false\n+SSH Server: Disabled\n Networks: 10.10.0.0/24\n Forwarding rules: 0\n Peers count: 2/2 Connected\ndiff --git a/management/server/account_test.go b/management/server/account_test.go\nindex ee9950796e0..10d718bbf6a 100644\n--- a/management/server/account_test.go\n+++ b/management/server/account_test.go\n@@ -28,7 +28,6 @@ import (\n \tnbAccount \"github.com/netbirdio/netbird/management/server/account\"\n \t\"github.com/netbirdio/netbird/management/server/activity\"\n \t\"github.com/netbirdio/netbird/management/server/cache\"\n-\tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/http/testing/testing_tools\"\n \t\"github.com/netbirdio/netbird/management/server/idp\"\n \t\"github.com/netbirdio/netbird/management/server/integrations/port_forwarding\"\n@@ -45,6 +44,7 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/types\"\n \t\"github.com/netbirdio/netbird/management/server/util\"\n \t\"github.com/netbirdio/netbird/route\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n )\n \n func verifyCanAddPeerToAccount(t *testing.T, manager nbAccount.Manager, account *types.Account, userID string) {\n@@ -445,7 +445,7 @@ func TestAccountManager_GetOrCreateAccountByUser(t *testing.T) {\n }\n \n func TestDefaultAccountManager_GetAccountIDFromToken(t *testing.T) {\n-\ttype initUserParams nbcontext.UserAuth\n+\ttype initUserParams auth.UserAuth\n \n \tvar (\n \t\tpublicDomain  = \"public.com\"\n@@ -468,7 +468,7 @@ func TestDefaultAccountManager_GetAccountIDFromToken(t *testing.T) {\n \n \ttestCases := []struct {\n \t\tname                        string\n-\t\tinputClaims                 nbcontext.UserAuth\n+\t\tinputClaims                 auth.UserAuth\n \t\tinputInitUserParams         initUserParams\n \t\tinputUpdateAttrs            bool\n \t\tinputUpdateClaimAccount     bool\n@@ -483,7 +483,7 @@ func TestDefaultAccountManager_GetAccountIDFromToken(t *testing.T) {\n \t}{\n \t\t{\n \t\t\tname: \"New User With Public Domain\",\n-\t\t\tinputClaims: nbcontext.UserAuth{\n+\t\t\tinputClaims: auth.UserAuth{\n \t\t\t\tDomain:         publicDomain,\n \t\t\t\tUserId:         \"pub-domain-user\",\n \t\t\t\tDomainCategory: types.PublicCategory,\n@@ -500,7 +500,7 @@ func TestDefaultAccountManager_GetAccountIDFromToken(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname: \"New User With Unknown Domain\",\n-\t\t\tinputClaims: nbcontext.UserAuth{\n+\t\t\tinputClaims: auth.UserAuth{\n \t\t\t\tDomain:         unknownDomain,\n \t\t\t\tUserId:         \"unknown-domain-user\",\n \t\t\t\tDomainCategory: types.UnknownCategory,\n@@ -517,7 +517,7 @@ func TestDefaultAccountManager_GetAccountIDFromToken(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname: \"New User With Private Domain\",\n-\t\t\tinputClaims: nbcontext.UserAuth{\n+\t\t\tinputClaims: auth.UserAuth{\n \t\t\t\tDomain:         privateDomain,\n \t\t\t\tUserId:         \"pvt-domain-user\",\n \t\t\t\tDomainCategory: types.PrivateCategory,\n@@ -534,7 +534,7 @@ func TestDefaultAccountManager_GetAccountIDFromToken(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname: \"New Regular User With Existing Private Domain\",\n-\t\t\tinputClaims: nbcontext.UserAuth{\n+\t\t\tinputClaims: auth.UserAuth{\n \t\t\t\tDomain:         privateDomain,\n \t\t\t\tUserId:         \"new-pvt-domain-user\",\n \t\t\t\tDomainCategory: types.PrivateCategory,\n@@ -552,7 +552,7 @@ func TestDefaultAccountManager_GetAccountIDFromToken(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname: \"Existing User With Existing Reclassified Private Domain\",\n-\t\t\tinputClaims: nbcontext.UserAuth{\n+\t\t\tinputClaims: auth.UserAuth{\n \t\t\t\tDomain:         defaultInitAccount.Domain,\n \t\t\t\tUserId:         defaultInitAccount.UserId,\n \t\t\t\tDomainCategory: types.PrivateCategory,\n@@ -569,7 +569,7 @@ func TestDefaultAccountManager_GetAccountIDFromToken(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname: \"Existing Account Id With Existing Reclassified Private Domain\",\n-\t\t\tinputClaims: nbcontext.UserAuth{\n+\t\t\tinputClaims: auth.UserAuth{\n \t\t\t\tDomain:         defaultInitAccount.Domain,\n \t\t\t\tUserId:         defaultInitAccount.UserId,\n \t\t\t\tDomainCategory: types.PrivateCategory,\n@@ -587,7 +587,7 @@ func TestDefaultAccountManager_GetAccountIDFromToken(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname: \"User With Private Category And Empty Domain\",\n-\t\t\tinputClaims: nbcontext.UserAuth{\n+\t\t\tinputClaims: auth.UserAuth{\n \t\t\t\tDomain:         \"\",\n \t\t\t\tUserId:         \"pvt-domain-user\",\n \t\t\t\tDomainCategory: types.PrivateCategory,\n@@ -616,7 +616,7 @@ func TestDefaultAccountManager_GetAccountIDFromToken(t *testing.T) {\n \t\t\trequire.NoError(t, err, \"get init account failed\")\n \n \t\t\tif testCase.inputUpdateAttrs {\n-\t\t\t\terr = manager.updateAccountDomainAttributesIfNotUpToDate(context.Background(), initAccount.Id, nbcontext.UserAuth{UserId: testCase.inputInitUserParams.UserId, Domain: testCase.inputInitUserParams.Domain, DomainCategory: testCase.inputInitUserParams.DomainCategory}, true)\n+\t\t\t\terr = manager.updateAccountDomainAttributesIfNotUpToDate(context.Background(), initAccount.Id, auth.UserAuth{UserId: testCase.inputInitUserParams.UserId, Domain: testCase.inputInitUserParams.Domain, DomainCategory: testCase.inputInitUserParams.DomainCategory}, true)\n \t\t\t\trequire.NoError(t, err, \"update init user failed\")\n \t\t\t}\n \n@@ -656,7 +656,7 @@ func TestDefaultAccountManager_SyncUserJWTGroups(t *testing.T) {\n \t// it is important to set the id as it help to avoid creating additional account with empty Id and re-pointing indices to it\n \tinitAccount, err := manager.Store.GetAccount(context.Background(), accountID)\n \trequire.NoError(t, err, \"get init account failed\")\n-\tclaims := nbcontext.UserAuth{\n+\tclaims := auth.UserAuth{\n \t\tAccountId:      accountID, // is empty as it is based on accountID right after initialization of initAccount\n \t\tDomain:         domain,\n \t\tUserId:         userId,\n@@ -915,13 +915,13 @@ func TestAccountManager_DeleteAccount(t *testing.T) {\n }\n \n func BenchmarkTest_GetAccountWithclaims(b *testing.B) {\n-\tclaims := nbcontext.UserAuth{\n+\tclaims := auth.UserAuth{\n \t\tDomain:         \"example.com\",\n \t\tUserId:         \"pvt-domain-user\",\n \t\tDomainCategory: types.PrivateCategory,\n \t}\n \n-\tpublicClaims := nbcontext.UserAuth{\n+\tpublicClaims := auth.UserAuth{\n \t\tDomain:         \"test.com\",\n \t\tUserId:         \"public-domain-user\",\n \t\tDomainCategory: types.PublicCategory,\n@@ -2709,7 +2709,7 @@ func TestAccount_SetJWTGroups(t *testing.T) {\n \tassert.NoError(t, manager.Store.SaveAccount(context.Background(), account), \"unable to save account\")\n \n \tt.Run(\"skip sync for token auth type\", func(t *testing.T) {\n-\t\tclaims := nbcontext.UserAuth{\n+\t\tclaims := auth.UserAuth{\n \t\t\tUserId:    \"user1\",\n \t\t\tAccountId: \"accountID\",\n \t\t\tGroups:    []string{\"group3\"},\n@@ -2724,7 +2724,7 @@ func TestAccount_SetJWTGroups(t *testing.T) {\n \t})\n \n \tt.Run(\"empty jwt groups\", func(t *testing.T) {\n-\t\tclaims := nbcontext.UserAuth{\n+\t\tclaims := auth.UserAuth{\n \t\t\tUserId:    \"user1\",\n \t\t\tAccountId: \"accountID\",\n \t\t\tGroups:    []string{},\n@@ -2738,7 +2738,7 @@ func TestAccount_SetJWTGroups(t *testing.T) {\n \t})\n \n \tt.Run(\"jwt match existing api group\", func(t *testing.T) {\n-\t\tclaims := nbcontext.UserAuth{\n+\t\tclaims := auth.UserAuth{\n \t\t\tUserId:    \"user1\",\n \t\t\tAccountId: \"accountID\",\n \t\t\tGroups:    []string{\"group1\"},\n@@ -2759,7 +2759,7 @@ func TestAccount_SetJWTGroups(t *testing.T) {\n \t\taccount.Users[\"user1\"].AutoGroups = []string{\"group1\"}\n \t\tassert.NoError(t, manager.Store.SaveUser(context.Background(), account.Users[\"user1\"]))\n \n-\t\tclaims := nbcontext.UserAuth{\n+\t\tclaims := auth.UserAuth{\n \t\t\tUserId:    \"user1\",\n \t\t\tAccountId: \"accountID\",\n \t\t\tGroups:    []string{\"group1\"},\n@@ -2777,7 +2777,7 @@ func TestAccount_SetJWTGroups(t *testing.T) {\n \t})\n \n \tt.Run(\"add jwt group\", func(t *testing.T) {\n-\t\tclaims := nbcontext.UserAuth{\n+\t\tclaims := auth.UserAuth{\n \t\t\tUserId:    \"user1\",\n \t\t\tAccountId: \"accountID\",\n \t\t\tGroups:    []string{\"group1\", \"group2\"},\n@@ -2791,7 +2791,7 @@ func TestAccount_SetJWTGroups(t *testing.T) {\n \t})\n \n \tt.Run(\"existed group not update\", func(t *testing.T) {\n-\t\tclaims := nbcontext.UserAuth{\n+\t\tclaims := auth.UserAuth{\n \t\t\tUserId:    \"user1\",\n \t\t\tAccountId: \"accountID\",\n \t\t\tGroups:    []string{\"group2\"},\n@@ -2805,7 +2805,7 @@ func TestAccount_SetJWTGroups(t *testing.T) {\n \t})\n \n \tt.Run(\"add new group\", func(t *testing.T) {\n-\t\tclaims := nbcontext.UserAuth{\n+\t\tclaims := auth.UserAuth{\n \t\t\tUserId:    \"user2\",\n \t\t\tAccountId: \"accountID\",\n \t\t\tGroups:    []string{\"group1\", \"group3\"},\n@@ -2823,7 +2823,7 @@ func TestAccount_SetJWTGroups(t *testing.T) {\n \t})\n \n \tt.Run(\"remove all JWT groups when list is empty\", func(t *testing.T) {\n-\t\tclaims := nbcontext.UserAuth{\n+\t\tclaims := auth.UserAuth{\n \t\t\tUserId:    \"user1\",\n \t\t\tAccountId: \"accountID\",\n \t\t\tGroups:    []string{},\n@@ -2838,7 +2838,7 @@ func TestAccount_SetJWTGroups(t *testing.T) {\n \t})\n \n \tt.Run(\"remove all JWT groups when claim does not exist\", func(t *testing.T) {\n-\t\tclaims := nbcontext.UserAuth{\n+\t\tclaims := auth.UserAuth{\n \t\t\tUserId:    \"user2\",\n \t\t\tAccountId: \"accountID\",\n \t\t\tGroups:    []string{},\n@@ -2959,7 +2959,7 @@ func createManager(t testing.TB) (*DefaultAccountManager, *update_channel.PeersU\n \tupdateManager := update_channel.NewPeersUpdateManager(metrics)\n \trequestBuffer := NewAccountRequestBuffer(ctx, store)\n \tnetworkMapController := controller.NewController(ctx, store, metrics, updateManager, requestBuffer, MockIntegratedValidator{}, settingsMockManager, \"netbird.cloud\", port_forwarding.NewControllerMock())\n-\tmanager, err := BuildManager(ctx, store, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n+\tmanager, err := BuildManager(ctx, nil, store, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n \tif err != nil {\n \t\treturn nil, nil, err\n \t}\n@@ -3692,7 +3692,7 @@ func TestAddNewUserToDomainAccountWithApproval(t *testing.T) {\n \n \t// Test adding new user to existing account with approval required\n \tnewUserID := \"new-user-id\"\n-\tuserAuth := nbcontext.UserAuth{\n+\tuserAuth := auth.UserAuth{\n \t\tUserId:         newUserID,\n \t\tDomain:         \"example.com\",\n \t\tDomainCategory: types.PrivateCategory,\n@@ -3722,7 +3722,7 @@ func TestAddNewUserToDomainAccountWithoutApproval(t *testing.T) {\n \t}\n \n \t// Create a domain-based account without user approval\n-\townerUserAuth := nbcontext.UserAuth{\n+\townerUserAuth := auth.UserAuth{\n \t\tUserId:         \"owner-user\",\n \t\tDomain:         \"example.com\",\n \t\tDomainCategory: types.PrivateCategory,\n@@ -3741,7 +3741,7 @@ func TestAddNewUserToDomainAccountWithoutApproval(t *testing.T) {\n \n \t// Test adding new user to existing account without approval required\n \tnewUserID := \"new-user-id\"\n-\tuserAuth := nbcontext.UserAuth{\n+\tuserAuth := auth.UserAuth{\n \t\tUserId:         newUserID,\n \t\tDomain:         \"example.com\",\n \t\tDomainCategory: types.PrivateCategory,\ndiff --git a/management/server/auth/manager_test.go b/management/server/auth/manager_test.go\nindex c8015eb370f..b9f091b1ee8 100644\n--- a/management/server/auth/manager_test.go\n+++ b/management/server/auth/manager_test.go\n@@ -17,10 +17,10 @@ import (\n \t\"github.com/stretchr/testify/require\"\n \n \t\"github.com/netbirdio/netbird/management/server/auth\"\n-\tnbjwt \"github.com/netbirdio/netbird/management/server/auth/jwt\"\n-\tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/store\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n+\tnbauth \"github.com/netbirdio/netbird/shared/auth\"\n+\tnbjwt \"github.com/netbirdio/netbird/shared/auth/jwt\"\n )\n \n func TestAuthManager_GetAccountInfoFromPAT(t *testing.T) {\n@@ -131,7 +131,7 @@ func TestAuthManager_EnsureUserAccessByJWTGroups(t *testing.T) {\n \t}\n \n \t// this has been validated and parsed by ValidateAndParseToken\n-\tuserAuth := nbcontext.UserAuth{\n+\tuserAuth := nbauth.UserAuth{\n \t\tAccountId:      account.Id,\n \t\tDomain:         domain,\n \t\tUserId:         userId,\n@@ -236,7 +236,7 @@ func TestAuthManager_ValidateAndParseToken(t *testing.T) {\n \ttests := []struct {\n \t\tname      string\n \t\ttokenFunc func() string\n-\t\texpected  *nbcontext.UserAuth // nil indicates expected error\n+\t\texpected  *nbauth.UserAuth // nil indicates expected error\n \t}{\n \t\t{\n \t\t\tname: \"Valid with custom claims\",\n@@ -258,7 +258,7 @@ func TestAuthManager_ValidateAndParseToken(t *testing.T) {\n \t\t\t\ttokenString, _ := token.SignedString(key)\n \t\t\t\treturn tokenString\n \t\t\t},\n-\t\t\texpected: &nbcontext.UserAuth{\n+\t\t\texpected: &nbauth.UserAuth{\n \t\t\t\tUserId:         \"user-id|123\",\n \t\t\t\tAccountId:      \"account-id|567\",\n \t\t\t\tDomain:         \"http://localhost\",\n@@ -282,7 +282,7 @@ func TestAuthManager_ValidateAndParseToken(t *testing.T) {\n \t\t\t\ttokenString, _ := token.SignedString(key)\n \t\t\t\treturn tokenString\n \t\t\t},\n-\t\t\texpected: &nbcontext.UserAuth{\n+\t\t\texpected: &nbauth.UserAuth{\n \t\t\t\tUserId: \"user-id|123\",\n \t\t\t},\n \t\t},\ndiff --git a/management/server/dns_test.go b/management/server/dns_test.go\nindex 356a2f64048..6b7a36c20d7 100644\n--- a/management/server/dns_test.go\n+++ b/management/server/dns_test.go\n@@ -224,7 +224,7 @@ func createDNSManager(t *testing.T) (*DefaultAccountManager, error) {\n \trequestBuffer := NewAccountRequestBuffer(ctx, store)\n \tnetworkMapController := controller.NewController(ctx, store, metrics, updateManager, requestBuffer, MockIntegratedValidator{}, settingsMockManager, \"netbird.test\", port_forwarding.NewControllerMock())\n \n-\treturn BuildManager(context.Background(), store, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n+\treturn BuildManager(context.Background(), nil, store, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n }\n \n func createDNSStore(t *testing.T) (store.Store, error) {\ndiff --git a/management/server/http/handlers/accounts/accounts_handler_test.go b/management/server/http/handlers/accounts/accounts_handler_test.go\nindex 4b9b79fdc18..c5c48ef3210 100644\n--- a/management/server/http/handlers/accounts/accounts_handler_test.go\n+++ b/management/server/http/handlers/accounts/accounts_handler_test.go\n@@ -18,6 +18,7 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n \t\"github.com/netbirdio/netbird/management/server/settings\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n \t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n@@ -236,7 +237,7 @@ func TestAccounts_AccountsHandler(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    adminUser.Id,\n \t\t\t\tAccountId: accountID,\n \t\t\t\tDomain:    \"hotmail.com\",\ndiff --git a/management/server/http/handlers/dns/dns_settings_handler_test.go b/management/server/http/handlers/dns/dns_settings_handler_test.go\nindex 42b519c292e..a027c067e36 100644\n--- a/management/server/http/handlers/dns/dns_settings_handler_test.go\n+++ b/management/server/http/handlers/dns/dns_settings_handler_test.go\n@@ -11,13 +11,14 @@ import (\n \n \t\"github.com/stretchr/testify/assert\"\n \n+\t\"github.com/netbirdio/netbird/management/server/types\"\n \t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n-\t\"github.com/netbirdio/netbird/management/server/types\"\n \n \t\"github.com/gorilla/mux\"\n \n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n \n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n )\n@@ -107,7 +108,7 @@ func TestDNSSettingsHandlers(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    testingDNSSettingsAccount.Users[testDNSSettingsUserID].Id,\n \t\t\t\tAccountId: testingDNSSettingsAccount.Id,\n \t\t\t\tDomain:    testingDNSSettingsAccount.Domain,\ndiff --git a/management/server/http/handlers/dns/nameservers_handler_test.go b/management/server/http/handlers/dns/nameservers_handler_test.go\nindex d49b6c7e063..4716782f3fa 100644\n--- a/management/server/http/handlers/dns/nameservers_handler_test.go\n+++ b/management/server/http/handlers/dns/nameservers_handler_test.go\n@@ -19,6 +19,7 @@ import (\n \t\"github.com/gorilla/mux\"\n \n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n \n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n )\n@@ -193,7 +194,7 @@ func TestNameserversHandlers(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"test_user\",\n \t\t\t\tAccountId: testNSGroupAccountID,\n \t\t\t\tDomain:    \"hotmail.com\",\ndiff --git a/management/server/http/handlers/events/events_handler_test.go b/management/server/http/handlers/events/events_handler_test.go\nindex a0695fa3fa4..923a24e31e5 100644\n--- a/management/server/http/handlers/events/events_handler_test.go\n+++ b/management/server/http/handlers/events/events_handler_test.go\n@@ -14,11 +14,12 @@ import (\n \t\"github.com/stretchr/testify/assert\"\n \n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n \n \t\"github.com/netbirdio/netbird/management/server/activity\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n )\n \n func initEventsTestData(account string, events ...*activity.Event) *handler {\n@@ -188,7 +189,7 @@ func TestEvents_GetEvents(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"test_user\",\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_account\",\ndiff --git a/management/server/http/handlers/groups/groups_handler_test.go b/management/server/http/handlers/groups/groups_handler_test.go\nindex 34694ec8c4a..b7dd3944a2b 100644\n--- a/management/server/http/handlers/groups/groups_handler_test.go\n+++ b/management/server/http/handlers/groups/groups_handler_test.go\n@@ -19,12 +19,13 @@ import (\n \n \t\"github.com/netbirdio/netbird/management/server\"\n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/util\"\n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n \tnbpeer \"github.com/netbirdio/netbird/management/server/peer\"\n-\t\"github.com/netbirdio/netbird/shared/management/status\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/util\"\n+\t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n \n var TestPeers = map[string]*nbpeer.Peer{\n@@ -122,7 +123,7 @@ func TestGetGroup(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"test_user\",\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_id\",\n@@ -248,7 +249,7 @@ func TestWriteGroup(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"test_user\",\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_id\",\n@@ -330,7 +331,7 @@ func TestDeleteGroup(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, nil)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"test_user\",\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_id\",\ndiff --git a/management/server/http/handlers/peers/peers_handler_test.go b/management/server/http/handlers/peers/peers_handler_test.go\nindex 7a5a6d91129..ddf2e2a7062 100644\n--- a/management/server/http/handlers/peers/peers_handler_test.go\n+++ b/management/server/http/handlers/peers/peers_handler_test.go\n@@ -21,6 +21,7 @@ import (\n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \tnbpeer \"github.com/netbirdio/netbird/management/server/peer\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n \t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \n \t\"github.com/stretchr/testify/assert\"\n@@ -296,7 +297,7 @@ func TestGetPeers(t *testing.T) {\n \n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"admin_user\",\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_id\",\n@@ -444,7 +445,7 @@ func TestGetAccessiblePeers(t *testing.T) {\n \n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(http.MethodGet, fmt.Sprintf(\"/api/peers/%s/accessible-peers\", tc.peerID), nil)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    tc.callerUserID,\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_id\",\n@@ -527,7 +528,7 @@ func TestPeersHandlerUpdatePeerIP(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\treq := httptest.NewRequest(http.MethodPut, fmt.Sprintf(\"/peers/%s\", tc.peerID), bytes.NewBuffer([]byte(tc.requestBody)))\n \t\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    tc.callerUserID,\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_id\",\ndiff --git a/management/server/http/handlers/policies/geolocation_handler_test.go b/management/server/http/handlers/policies/geolocation_handler_test.go\nindex cedd5ac8872..094a36e38f3 100644\n--- a/management/server/http/handlers/policies/geolocation_handler_test.go\n+++ b/management/server/http/handlers/policies/geolocation_handler_test.go\n@@ -16,12 +16,13 @@ import (\n \n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/geolocation\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n \t\"github.com/netbirdio/netbird/management/server/permissions\"\n \t\"github.com/netbirdio/netbird/management/server/permissions/modules\"\n \t\"github.com/netbirdio/netbird/management/server/permissions/operations\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/util\"\n )\n \n@@ -113,7 +114,7 @@ func TestGetCitiesByCountry(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, nil)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"test_user\",\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_id\",\n@@ -206,7 +207,7 @@ func TestGetAllCountries(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, nil)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"test_user\",\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_id\",\ndiff --git a/management/server/http/handlers/policies/policies_handler_test.go b/management/server/http/handlers/policies/policies_handler_test.go\nindex fd39ae2a3bc..ca5a0a6abfb 100644\n--- a/management/server/http/handlers/policies/policies_handler_test.go\n+++ b/management/server/http/handlers/policies/policies_handler_test.go\n@@ -14,10 +14,11 @@ import (\n \t\"github.com/stretchr/testify/assert\"\n \n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n-\t\"github.com/netbirdio/netbird/shared/management/status\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n+\t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n \n func initPoliciesTestData(policies ...*types.Policy) *handler {\n@@ -103,7 +104,7 @@ func TestPoliciesGetPolicy(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"test_user\",\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_id\",\n@@ -267,7 +268,7 @@ func TestPoliciesWritePolicy(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"test_user\",\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_id\",\ndiff --git a/management/server/http/handlers/policies/posture_checks_handler_test.go b/management/server/http/handlers/policies/posture_checks_handler_test.go\nindex c644b533a1a..8c60d6fe871 100644\n--- a/management/server/http/handlers/policies/posture_checks_handler_test.go\n+++ b/management/server/http/handlers/policies/posture_checks_handler_test.go\n@@ -16,9 +16,10 @@ import (\n \n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/geolocation\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n \t\"github.com/netbirdio/netbird/management/server/posture\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n \n@@ -175,7 +176,7 @@ func TestGetPostureCheck(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(http.MethodGet, \"/api/posture-checks/\"+tc.id, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"test_user\",\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_id\",\n@@ -828,7 +829,7 @@ func TestPostureCheckUpdate(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"test_user\",\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"test_id\",\ndiff --git a/management/server/http/handlers/routes/routes_handler_test.go b/management/server/http/handlers/routes/routes_handler_test.go\nindex 466a7987f4b..a44d81e3ec8 100644\n--- a/management/server/http/handlers/routes/routes_handler_test.go\n+++ b/management/server/http/handlers/routes/routes_handler_test.go\n@@ -19,6 +19,7 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n \t\"github.com/netbirdio/netbird/management/server/util\"\n \t\"github.com/netbirdio/netbird/route\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n \t\"github.com/netbirdio/netbird/shared/management/domain\"\n \t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n@@ -493,7 +494,7 @@ func TestRoutesHandlers(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    \"test_user\",\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: testAccountID,\ndiff --git a/management/server/http/handlers/setup_keys/setupkeys_handler_test.go b/management/server/http/handlers/setup_keys/setupkeys_handler_test.go\nindex 7b46b486b64..b137b6dd1e5 100644\n--- a/management/server/http/handlers/setup_keys/setupkeys_handler_test.go\n+++ b/management/server/http/handlers/setup_keys/setupkeys_handler_test.go\n@@ -15,10 +15,11 @@ import (\n \t\"github.com/stretchr/testify/assert\"\n \n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n-\t\"github.com/netbirdio/netbird/shared/management/status\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n+\t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n \n const (\n@@ -163,7 +164,7 @@ func TestSetupKeysHandlers(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    adminUser.Id,\n \t\t\t\tDomain:    \"hotmail.com\",\n \t\t\t\tAccountId: \"testAccountId\",\ndiff --git a/management/server/http/handlers/users/pat_handler_test.go b/management/server/http/handlers/users/pat_handler_test.go\nindex 92544c56da0..7cda144686c 100644\n--- a/management/server/http/handlers/users/pat_handler_test.go\n+++ b/management/server/http/handlers/users/pat_handler_test.go\n@@ -17,10 +17,11 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/util\"\n \n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n-\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n-\t\"github.com/netbirdio/netbird/shared/management/status\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n+\t\"github.com/netbirdio/netbird/shared/management/http/api\"\n+\t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n \n const (\n@@ -173,7 +174,7 @@ func TestTokenHandlers(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    existingUserID,\n \t\t\t\tDomain:    testDomain,\n \t\t\t\tAccountId: existingAccountID,\ndiff --git a/management/server/http/handlers/users/users_handler_test.go b/management/server/http/handlers/users/users_handler_test.go\nindex e080042187e..37f0a6c1dc8 100644\n--- a/management/server/http/handlers/users/users_handler_test.go\n+++ b/management/server/http/handlers/users/users_handler_test.go\n@@ -21,6 +21,7 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/permissions/roles\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n \t\"github.com/netbirdio/netbird/management/server/users\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n \t\"github.com/netbirdio/netbird/shared/management/http/api\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n@@ -128,7 +129,7 @@ func initUsersTestData() *handler {\n \n \t\t\t\treturn nil\n \t\t\t},\n-\t\t\tGetCurrentUserInfoFunc: func(ctx context.Context, userAuth nbcontext.UserAuth) (*users.UserInfoWithPermissions, error) {\n+\t\t\tGetCurrentUserInfoFunc: func(ctx context.Context, userAuth auth.UserAuth) (*users.UserInfoWithPermissions, error) {\n \t\t\t\tswitch userAuth.UserId {\n \t\t\t\tcase \"not-found\":\n \t\t\t\t\treturn nil, status.NewUserNotFoundError(\"not-found\")\n@@ -225,7 +226,7 @@ func TestGetUsers(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, nil)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    existingUserID,\n \t\t\t\tDomain:    testDomain,\n \t\t\t\tAccountId: existingAccountID,\n@@ -335,7 +336,7 @@ func TestUpdateUser(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\trecorder := httptest.NewRecorder()\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    existingUserID,\n \t\t\t\tDomain:    testDomain,\n \t\t\t\tAccountId: existingAccountID,\n@@ -432,7 +433,7 @@ func TestCreateUser(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, tc.requestBody)\n \t\t\trr := httptest.NewRecorder()\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    existingUserID,\n \t\t\t\tDomain:    testDomain,\n \t\t\t\tAccountId: existingAccountID,\n@@ -481,7 +482,7 @@ func TestInviteUser(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, nil)\n \t\t\treq = mux.SetURLVars(req, tc.requestVars)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    existingUserID,\n \t\t\t\tDomain:    testDomain,\n \t\t\t\tAccountId: existingAccountID,\n@@ -540,7 +541,7 @@ func TestDeleteUser(t *testing.T) {\n \t\tt.Run(tc.name, func(t *testing.T) {\n \t\t\treq := httptest.NewRequest(tc.requestType, tc.requestPath, nil)\n \t\t\treq = mux.SetURLVars(req, tc.requestVars)\n-\t\t\treq = nbcontext.SetUserAuthInRequest(req, nbcontext.UserAuth{\n+\t\t\treq = nbcontext.SetUserAuthInRequest(req, auth.UserAuth{\n \t\t\t\tUserId:    existingUserID,\n \t\t\t\tDomain:    testDomain,\n \t\t\t\tAccountId: existingAccountID,\n@@ -565,7 +566,7 @@ func TestCurrentUser(t *testing.T) {\n \ttt := []struct {\n \t\tname           string\n \t\texpectedStatus int\n-\t\trequestAuth    nbcontext.UserAuth\n+\t\trequestAuth    auth.UserAuth\n \t\texpectedResult *api.User\n \t}{\n \t\t{\n@@ -574,27 +575,27 @@ func TestCurrentUser(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname:           \"user not found\",\n-\t\t\trequestAuth:    nbcontext.UserAuth{UserId: \"not-found\"},\n+\t\t\trequestAuth:    auth.UserAuth{UserId: \"not-found\"},\n \t\t\texpectedStatus: http.StatusNotFound,\n \t\t},\n \t\t{\n \t\t\tname:           \"not of account\",\n-\t\t\trequestAuth:    nbcontext.UserAuth{UserId: \"not-of-account\"},\n+\t\t\trequestAuth:    auth.UserAuth{UserId: \"not-of-account\"},\n \t\t\texpectedStatus: http.StatusForbidden,\n \t\t},\n \t\t{\n \t\t\tname:           \"blocked user\",\n-\t\t\trequestAuth:    nbcontext.UserAuth{UserId: \"blocked-user\"},\n+\t\t\trequestAuth:    auth.UserAuth{UserId: \"blocked-user\"},\n \t\t\texpectedStatus: http.StatusForbidden,\n \t\t},\n \t\t{\n \t\t\tname:           \"service user\",\n-\t\t\trequestAuth:    nbcontext.UserAuth{UserId: \"service-user\"},\n+\t\t\trequestAuth:    auth.UserAuth{UserId: \"service-user\"},\n \t\t\texpectedStatus: http.StatusForbidden,\n \t\t},\n \t\t{\n \t\t\tname:           \"owner\",\n-\t\t\trequestAuth:    nbcontext.UserAuth{UserId: \"owner\"},\n+\t\t\trequestAuth:    auth.UserAuth{UserId: \"owner\"},\n \t\t\texpectedStatus: http.StatusOK,\n \t\t\texpectedResult: &api.User{\n \t\t\t\tId:            \"owner\",\n@@ -613,7 +614,7 @@ func TestCurrentUser(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname:           \"regular user\",\n-\t\t\trequestAuth:    nbcontext.UserAuth{UserId: \"regular-user\"},\n+\t\t\trequestAuth:    auth.UserAuth{UserId: \"regular-user\"},\n \t\t\texpectedStatus: http.StatusOK,\n \t\t\texpectedResult: &api.User{\n \t\t\t\tId:            \"regular-user\",\n@@ -632,7 +633,7 @@ func TestCurrentUser(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname:           \"admin user\",\n-\t\t\trequestAuth:    nbcontext.UserAuth{UserId: \"admin-user\"},\n+\t\t\trequestAuth:    auth.UserAuth{UserId: \"admin-user\"},\n \t\t\texpectedStatus: http.StatusOK,\n \t\t\texpectedResult: &api.User{\n \t\t\t\tId:            \"admin-user\",\n@@ -651,7 +652,7 @@ func TestCurrentUser(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname:           \"restricted user\",\n-\t\t\trequestAuth:    nbcontext.UserAuth{UserId: \"restricted-user\"},\n+\t\t\trequestAuth:    auth.UserAuth{UserId: \"restricted-user\"},\n \t\t\texpectedStatus: http.StatusOK,\n \t\t\texpectedResult: &api.User{\n \t\t\t\tId:            \"restricted-user\",\n@@ -783,7 +784,7 @@ func TestApproveUserEndpoint(t *testing.T) {\n \t\t\treq, err := http.NewRequest(\"POST\", \"/users/pending-user/approve\", nil)\n \t\t\trequire.NoError(t, err)\n \n-\t\t\tuserAuth := nbcontext.UserAuth{\n+\t\t\tuserAuth := auth.UserAuth{\n \t\t\t\tAccountId: existingAccountID,\n \t\t\t\tUserId:    tc.requestingUser.Id,\n \t\t\t}\n@@ -841,7 +842,7 @@ func TestRejectUserEndpoint(t *testing.T) {\n \t\t\treq, err := http.NewRequest(\"DELETE\", \"/users/pending-user/reject\", nil)\n \t\t\trequire.NoError(t, err)\n \n-\t\t\tuserAuth := nbcontext.UserAuth{\n+\t\t\tuserAuth := auth.UserAuth{\n \t\t\t\tAccountId: existingAccountID,\n \t\t\t\tUserId:    tc.requestingUser.Id,\n \t\t\t}\ndiff --git a/management/server/http/middleware/auth_middleware_test.go b/management/server/http/middleware/auth_middleware_test.go\nindex d1bd9959f88..7badc03e493 100644\n--- a/management/server/http/middleware/auth_middleware_test.go\n+++ b/management/server/http/middleware/auth_middleware_test.go\n@@ -12,11 +12,12 @@ import (\n \t\"github.com/stretchr/testify/assert\"\n \n \t\"github.com/netbirdio/netbird/management/server/auth\"\n-\tnbjwt \"github.com/netbirdio/netbird/management/server/auth/jwt\"\n \tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/http/middleware/bypass\"\n \t\"github.com/netbirdio/netbird/management/server/types\"\n \t\"github.com/netbirdio/netbird/management/server/util\"\n+\tnbauth \"github.com/netbirdio/netbird/shared/auth\"\n+\tnbjwt \"github.com/netbirdio/netbird/shared/auth/jwt\"\n )\n \n const (\n@@ -75,9 +76,9 @@ func mockGetAccountInfoFromPAT(_ context.Context, token string) (user *types.Use\n \treturn nil, nil, \"\", \"\", fmt.Errorf(\"PAT invalid\")\n }\n \n-func mockValidateAndParseToken(_ context.Context, token string) (nbcontext.UserAuth, *jwt.Token, error) {\n+func mockValidateAndParseToken(_ context.Context, token string) (nbauth.UserAuth, *jwt.Token, error) {\n \tif token == JWT {\n-\t\treturn nbcontext.UserAuth{\n+\t\treturn nbauth.UserAuth{\n \t\t\t\tUserId:         userID,\n \t\t\t\tAccountId:      accountID,\n \t\t\t\tDomain:         testAccount.Domain,\n@@ -91,7 +92,7 @@ func mockValidateAndParseToken(_ context.Context, token string) (nbcontext.UserA\n \t\t\t\tValid: true,\n \t\t\t}, nil\n \t}\n-\treturn nbcontext.UserAuth{}, nil, fmt.Errorf(\"JWT invalid\")\n+\treturn nbauth.UserAuth{}, nil, fmt.Errorf(\"JWT invalid\")\n }\n \n func mockMarkPATUsed(_ context.Context, token string) error {\n@@ -101,7 +102,7 @@ func mockMarkPATUsed(_ context.Context, token string) error {\n \treturn fmt.Errorf(\"Should never get reached\")\n }\n \n-func mockEnsureUserAccessByJWTGroups(_ context.Context, userAuth nbcontext.UserAuth, token *jwt.Token) (nbcontext.UserAuth, error) {\n+func mockEnsureUserAccessByJWTGroups(_ context.Context, userAuth nbauth.UserAuth, token *jwt.Token) (nbauth.UserAuth, error) {\n \tif userAuth.IsChild || userAuth.IsPAT {\n \t\treturn userAuth, nil\n \t}\n@@ -197,13 +198,13 @@ func TestAuthMiddleware_Handler(t *testing.T) {\n \n \tauthMiddleware := NewAuthMiddleware(\n \t\tmockAuth,\n-\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (string, string, error) {\n+\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (string, string, error) {\n \t\t\treturn userAuth.AccountId, userAuth.UserId, nil\n \t\t},\n-\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) error {\n+\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) error {\n \t\t\treturn nil\n \t\t},\n-\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (*types.User, error) {\n+\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (*types.User, error) {\n \t\t\treturn &types.User{}, nil\n \t\t},\n \t\tnil,\n@@ -255,13 +256,13 @@ func TestAuthMiddleware_RateLimiting(t *testing.T) {\n \n \t\tauthMiddleware := NewAuthMiddleware(\n \t\t\tmockAuth,\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (string, string, error) {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (string, string, error) {\n \t\t\t\treturn userAuth.AccountId, userAuth.UserId, nil\n \t\t\t},\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) error {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) error {\n \t\t\t\treturn nil\n \t\t\t},\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (*types.User, error) {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (*types.User, error) {\n \t\t\t\treturn &types.User{}, nil\n \t\t\t},\n \t\t\trateLimitConfig,\n@@ -306,13 +307,13 @@ func TestAuthMiddleware_RateLimiting(t *testing.T) {\n \n \t\tauthMiddleware := NewAuthMiddleware(\n \t\t\tmockAuth,\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (string, string, error) {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (string, string, error) {\n \t\t\t\treturn userAuth.AccountId, userAuth.UserId, nil\n \t\t\t},\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) error {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) error {\n \t\t\t\treturn nil\n \t\t\t},\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (*types.User, error) {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (*types.User, error) {\n \t\t\t\treturn &types.User{}, nil\n \t\t\t},\n \t\t\trateLimitConfig,\n@@ -348,13 +349,13 @@ func TestAuthMiddleware_RateLimiting(t *testing.T) {\n \n \t\tauthMiddleware := NewAuthMiddleware(\n \t\t\tmockAuth,\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (string, string, error) {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (string, string, error) {\n \t\t\t\treturn userAuth.AccountId, userAuth.UserId, nil\n \t\t\t},\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) error {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) error {\n \t\t\t\treturn nil\n \t\t\t},\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (*types.User, error) {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (*types.User, error) {\n \t\t\t\treturn &types.User{}, nil\n \t\t\t},\n \t\t\trateLimitConfig,\n@@ -391,13 +392,13 @@ func TestAuthMiddleware_RateLimiting(t *testing.T) {\n \n \t\tauthMiddleware := NewAuthMiddleware(\n \t\t\tmockAuth,\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (string, string, error) {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (string, string, error) {\n \t\t\t\treturn userAuth.AccountId, userAuth.UserId, nil\n \t\t\t},\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) error {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) error {\n \t\t\t\treturn nil\n \t\t\t},\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (*types.User, error) {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (*types.User, error) {\n \t\t\t\treturn &types.User{}, nil\n \t\t\t},\n \t\t\trateLimitConfig,\n@@ -454,13 +455,13 @@ func TestAuthMiddleware_RateLimiting(t *testing.T) {\n \n \t\tauthMiddleware := NewAuthMiddleware(\n \t\t\tmockAuth,\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (string, string, error) {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (string, string, error) {\n \t\t\t\treturn userAuth.AccountId, userAuth.UserId, nil\n \t\t\t},\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) error {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) error {\n \t\t\t\treturn nil\n \t\t\t},\n-\t\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (*types.User, error) {\n+\t\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (*types.User, error) {\n \t\t\t\treturn &types.User{}, nil\n \t\t\t},\n \t\t\trateLimitConfig,\n@@ -508,13 +509,13 @@ func TestAuthMiddleware_Handler_Child(t *testing.T) {\n \t\tname             string\n \t\tpath             string\n \t\tauthHeader       string\n-\t\texpectedUserAuth *nbcontext.UserAuth // nil expects 401 response status\n+\t\texpectedUserAuth *nbauth.UserAuth // nil expects 401 response status\n \t}{\n \t\t{\n \t\t\tname:       \"Valid PAT Token\",\n \t\t\tpath:       \"/test\",\n \t\t\tauthHeader: \"Token \" + PAT,\n-\t\t\texpectedUserAuth: &nbcontext.UserAuth{\n+\t\t\texpectedUserAuth: &nbauth.UserAuth{\n \t\t\t\tAccountId:      accountID,\n \t\t\t\tUserId:         userID,\n \t\t\t\tDomain:         testAccount.Domain,\n@@ -526,7 +527,7 @@ func TestAuthMiddleware_Handler_Child(t *testing.T) {\n \t\t\tname:       \"Valid PAT Token accesses child\",\n \t\t\tpath:       \"/test?account=xyz\",\n \t\t\tauthHeader: \"Token \" + PAT,\n-\t\t\texpectedUserAuth: &nbcontext.UserAuth{\n+\t\t\texpectedUserAuth: &nbauth.UserAuth{\n \t\t\t\tAccountId:      \"xyz\",\n \t\t\t\tUserId:         userID,\n \t\t\t\tDomain:         testAccount.Domain,\n@@ -539,7 +540,7 @@ func TestAuthMiddleware_Handler_Child(t *testing.T) {\n \t\t\tname:       \"Valid JWT Token\",\n \t\t\tpath:       \"/test\",\n \t\t\tauthHeader: \"Bearer \" + JWT,\n-\t\t\texpectedUserAuth: &nbcontext.UserAuth{\n+\t\t\texpectedUserAuth: &nbauth.UserAuth{\n \t\t\t\tAccountId:      accountID,\n \t\t\t\tUserId:         userID,\n \t\t\t\tDomain:         testAccount.Domain,\n@@ -551,7 +552,7 @@ func TestAuthMiddleware_Handler_Child(t *testing.T) {\n \t\t\tname:       \"Valid JWT Token with child\",\n \t\t\tpath:       \"/test?account=xyz\",\n \t\t\tauthHeader: \"Bearer \" + JWT,\n-\t\t\texpectedUserAuth: &nbcontext.UserAuth{\n+\t\t\texpectedUserAuth: &nbauth.UserAuth{\n \t\t\t\tAccountId:      \"xyz\",\n \t\t\t\tUserId:         userID,\n \t\t\t\tDomain:         testAccount.Domain,\n@@ -570,13 +571,13 @@ func TestAuthMiddleware_Handler_Child(t *testing.T) {\n \n \tauthMiddleware := NewAuthMiddleware(\n \t\tmockAuth,\n-\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (string, string, error) {\n+\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (string, string, error) {\n \t\t\treturn userAuth.AccountId, userAuth.UserId, nil\n \t\t},\n-\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) error {\n+\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) error {\n \t\t\treturn nil\n \t\t},\n-\t\tfunc(ctx context.Context, userAuth nbcontext.UserAuth) (*types.User, error) {\n+\t\tfunc(ctx context.Context, userAuth nbauth.UserAuth) (*types.User, error) {\n \t\t\treturn &types.User{}, nil\n \t\t},\n \t\tnil,\ndiff --git a/management/server/http/testing/testing_tools/channel/channel.go b/management/server/http/testing/testing_tools/channel/channel.go\nindex ab3f5437a4a..ac165aeb207 100644\n--- a/management/server/http/testing/testing_tools/channel/channel.go\n+++ b/management/server/http/testing/testing_tools/channel/channel.go\n@@ -10,6 +10,7 @@ import (\n \t\"github.com/stretchr/testify/assert\"\n \n \t\"github.com/netbirdio/management-integrations/integrations\"\n+\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map\"\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map/controller\"\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map/update_channel\"\n@@ -18,8 +19,7 @@ import (\n \t\"github.com/netbirdio/netbird/management/server\"\n \t\"github.com/netbirdio/netbird/management/server/account\"\n \t\"github.com/netbirdio/netbird/management/server/activity\"\n-\t\"github.com/netbirdio/netbird/management/server/auth\"\n-\tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n+\tserverauth \"github.com/netbirdio/netbird/management/server/auth\"\n \t\"github.com/netbirdio/netbird/management/server/geolocation\"\n \t\"github.com/netbirdio/netbird/management/server/groups\"\n \thttp2 \"github.com/netbirdio/netbird/management/server/http\"\n@@ -33,6 +33,7 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/store\"\n \t\"github.com/netbirdio/netbird/management/server/telemetry\"\n \t\"github.com/netbirdio/netbird/management/server/users\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n )\n \n func BuildApiBlackBoxWithDBState(t testing_tools.TB, sqlFile string, expectedPeerUpdate *network_map.UpdateMessage, validateUpdate bool) (http.Handler, account.Manager, chan struct{}) {\n@@ -71,14 +72,14 @@ func BuildApiBlackBoxWithDBState(t testing_tools.TB, sqlFile string, expectedPee\n \tctx := context.Background()\n \trequestBuffer := server.NewAccountRequestBuffer(ctx, store)\n \tnetworkMapController := controller.NewController(ctx, store, metrics, peersUpdateManager, requestBuffer, server.MockIntegratedValidator{}, settingsManager, \"\", port_forwarding.NewControllerMock())\n-\tam, err := server.BuildManager(ctx, store, networkMapController, nil, \"\", &activity.InMemoryEventStore{}, geoMock, false, validatorMock, metrics, proxyController, settingsManager, permissionsManager, false)\n+\tam, err := server.BuildManager(ctx, nil, store, networkMapController, nil, \"\", &activity.InMemoryEventStore{}, geoMock, false, validatorMock, metrics, proxyController, settingsManager, permissionsManager, false)\n \tif err != nil {\n \t\tt.Fatalf(\"Failed to create manager: %v\", err)\n \t}\n \n \t// @note this is required so that PAT's validate from store, but JWT's are mocked\n-\tauthManager := auth.NewManager(store, \"\", \"\", \"\", \"\", []string{}, false)\n-\tauthManagerMock := &auth.MockManager{\n+\tauthManager := serverauth.NewManager(store, \"\", \"\", \"\", \"\", []string{}, false)\n+\tauthManagerMock := &serverauth.MockManager{\n \t\tValidateAndParseTokenFunc:       mockValidateAndParseToken,\n \t\tEnsureUserAccessByJWTGroupsFunc: authManager.EnsureUserAccessByJWTGroups,\n \t\tMarkPATUsedFunc:                 authManager.MarkPATUsed,\n@@ -123,8 +124,8 @@ func peerShouldReceiveUpdate(t testing_tools.TB, updateMessage <-chan *network_m\n \t}\n }\n \n-func mockValidateAndParseToken(_ context.Context, token string) (nbcontext.UserAuth, *jwt.Token, error) {\n-\tuserAuth := nbcontext.UserAuth{}\n+func mockValidateAndParseToken(_ context.Context, token string) (auth.UserAuth, *jwt.Token, error) {\n+\tuserAuth := auth.UserAuth{}\n \n \tswitch token {\n \tcase \"testUserId\", \"testAdminId\", \"testOwnerId\", \"testServiceUserId\", \"testServiceAdminId\", \"blockedUserId\":\ndiff --git a/management/server/idp/pocketid_test.go b/management/server/idp/pocketid_test.go\nindex 49075a0d345..126a7691900 100644\n--- a/management/server/idp/pocketid_test.go\n+++ b/management/server/idp/pocketid_test.go\n@@ -1,138 +1,137 @@\n package idp\n \n import (\n-    \"context\"\n-    \"testing\"\n+\t\"context\"\n+\t\"testing\"\n \n-    \"github.com/stretchr/testify/assert\"\n-    \"github.com/stretchr/testify/require\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n \n-    \"github.com/netbirdio/netbird/management/server/telemetry\"\n+\t\"github.com/netbirdio/netbird/management/server/telemetry\"\n )\n \n-\n func TestNewPocketIdManager(t *testing.T) {\n-    type test struct {\n-        name                 string\n-        inputConfig          PocketIdClientConfig\n-        assertErrFunc        require.ErrorAssertionFunc\n-        assertErrFuncMessage string\n-    }\n-\n-    defaultTestConfig := PocketIdClientConfig{\n-        APIToken:           \"api_token\",\n-        ManagementEndpoint: \"http://localhost\",\n-    }\n-\n-    tests := []test{\n-        {\n-            name:                 \"Good Configuration\",\n-            inputConfig:          defaultTestConfig,\n-            assertErrFunc:        require.NoError,\n-            assertErrFuncMessage: \"shouldn't return error\",\n-        },\n-        {\n-            name: \"Missing ManagementEndpoint\",\n-            inputConfig: PocketIdClientConfig{\n-                APIToken:           defaultTestConfig.APIToken,\n-                ManagementEndpoint: \"\",\n-            },\n-            assertErrFunc:        require.Error,\n-            assertErrFuncMessage: \"should return error when field empty\",\n-        },\n-        {\n-            name: \"Missing APIToken\",\n-            inputConfig: PocketIdClientConfig{\n-                APIToken:           \"\",\n-                ManagementEndpoint: defaultTestConfig.ManagementEndpoint,\n-            },\n-            assertErrFunc:        require.Error,\n-            assertErrFuncMessage: \"should return error when field empty\",\n-        },\n-    }\n-\n-    for _, tc := range tests {\n-        t.Run(tc.name, func(t *testing.T) {\n-            _, err := NewPocketIdManager(tc.inputConfig, &telemetry.MockAppMetrics{})\n-            tc.assertErrFunc(t, err, tc.assertErrFuncMessage)\n-        })\n-    }\n+\ttype test struct {\n+\t\tname                 string\n+\t\tinputConfig          PocketIdClientConfig\n+\t\tassertErrFunc        require.ErrorAssertionFunc\n+\t\tassertErrFuncMessage string\n+\t}\n+\n+\tdefaultTestConfig := PocketIdClientConfig{\n+\t\tAPIToken:           \"api_token\",\n+\t\tManagementEndpoint: \"http://localhost\",\n+\t}\n+\n+\ttests := []test{\n+\t\t{\n+\t\t\tname:                 \"Good Configuration\",\n+\t\t\tinputConfig:          defaultTestConfig,\n+\t\t\tassertErrFunc:        require.NoError,\n+\t\t\tassertErrFuncMessage: \"shouldn't return error\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Missing ManagementEndpoint\",\n+\t\t\tinputConfig: PocketIdClientConfig{\n+\t\t\t\tAPIToken:           defaultTestConfig.APIToken,\n+\t\t\t\tManagementEndpoint: \"\",\n+\t\t\t},\n+\t\t\tassertErrFunc:        require.Error,\n+\t\t\tassertErrFuncMessage: \"should return error when field empty\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Missing APIToken\",\n+\t\t\tinputConfig: PocketIdClientConfig{\n+\t\t\t\tAPIToken:           \"\",\n+\t\t\t\tManagementEndpoint: defaultTestConfig.ManagementEndpoint,\n+\t\t\t},\n+\t\t\tassertErrFunc:        require.Error,\n+\t\t\tassertErrFuncMessage: \"should return error when field empty\",\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range tests {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\t_, err := NewPocketIdManager(tc.inputConfig, &telemetry.MockAppMetrics{})\n+\t\t\ttc.assertErrFunc(t, err, tc.assertErrFuncMessage)\n+\t\t})\n+\t}\n }\n \n func TestPocketID_GetUserDataByID(t *testing.T) {\n-    client := &mockHTTPClient{code: 200, resBody: `{\"id\":\"u1\",\"email\":\"user1@example.com\",\"displayName\":\"User One\"}`}\n-\n-    mgr, err := NewPocketIdManager(PocketIdClientConfig{APIToken: \"tok\", ManagementEndpoint: \"http://localhost\"}, nil)\n-    require.NoError(t, err)\n-    mgr.httpClient = client\n-\n-    md := AppMetadata{WTAccountID: \"acc1\"}\n-    got, err := mgr.GetUserDataByID(context.Background(), \"u1\", md)\n-    require.NoError(t, err)\n-    assert.Equal(t, \"u1\", got.ID)\n-    assert.Equal(t, \"user1@example.com\", got.Email)\n-    assert.Equal(t, \"User One\", got.Name)\n-    assert.Equal(t, \"acc1\", got.AppMetadata.WTAccountID)\n+\tclient := &mockHTTPClient{code: 200, resBody: `{\"id\":\"u1\",\"email\":\"user1@example.com\",\"displayName\":\"User One\"}`}\n+\n+\tmgr, err := NewPocketIdManager(PocketIdClientConfig{APIToken: \"tok\", ManagementEndpoint: \"http://localhost\"}, nil)\n+\trequire.NoError(t, err)\n+\tmgr.httpClient = client\n+\n+\tmd := AppMetadata{WTAccountID: \"acc1\"}\n+\tgot, err := mgr.GetUserDataByID(context.Background(), \"u1\", md)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, \"u1\", got.ID)\n+\tassert.Equal(t, \"user1@example.com\", got.Email)\n+\tassert.Equal(t, \"User One\", got.Name)\n+\tassert.Equal(t, \"acc1\", got.AppMetadata.WTAccountID)\n }\n \n func TestPocketID_GetAccount_WithPagination(t *testing.T) {\n-    // Single page response with two users\n-    client := &mockHTTPClient{code: 200, resBody: `{\"data\":[{\"id\":\"u1\",\"email\":\"e1\",\"displayName\":\"n1\"},{\"id\":\"u2\",\"email\":\"e2\",\"displayName\":\"n2\"}],\"pagination\":{\"currentPage\":1,\"itemsPerPage\":100,\"totalItems\":2,\"totalPages\":1}}`}\n-\n-    mgr, err := NewPocketIdManager(PocketIdClientConfig{APIToken: \"tok\", ManagementEndpoint: \"http://localhost\"}, nil)\n-    require.NoError(t, err)\n-    mgr.httpClient = client\n-\n-    users, err := mgr.GetAccount(context.Background(), \"accX\")\n-    require.NoError(t, err)\n-    require.Len(t, users, 2)\n-    assert.Equal(t, \"u1\", users[0].ID)\n-    assert.Equal(t, \"accX\", users[0].AppMetadata.WTAccountID)\n-    assert.Equal(t, \"u2\", users[1].ID)\n+\t// Single page response with two users\n+\tclient := &mockHTTPClient{code: 200, resBody: `{\"data\":[{\"id\":\"u1\",\"email\":\"e1\",\"displayName\":\"n1\"},{\"id\":\"u2\",\"email\":\"e2\",\"displayName\":\"n2\"}],\"pagination\":{\"currentPage\":1,\"itemsPerPage\":100,\"totalItems\":2,\"totalPages\":1}}`}\n+\n+\tmgr, err := NewPocketIdManager(PocketIdClientConfig{APIToken: \"tok\", ManagementEndpoint: \"http://localhost\"}, nil)\n+\trequire.NoError(t, err)\n+\tmgr.httpClient = client\n+\n+\tusers, err := mgr.GetAccount(context.Background(), \"accX\")\n+\trequire.NoError(t, err)\n+\trequire.Len(t, users, 2)\n+\tassert.Equal(t, \"u1\", users[0].ID)\n+\tassert.Equal(t, \"accX\", users[0].AppMetadata.WTAccountID)\n+\tassert.Equal(t, \"u2\", users[1].ID)\n }\n \n func TestPocketID_GetAllAccounts_WithPagination(t *testing.T) {\n-    client := &mockHTTPClient{code: 200, resBody: `{\"data\":[{\"id\":\"u1\",\"email\":\"e1\",\"displayName\":\"n1\"},{\"id\":\"u2\",\"email\":\"e2\",\"displayName\":\"n2\"}],\"pagination\":{\"currentPage\":1,\"itemsPerPage\":100,\"totalItems\":2,\"totalPages\":1}}`}\n+\tclient := &mockHTTPClient{code: 200, resBody: `{\"data\":[{\"id\":\"u1\",\"email\":\"e1\",\"displayName\":\"n1\"},{\"id\":\"u2\",\"email\":\"e2\",\"displayName\":\"n2\"}],\"pagination\":{\"currentPage\":1,\"itemsPerPage\":100,\"totalItems\":2,\"totalPages\":1}}`}\n \n-    mgr, err := NewPocketIdManager(PocketIdClientConfig{APIToken: \"tok\", ManagementEndpoint: \"http://localhost\"}, nil)\n-    require.NoError(t, err)\n-    mgr.httpClient = client\n+\tmgr, err := NewPocketIdManager(PocketIdClientConfig{APIToken: \"tok\", ManagementEndpoint: \"http://localhost\"}, nil)\n+\trequire.NoError(t, err)\n+\tmgr.httpClient = client\n \n-    accounts, err := mgr.GetAllAccounts(context.Background())\n-    require.NoError(t, err)\n-    require.Len(t, accounts[UnsetAccountID], 2)\n+\taccounts, err := mgr.GetAllAccounts(context.Background())\n+\trequire.NoError(t, err)\n+\trequire.Len(t, accounts[UnsetAccountID], 2)\n }\n \n func TestPocketID_CreateUser(t *testing.T) {\n-    client := &mockHTTPClient{code: 201, resBody: `{\"id\":\"newid\",\"email\":\"new@example.com\",\"displayName\":\"New User\"}`}\n-\n-    mgr, err := NewPocketIdManager(PocketIdClientConfig{APIToken: \"tok\", ManagementEndpoint: \"http://localhost\"}, nil)\n-    require.NoError(t, err)\n-    mgr.httpClient = client\n-\n-    ud, err := mgr.CreateUser(context.Background(), \"new@example.com\", \"New User\", \"acc1\", \"inviter@example.com\")\n-    require.NoError(t, err)\n-    assert.Equal(t, \"newid\", ud.ID)\n-    assert.Equal(t, \"new@example.com\", ud.Email)\n-    assert.Equal(t, \"New User\", ud.Name)\n-    assert.Equal(t, \"acc1\", ud.AppMetadata.WTAccountID)\n-    if assert.NotNil(t, ud.AppMetadata.WTPendingInvite) {\n-        assert.True(t, *ud.AppMetadata.WTPendingInvite)\n-    }\n-    assert.Equal(t, \"inviter@example.com\", ud.AppMetadata.WTInvitedBy)\n+\tclient := &mockHTTPClient{code: 201, resBody: `{\"id\":\"newid\",\"email\":\"new@example.com\",\"displayName\":\"New User\"}`}\n+\n+\tmgr, err := NewPocketIdManager(PocketIdClientConfig{APIToken: \"tok\", ManagementEndpoint: \"http://localhost\"}, nil)\n+\trequire.NoError(t, err)\n+\tmgr.httpClient = client\n+\n+\tud, err := mgr.CreateUser(context.Background(), \"new@example.com\", \"New User\", \"acc1\", \"inviter@example.com\")\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, \"newid\", ud.ID)\n+\tassert.Equal(t, \"new@example.com\", ud.Email)\n+\tassert.Equal(t, \"New User\", ud.Name)\n+\tassert.Equal(t, \"acc1\", ud.AppMetadata.WTAccountID)\n+\tif assert.NotNil(t, ud.AppMetadata.WTPendingInvite) {\n+\t\tassert.True(t, *ud.AppMetadata.WTPendingInvite)\n+\t}\n+\tassert.Equal(t, \"inviter@example.com\", ud.AppMetadata.WTInvitedBy)\n }\n \n func TestPocketID_InviteAndDeleteUser(t *testing.T) {\n-    // Same mock for both calls; returns OK with empty JSON\n-    client := &mockHTTPClient{code: 200, resBody: `{}`}\n+\t// Same mock for both calls; returns OK with empty JSON\n+\tclient := &mockHTTPClient{code: 200, resBody: `{}`}\n \n-    mgr, err := NewPocketIdManager(PocketIdClientConfig{APIToken: \"tok\", ManagementEndpoint: \"http://localhost\"}, nil)\n-    require.NoError(t, err)\n-    mgr.httpClient = client\n+\tmgr, err := NewPocketIdManager(PocketIdClientConfig{APIToken: \"tok\", ManagementEndpoint: \"http://localhost\"}, nil)\n+\trequire.NoError(t, err)\n+\tmgr.httpClient = client\n \n-    err = mgr.InviteUserByID(context.Background(), \"u1\")\n-    require.NoError(t, err)\n+\terr = mgr.InviteUserByID(context.Background(), \"u1\")\n+\trequire.NoError(t, err)\n \n-    err = mgr.DeleteUser(context.Background(), \"u1\")\n-    require.NoError(t, err)\n+\terr = mgr.DeleteUser(context.Background(), \"u1\")\n+\trequire.NoError(t, err)\n }\ndiff --git a/management/server/management_proto_test.go b/management/server/management_proto_test.go\nindex fc67e01afeb..496be9caa32 100644\n--- a/management/server/management_proto_test.go\n+++ b/management/server/management_proto_test.go\n@@ -364,7 +364,7 @@ func startManagementForTest(t *testing.T, testFile string, config *config.Config\n \tupdateManager := update_channel.NewPeersUpdateManager(metrics)\n \trequestBuffer := NewAccountRequestBuffer(ctx, store)\n \tnetworkMapController := controller.NewController(ctx, store, metrics, updateManager, requestBuffer, MockIntegratedValidator{}, settingsMockManager, \"netbird.selfhosted\", port_forwarding.NewControllerMock())\n-\taccountManager, err := BuildManager(ctx, store, networkMapController, nil, \"\",\n+\taccountManager, err := BuildManager(ctx, nil, store, networkMapController, nil, \"\",\n \t\teventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n \n \tif err != nil {\ndiff --git a/management/server/management_test.go b/management/server/management_test.go\nindex 930ecfb5a74..c485f16b4a1 100644\n--- a/management/server/management_test.go\n+++ b/management/server/management_test.go\n@@ -209,6 +209,7 @@ func startServer(\n \n \taccountManager, err := server.BuildManager(\n \t\tcontext.Background(),\n+\t\tnil,\n \t\tstr,\n \t\tnetworkMapController,\n \t\tnil,\ndiff --git a/management/server/nameserver_test.go b/management/server/nameserver_test.go\nindex 35291b30c75..51738c10626 100644\n--- a/management/server/nameserver_test.go\n+++ b/management/server/nameserver_test.go\n@@ -793,7 +793,7 @@ func createNSManager(t *testing.T) (*DefaultAccountManager, error) {\n \trequestBuffer := NewAccountRequestBuffer(ctx, store)\n \tnetworkMapController := controller.NewController(ctx, store, metrics, updateManager, requestBuffer, MockIntegratedValidator{}, settingsMockManager, \"netbird.selfhosted\", port_forwarding.NewControllerMock())\n \n-\treturn BuildManager(context.Background(), store, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n+\treturn BuildManager(context.Background(), nil, store, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n }\n \n func createNSStore(t *testing.T) (store.Store, error) {\ndiff --git a/management/server/networks/resources/manager_test.go b/management/server/networks/resources/manager_test.go\nindex c6cec6f7e75..e2dea2c6bde 100644\n--- a/management/server/networks/resources/manager_test.go\n+++ b/management/server/networks/resources/manager_test.go\n@@ -10,8 +10,8 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n \t\"github.com/netbirdio/netbird/management/server/networks/resources/types\"\n \t\"github.com/netbirdio/netbird/management/server/permissions\"\n-\t\"github.com/netbirdio/netbird/shared/management/status\"\n \t\"github.com/netbirdio/netbird/management/server/store\"\n+\t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n \n func Test_GetAllResourcesInNetworkReturnsResources(t *testing.T) {\ndiff --git a/management/server/networks/routers/manager_test.go b/management/server/networks/routers/manager_test.go\nindex 8054d05c6ca..6be90baa7a9 100644\n--- a/management/server/networks/routers/manager_test.go\n+++ b/management/server/networks/routers/manager_test.go\n@@ -9,8 +9,8 @@ import (\n \t\"github.com/netbirdio/netbird/management/server/mock_server\"\n \t\"github.com/netbirdio/netbird/management/server/networks/routers/types\"\n \t\"github.com/netbirdio/netbird/management/server/permissions\"\n-\t\"github.com/netbirdio/netbird/shared/management/status\"\n \t\"github.com/netbirdio/netbird/management/server/store\"\n+\t\"github.com/netbirdio/netbird/shared/management/status\"\n )\n \n func Test_GetAllRoutersInNetworkReturnsRouters(t *testing.T) {\ndiff --git a/management/server/peer_test.go b/management/server/peer_test.go\nindex 95c609595c3..21a6952a9b3 100644\n--- a/management/server/peer_test.go\n+++ b/management/server/peer_test.go\n@@ -1292,7 +1292,7 @@ func Test_RegisterPeerByUser(t *testing.T) {\n \trequestBuffer := NewAccountRequestBuffer(ctx, s)\n \tnetworkMapController := controller.NewController(ctx, s, metrics, updateManager, requestBuffer, MockIntegratedValidator{}, settingsMockManager, \"netbird.cloud\", port_forwarding.NewControllerMock())\n \n-\tam, err := BuildManager(context.Background(), s, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n+\tam, err := BuildManager(context.Background(), nil, s, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n \tassert.NoError(t, err)\n \n \texistingAccountID := \"bf1c8084-ba50-4ce7-9439-34653001fc3b\"\n@@ -1377,7 +1377,7 @@ func Test_RegisterPeerBySetupKey(t *testing.T) {\n \trequestBuffer := NewAccountRequestBuffer(ctx, s)\n \tnetworkMapController := controller.NewController(ctx, s, metrics, updateManager, requestBuffer, MockIntegratedValidator{}, settingsMockManager, \"netbird.cloud\", port_forwarding.NewControllerMock())\n \n-\tam, err := BuildManager(context.Background(), s, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n+\tam, err := BuildManager(context.Background(), nil, s, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n \tassert.NoError(t, err)\n \n \texistingAccountID := \"bf1c8084-ba50-4ce7-9439-34653001fc3b\"\n@@ -1530,7 +1530,7 @@ func Test_RegisterPeerRollbackOnFailure(t *testing.T) {\n \trequestBuffer := NewAccountRequestBuffer(ctx, s)\n \tnetworkMapController := controller.NewController(ctx, s, metrics, updateManager, requestBuffer, MockIntegratedValidator{}, settingsMockManager, \"netbird.cloud\", port_forwarding.NewControllerMock())\n \n-\tam, err := BuildManager(context.Background(), s, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n+\tam, err := BuildManager(context.Background(), nil, s, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n \tassert.NoError(t, err)\n \n \texistingAccountID := \"bf1c8084-ba50-4ce7-9439-34653001fc3b\"\n@@ -1610,7 +1610,7 @@ func Test_LoginPeer(t *testing.T) {\n \trequestBuffer := NewAccountRequestBuffer(ctx, s)\n \tnetworkMapController := controller.NewController(ctx, s, metrics, updateManager, requestBuffer, MockIntegratedValidator{}, settingsMockManager, \"netbird.cloud\", port_forwarding.NewControllerMock())\n \n-\tam, err := BuildManager(context.Background(), s, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n+\tam, err := BuildManager(context.Background(), nil, s, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n \tassert.NoError(t, err)\n \n \texistingAccountID := \"bf1c8084-ba50-4ce7-9439-34653001fc3b\"\ndiff --git a/management/server/route_test.go b/management/server/route_test.go\nindex 27fe033c867..7ff362bc6f3 100644\n--- a/management/server/route_test.go\n+++ b/management/server/route_test.go\n@@ -1292,7 +1292,7 @@ func createRouterManager(t *testing.T) (*DefaultAccountManager, *update_channel.\n \trequestBuffer := NewAccountRequestBuffer(ctx, store)\n \tnetworkMapController := controller.NewController(ctx, store, metrics, updateManager, requestBuffer, MockIntegratedValidator{}, settingsMockManager, \"netbird.selfhosted\", port_forwarding.NewControllerMock())\n \n-\tam, err := BuildManager(context.Background(), store, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n+\tam, err := BuildManager(context.Background(), nil, store, networkMapController, nil, \"\", eventStore, nil, false, MockIntegratedValidator{}, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManager, false)\n \tif err != nil {\n \t\treturn nil, nil, err\n \t}\ndiff --git a/management/server/user_test.go b/management/server/user_test.go\nindex 69b8c85eeba..5ce15621eb2 100644\n--- a/management/server/user_test.go\n+++ b/management/server/user_test.go\n@@ -11,12 +11,12 @@ import (\n \t\"golang.org/x/exp/maps\"\n \n \tnbcache \"github.com/netbirdio/netbird/management/server/cache\"\n-\tnbcontext \"github.com/netbirdio/netbird/management/server/context\"\n \t\"github.com/netbirdio/netbird/management/server/permissions\"\n \t\"github.com/netbirdio/netbird/management/server/permissions/modules\"\n \t\"github.com/netbirdio/netbird/management/server/permissions/roles\"\n \t\"github.com/netbirdio/netbird/management/server/users\"\n \t\"github.com/netbirdio/netbird/management/server/util\"\n+\t\"github.com/netbirdio/netbird/shared/auth\"\n \t\"github.com/netbirdio/netbird/shared/management/status\"\n \n \tnbpeer \"github.com/netbirdio/netbird/management/server/peer\"\n@@ -966,7 +966,7 @@ func TestDefaultAccountManager_GetUser(t *testing.T) {\n \t\tpermissionsManager: permissionsManager,\n \t}\n \n-\tclaims := nbcontext.UserAuth{\n+\tclaims := auth.UserAuth{\n \t\tUserId:    mockUserID,\n \t\tAccountId: mockAccountID,\n \t}\n@@ -1573,33 +1573,33 @@ func TestDefaultAccountManager_GetCurrentUserInfo(t *testing.T) {\n \n \ttt := []struct {\n \t\tname           string\n-\t\tuserAuth       nbcontext.UserAuth\n+\t\tuserAuth       auth.UserAuth\n \t\texpectedErr    error\n \t\texpectedResult *users.UserInfoWithPermissions\n \t}{\n \t\t{\n \t\t\tname:        \"not found\",\n-\t\t\tuserAuth:    nbcontext.UserAuth{AccountId: account1.Id, UserId: \"not-found\"},\n+\t\t\tuserAuth:    auth.UserAuth{AccountId: account1.Id, UserId: \"not-found\"},\n \t\t\texpectedErr: status.NewUserNotFoundError(\"not-found\"),\n \t\t},\n \t\t{\n \t\t\tname:        \"not part of account\",\n-\t\t\tuserAuth:    nbcontext.UserAuth{AccountId: account1.Id, UserId: \"account2Owner\"},\n+\t\t\tuserAuth:    auth.UserAuth{AccountId: account1.Id, UserId: \"account2Owner\"},\n \t\t\texpectedErr: status.NewUserNotPartOfAccountError(),\n \t\t},\n \t\t{\n \t\t\tname:        \"blocked\",\n-\t\t\tuserAuth:    nbcontext.UserAuth{AccountId: account1.Id, UserId: \"blocked-user\"},\n+\t\t\tuserAuth:    auth.UserAuth{AccountId: account1.Id, UserId: \"blocked-user\"},\n \t\t\texpectedErr: status.NewUserBlockedError(),\n \t\t},\n \t\t{\n \t\t\tname:        \"service user\",\n-\t\t\tuserAuth:    nbcontext.UserAuth{AccountId: account1.Id, UserId: \"service-user\"},\n+\t\t\tuserAuth:    auth.UserAuth{AccountId: account1.Id, UserId: \"service-user\"},\n \t\t\texpectedErr: status.NewPermissionDeniedError(),\n \t\t},\n \t\t{\n \t\t\tname:     \"owner user\",\n-\t\t\tuserAuth: nbcontext.UserAuth{AccountId: account1.Id, UserId: \"account1Owner\"},\n+\t\t\tuserAuth: auth.UserAuth{AccountId: account1.Id, UserId: \"account1Owner\"},\n \t\t\texpectedResult: &users.UserInfoWithPermissions{\n \t\t\t\tUserInfo: &types.UserInfo{\n \t\t\t\t\tID:                   \"account1Owner\",\n@@ -1619,7 +1619,7 @@ func TestDefaultAccountManager_GetCurrentUserInfo(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname:     \"regular user\",\n-\t\t\tuserAuth: nbcontext.UserAuth{AccountId: account1.Id, UserId: \"regular-user\"},\n+\t\t\tuserAuth: auth.UserAuth{AccountId: account1.Id, UserId: \"regular-user\"},\n \t\t\texpectedResult: &users.UserInfoWithPermissions{\n \t\t\t\tUserInfo: &types.UserInfo{\n \t\t\t\t\tID:                   \"regular-user\",\n@@ -1638,7 +1638,7 @@ func TestDefaultAccountManager_GetCurrentUserInfo(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname:     \"admin user\",\n-\t\t\tuserAuth: nbcontext.UserAuth{AccountId: account1.Id, UserId: \"admin-user\"},\n+\t\t\tuserAuth: auth.UserAuth{AccountId: account1.Id, UserId: \"admin-user\"},\n \t\t\texpectedResult: &users.UserInfoWithPermissions{\n \t\t\t\tUserInfo: &types.UserInfo{\n \t\t\t\t\tID:                   \"admin-user\",\n@@ -1657,7 +1657,7 @@ func TestDefaultAccountManager_GetCurrentUserInfo(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname:     \"settings blocked regular user\",\n-\t\t\tuserAuth: nbcontext.UserAuth{AccountId: account2.Id, UserId: \"settings-blocked-user\"},\n+\t\t\tuserAuth: auth.UserAuth{AccountId: account2.Id, UserId: \"settings-blocked-user\"},\n \t\t\texpectedResult: &users.UserInfoWithPermissions{\n \t\t\t\tUserInfo: &types.UserInfo{\n \t\t\t\t\tID:                   \"settings-blocked-user\",\n@@ -1678,7 +1678,7 @@ func TestDefaultAccountManager_GetCurrentUserInfo(t *testing.T) {\n \n \t\t{\n \t\t\tname:     \"settings blocked regular user child account\",\n-\t\t\tuserAuth: nbcontext.UserAuth{AccountId: account2.Id, UserId: \"settings-blocked-user\", IsChild: true},\n+\t\t\tuserAuth: auth.UserAuth{AccountId: account2.Id, UserId: \"settings-blocked-user\", IsChild: true},\n \t\t\texpectedResult: &users.UserInfoWithPermissions{\n \t\t\t\tUserInfo: &types.UserInfo{\n \t\t\t\t\tID:                   \"settings-blocked-user\",\n@@ -1698,7 +1698,7 @@ func TestDefaultAccountManager_GetCurrentUserInfo(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\tname:     \"settings blocked owner user\",\n-\t\t\tuserAuth: nbcontext.UserAuth{AccountId: account2.Id, UserId: \"account2Owner\"},\n+\t\t\tuserAuth: auth.UserAuth{AccountId: account2.Id, UserId: \"account2Owner\"},\n \t\t\texpectedResult: &users.UserInfoWithPermissions{\n \t\t\t\tUserInfo: &types.UserInfo{\n \t\t\t\t\tID:                   \"account2Owner\",\ndiff --git a/shared/management/client/client_test.go b/shared/management/client/client_test.go\nindex d3f341529fd..f98e76ce751 100644\n--- a/shared/management/client/client_test.go\n+++ b/shared/management/client/client_test.go\n@@ -18,6 +18,7 @@ import (\n \t\"google.golang.org/grpc/status\"\n \n \t\"github.com/netbirdio/management-integrations/integrations\"\n+\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map/controller\"\n \t\"github.com/netbirdio/netbird/management/internals/controllers/network_map/update_channel\"\n \tnbgrpc \"github.com/netbirdio/netbird/management/internals/shared/grpc\"\n@@ -117,7 +118,7 @@ func startManagement(t *testing.T) (*grpc.Server, net.Listener) {\n \tupdateManager := update_channel.NewPeersUpdateManager(metrics)\n \trequestBuffer := mgmt.NewAccountRequestBuffer(ctx, store)\n \tnetworkMapController := controller.NewController(ctx, store, metrics, updateManager, requestBuffer, mgmt.MockIntegratedValidator{}, settingsMockManager, \"netbird.selfhosted\", port_forwarding.NewControllerMock())\n-\taccountManager, err := mgmt.BuildManager(context.Background(), store, networkMapController, nil, \"\", eventStore, nil, false, ia, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManagerMock, false)\n+\taccountManager, err := mgmt.BuildManager(context.Background(), config, store, networkMapController, nil, \"\", eventStore, nil, false, ia, metrics, port_forwarding.NewControllerMock(), settingsMockManager, permissionsManagerMock, false)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n"}
